

!     FM 1.3                              David M. Smith                          10-17-2017


!  The routines in this package perform multiple precision arithmetic and functions
!  on three kinds of numbers.
!  FM routines handle floating-point real multiple precision numbers,
!  IM routines handle integer multiple precision numbers, and
!  ZM routines handle floating-point complex multiple precision numbers.
!  References to FM numbers below mean the low-level array form of the number used by the routines
!  in FM.f95, and not the derived type (fm) numbers handled by the FMZM module.  Logically, both may
!  refer to the same multiple precision number, but the syntax for dealing with the two types of
!  objects is different.  The same is true of references to IM numbers and ZM numbers below.

!  These are the basic routines for the FM package, and the expectation is that the user will not
!  call these routines directly.  The typical usage is for a program to declare multiple precision
!  variables with the three derived types defined in module FMZM in file FMZM90.f95.  Then that
!  module provides the interface between the user's program and the routines in this file.  See the
!  documentation in the FM_User_Manual.txt file for advice on using the FMZM module.
!  The information below is intended as a technical reference on the inner workings of FM, and most
!  FM users should not need to study it.


!  1. INITIALIZING THE PACKAGE

!  The variables that contain values to be shared by the different routines are located in module
!  FMVALS in file FMSAVE.f95.  Variables that are described below for controlling various features
!  of the FM package are found in this module.  They are initialized to default values assuming
!  32-bit integers and 64-bit double precision representation of the arrays holding multiple
!  precision numbers.  The base and number of digits to be used are initialized to give slightly
!  more than 50 decimal digits.  Subroutine FMVARS can be used to get a list of these variables
!  and their values.

!  The intent of module FMVALS is to hide the FM internal variables from the user's program, so that
!  no name conflicts can occur.  Subroutine FMSETVAR can be used to change the variables listed
!  below to new values.  It is not always safe to try to change these variables directly by putting
!  USE FMVALS into the calling program and then changing them by hand.  Some of the saved constants
!  depend upon others, so that changing one variable may cause errors if others depending on that
!  one are not also changed.  FMSETVAR automatically updates any others that depend upon the one
!  being changed.

!  Subroutine FMSET also initializes these variables.  It tries to compute the best value for each,
!  and it checks several of the default values set in FMVALS to see that they are reasonable for a
!  given machine.  FMSET can also be called to set or change the current precision level for the
!  multiple precision numbers.

!  Calling FMSET is optional starting in version 1.2 of the FM package.  In previous versions one
!  call was required before any other routine in the package could be used.

!  The routine ZMSET from version 1.1 is no longer needed, and the complex operations are
!  automatically initialized in FMVALS.  It has been left in the package for compatibility with
!  version 1.1.


!  2.  REPRESENTATION OF FM NUMBERS

!  MBASE is the base in which the arithmetic is done.  MBASE must be bigger than one, and less than
!        or equal to the square root of the largest representable integer.  For best efficiency
!        MBASE should be large, but no more than about 1/4 of the square root of the largest
!        representable integer.  Input and output conversions are much faster when MBASE is a
!        power of ten.

!  NDIG  is the number of base MBASE digits that are carried in the multiple precision numbers.
!        NDIG must be at least two.  The upper limit for NDIG is restricted only by the amount
!        of memory available.

!  Sometimes it is useful to dynamically vary NDIG during the program.  Routine FMEQU should be used
!  to round numbers to lower precision or zero-pad them to higher precision when changing NDIG.

!  The default value of MBASE is a large power of ten.  FMSET also sets MBASE to a large power of
!  ten.  For an application where another base is used, such as simulating a given machine's base
!  two arithmetic, use subroutine FMSETVAR to change MBASE, so that the other internal values
!  depending on MBASE will be changed accordingly.

!  There are two representations for a floating point multiple precision number.  The unpacked
!  representation used by the routines while doing the computations is base MBASE and is stored
!  in NDIG+3 words.  A packed representation is available to store the numbers in compressed form.
!  In this format, the NDIG (base MBASE) digits of the mantissa are packed two per word to conserve
!  storage.  Thus the external, packed form of a number requires (NDIG+1)/2+3 words.

!  This version uses double precision arrays to hold the numbers.  Version 1.0 of FM used integer
!  arrays, which are faster on some machines.  The package can be changed to use integer arrays ---
!  see section 10 on EFFICIENCY below.

!  The unpacked format of a floating multiple precision number is as follows.  A number MA refers
!  to elements of an array with the multiple precision number stored as follows:
!       1  Sign of the number
!       2  Accuracy
!       3  Exponent of the number
!       4  First digit of the number
!     ...
!  NDIG+3  Last digit of the number.

!  The accuracy is the approximate number of bits of precision of the number.  This precision value
!  is intended to be used by FM functions that need to monitor cancellation error in addition and
!  subtraction.  The cancellation monitor code is usually disabled for user calls, and FM functions
!  only check for cancellation when they must.  Tracking cancellation causes most routines to run
!  slower, with addition and subtraction being affected the most.

!  The exponent is a power of MBASE and the implied radix point is immediately before the first
!  digit of the mantissa.  The exponent is a signed integer.  The overflow threshold is
!  MBASE**(MXEXP+1), and the underflow threshold is MBASE**(-MXEXP-1).  This means the valid
!  exponents for an FM number can range from -MXEXP to MXEXP+1 (inclusive).
!  Every nonzero number is normalized so that the first digit of the mantissa is nonzero.

!  For MBASE = 10,000 and NDIG = 4, if MA is the number -pi, it would have these representations:

!                   Word 1         2         3         4         5         6         7

!         Unpacked:     -1        42         1         3      1415      9265      3590
!         Packed:       -1        42         1     31415  92653590

!  The mantissa has about 42 bits of precision, and the number represented is
!  (-1)*(10000**1)*(.0003141592653590).

!  Because of the normalization of the digits with a large base, the equivalent number of base 10
!  significant digits for an FM number may be as small as LOG10(MBASE)*(NDIG-1) + 1.  In the -pi
!  example above, this is 4*3 + 1 = 13.

!  In version 1.2 and before, each variable like MA was a fixed-size array.  Now the array values
!  for all multiple precision numbers are stored together in one dynamic array, MWK.  A variable
!  name like MA is just an integer index giving the location within MWK where the digits are put.
!  This allows the memory management of the package to be more flexible than before, to handle
!  large arrays of multiple precision numbers at low precision (30 to 50 s.d.) as well as some
!  at high precision (millions of s.d.).

!  The integer routines use the FM format to represent numbers, without the number of digits (NDIG)
!  being fixed.  Integers in IM format are essentially variable precision, using the minimum number
!  of words to represent each value.

!  The unpacked format is the default.  As machines' memories have gotten bigger, few applications
!  need the packed format.  A program that uses packed format numbers should not use the FMZM module
!  or the multiple precision derived types defined in FMZM.  Packed numbers are treated as temporary
!  values by the routines in FMZM, so mixing packed numbers with derived type operations from FMZM
!  means the packed numbers could be deleted before the main program is finished with them.

!  For programs using both FM and IM numbers, FM routines should not be called with IM numbers, and
!  IM routines should not be called with FM numbers, since the implied value of NDIG used for an IM
!  number may not match the explicit NDIG expected by an FM routine.  Use the conversion routines
!  IMFM2I and IMI2FM to change between the FM and IM formats.

!  The format for complex FM numbers (called ZM numbers below) is very similar to that for real FM
!  numbers.  Each ZM number consists of two FM numbers representing the real and imaginary parts of
!  a complex number.  If MA is a ZM number, then the real part is MA(1) and the imaginary part is
!  MA(2).  As with FM, there are packed and unpacked formats for the numbers.


!  3. INPUT/OUTPUT ROUTINES

!  All versions of the input routines perform free-format conversion from characters to FM numbers.

!  a. Conversion to or from a character array

!     FMINP converts from a character(1) array to an FM number.

!     FMOUT converts an FM number to base 10 and formats it for output as an array of type
!           character(1).  The output is left justified in the array, and the format is defined
!           by two variables in module FMVALS, so that a separate format definition does not have
!           to be provided for each output call.

!     JFORM1 and JFORM2 define a default output format.

!     JFORM1 = 0     E   format       ( .314159M+6 )
!            = 1     ES  format       ( 3.14159M+5 )
!            = 2     F   format       ( 314159.000 )

!     JFORM2 is the number of significant digits to display (if JFORM1 = 0 or 1).
!            If JFORM2 = 0 then a default number of digits is chosen.  The default is roughly
!            the full precision of the number.
!     JFORM2 is the number of digits after the decimal point (if JFORM1 = 2).
!            See the FMOUT documentation for more details.

!  b. Conversion to or from a character string

!     FMST2M converts from a character string to an FM number.

!     FMFORM converts an FM number to a character string according to a format provided in each
!            call.  The format description is more like that of a Fortran FORMAT statement, and
!            integer or fixed-point output is right justified.

!  c. Direct read or write

!     FMPRINT uses FMOUT to print one FM number.

!     FMFPRINT uses FMFORM to print one FM number.

!     FMWRITE writes FM numbers for later input using FMREAD.

!     FMREAD reads FM numbers written by FMWRITE.

!  The values given to JFORM1 and JFORM2 can be used to define a default output format when FMOUT
!  or FMPRINT are called.  The explicit format used in a call to FMFORM or FMFPRINT overrides the
!  settings of JFORM1 and JFORM2.

!  KW is the unit number to be used for standard output from the package, including error and
!  warning messages, and trace output.

!  For multiple precision integers, the corresponding routines IMINP, IMOUT, IMST2M, IMFORM,
!  IMPRINT, IMFPRINT, IMWRITE, and IMREAD provide similar input and output conversions.  For output
!  of IM numbers, JFORM1 and JFORM2 are ignored and integer format (JFORM1=2, JFORM2=0) is used.

!  For ZM numbers, the corresponding routines ZMINP, ZMOUT, ZMST2M, ZMFORM, ZMPRINT, ZMFPRINT,
!  ZMWRITE, and ZMREAD provide similar input and output conversions.

!  For the output format of ZM numbers, JFORM1 and JFORM2 determine the default format for the
!  individual parts of a complex number as with FM numbers.

!     JFORMZ determines the combined output format of the real and imaginary parts.

!     JFORMZ = 1  normal setting    :    1.23 - 4.56 i
!            = 2  use capital I     :    1.23 - 4.56 I
!            = 3  parenthesis format:  ( 1.23 , -4.56 )

!     JPRNTZ controls whether to print real and imaginary parts on one line whenever possible.

!     JPRNTZ = 1  print both parts as a single string :
!                     1.23456789M+321 - 9.87654321M-123 i
!            = 2  print on separate lines without the 'i' :
!                     1.23456789M+321
!                    -9.87654321M-123

!  For further description of these routines, see section 9 below.


!  4. ARITHMETIC TRACING

!  NTRACE and LVLTRC control trace printout from the package.

!  NTRACE =  0   No output except warnings and errors.  (Default)
!         =  1   The result of each call to one of the routines is printed in base 10, using FMOUT.
!         = -1   The result of each call to one of the routines is printed in internal base MBASE
!                     format.
!         =  2   The input arguments and result of each call to one of the routines is printed in
!                     base 10, using FMOUT.
!         = -2   The input arguments and result of each call to one of the routines is printed in
!                     base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = 2 also prints traces for FM routines
!         called by other FM routines called directly by the user, etc.  Default is 1.

!  In the above description, internal MBASE format means the number is printed as it appears in the
!  array --- the sign, accuracy, exponent, then the NDIG base MBASE digits.


!  5. ERROR CONDITIONS

!  KFLAG is a condition value returned by the package after each call to one of the routines.
!        Negative values indicate conditions for which a warning message will be printed unless
!        KWARN = 0.
!        Positive values indicate conditions that may be of interest but are not errors.  No warning
!        message is printed if KFLAG is nonnegative.

!  Subroutine FMFLAG is provided to give the user access to the current condition code.  For
!  example, to set the user's local variable LFLAG to FM's internal KFLAG value:
!        CALL FMFLAG(LFLAG)

!    KFLAG =  0     Normal operation.

!          =  1     One of the operands in FMADD or FMSUB was insignificant with respect to the
!                       other.  This means that in the default (symmetric) rounding mode the result
!                       is equal to the argument of larger magnitude.  KFLAG = 1 is still returned
!                       with the other three rounding modes (see KROUND below), but the result may
!                       not be equal to either input argument.
!          =  2     In converting an FM number to a one word integer in FMM2I, the FM number was
!                       not exactly an integer.  The next integer toward zero was returned.

!          = -1     NDIG was less than 2.
!          = -2     MBASE was less than 2 or more than MXBASE.
!          = -3     An exponent was out of range.
!          = -4     Invalid input argument(s) to an FM routine.  UNKNOWN was returned.
!          = -5     + or - OVERFLOW was generated as a result from an FM routine.
!          = -6     + or - UNDERFLOW was generated as a result from an FM routine.
!          = -7     The input string (array) to FMINP was not legal.
!          = -8     The character array was not large enough in an input or output routine.
!          = -9     Precision could not be raised enough to provide all requested guard digits.
!                        This means the program has run out of memory.
!                        UNKNOWN was returned.
!          = -10    An FM input argument was too small in magnitude to convert to the machine's
!                        single or double precision in FMM2SP or FMM2DP.  Check that the definitions
!                        of SPMAX and DPMAX in file FMSAVE.f95 are correct for the current machine.
!                        Zero was returned.
!          = -11    Array MBERN is not dimensioned large enough for the requested number of
!                        Bernoulli numbers.
!          = -12    Array MJSUMS is not dimensioned large enough for the number of coefficients
!                        needed in the reflection formula in FMPGAM.

!  When a negative KFLAG condition is encountered, the value of KWARN determines the action to
!  be taken.

!  KWARN = 0     Execution continues and no message is printed.
!        = 1     A warning message is printed and execution continues.
!        = 2     A warning message is printed and execution stops.

!  The default setting is KWARN = 1.

!  When an overflow or underflow is generated for an operation in which an input argument was
!  already an overflow or underflow, no additional message is printed.  When an unknown result
!  is generated and an input argument was already unknown, no additional message is printed.
!  In these cases the negative KFLAG value is still returned.

!  IM routines handle exceptions like OVERFLOW or UNKNOWN in the same way as FM routines, but there
!  are some differences because the number of digits carried for IM numbers is not fixed.  For
!  example, in computing the product of two large integers FM will try to allocate more space rather
!  than returning +OVERFLOW.  If this allocation fails, FM will write an error message indicating it
!  could not get more memory, and the program will stop.  The routines IMMPY_MOD and IMPOWER_MOD can
!  be used to obtain modular products and powers without as much chance of running out of memory.


!  6. OTHER OPTIONS

!  KRAD = 0     All angles in the real trigonometric functions and inverse functions are measured
!                   in degrees.
!       = 1     All angles are measured in radians.  (Default)

!  KROUND = -1  All results are rounded toward minus infinity.
!         =  0  All results are rounded toward zero (chopped).
!         =  1  All results are rounded to the nearest FM number, or to the value with an even last
!                   digit if the result is exactly halfway between two FM numbers.  (Default)
!         =  2  All results are rounded toward plus infinity.

!  KSWIDE defines the maximum screen width to be used for all unit KW output.  Default is 80.

!  KESWCH controls the action taken in FMINP and other input routines for strings like 'E7' that
!         have no digits before the exponent field.  This is sometimes a convenient abbreviation
!         when doing interactive keyboard input.
!         KESWCH = 1 causes 'E7' to translate like '1.0E+7'.  (Default)
!         KESWCH = 0 causes 'E7' to translate like '0.0E+7' and give 0.

!  CMCHAR defines the exponent letter to be used for FM variable output.
!         Default is 'M', as in 1.2345M+678.
!         Change it to 'E' for output to be read by a non-FM program.

!  KDEBUG = 0   No error checking is done to see if input arguments are valid and parameters like
!                  NDIG and MBASE are correct upon entry to each routine.  (Default)
!         = 1   Some error checking is done.  (Slower speed)

!  See module FMVALS in file FMSAVE.f95 for additional description of these and other variables
!  defining various FM conditions.


!  7. ARRAY DIMENSIONS

!  Before version 1.3 the multiple-precision numbers were each stored in a separate array.  Now all
!  these arrays have been combined into one, MWK.  Each multiple-precision number is represented by
!  a single integer that is used to access the number in the MWK array.  This makes the memory usage
!  within the package much more flexible.


!  8. PORTABILITY

!  In FMSET several variables are set to machine-dependent values, and many of the variables
!  initialized in module FMVALS in file FMSAVE.f95 are checked to see that they have reasonable
!  values.  FMSET will print warning messages on unit KW for any of the FMVALS variables that
!  seem to be poorly initialized.

!  If an FM run fails, call FMVARS to get a list of all the FMVALS variables printed on unit KW.
!  Setting KDEBUG = 1 at the start may also identify some errors.

!  In the routines for special functions, several constants are used that require the machine's
!  integer word size to be at least 32 bits.


!  9.  LIST OF ROUTINES

!  First are the routines that deal with multiple precision real numbers.  All of these are
!  subroutines except logical function FMCOMPARE.

!  MA, MB, MC refer to FM format numbers (i.e., integers as opposed to the derived types with
!  integer components that are defined in file FMZM90.f95)

!  In Fortran-90 and later versions of the Fortran standard, it is potentially unsafe to use the
!  same variable more than once in the calling sequence.  The operation MA = MA + MB should not be
!  written as
!        CALL FMADD(MA,MB,MA)
!  since the code for the subroutine will not know that the first and third arguments are the same,
!  and some code optimizations under the assumption that all three arguments are different could
!  cause errors.

!  One solution is to use a third array and then put the result back in MA:
!        CALL FMADD(MA,MB,MC)
!        CALL FMEQ(MC,MA)

!  When the first call is doing one of the "fast" operations like addition, the extra call to move
!  the result back to MA can cause a noticeable loss in efficiency.  To avoid this, separate
!  routines are provided for the basic arithmetic operations when the result is to be returned in
!  the same array as one of the inputs.

!  A routine name with a suffix of  "_R1" returns the result in the first input array, and a suffix
!  of "_R2" returns the result in the second input array.  The example above would then be:
!        CALL FMADD_R1(MA,MB)

!  These routines each have one less argument than the original version, since the output is
!  re-directed to one of the inputs.  The result array should not be the same as any input array
!  when the original version of the routine is used.

!  The routines that can be used this way are listed below.  For others, like
!        CALL FMEXP(MA,MA)
!  the relative cost of doing an extra copy is small.  This one should become
!        CALL FMEXP(MA,MB)
!        CALL FMEQ(MB,MA)

!  When the derived-type interface is used, as in
!        TYPE (FM), SAVE :: A, B
!        ...
!        A = A + B
!  there is no problem putting the result back into A, since the interface routine creates a
!  temporary scratch array for the result of A + B.

!  For each of these routines there is also a version available for which the argument list is
!  the same but all FM numbers are in packed format.  The routines using packed numbers have the
!  same names except 'FM' is replaced by 'FP' at the start of each name.

!  Some of the routine names were restricted to 6 characters in earlier versions of FM.  The old
!  names have been retained for compatibility, but new names that are longer and more readable
!  have been added.  For example, the old routine FMCSSN can now also be called as FMCOS_SIN.
!  Both old and new names are listed below.


!  FMABS(MA,MB)              MB = ABS(MA)

!  FMACOS(MA,MB)             MB = ACOS(MA)

!  FMACOSH(MA,MB)            MB = ACOSH(MA)

!  FMADD(MA,MB,MC)           MC = MA + MB

!  FMADD_R1(MA,MB)           MA = MA + MB

!  FMADD_R2(MA,MB)           MB = MA + MB

!  FMADDI(MA,IVAL)           MA = MA + IVAL   Increment an FM number by a one word integer.
!                                             Note this call does not have an "MB" result
!                                             like FMDIVI and FMMPYI.

!  FMASIN(MA,MB)             MB = ASIN(MA)

!  FMASINH(MA,MB)            MB = ASINH(MA)

!  FMATAN(MA,MB)             MB = ATAN(MA)

!  FMATANH(MA,MB)            MB = ATANH(MA)

!  FMATAN2(MA,MB,MC)         MC = ATAN2(MA,MB)     < old name: FMATN2 >

!  FMBIG(MA)                 MA = Biggest FM number less than overflow.

!  FMCHANGEBASE(MA,MB,NEW_MBASE,NEW_NDIG)
!                            MB is returned with the base NEW_MBASE and precision NEW_NDIG
!                               representation of MA, where MA is given in the current base (MBASE)
!                               and precision (NDIG).  This routine is primarily meant to be used
!                               for input and output conversion when a base is being used that is
!                               not a power of ten.

!  FMCOMPARE(MA,LREL,MB)     Logical comparison of MA and MB.     < old name: FMCOMP >
!                            LREL is a character(2) value identifying which of the six comparisons
!                                 is to be made.
!                            Example:  IF (FMCOMPARE(MA,'>=',MB)) ...
!                            Also can be:  IF (FMCOMPARE(MA,'GE',MB)) ...
!                            character(1) is ok:  IF (FMCOMPARE(MA,'>',MB)) ...

!  FMCONS                    Set several saved constants that depend on MBASE, the base being used.
!                            FMCONS should be called immediately after changing MBASE.

!  FMCOS(MA,MB)              MB = COS(MA)

!  FMCOS_SIN(MA,MB,MC)       MB = COS(MA),  MC = SIN(MA).     < old name: FMCSSN >
!                                 Faster than making two separate calls.

!  FMCOSH(MA,MB)             MB = COSH(MA)

!  FMCOSH_SINH(MA,MB,MC)     MB = COSH(MA),  MC = SINH(MA).     < old name: FMCHSH >
!                                 Faster than making two separate calls.

!  FMDIG(NSTACK,KST)         Find a set of precisions to use during Newton iteration for finding a
!                            simple root starting with about double precision accuracy.

!  FMDIM(MA,MB,MC)           MC = DIM(MA,MB)

!  FMDIV(MA,MB,MC)           MC = MA / MB

!  FMDIV_R1(MA,MB)           MA = MA / MB

!  FMDIV_R2(MA,MB)           MB = MA / MB

!  FMDIVI(MA,IVAL,MB)        MB = MA/IVAL   IVAL is a one word integer.

!  FMDIVI_R1(MA,IVAL)        MA = MA/IVAL

!  FMDP2M(X,MA)              MA = X    Convert from double precision to FM.

!  FMDPM(X,MA)               MA = X    Convert from double precision to FM.
!                                      Faster than FMDP2M, but MA agrees with X only to D.P.
!                                      accuracy.  See the comments in the two routines.

!  FMEQ(MA,MB)               MB = MA   Both have precision NDIG.
!                                      This is the version to use for standard  B = A  statements.

!  FMEQU(MA,MB,NA,NB)        MB = MA   Version for changing precision.
!                                      MA has NA digits (i.e., MA was computed using NDIG = NA), and
!                                      MB will be defined having NB digits.
!                                      MB is rounded if NB < NA
!                                      MB is zero-padded if NB > NA

!  FMEXP(MA,MB)              MB = EXP(MA)

!  FMFLAG(K)                 K = KFLAG  get the value of the FM condition flag -- stored in the
!                                       internal FM variable KFLAG in module FMVALS.

!  FMFORM(FORM,MA,STRING)    MA is converted to a character string using format FORM and returned in
!                               STRING.  FORM can represent I, F, E, or ES formats.  Example:
!                               CALL FMFORM('F60.40',MA,STRING)

!  FMFPRINT(FORM,MA)         Print MA on unit KW using FORM format.     < old name: FMFPRT >

!  FMHYPOT(MA,MB,MC)         MA = SQRT(MA**2 + MB**2)

!  FMI2M(IVAL,MA)            MA = IVAL   Convert from one word integer to FM.

!  FMINP(LINE,MA,LA,LB)      MA = LINE   Input conversion.
!                                        Convert LINE(LA) through LINE(LB) from characters to FM.

!  FMINT(MA,MB)              MB = INT(MA)    Integer part of MA.

!  FMIPOWER(MA,IVAL,MB)      MB = MA**IVAL   Raise an FM number to a one word integer power.
!                                            < old name: FMIPWR >

!  FMLOG10(MA,MB)            MB = LOG10(MA)     < old name: FMLG10 >

!  FMLN(MA,MB)               MB = LOG(MA)

!  FMLNI(IVAL,MA)            MA = LOG(IVAL)   Natural log of a one word integer.

!  FMM2DP(MA,X)              X  = MA     Convert from FM to double precision.

!  FMM2I(MA,IVAL)            IVAL = MA   Convert from FM to integer.

!  FMM2SP(MA,X)              X  = MA     Convert from FM to single precision.

!  FMMAX(MA,MB,MC)           MC = MAX(MA,MB)

!  FMMIN(MA,MB,MC)           MC = MIN(MA,MB)

!  FMMOD(MA,MB,MC)           MC = MA mod MB

!  FMMPY(MA,MB,MC)           MC = MA * MB

!  FMMPY_R1(MA,MB)           MA = MA * MB

!  FMMPY_R2(MA,MB)           MB = MA * MB

!  FMMPYI(MA,IVAL,MB)        MB = MA*IVAL    Multiply by a one word integer.

!  FMMPYI_R1(MA,IVAL)        MA = MA*IVAL

!  FMNINT(MA,MB)             MB = NINT(MA)   Nearest FM integer.

!  FMNORM2(MA,N,MB)          MB = SQRT( MA(1)**2 + MA(2)**2 + ... + MA(N)**2 )

!  FMOUT(MA,LINE,LB)         LINE = MA   Convert from FM to character.
!                                        LINE is a character array of length LB.

!  FMPI(MA)                  MA = pi

!  FMPRINT(MA)               Print MA on unit KW using current format.     < old name: FMPRNT >

!  FMPOWER(MA,MB,MC)         MC = MA**MB     < old name: FMPWR >

!  FM_RANDOM_NUMBER(X)       X is returned as a double precision random number, uniformly
!                            distributed on the open interval (0,1).  It is a high-quality,
!                            long-period generator based on 49-digit prime numbers.
!                            Note that X is double precision, unlike the similar Fortran intrinsic
!                            random number routine, which returns a single-precision result.
!                            A default initial seed is used if FM_RANDOM_NUMBER is called without
!                            calling FM_RANDOM_SEED_PUT first.  See the comments in section 11 below
!                            and also those in the routine for more details.

!  FM_RANDOM_SEED_GET(SEED)  returns the seven integers SEED(1) through SEED(7) as the current seed
!                            for the FM_RANDOM_NUMBER generator.

!  FM_RANDOM_SEED_PUT(SEED)  initializes the FM_RANDOM_NUMBER generator using the seven integers
!                            SEED(1) through SEED(7). These get and put functions are slower than
!                            FM_RANDOM_NUMBER, so FM_RANDOM_NUMBER should be called many times
!                            between FM_RANDOM_SEED_PUT calls.  Also, some generators that used a
!                            9-digit modulus have failed randomness tests when used with only a few
!                            numbers being generated between calls to re-start with a new seed.

!  FM_RANDOM_SEED_SIZE(SIZE) returns integer SIZE as the size of the SEED array used by the
!                            FM_RANDOM_NUMBER generator.  Currently, SIZE = 7.

!  FMRATIONAL_POWER(MA,K,J,MB)
!                            MB = MA**(K/J)  Rational power.     < old name: FMRPWR >
!                            Faster than FMPOWER for functions like the cube root.

!  FMREAD(KREAD,MA)          MA   is returned after reading one (possibly multi-line) FM number
!                                 on unit KREAD.  This routine reads numbers written by FMWRITE.

!  FMSET(NPREC)              Set the internal FM variables so that the precision is at least NPREC
!                            base 10 digits plus three base 10 guard digits.

!  FMSETVAR(STRING)          Define a new value for one of the internal FM variables in module
!                            FMVALS that controls one of the FM options.  STRING has the form
!                                  variable = value.
!                            Example:  To change the screen width for FM output:
!                                  CALL FMSETVAR(' KSWIDE = 120 ')
!                            The variables that can be changed and the options they control are
!                            listed in sections 2 through 6 above.  Only one variable can be set
!                            per call.  The variable name in STRING must have no embedded blanks.
!                            The value part of STRING can be in any numerical format, except in
!                            the case of variable CMCHAR, which is character type.  To set CMCHAR
!                            to 'E', don't use any quotes in STRING:
!                                  CALL FMSETVAR(' CMCHAR = E ')

!  FMSIGN(MA,MB,MC)          MC = SIGN(MA,MB)   Returns the absolute value of MA times the sign
!                                               of MB.

!  FMSIN(MA,MB)              MB = SIN(MA)

!  FMSINH(MA,MB)             MB = SINH(MA)

!  FMSP2M(X,MA)              MA = X   Convert from single precision to FM.

!  FMSQR(MA,MB)              MB = MA * MA   Faster than FMMPY.

!  FMSQR_R1(MA)              MA = MA * MA

!  FMSQRT(MA,MB)             MB = SQRT(MA)

!  FMSQRT_R1(MA)             MA = SQRT(MA)

!  FMST2M(STRING,MA)         MA = STRING
!                                 Convert from character string to FM.  STRING may be in any
!                                 numerical format.  FMST2M is often more convenient than FMINP,
!                                 which converts an array of character(1) values.  Example:
!                                       CALL FMST2M('123.4',MA)

!  FMSUB(MA,MB,MC)           MC = MA - MB

!  FMSUB_R1(MA,MB)           MA = MA - MB

!  FMSUB_R2(MA,MB)           MB = MA - MB

!  FMTAN(MA,MB)              MB = TAN(MA)

!  FMTANH(MA,MB)             MB = TANH(MA)

!  FMTINY(MA)                MA = Smallest positive FM number greater than underflow.

!  FMULP(MA,MB)              MB = One Unit in the Last Place of MA.  For positive MA this is the
!                                 same as the Fortran function SPACING, but MB < 0 if MA < 0.
!                                 Examples:  If MBASE = 10 and NDIG = 30, then ulp(1.0) = 1.0E-29,
!                                            ulp(-4.5E+67) = -1.0E+38.

!  FMVARS                    Write the current values of the internal FM variables on unit KW.

!  FMWRITE(KWRITE,MA)        Write MA on unit KWRITE.     < old name: FMWRIT >
!                            Multi-line numbers will have '&' as the last nonblank character on all
!                            but the last line.  These numbers can then be read easily using FMREAD.


!  These are the available mathematical special functions.

!  FMBERNOULLI(N,MA)         MA = B(N)      Nth Bernoulli number

!  FMBESJ(N,MA,MB)           MB = J(N,MA)   Bessel function of the first kind

!  FMBESJ2(N1,N2,MA,MB)      MB = (/  J(N1,MA) , ..., J(N2,MA)  /)  returns an array

!  FMBESY(N,MA,MB)           MB = Y(N,MA)   Bessel function of the second kind

!  FMBESY2(N1,N2,MA,MB)      MB = (/  Y(N1,MA) , ..., Y(N2,MA)  /)  returns an array

!  FMBETA(MA,MB,MC)          MC = Beta(MA,MB)

!  FMC(MA,MB)                MB = C(MA)     Fresnel Cosine Integral

!  FMCHI(MA,MB)              MB = Chi(MA)   Hyperbolic Cosine Integral

!  FMCI(MA,MB)               MB = Ci(MA)    Cosine Integral

!  FMCOMB(MA,MB,MC)          MC = Combination MA choose MB  (Binomial coefficient)

!  FMEI(MA,MB)               MB = Ei(MA)    Exponential Integral

!  FMEN(N,MA,MB)             MB = E(N,MA)   Exponential Integral E_n

!  FMERF(MA,MB)              MB = Erf(MA)   Error function

!  FMERFC(MA,MB)             MB = Erfc(MA)  Complimentary Error function

!  FMERFC_SCALED(MA,MB)      MB = Exp(x**2) * Erfc(MA)

!  FMEULER(MA)               MA = Euler's constant ( 0.5772156649... )     < old name: FMEULR >

!  FMFACT(MA,MB)             MB = MA Factorial  (Gamma(MA+1))

!  FMGAM(MA,MB)              MB = Gamma(MA)

!  FMIBTA(MX,MA,MB,MC)       MC = Incomplete Beta(MX,MA,MB)

!  FMIGM1(MA,MB,MC)          MC = Incomplete Gamma(MA,MB).  Lower case Gamma(a,x)

!  FMIGM2(MA,MB,MC)          MC = Incomplete Gamma(MA,MB).  Upper case Gamma(a,x)

!  FMLERC(MA,MB)             MB = Ln(Erfc(MA))  Log Erfc

!  FMLI(MA,MB)               MB = Li(MA)    Logarithmic Integral

!  FMLNGM(MA,MB)             MB = Ln(Gamma(MA))

!  FMPGAM(N,MA,MB)           MB = Polygamma(N,MA)  (Nth derivative of Psi)

!  FMPOCH(MA,N,MB)           MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)  (Pochhammer)

!  FMPSI(MA,MB)              MB = Psi(MA)   (Derivative of Ln(Gamma(MA))

!  FMS(MA,MB)                MB = S(MA)     Fresnel Sine Integral

!  FMSHI(MA,MB)              MB = Shi(MA)   Hyperbolic Sine Integral

!  FMSI(MA,MB)               MB = Si(MA)    Sine Integral


!  These are the routines that deal with multiple precision integer numbers.
!  All are subroutines except logical function IMCOMPARE.  MA, MB, MC refer to IM format numbers.
!  In each case the version of the routine to handle packed IM numbers has the same name, with
!  'IM' replaced by 'IP'.

!  IMABS(MA,MB)              MB = ABS(MA)

!  IMADD(MA,MB,MC)           MC = MA + MB

!  IMBIG(MA)                 MA = 10**(10**6).
!                                 Larger IM numbers can be obtained, but setting MA to the largest
!                                 possible value would leave no room for any other numbers.

!  IMCOMPARE(MA,LREL,MB)     Logical comparison of MA and MB.     < old name: IMCOMP >
!                            LREL is a character(2) value identifying which of the six comparisons
!                                 is to be made.
!                            Example:  IF (IMCOMPARE(MA,'GE',MB)) ...
!                            Also can be:  IF (IMCOMPARE(MA,'>=',MB))
!                            character(1) is ok:  IF (IMCOMPARE(MA,'>',MB)) ...

!  IMDIM(MA,MB,MC)           MC = DIM(MA,MB)

!  IMDIV(MA,MB,MC)           MC = int(MA/MB)
!                                 Use IMDIVR if the remainder is also needed.

!  IMDIVI(MA,IVAL,MB)        MB = int(MA/IVAL)
!                                 IVAL is a one word integer.  Use IMDVIR to get the remainder also.

!  IMDIVR(MA,MB,MC,MD)       MC = int(MA/MB),   MD = MA mod MB
!                                 When both the quotient and remainder are needed, this routine is
!                                 twice as fast as calling both IMDIV and IMMOD.

!  IMDVIR(MA,IVAL,MB,IREM)   MB = int(MA/IVAL),   IREM = MA mod IVAL
!                            IVAL and IREM are one word integers.

!  IMEQ(MA,MB)               MB = MA

!  IMFM2I(MAFM,MB)           MB = MAFM  Convert from real (FM) format to integer (IM) format.

!  IMFORM(FORM,MA,STRING)    MA is converted to a character string using format FORM and
!                               returned in STRING.  FORM can represent I, F, E, or ES formats.
!                               Example: CALL IMFORM('I70',MA,STRING)

!  IMFPRINT(FORM,MA)         Print MA on unit KW using FORM format.     < old name: IMFPRT >

!  IMGCD(MA,MB,MC)           MC = greatest common divisor of MA and MB.

!  IMI2FM(MA,MBFM)           MBFM = MA  Convert from integer (IM) format to real (FM) format.

!  IMI2M(IVAL,MA)            MA = IVAL   Convert from one word integer to IM.

!  IMINP(LINE,MA,LA,LB)      MA = LINE   Input conversion.
!                                        Convert LINE(LA) through LINE(LB) from characters to IM.

!  IMM2DP(MA,X)              X  = MA     Convert from IM to double precision.

!  IMM2I(MA,IVAL)            IVAL = MA   Convert from IM to one word integer.

!  IMM2SP(MA,X)              X  = MA     Convert from IM to single precision.

!  IMMAX(MA,MB,MC)           MC = MAX(MA,MB)

!  IMMIN(MA,MB,MC)           MC = MIN(MA,MB)

!  IMMOD(MA,MB,MC)           MC = MA mod MB

!  IMMPY(MA,MB,MC)           MC = MA*MB

!  IMMPYI(MA,IVAL,MB)        MB = MA*IVAL    Multiply by a one word integer.

!  IMMPY_MOD(MA,MB,MC,MD)    MD = MA*MB mod MC     < old name: IMMPYM >
!                                 Slightly faster than calling IMMPY and IMMOD separately.

!  IMOUT(MA,LINE,LB)         LINE = MA   Convert from IM to character.
!                                        LINE is a character array of length LB.

!  IMPOWER(MA,MB,MC)         MC = MA**MB     < old name: IMPWR >

!  IMPOWER_MOD(MA,MB,MC,MD)  MD = MA**MB mod MC     < old name: IMPMOD >

!  IMPRINT(MA)               Print MA on unit KW.     < old name: IMPRNT >

!  IMREAD(KREAD,MA)          MA   is returned after reading one (possibly multi-line)
!                                 IM number on unit KREAD.
!                                 This routine reads numbers written by IMWRITE.

!  IMSIGN(MA,MB,MC)          MC = SIGN(MA,MB)   Returns the absolute value of MA times the
!                                               sign of MB.

!  IMSQR(MA,MB)              MB = MA*MA   Faster than IMMPY.

!  IMST2M(STRING,MA)         MA = STRING
!                                 Convert from character string to IM.
!                                 IMST2M is often more convenient than IMINP, which converts
!                                 an array of character(1) values.  Example:
!                                      CALL IMST2M('12345678901',MA)

!  IMSUB(MA,MB,MC)           MC = MA - MB

!  IMWRITE(KWRITE,MA)        Write MA on unit KWRITE.
!                            Multi-line numbers will have '&' as the last nonblank character on all
!                            but the last line.  These numbers can then be read easily using IMREAD.


!  These are the routines that deal with multiple precision complex numbers.
!  All are subroutines, and in each case the version of the routine to handle packed ZM numbers has
!  the same name, with 'ZM' replaced by 'ZP'.

!  MA, MB, MC refer to ZM format complex numbers.
!  MAFM, MBFM, MCFM refer to FM format real numbers.
!  INTEG is a Fortran INTEGER variable.
!  ZVAL is a Fortran COMPLEX variable.

!  ZMABS(MA,MBFM)            MBFM = ABS(MA)    Result is real.

!  ZMACOS(MA,MB)             MB = ACOS(MA)

!  ZMACOSH(MA,MB)            MB = ACOSH(MA)

!  ZMADD(MA,MB,MC)           MC = MA + MB

!  ZMADDI(MA,INTEG)          MA = MA + INTEG  Increment an ZM number by a one word integer.
!                                             Note this call does not have an "MB" result
!                                             like ZMDIVI and ZMMPYI.

!  ZMARG(MA,MBFM)            MBFM = Argument(MA)    Result is real.

!  ZMASIN(MA,MB)             MB = ASIN(MA)

!  ZMASINH(MA,MB)            MB = ASINH(MA)

!  ZMATAN(MA,MB)             MB = ATAN(MA)

!  ZMATANH(MA,MB)            MB = ATANH(MA)

!  ZMCOMPLEX(MAFM,MBFM,MC)   MC = CMPLX(MAFM,MBFM)     < old name: ZMCMPX >

!  ZMCONJUGATE(MA,MB)        MB = CONJG(MA)     < old name: ZMCONJ >

!  ZMCOS(MA,MB)              MB = COS(MA)

!  ZMCOS_SIN(MA,MB,MC)       MB = COS(MA),  MC = SIN(MA).     < old name: ZMCSSN >
!                                 Faster than 2 calls.

!  ZMCOSH(MA,MB)             MB = COSH(MA)

!  ZMCOSH_SINH(MA,MB,MC)     MB = COSH(MA),  MC = SINH(MA).     < old name: ZMCHSH >
!                                 Faster than 2 calls.

!  ZMDIV(MA,MB,MC)           MC = MA / MB

!  ZMDIVI(MA,INTEG,MB)       MB = MA / INTEG

!  ZMEQ(MA,MB)               MB = MA

!  ZMEQU(MA,MB,NDA,NDB)      MB = MA    Version for changing precision.
!                                       (NDA and NDB are as in FMEQU)

!  ZMEXP(MA,MB)              MB = EXP(MA)

!  ZMFORM(FORM1,FORM2,MA,STRING)
!                            STRING = MA
!                            MA is converted to a character string using format FORM1 for the real
!                            part and FORM2 for the imaginary part.  The result is returned in
!                            STRING.  FORM1 and FORM2 can represent I, F, E, or ES formats.
!                            Example:
!                                  CALL ZMFORM('F20.10','F15.10',MA,STRING)

!  ZMFPRINT(FORM1,FORM2,MA)  Print MA on unit KW using formats FORM1 and FORM2.
!                            < old name: ZMFPRT >

!  ZMI2M(INTEG,MA)           MA = CMPLX(INTEG,0)

!  ZM2I2M(INTEG1,INTEG2,MA)  MA = CMPLX(INTEG1,INTEG2)

!  ZMIMAG(MA,MBFM)           MBFM = IMAG(MA)    Imaginary part.

!  ZMINP(LINE,MA,LA,LB)      MA = LINE   Input conversion.
!                                 Convert LINE(LA) through LINE(LB) from characters to ZM.
!                                 LINE is a character array of length at least LB.

!  ZMINT(MA,MB)              MB = INT(MA)       Integer part of both Real and Imaginary parts of MA.

!  ZMIPOWER(MA,INTEG,MB)     MB = MA ** INTEG   Integer power function.     < old name: ZMIPWR >

!  ZMLOG10(MA,MB)            MB = LOG10(MA)     < old name: ZMLG10 >

!  ZMLN(MA,MB)               MB = LOG(MA)

!  ZMM2I(MA,INTEG)           INTEG = INT(REAL(MA))

!  ZMM2Z(MA,ZVAL)            ZVAL = MA

!  ZMMPY(MA,MB,MC)           MC = MA * MB

!  ZMMPYI(MA,INTEG,MB)       MB = MA * INTEG

!  ZMNINT(MA,MB)             MB = NINT(MA)   Nearest integer of both Real and Imaginary.

!  ZMOUT(MA,LINE,LB,LAST1,LAST2)
!                            LINE = MA
!                            Convert from FM to character.
!                            LINE  is the returned character(1) array.
!                            LB    is the dimensioned size of LINE.
!                            LAST1 is returned as the position in LINE of the last character
!                                  of REAL(MA)
!                            LAST2 is returned as the position in LINE of the last character
!                                  of AIMAG(MA)

!  ZMPOWER(MA,MB,MC)         MC = MA ** MB     < old name: ZMPWR >

!  ZMPRINT(MA)               Print MA on unit KW using current format.     < old name: ZMPRNT >

!  ZMRATIONAL_POWER(MA,IVAL,JVAL,MB)
!                            MB = MA ** (IVAL/JVAL)     < old name: ZMRPWR >

!  ZMREAD(KREAD,MA)          MA   is returned after reading one (possibly multi-line) ZM number on
!                                 unit KREAD.  This routine reads numbers written by ZMWRITE.

!  ZMREAL(MA,MBFM)           MBFM = REAL(MA)    Real part.

!  ZMSET(NPREC)              Set precision to the equivalent of a few more than NPREC base 10
!                            digits.  This is now the same as FMSET, but is retained for
!                            compatibility with earlier versions of the package.

!  ZMSIN(MA,MB)              MB = SIN(MA)

!  ZMSINH(MA,MB)             MB = SINH(MA)

!  ZMSQR(MA,MB)              MB = MA*MA    Faster than ZMMPY.

!  ZMSQRT(MA,MB)             MB = SQRT(MA)

!  ZMST2M(STRING,MA)         MA = STRING
!                                 Convert from character string to ZM.  ZMST2M is often more
!                                 convenient than ZMINP, which converts an array of character(1)
!                                 values.  Example:
!                                       CALL ZMST2M('123.4+5.67i',MA).

!  ZMSUB(MA,MB,MC)           MC = MA - MB

!  ZMTAN(MA,MB)              MB = TAN(MA)

!  ZMTANH(MA,MB)             MB = TANH(MA)

!  ZMWRITE(KWRITE,MA)        Write MA on unit KWRITE.  Multi-line numbers are formatted for
!                            automatic reading with ZMREAD.     < old name: ZMWRIT >

!  ZMZ2M(ZVAL,MA)            MA = ZVAL


!  10. EFFICIENCY

!  To take advantage of hardware architecture on different machines, the package has been designed
!  so that the arithmetic used to perform the multiple precision operations can easily be changed.
!  All variables that must be changed to get a different arithmetic have names beginning with 'M'
!  and are declared using REAL (KIND(1.0D0)) ...

!  For example, to change the package to use integer arithmetic internally, make these two changes
!  everywhere in the FM.f95 file.
!  Change  'REAL (KIND(1.0D0))'  to  'INTEGER'.
!  Change  'AINT ('  to  '('.  Note the blank between AINT and (.

!  In many places in FM, an AINT function is not supposed to be changed.  These are written 'AINT(',
!  with no embedded blank, so they will not be changed by the global change above.

!  The first of these changes must also be made throughout the file FMSAVE.f95.
!  Change  'REAL (KIND(1.0D0))'  to  'INTEGER'.

!  This version of FM restricts the base used to be also representable in integer variables, so
!  using precision above double usually does not save much time unless integers can also be declared
!  at a higher precision.  Using IEEE Extended would allow a base of around 10**9 to be chosen, but
!  the delayed digit-normalization method used for multiplication and division means that a slightly
!  smaller base like 10**8 would probably run faster.  This would usually not be much faster than
!  using the usual base 10**7 with double precision.

!  For cases where special compiler directives or minor re-writing of the code may improve speed,
!  several of the most important loops in FM are identified by comments containing the string
!  '(Inner Loop)'.


!  11. NEW FOR VERSION 1.3

!  This is the second edition of version 1.3.  The first edition appeared in ACM Transactions on
!  Mathematical Software (2-2011).  Since then several additions have been made.
!  (a) New Fortran-08 functions are available in FMZM
!      ACOSH(X), ASINH(X), ATANH(X) for real and complex X
!      ATAN(X,Y) can be used in place of ATAN2(X,Y)
!      BESSEL_J0(X), BESSEL_J1(X), BESSEL_JN(N,X), BESSEL_JN(N1,N2,X)
!      BESSEL_Y0(X), BESSEL_Y1(X), BESSEL_YN(N,X), BESSEL_YN(N1,N2,X)
!         The older FM names, BESSEL_J(N,X) and BESSEL_Y(N,X) are still available.
!      ERFC_SCALED(X) for exp(x**2) * erfc(x)
!         The older FM function LOG_ERFC(X) is also still available for avoiding underflow in erfc.
!      HYPOT(X,Y) for sqrt(x**2 + y**2)
!      NORM2(A) for sqrt( a(1)**2 + a(2)**2 + ... + a(n)**2 )
!         This could previously have been done with array operations as SQRT(DOT_PRODUCT(A,A)).
!  (b) Many of the elementary and special functions are now faster, after some code-tuning was
!      done and a few new methods were added.

!  The routines for the exponential integral function and related mathematical special functions
!  are new in version 1.3.  These routines are:
!  FMBESJ, FMBESY, FMC, FMCHI, FMCI, FMEI, FMEN, FMERF, FMERFC, FMLERC, FMLI, FMS, FMSHI, FMSI.

!  Some of the routines were moved between files FM.f95 and FMZM90.f95 so that now all routines
!  using the module FMZM (in file FMZM90.f95) for multiple precision derived types and operator
!  overloading are located in FMZM90.f95.  This means that programs not using derived types can
!  skip compiling and/or linking FMZM90.f95.

!  The array function DOTPRODUCT in FMZM has been re-named DOT_PRODUCT to agree with the Fortran
!  standard.  For type ZM complex arguments its definition has been changed to agree with the
!  Fortran intrinsic function.  When X and Y are complex, DOT_PRODUCT(X,Y) is not just the sum of
!  the products of the corresponding array elements, as it is for types FM and IM.  For type ZM,
!  the formula is the sum of conjg(X(j)) * Y(j).  This definition is used so that the complex dot
!  product will be an inner product in the mathematical sense.

!  New routines have been added to module FMZM to provide array syntax for the three multiple
!  precision derived types.  This means statements like V = 1 and A = B + C now work when these
!  variables are vectors or matrices of multiple precision numbers.

!  One routine from FM 1.2 has been split into three routines in version 1.3.  The routine
!  FM_RANDOM_SEED from FM 1.2 has become three subroutines, so that the optional arguments and
!  the need for an explicit interface can be avoided.  See the three routines starting with
!  FM_RANDOM_SEED in the list above.  The same multiplicative congruential generator as before
!  is used, but the shuffling of those values has been removed, so that saving seeds and
!  re-starting the generator now works more like the standard Fortran random function.

!  Multiple precision variables were separate fixed-size arrays in previous versions.  Now they are
!  single integers that serve as index values to a single large array (MWK, defined in file
!  FMSAVE.f95) where the actual values are stored.  This often improves both efficiency and memory
!  utilization, since many compilers implemented the derived type operations using copy in and copy
!  out of the arguments for a given operation.  Copying entire arrays was slower, and there were
!  often memory leaks when the compiler automatically created temporary derived type objects while
!  evaluating derived type expressions.  The static arrays in previous versions also meant that
!  memory was wasted when only a few kinds of operations were used at high precision.  Now the
!  space needed by any unused operations never gets allocated.

!  Some new error checking is now done for the derived type multiple precision variables. Attempting
!  to use an undefined variable will cause an error message to be printed.

!  Much higher precision can be attained in version 1.3, since machines are faster and have more
!  memory.  To support higher precision, a routine for FFT-based multiplication has been included,
!  and when precision gets high enough, the algorithms for multiplication, division, squares, square
!  roots, etc., will switch to the FFT routine.

!  Binary splitting algorithms are used for the mathematical constants at high precision.  At the
!  time version 1.3 was released, computing a million digits of e, pi, or the logarithm of a small
!  integer took a few seconds, while a million digits of Euler's constant took a few minutes.

!  Perfect rounding is now done all the time.  In version 1.2 perfect rounding was an option, but
!  the default rounding could round the wrong direction once every few million operations, when the
!  exact result was very close to halfway between two adjacent representable numbers.

! --------------------------------------------------------------------------------------------------
! --------------------------------------------------------------------------------------------------



      SUBROUTINE FMSET(NPREC)

!  Initialize the global FM variables that must be set before calling other FM routines.
!  These variables are initialized to fairly standard values in the FMSAVE.f95 file (MODULE FMVALS),
!  so calling FMSET at the beginning of a program is now optional.  FMSET is a convenient way to set
!  or change the precision being used, and it also checks to see that the generic values chosen for
!  several machine-dependent variables are valid.

!  Base and precision will be set to give at least NPREC+3 decimal digits of precision (giving the
!  user at least three base ten guard digits).  When the base is large, each extra word contains
!  several extra digits when viewed in base ten.  This means that some choices of NPREC will give
!  a few more than three base ten guard digits.

!  MBASE (base for FM arithmetic) is set to a large power of ten.
!  JFORM1 and JFORM2 (default output format controls) are set to ES format displaying NPREC
!  significant digits.

!  Several FM options were set here in previous versions of the package, and are now initialized to
!  their default values in module FMVALS.
!  Here are the initial settings:

!  The trace option is set off.
!  The mode for angles in trig functions is set to radians.
!  The rounding mode is set to symmetric rounding.
!  Warning error message level is set to 1.
!  Cancellation error monitor is set off.
!  Screen width for output is set to 80 columns.
!  The exponent character for FM output is set to 'M'.
!  Debug error checking is set off.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NPREC

      REAL (KIND(1.0D0)) :: MAXINT_CHK,MXEXP2_CHK,MEXPOV_CHK,MEXPUN_CHK,MUNKNO_CHK
      DOUBLE PRECISION :: DPEPS_CHK,DPMAX_CHK,SPMAX_CHK,TEMP
      INTEGER :: INTMAX_CHK,K,NPSAVE
      INTENT (IN) :: NPREC

!             MAXINT should be set to a very large integer, possibly the largest representable
!                    integer for the current machine.  For most 32-bit machines, MAXINT is set
!                    to  2**53 - 1 = 9.007D+15  when double precision arithmetic is used for
!                    M-variables.  Using integer M-variables usually gives
!                    MAXINT = 2**31 - 1 = 2147483647.

!                    Setting MAXINT to a smaller number is ok, but this unnecessarily restricts
!                    the permissible range of MBASE and MXEXP.

      MAXINT_CHK = MAX_REPRESENTABLE_M_VAR
      IF (MAXINT > MAXINT_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MAXINT was set to ',MAXINT,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MAXINT_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MAXINT has been changed to ',MAXINT_CHK
          WRITE (KW,*) ' '
          MAXINT = MAXINT_CHK
      ELSE IF (MAXINT < MAXINT_CHK/2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MAXINT was set to ',MAXINT,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',MAXINT_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MAXINT has been changed to ',MAXINT_CHK
          WRITE (KW,*) ' '
          MAXINT = MAXINT_CHK
      ENDIF

!             INTMAX is a large value close to the overflow threshold for integer variables.
!                    It is usually 2**31 - 1 for machines with 32-bit integer arithmetic.

!                    The following code sets INTMAX_CHK to the largest representable integer.
!                    Then INTMAX is checked against this value.

      INTMAX_CHK = HUGE(I_TWO)
      IF (INTMAX > INTMAX_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' INTMAX was set to ',INTMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',INTMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, INTMAX has been changed to ',INTMAX_CHK
          WRITE (KW,*) ' '
          INTMAX = INTMAX_CHK
      ELSE IF (INTMAX < INTMAX_CHK/2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' INTMAX was set to ',INTMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',INTMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, INTMAX has been changed to ',INTMAX_CHK
          WRITE (KW,*) ' '
          INTMAX = INTMAX_CHK
      ENDIF

!             DPMAX should be set to a value near the machine's double precision overflow threshold,
!                   so that DPMAX and 1.0D0/DPMAX are both representable in double precision.

      DPMAX_CHK = HUGE(DP_TWO)/5
      IF (DPMAX > DPMAX_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPMAX was set to ',DPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',DPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPMAX has been changed to ',DPMAX_CHK
          WRITE (KW,*) ' '
          DPMAX = DPMAX_CHK
      ELSE IF (DPMAX < DPMAX_CHK/1.0D2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPMAX was set to ',DPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',DPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPMAX has been changed to ',DPMAX_CHK
          WRITE (KW,*) ' '
          DPMAX = DPMAX_CHK
      ENDIF

!             SPMAX should be set to a value near the machine's single precision overflow threshold,
!                   so that 1.01*SPMAX and 1.0/SPMAX are both representable in single precision.

      SPMAX_CHK = HUGE(R_TWO)/5
      IF (SPMAX > SPMAX_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' SPMAX was set to ',SPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',SPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, SPMAX has been changed to ',SPMAX_CHK
          WRITE (KW,*) ' '
          SPMAX = SPMAX_CHK
      ELSE IF (SPMAX < SPMAX_CHK/1.0D2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' SPMAX was set to ',SPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',SPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, SPMAX has been changed to ',SPMAX_CHK
          WRITE (KW,*) ' '
          SPMAX = SPMAX_CHK
      ENDIF

!             MXBASE is the maximum value for MBASE.

      TEMP = MAXINT
      TEMP = INT(MIN(DBLE(INTMAX),SQRT(TEMP)))
      IF (MXBASE > TEMP) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXBASE was set to ',MXBASE,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',TEMP
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXBASE has been changed to ',TEMP
          WRITE (KW,*) ' '
          MXBASE = TEMP
      ELSE IF (MXBASE < TEMP/2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXBASE was set to ',MXBASE,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',TEMP
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXBASE has been changed to ',TEMP
          WRITE (KW,*) ' '
          MXBASE = TEMP
      ENDIF

!             KROUND controls the rounding mode.  Set it to symmetric rounding.

      KROUND = 1

!             MBASE is the currently used base for arithmetic.

      K = INT(LOG10(DBLE(MXBASE)/4))
      MBASE = 10**K

!             NDIG is the number of digits currently being carried.

      NPSAVE = NPREC
      NDIG = 2 + (NPREC+2)/K
      IF (NDIG < 2) THEN
          NDIG = MAX(2,NDIG)
          WRITE (KW,                                                      &
                 "(//' Precision out of range when calling FMSET.',"  //  &
                 "'  NPREC =',I20/' The nearest valid NDIG will be'," //  &
                 "' used instead:   NDIG =',I20//)"                       &
                ) NPREC,NDIG
          NPSAVE = 0
      ENDIF

!             NCALL is the call stack pointer.

      NCALL = 0

!             MXEXP  is the current maximum exponent.
!             MXEXP2 is the internal maximum exponent.  This is used to define the overflow and
!                    underflow thresholds.

!             These values are chosen so that FM routines can raise the overflow/underflow limit
!             temporarily while computing intermediate results, and so that EXP(INTMAX) is greater
!             than MXBASE**(MXEXP2+1).

!             The overflow threshold is MBASE**(MXEXP+1), and the underflow threshold is
!             MBASE**(-MXEXP-1).  This means the valid exponents in the first word of an FM number
!             can range from -MXEXP to MXEXP+1 (inclusive).

      MXEXP = AINT( MAX_EXPONENT / 2.01D0 + 0.5D0 )
      MXEXP2_CHK = MAX_EXPONENT
      IF (MXEXP2 > MXEXP2_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXEXP2 was set to ',MXEXP2,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MXEXP2_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXEXP2 has been changed to ',MXEXP2_CHK
          WRITE (KW,*) ' '
          MXEXP2 = MXEXP2_CHK
      ELSE IF (MXEXP2 < MXEXP2_CHK*0.99) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXEXP2 was set to ',MXEXP2,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',MXEXP2_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXEXP2 has been changed to ',MXEXP2_CHK
          WRITE (KW,*) ' '
          MXEXP2 = MXEXP2_CHK
      ENDIF

!             KACCSW is a switch used to enable cancellation error monitoring.  Routines where
!                    cancellation is not a problem run faster by skipping the cancellation monitor
!                    calculations.
!                    KACCSW = 0 means no error monitoring,
!                           = 1 means error monitoring is done.

      KACCSW = 0

!             MEXPUN is the exponent used as a special symbol for underflowed results.

      MEXPUN_CHK = AINT( -MAX_EXPONENT * 1.01D0 )
      IF (MEXPUN < MEXPUN_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MEXPUN was set to ',MEXPUN,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',MEXPUN_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MEXPUN has been changed to ',MEXPUN_CHK
          WRITE (KW,*) ' '
          MEXPUN = MEXPUN_CHK
      ELSE IF (MEXPUN > MEXPUN_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MEXPUN was set to ',MEXPUN,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MEXPUN_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MEXPUN has been changed to ',MEXPUN_CHK
          WRITE (KW,*) ' '
          MEXPUN = MEXPUN_CHK
      ENDIF

!             MEXPOV is the exponent used as a special symbol for overflowed results.

      MEXPOV_CHK = -MEXPUN
      IF (MEXPOV /= MEXPOV_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MEXPOV was set to ',MEXPOV,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be ',MEXPOV_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MEXPOV has been changed to ',MEXPOV_CHK
          WRITE (KW,*) ' '
          MEXPOV = MEXPOV_CHK
      ENDIF

!             MUNKNO is the exponent used as a special symbol for unknown FM results
!                    (1/0, SQRT(-3.0), ...).

      MUNKNO_CHK = AINT( MAX_EXPONENT * 1.0201D0 )
      IF (MUNKNO > MUNKNO_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MUNKNO was set to ',MUNKNO,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MUNKNO_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MUNKNO has been changed to ',MUNKNO_CHK
          WRITE (KW,*) ' '
          MUNKNO = MUNKNO_CHK
      ELSE IF (MUNKNO < MUNKNO_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MUNKNO was set to ',MUNKNO,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',MUNKNO_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MUNKNO has been changed to ',MUNKNO_CHK
          WRITE (KW,*) ' '
          MUNKNO = MUNKNO_CHK
      ENDIF

!             RUNKNO is returned from FM to real or double conversion routines when no valid result
!                    can be expressed in real or double precision.  On systems that provide a value
!                    for undefined results (e.g., Not A Number) setting RUNKNO to that value is
!                    reasonable.  On other systems set it to a value that is likely to make any
!                    subsequent results obviously wrong that use it.  In either case a KFLAG = -4
!                    condition is also returned.

      RUNKNO = -1.01*SPMAX

!             IUNKNO is returned from FM to integer conversion routines when no valid result can be
!                    expressed as a one word integer.  KFLAG = -4 is also set.

      IUNKNO = -INT(MXEXP2)

!             DPEPS is the approximate machine precision.

      DPEPS_CHK = EPSILON(DP_TWO)
      IF (DPEPS > DPEPS_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPEPS was set to ',DPEPS,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',DPEPS_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPEPS has been changed to ',DPEPS_CHK
          WRITE (KW,*) ' '
          DPEPS = DPEPS_CHK
      ELSE IF (DPEPS < DPEPS_CHK*0.99) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPEPS was set to ',DPEPS,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',DPEPS_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPEPS has been changed to ',DPEPS_CHK
          WRITE (KW,*) ' '
          DPEPS = DPEPS_CHK
      ENDIF

!             JFORM1 indicates the format used by FMOUT.

      JFORM1 = 1

!             JFORM2 indicates the number of digits used in FMOUT.

      JFORM2 = NPSAVE

!             Set JFORMZ to ' 1.23 + 4.56 i ' format.

      JFORMZ = 1

!             Set JPRNTZ to print real and imaginary parts on one line whenever possible.

      JPRNTZ = 1

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      CALL FMHTBL

!             FMCONS sets several real and double precision constants.

      CALL FMCONS

      RETURN
      END SUBROUTINE FMSET

      SUBROUTINE FMABS(MA,MB)

!  MB = ABS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      REAL (KIND(1.0D0)) :: MD2B
      INTEGER :: KWRNSV

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMABS'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)

      KFLAG = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMEQ(MA,MB)
      MWK(START(MB)) = 1
      KWARN = KWRNSV

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MWK(START(MB)+1),MD2B)
      ENDIF
      IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMABS

      SUBROUTINE FMACOS(MA,MB)

!  MB = ACOS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 0) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMI2M(180,MXY(1))
          CALL FMPI(MXY(2))
          CALL FMDIV(MXY(1),MXY(2),MXY(3))
          IF (MWK(START(MA)+2) > MEXPUN) THEN
              CALL FMMPY(MXY(3),MA,MXY(2))
          ELSE
              CALL FMEQ(MA,MXY(2))
          ENDIF
          CALL FMI2M(90,MXY(1))
          CALL FMSUB(MXY(1),MXY(2),MB)
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+2) > 0 .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMACOS   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMACOS'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MAS = MWK(START(MA))
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(6),NDSAVE,NDIG)
      MWK(START(MXY(6))+1) = NINT(NDIG*ALOGM2)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMST2M('0.5',MXY(1))
          CALL FMSUB(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('60',MXY(6))
              GO TO 120
          ENDIF
          CALL FMADD(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('120',MXY(6))
              GO TO 120
          ENDIF
      ENDIF

!             Use ACOS(X) = ATAN(SQRT(1-X*X)/X)

      MWK(START(MXY(6))) = 1
      CALL FMI2M(1,MXY(4))
      CALL FMSUB(MXY(4),MXY(6),MXY(2))
      CALL FMADD(MXY(4),MXY(6),MXY(3))
      CALL FMMPY_R2(MXY(2),MXY(3))
      CALL FMSQRT_R1(MXY(3))
      CALL FMDIV(MXY(3),MXY(6),MXY(5))
      CALL FMATAN(MXY(5),MXY(6))

      IF (MAS < 0) THEN
          IF (KRAD == 1) THEN
              CALL FMPI(MXY(4))
          ELSE
              CALL FMI2M(180,MXY(4))
          ENDIF
          CALL FMSUB_R2(MXY(4),MXY(6))
      ENDIF

!             Round the result and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMACOS

      SUBROUTINE FMACOSH(MA,MB)

!  MB = ARCCOSH(MA)      Inverse hyperbolic cosine.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENTR('FMACOSH  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) <= 0 .OR.  &
          MWK(START(MXY(1))) < 0) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(2))
      ELSE IF (4.0*(MWK(START(MXY(1))+2)-1) > NDIG) THEN
          CALL FMMPYI(MXY(1),2,MXY(2))
          IF (MWK(START(MXY(2))+2) == MEXPOV) THEN
              CALL FMLN(MXY(1),MXY(2))
              CALL FMLNI(2,MXY(3))
              CALL FMADD_R1(MXY(2),MXY(3))
          ELSE
              CALL FMI2M(1,MXY(3))
              CALL FMSQR(MXY(2),MXY(4))
              CALL FMDIV_R2(MXY(3),MXY(4))
              CALL FMLN(MXY(2),MXY(3))
              CALL FMSUB(MXY(3),MXY(4),MXY(2))
          ENDIF
      ELSE
          IEXTRA = MWK(START(MXY(1))+2)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              NDIG = NDIG + IEXTRA
          ENDIF
          CALL FMI2M(1,MXY(2))
          CALL FMSUB(MXY(1),MXY(2),MXY(3))
          CALL FMADD(MXY(1),MXY(2),MXY(4))
          CALL FMMPY_R1(MXY(3),MXY(4))
          CALL FMSQRT_R1(MXY(3))
          CALL FMDIV_R1(MXY(3),MXY(1))
          CALL FMATANH(MXY(3),MXY(2))
      ENDIF

      NAMEST(NCALL) = 'FMACOSH'
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMACOSH

      SUBROUTINE FMADD(MA,MB,MC)

!  MC = MA + MB

!  This routine performs the trace printing for addition.  FMADD2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADD'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMADD2(MA,MB,MC)

          CALL FMNTR(1,MC,MC,1,1)
      ELSE
          CALL FMADD2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD

      SUBROUTINE FMADD2(MA,MB,MC)

!  Internal addition routine.  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MA0,MA1,MA2,MAS,MB0,MB1,MB2,MB2RD,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      REAL :: B2RDA,B2RDB
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MA2 = MWK(START(MA)+3)
      MB2 = MWK(START(MB)+3)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          IF (KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MWK(START(MA)+3) == 0 .OR.  &
                  MWK(START(MB)+3) == 0) THEN
                  NCALL = NCALL + 1
                  IF (KSUB == 1) THEN
                      NAMEST(NCALL) = 'FMSUB'
                  ELSE
                      NAMEST(NCALL) = 'FMADD'
                  ENDIF
                  CALL FMRSLT(MA,MB,MC,KRESLT)
                  JRSIGN = JRSSAV
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MWK(START(MA)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MB,MC)
              MWK(START(MC)+1) = MA0
              KFLAG = 1
              IF (KSUB == 1) THEN
                  IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                      MWK(START(MC)) = -MWK(START(MC))
                  KFLAG = 0
              ENDIF
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MA,MC)
              MWK(START(MC)+1) = MA0
              KFLAG = 1
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      MA0 = MWK(START(MA)+1)
      IF (KACCSW == 1) THEN
          MB0 = MWK(START(MB)+1)
          MA1 = MWK(START(MA)+2)
          MB1 = MWK(START(MB)+2)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KROUND_RETRY >= 1) THEN
              NGUARD = NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MA,MB,NGUARD,NMWA)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MB,MA,NGUARD,NMWA)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (KROUND_RETRY == 1 .AND. NGUARD < NDIG) THEN
          KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MC and fix the sign of the result.

      CALL FMMOVE(MWA,MC)
      MWK(START(MC)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'FMSUB'
          ELSE
              NAMEST(NCALL) = 'FMADD'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          B2RDA = LOG(REAL(ABS(MWK(START(MC)+3))+1)/REAL(ABS(MA2)+1))/0.69315 +  &
                  REAL(MWK(START(MC)+2)-MA1)*ALOGM2 + REAL(MA0)
          B2RDB = LOG(REAL(ABS(MWK(START(MC)+3))+1)/REAL(ABS(MB2)+1))/0.69315 +  &
                  REAL(MWK(START(MC)+2)-MB1)*ALOGM2 + REAL(MB0)
          MB2RD = NINT(MAX(0.0,MIN(B2RDA,B2RDB,  &
                  (NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MC)+3))+1))/0.69315)))
          IF (MWK(START(MC)+3) == 0) THEN
              MWK(START(MC)+1) = 0
          ELSE
              MWK(START(MC)+1) = MIN(MAX(MA0,MB0),MB2RD)
          ENDIF
      ELSE
          MWK(START(MC)+1) = MA0
      ENDIF

      JRSIGN = JRSSAV
      KROUND_RETRY = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD2

      SUBROUTINE FMADD_R1(MA,MB)

!  MA = MA + MB

!  This routine performs the trace printing for addition.  FMADD2_R1 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADD_R1'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMADD2_R1(MA,MB)

          NAMEST(NCALL) = 'FMADD_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMADD2_R1(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD_R1

      SUBROUTINE FMADD2_R1(MA,MB)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MA0,MA1,MA2,MAS,MB0,MB1,MB2,MB2RD,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      REAL :: B2RDA,B2RDB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MA2 = MWK(START(MA)+3)
      MB2 = MWK(START(MB)+3)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          IF (KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MWK(START(MA)+3) == 0 .OR.  &
                  MWK(START(MB)+3) == 0) THEN
                  NCALL = NCALL + 1
                  IF (KSUB == 1) THEN
                      NAMEST(NCALL) = 'FMSUB_R1'
                  ELSE
                      NAMEST(NCALL) = 'FMADD_R1'
                  ENDIF
                  CALL FMRSLT(MA,MB,MXY(1),KRESLT)
                  CALL FMEQ(MXY(1),MA)
                  JRSIGN = JRSSAV
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MA) == -1) TEMPV(MA) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MWK(START(MA)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MB,MA)
              MWK(START(MA)+1) = MA0
              KFLAG = 1
              IF (KSUB == 1) THEN
                  IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0)  &
                      MWK(START(MA)) = -MWK(START(MA))
                  KFLAG = 0
              ENDIF
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MA)+1) = MA0
              KFLAG = 1
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      MA0 = MWK(START(MA)+1)
      IF (KACCSW == 1) THEN
          MB0 = MWK(START(MB)+1)
          MA1 = MWK(START(MA)+2)
          MB1 = MWK(START(MB)+2)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KROUND_RETRY >= 1) THEN
              NGUARD = NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MA,MB,NGUARD,NMWA)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MB,MA,NGUARD,NMWA)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (KROUND_RETRY == 1 .AND. NGUARD < NDIG) THEN
          KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MA and fix the sign of the result.

      CALL FMMOVE(MWA,MA)
      MWK(START(MA)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'FMSUB_R1'
          ELSE
              NAMEST(NCALL) = 'FMADD_R1'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          B2RDA = LOG(REAL(ABS(MWK(START(MA)+3))+1)/REAL(ABS(MA2)+1))/0.69315 +  &
                  REAL(MWK(START(MA)+2)-MA1)*ALOGM2 + REAL(MA0)
          B2RDB = LOG(REAL(ABS(MWK(START(MA)+3))+1)/REAL(ABS(MB2)+1))/0.69315 +  &
                  REAL(MWK(START(MA)+2)-MB1)*ALOGM2 + REAL(MB0)
          MB2RD = NINT(MAX(0.0,MIN(B2RDA,B2RDB,  &
                  (NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)))
          IF (MWK(START(MA)+3) == 0) THEN
              MWK(START(MA)+1) = 0
          ELSE
              MWK(START(MA)+1) = MIN(MAX(MA0,MB0),MB2RD)
          ENDIF
      ELSE
          MWK(START(MA)+1) = MA0
      ENDIF

      JRSIGN = JRSSAV
      KROUND_RETRY = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD2_R1

      SUBROUTINE FMADD_R2(MA,MB)

!  MB = MA + MB

!  This routine performs the trace printing for addition.  FMADD2_R2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADD_R2'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMADD2_R2(MA,MB)

          NAMEST(NCALL) = 'FMADD_R2'
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMADD2_R2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD_R2

      SUBROUTINE FMADD2_R2(MA,MB)

!  Internal addition routine.  MB = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MA0,MA1,MA2,MAS,MB0,MB1,MB2,MB2RD,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      REAL :: B2RDA,B2RDB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MA2 = MWK(START(MA)+3)
      MB2 = MWK(START(MB)+3)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          IF (KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MWK(START(MA)+3) == 0 .OR.  &
                  MWK(START(MB)+3) == 0) THEN
                  NCALL = NCALL + 1
                  IF (KSUB == 1) THEN
                      NAMEST(NCALL) = 'FMSUB_R2'
                  ELSE
                      NAMEST(NCALL) = 'FMADD_R2'
                  ENDIF
                  CALL FMRSLT(MA,MB,MXY(1),KRESLT)
                  CALL FMEQ(MXY(1),MB)
                  JRSIGN = JRSSAV
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MB) == -1) TEMPV(MB) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MWK(START(MA)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MB)+1) = MA0
              KFLAG = 1
              IF (KSUB == 1) THEN
                  IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
                      MWK(START(MB)) = -MWK(START(MB))
                  KFLAG = 0
              ENDIF
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MA,MB)
              MWK(START(MB)+1) = MA0
              KFLAG = 1
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      MA0 = MWK(START(MA)+1)
      IF (KACCSW == 1) THEN
          MB0 = MWK(START(MB)+1)
          MA1 = MWK(START(MA)+2)
          MB1 = MWK(START(MB)+2)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KROUND_RETRY >= 1) THEN
              NGUARD = NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MA,MB,NGUARD,NMWA)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MB,MA,NGUARD,NMWA)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (KROUND_RETRY == 1 .AND. NGUARD < NDIG) THEN
          KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MB and fix the sign of the result.

      CALL FMMOVE(MWA,MB)
      MWK(START(MB)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'FMSUB_R2'
          ELSE
              NAMEST(NCALL) = 'FMADD_R2'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          B2RDA = LOG(REAL(ABS(MWK(START(MB)+3))+1)/REAL(ABS(MA2)+1))/0.69315 +  &
                  REAL(MWK(START(MB)+2)-MA1)*ALOGM2 + REAL(MA0)
          B2RDB = LOG(REAL(ABS(MWK(START(MB)+3))+1)/REAL(ABS(MB2)+1))/0.69315 +  &
                  REAL(MWK(START(MB)+2)-MB1)*ALOGM2 + REAL(MB0)
          MB2RD = NINT(MAX(0.0,MIN(B2RDA,B2RDB,  &
                  (NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)))
          IF (MWK(START(MB)+3) == 0) THEN
              MWK(START(MB)+1) = 0
          ELSE
              MWK(START(MB)+1) = MIN(MAX(MA0,MB0),MB2RD)
          ENDIF
      ELSE
          MWK(START(MB)+1) = MA0
      ENDIF

      JRSIGN = JRSSAV
      KROUND_RETRY = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD2_R2

      SUBROUTINE FMADDI(MA,IVAL)

!  MA = MA + IVAL

!  Increment MA by one word integer IVAL.

!  This routine is faster than FMADD when IVAL is small enough so that it can be added to a single
!  word of MA without often causing a carry.  Otherwise FMI2M and FMADD are used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAEXP,MD2B,MKSUM
      INTEGER :: KPTMA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADDI'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KFLAG = 0

      MAEXP = MWK(START(MA)+2)
      IF (MAEXP <= 0 .OR. MAEXP > NDIG) GO TO 110
      KPTMA = INT(MAEXP) + 1
      IF (MWK(START(MA)) < 0) THEN
          MKSUM = MWK(START(MA)+KPTMA+1) - IVAL
      ELSE
          MKSUM = MWK(START(MA)+KPTMA+1) + IVAL
      ENDIF

      IF (MKSUM >= MBASE .OR. MKSUM < 0) GO TO 110
      IF (KPTMA == 2 .AND. MKSUM == 0) GO TO 110
      MWK(START(MA)+KPTMA+1) = MKSUM
      GO TO 120

  110 CALL FMI2M(IVAL,MXY(1))
      CALL FMADD2_R1(MA,MXY(1))

  120 IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MWK(START(MA)+1),MD2B)
      ENDIF
      IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MA,MA,1,1)
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMADDI

      SUBROUTINE FMADDN(MA,MB,NGUARD,NMWA)

!  Internal addition routine.  MWA = MA - MB
!  The arguments are such that MA >= MB >= 0.

!  NGUARD is the number of guard digits being carried.
!  NMWA is the number of words in MWA that will be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NGUARD,NMWA
      REAL (KIND(1.0D0)) :: MK,MR
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMB,JMWA,K,KL,KP1,KP2,KPT,KSH,N1,N2,NK,NK1
      INTENT (IN) :: MA,MB

      N1 = NDIG + 1

!             Check for an insignificant operand.

      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      IF (MK >= NDIG+2) THEN
          DO J = 1, N1
             MWK(START(MWA)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+N1+2) = 0
          IF (KROUND == 0 .OR. (KROUND == 2 .AND. JRSIGN == -1) .OR.  &
             (KROUND == -1 .AND. JRSIGN == 1)) THEN
              MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) - 1
              GO TO 120
          ENDIF
          KFLAG = 1
          RETURN
      ENDIF
      K = INT(MK)
      IF (NGUARD <= 1) NMWA = N1 + 2

!             Subtract MB from MA.

      KP1 = MIN(N1,K+1)
      MWK(START(MWA)+K+2) = 0
      DO J = 1, KP1
         MWK(START(MWA)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 1
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) - MWK(JMB+J)
      ENDDO

      N2 = NDIG + 2
      IF (N2-K <= 1) N2 = 2 + K
      NK = MIN(NMWA,N1+K)
      DO J = N2, NK
         MWK(START(MWA)+J+1) = -MWK(START(MB)+J-K+1)
      ENDDO
      NK1 = NK + 1
      DO J = NK1, NMWA
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             Normalize.  Fix the sign of any negative digit.

      IF (K > 0) THEN
          DO J = NMWA, KP2, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
             ENDIF
          ENDDO

          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) < 0 .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) + MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) - 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
          GO TO 130
      ENDIF

  120 DO J = N1, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
         ENDIF
      ENDDO

!             Shift left if there are any leading zeros in the mantissa.

  130 DO J = 2, NMWA
         IF (MWK(START(MWA)+J+1) > 0) THEN
             KSH = J - 2
             GO TO 140
         ENDIF
      ENDDO
      MWK(START(MWA)+2) = 0
      RETURN

  140 IF (KSH > 0) THEN
          KL = NMWA - KSH
          DO J = 2, KL
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+KSH+1)
          ENDDO
          DO J = KL+1, NMWA
             MWK(START(MWA)+J+1) = 0
          ENDDO
          MWK(START(MWA)+2) = MWK(START(MWA)+2) - KSH
          IF (MK >= NDIG+2) THEN
              MWK(START(MWA)+N1+1) = MBASE - 1
          ENDIF
      ENDIF

!             Round the result.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KROUND_RETRY = KROUND_RETRY + 1
      ENDIF
      MR = 2*MWK(START(MWA)+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,0)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                  MWK(START(MWA)+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ENDIF
      ENDIF

!             See if the result is equal to one of the input arguments.

      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) < NDIG) GO TO 150
      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) > NDIG+1) THEN
          KFLAG = 1
          GO TO 150
      ENDIF

      N2 = NDIG + 4
      DO J = 3, N1
         IF (MWK(START(MWA)+N2-J+1) /= MWK(START(MA)+N2-J+1)) GO TO 150
      ENDDO
      IF (MWK(START(MWA)+2) /= MWK(START(MA)+2)) GO TO 150
      IF (MWK(START(MWA)+3) /= ABS(MWK(START(MA)+3))) GO TO 150
      KFLAG = 1

  150 RETURN
      END SUBROUTINE FMADDN

      SUBROUTINE FMADDP(MA,MB,NGUARD,NMWA)

!  Internal addition routine.  MWA = MA + MB
!  The arguments are such that MA >= MB >= 0.

!  NMWA is the number of words in MWA that will be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NGUARD,NMWA
      REAL (KIND(1.0D0)) :: MK,MKT,MR
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMB,JMWA,K,KL,KP,KP2,KPT,KSHIFT,N1,N2,NK
      INTENT (IN) :: MA,MB

      N1 = NDIG + 1

!             Check for an insignificant operand.

      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      IF (MK >= NDIG+1) THEN
          MWK(START(MWA)+2) = MWK(START(MA)+2) + 1
          MWK(START(MWA)+3) = 0
          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+N1+3) = 0
          IF ((KROUND ==  2 .AND. JRSIGN ==  1) .OR.  &
              (KROUND == -1 .AND. JRSIGN == -1)) THEN
              MWK(START(MWA)+N1+3) = 1
              GO TO 120
          ENDIF
          KFLAG = 1
          RETURN
      ENDIF
      K = INT(MK)

!             Add MA and MB.

      MWK(START(MWA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MWA)+3) = 0
      DO J = 2, K+1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 2
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) + MWK(JMB+J)
      ENDDO
      N2 = NDIG + 2
      NK = MIN(NMWA,N1+K)
      DO J = N2, NK
         MWK(START(MWA)+J+2) = MWK(START(MB)+J-K+1)
      ENDDO
      DO J = NK+1, NMWA
         MWK(START(MWA)+J+2) = 0
      ENDDO

!             Normalize.  Fix any digit not less than MBASE.

      IF (K == NDIG) GO TO 140

      IF (K > 0) THEN
          DO J = N1+1, KP2, -1
             IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
             ENDIF
          ENDDO

          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) >= MBASE .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) - MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) + 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
          GO TO 120
      ENDIF

      DO J = N1+1, 3, -1
         IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
         ENDIF
      ENDDO

!             Shift right if the leading digit is not less than MBASE.

  120 IF (MWK(START(MWA)+3) >= MBASE) THEN
  130     KP = NMWA + 4
          DO J = 4, NMWA
             MWK(START(MWA)+KP-J+1) = MWK(START(MWA)+KP-J)
          ENDDO
          MKT = AINT (MWK(START(MWA)+3)/MBASE)
          MWK(START(MWA)+4) = MWK(START(MWA)+3) - MKT*MBASE
          MWK(START(MWA)+3) = MKT
          MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          IF (MWK(START(MWA)+3) >= MBASE) GO TO 130
      ENDIF

!             Round the result.

  140 KSHIFT = 0
      IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KROUND_RETRY = KROUND_RETRY + 1
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF

!             See if the result is equal to one of the input arguments.

      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) < NDIG) GO TO 150
      IF (KSHIFT == 0) GO TO 150
      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) > NDIG+1) THEN
          KFLAG = 1
          GO TO 150
      ENDIF

      N2 = NDIG + 4
      DO J = 3, N1
         IF (MWK(START(MWA)+N2-J+2) /= MWK(START(MA)+N2-J+1)) GO TO 150
      ENDDO
      IF (MWK(START(MWA)+2) /= MWK(START(MA)+2)+1) GO TO 150
      IF (MWK(START(MWA)+4) /= ABS(MWK(START(MA)+3))) GO TO 150
      KFLAG = 1

  150 RETURN
      END SUBROUTINE FMADDP

      SUBROUTINE FMARGS(KROUTN,NARGS,MA,MB,KRESLT)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)
!  KRESLT - Result code returned to the calling routine.

!  Result codes:

!   0 - Perform the normal operation
!   1 - The result is the first input argument
!   2 - The result is the second input argument
!   3 - The result is -OVERFLOW
!   4 - The result is +OVERFLOW
!   5 - The result is -UNDERFLOW
!   6 - The result is +UNDERFLOW
!   7 - The result is -1.0
!   8 - The result is +1.0
!   9 - The result is -pi/2
!  10 - The result is +pi/2
!  11 - The result is 0.0
!  12 - The result is UNKNOWN
!  13 - The result is +pi
!  14 - The result is -pi/4
!  15 - The result is +pi/4

      USE FMVALS
      IMPLICIT NONE
      CHARACTER(9) :: KROUTN
      INTEGER :: MA,MB
      INTEGER :: NARGS,KRESLT

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,NCATMA,NCATMB,NDS

!             These tables define the result codes to be returned for given values of the input
!             argument(s).

!             For example, row 7 column 2 of this array initialization KADD(2,7) = 2 means that if
!             the first argument in a call to FMADD is in category 7 ( -UNDERFLOW ) and the second
!             argument is in category 2 ( near -OVERFLOW but representable ) then the result code
!             is 2 ( the value of the sum is equal to the second input argument ).
!             See routine FMCAT for descriptions of the categories.

      INTEGER :: KADD(15,15) = RESHAPE(  (/                        &
                 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,12,12,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,12,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0,12, 1,12, 0, 0, 0, 0, 0, 4,      &
                 3, 2, 2, 2, 2,12,12, 5,12,12, 2, 2, 2, 2, 4,      &
                 3, 2, 2, 2, 2, 2, 5, 2, 6, 2, 2, 2, 2, 2, 4,      &
                 3, 2, 2, 2, 2,12,12, 6,12,12, 2, 2, 2, 2, 4,      &
                 3, 0, 0, 0, 0, 0,12, 1,12, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                12, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                12,12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KMPY(15,15) = RESHAPE(  (/                        &
                 4, 4, 4, 4,12,12,12,11,12,12,12, 3, 3, 3, 3,      &
                 4, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 3,      &
                 4, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 3,      &
                 4, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0, 3,      &
                12, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0,12,      &
                12,12,12, 6, 6, 6, 6,11, 5, 5, 5, 5,12,12,12,      &
                11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,      &
                12,12,12, 5, 5, 5, 5,11, 6, 6, 6, 6,12,12,12,      &
                12, 0, 0, 0, 0, 0, 5,11, 6, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 5,11, 6, 0, 0, 1, 0, 0,12,      &
                 3, 2, 2, 2, 2, 2, 5,11, 6, 2, 2, 2, 2, 2, 4,      &
                 3, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 4,      &
                 3, 3, 3, 3,12,12,12,11,12,12,12, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KDIV(15,15) = RESHAPE(  (/                        &
                12,12,12, 4, 4, 4, 4,12, 3, 3, 3, 3,12,12,12,      &
                12, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0,12,      &
                 6, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0, 5,      &
                 6, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 5,      &
                 6, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 5,      &
                 6, 6, 6, 6,12,12,12,12,12,12,12, 5, 5, 5, 5,      &
                11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,      &
                 5, 5, 5, 5,12,12,12,12,12,12,12, 6, 6, 6, 6,      &
                 5, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 6,      &
                 5, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 6,      &
                 5, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0, 6,      &
                12, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0,12,      &
                12,12,12, 3, 3, 3, 3,12, 4, 4, 4, 4,12,12,12   /)  &
        , (/ 15,15 /) )

      INTEGER :: KPWR(15,15) = RESHAPE(  (/                        &
                12,12, 0, 5,12,12,12, 8,12,12,12, 3, 0,12,12,      &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,      &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,      &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,      &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,      &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,      &
                12,12, 0, 3,12,12,12, 8,12,12,12, 5, 0,12,12,      &
                12,12,12,12,12,12,12,12,11,11,11,11,11,11,11,      &
                 4, 4, 4, 4,12,12,12, 8,12,12,12, 6, 6, 6, 6,      &
                 4, 4, 0, 0, 0, 8, 8, 8, 8, 0, 0, 1, 0, 6, 6,      &
                 4, 4, 0, 0, 0, 8, 8, 8, 8, 0, 0, 1, 0, 6, 6,      &
                 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,      &
                 6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 1, 0, 4, 4,      &
                 6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 1, 0, 4, 4,      &
                 6, 6, 6, 6,12,12,12, 8,12,12,12, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KSQRT(15) = (/ 12,12,12,12,12,12,12,11,12, 0, 0, 8, 0, 0,12 /)
      INTEGER :: KEXP(15)  = (/  6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 4, 4 /)
      INTEGER :: KLN(15)   = (/ 12,12,12,12,12,12,12,12,12, 0, 0,11, 0, 0,12 /)
      INTEGER :: KSIN(15)  = (/ 12,12, 0, 0, 0, 0, 5,11, 6, 0, 0, 0, 0,12,12 /)
      INTEGER :: KCOS(15)  = (/ 12,12, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0,12,12 /)
      INTEGER :: KTAN(15)  = (/ 12,12, 0, 0, 0, 0, 5,11, 6, 0, 0, 0, 0,12,12 /)
      INTEGER :: KASIN(15) = (/ 12,12,12, 9, 0, 0, 5,11, 6, 0, 0,10,12,12,12 /)
      INTEGER :: KACOS(15) = (/ 12,12,12,13, 0,10,10,10,10,10, 0,11,12,12,12 /)
      INTEGER :: KATAN(15) = (/  9, 9, 0,14, 0, 0, 5,11, 6, 0, 0,15, 0,10,10 /)
      INTEGER :: KSINH(15) = (/  3, 3, 0, 0, 0, 1, 5,11, 6, 1, 0, 0, 0, 4, 4 /)
      INTEGER :: KCOSH(15) = (/  4, 4, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 4, 4 /)
      INTEGER :: KTANH(15) = (/  7, 7, 0, 0, 0, 1, 5,11, 6, 1, 0, 0, 0, 8, 8 /)
      INTEGER :: KLG10(15) = (/ 12,12,12,12,12,12,12,12,12, 0, 0,11, 0, 0,12 /)
      INTENT (IN) :: MA,MB

      KRESLT = 12
      KFLAG = -4
      IF (MWK(START(MA)+2) == MUNKNO) RETURN
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MUNKNO) RETURN
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NAMEST(NCALL) = KROUTN

!             Check the validity of parameters if this is a user call.

      IF (NCALL > 1 .AND. KDEBUG == 0) GO TO 130

!             Check NDIG.

      IF (NDIG < 2) THEN
          KFLAG = -1
          CALL FMWARN
          NDS = NDIG
          IF (NDIG < 2) NDIG = 2
          WRITE (KW,                                                      &
                 "(' NDIG was',I10,'.  It has been changed to',I10,'.')"  &
                ) NDS,NDIG
          RETURN
      ENDIF

!             Check MBASE.

      IF (MBASE < 2 .OR. MBASE > MXBASE) THEN
          KFLAG = -2
          CALL FMWARN
          MBS = MBASE
          IF (MBASE < 2) MBASE = 2
          IF (MBASE > MXBASE) MBASE = MXBASE
          WRITE (KW,                                                       &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(MBASE)
          CALL FMCONS
          RETURN
      ENDIF

!             Check exponent range.

      IF (MWK(START(MA)+2) > MXEXP+1 .OR. MWK(START(MA)+2) < -MXEXP) THEN
          IF (ABS(MWK(START(MA)+2)) /= MEXPOV .OR. ABS(MWK(START(MA)+3)) /= 1) THEN
              KFLAG = -3
              CALL FMWARN
              RETURN
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) > MXEXP+1 .OR. MWK(START(MB)+2) < -MXEXP) THEN
              IF (ABS(MWK(START(MB)+2)) /= MEXPOV .OR. ABS(MWK(START(MB)+3)) /= 1) THEN
                  KFLAG = -3
                  CALL FMWARN
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MWK(START(MA)+2)-INT(MWK(START(MA)+2))) /= 0) KFLAG = 1
      IF (MWK(START(MA)+3) <= (-1) .OR. MWK(START(MA)+3) >= MBASE .OR.  &
          ABS(MWK(START(MA)+3)-INT(MWK(START(MA)+3))) /= 0) KFLAG = 2
      IF (KDEBUG == 0) GO TO 110
      DO J = 3, NDIG+1
         IF (MWK(START(MA)+J+1) < 0 .OR. MWK(START(MA)+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA)+J+1)-INT(MWK(START(MA)+J+1))) /= 0) THEN
             KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
  110 IF (KFLAG /= 0) THEN
          J = KFLAG
          KFLAG = -4
          KWRNSV = KWARN
          IF (KWARN >= 2) KWARN = 1
          CALL FMWARN
          KWARN = KWRNSV
          IF (KWARN >= 1) THEN
              WRITE (KW,*) ' First invalid array element:  MA(', J,') = ',MWK(START(MA)+J+1)
          ENDIF
          KFLAG = -4
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MWK(START(MB)+2)-INT(MWK(START(MB)+2))) /= 0) KFLAG = 1
          IF (MWK(START(MB)+3) <= (-1) .OR. MWK(START(MB)+3) >= MBASE .OR.  &
              ABS(MWK(START(MB)+3)-INT(MWK(START(MB)+3))) /= 0) KFLAG = 2
          IF (KDEBUG == 0) GO TO 120
          DO J = 3, NDIG+1
             IF (MWK(START(MB)+J+1) < 0 .OR. MWK(START(MB)+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB)+J+1)-INT(MWK(START(MB)+J+1))) /= 0) THEN
                 KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (KFLAG /= 0) THEN
              J = KFLAG
              KFLAG = -4
              KWRNSV = KWARN
              IF (KWARN >= 2) KWARN = 1
              CALL FMWARN
              KWARN = KWRNSV
              IF (KWARN >= 1) THEN
                  WRITE (KW,*) ' First invalid array element:  MB(', J,') = ',MWK(START(MB)+J+1)
              ENDIF
              KFLAG = -4
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              RETURN
          ENDIF
      ENDIF

!             Check for special cases.

  130 CALL FMCAT(MA,NCATMA)
      IF (NCATMA > 15) THEN
          KRESLT = 12
          RETURN
      ENDIF
      NCATMB = 0
      IF (NARGS == 2) THEN
          CALL FMCAT(MB,NCATMB)
          IF (NCATMB > 15) THEN
              KRESLT = 12
              RETURN
          ENDIF
      ENDIF

      IF (KROUTN == 'FMADD') THEN
          KRESLT = KADD(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSUB') THEN
          IF (NCATMB < 16) NCATMB = 16 - NCATMB
          KRESLT = KADD(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMMPY') THEN
          KRESLT = KMPY(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMDIV') THEN
          KRESLT = KDIV(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMPWR') THEN
          KRESLT = KPWR(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSQRT' .OR. KROUTN == 'FMSQRT_R1') THEN
          KRESLT = KSQRT(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMEXP') THEN
          KRESLT = KEXP(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMLN') THEN
          KRESLT = KLN(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSIN') THEN
          KRESLT = KSIN(NCATMA)
          IF (KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMCOS') THEN
          KRESLT = KCOS(NCATMA)
          IF (KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMTAN') THEN
          KRESLT = KTAN(NCATMA)
          IF (KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMASIN') THEN
          KRESLT = KASIN(NCATMA)
          IF ((NCATMA == 7.OR.NCATMA == 9) .AND. KRAD == 0) KRESLT = 12
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMACOS') THEN
          KRESLT = KACOS(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMATAN') THEN
          KRESLT = KATAN(NCATMA)
          IF ((NCATMA == 7.OR.NCATMA == 9) .AND. KRAD == 0) KRESLT = 12
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSINH') THEN
          KRESLT = KSINH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMCOSH') THEN
          KRESLT = KCOSH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMTANH') THEN
          KRESLT = KTANH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMLG10') THEN
          KRESLT = KLG10(NCATMA)
          GO TO 140
      ENDIF

      KRESLT = 0
      RETURN

  140 IF (KRESLT == 12) THEN
          KFLAG = -4
          CALL FMWARN
      ENDIF
      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -5
          ELSE
              KFLAG = -5
              CALL FMWARN
          ENDIF
      ENDIF
      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -6
          ELSE
              KFLAG = -6
              CALL FMWARN
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMARGS

      SUBROUTINE FMASIN(MA,MB)

!  MB = ARCSIN(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),6,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE IF (MWK(START(MA)) >= 0 .AND. KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+2) > 0 .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMASIN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMASIN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMST2M('0.5',MXY(1))
          CALL FMSUB(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('30',MXY(5))
              GO TO 120
          ENDIF
          CALL FMADD(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('-30',MXY(5))
              GO TO 120
          ENDIF
      ENDIF

!             Use ASIN(X) = ATAN(X/SQRT(1-X*X))

      CALL FMI2M(1,MXY(3))
      CALL FMSUB(MXY(3),MXY(5),MXY(1))
      CALL FMADD(MXY(3),MXY(5),MXY(2))
      CALL FMMPY_R2(MXY(1),MXY(2))
      CALL FMSQRT_R1(MXY(2))
      CALL FMDIV(MXY(5),MXY(2),MXY(4))
      CALL FMATAN(MXY(4),MXY(5))

!             Round the result and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMASIN

      SUBROUTINE FMASINH(MA,MB)

!  MB = ARCSINH(MA)      Inverse hyperbolic sine.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENTR('FMASINH  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(2))
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(2))
      ELSE IF (MWK(START(MXY(1))+2) <= -MEXPAB) THEN
          CALL FMSIN(MXY(1),MXY(2))
          IF (KROUND /= 1) KR_RETRY = 2
      ELSE IF (MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMMPY_R2(MXY(1),MXY(2))
          CALL FMDIVI_R1(MXY(2),6)
          CALL FMSUB_R2(MXY(1),MXY(2))
          IF (KROUND /= 1) KR_RETRY = 2
      ELSE IF (4.0*(MWK(START(MXY(1))+2)-1) > NDIG) THEN
          CALL FMMPYI(MXY(1),2,MXY(2))
          IF (MWK(START(MXY(2))+2) == MEXPOV) THEN
              IF (MWK(START(MA)) < 0) THEN
                  CALL FMABS(MXY(1),MXY(3))
                  CALL FMLN(MXY(3),MXY(2))
                  CALL FMLNI(2,MXY(3))
                  CALL FMADD_R1(MXY(2),MXY(3))
                  IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
                      MWK(START(MXY(2))) = -MWK(START(MXY(2)))
              ELSE
                  CALL FMLN(MXY(1),MXY(2))
                  CALL FMLNI(2,MXY(3))
                  CALL FMADD_R1(MXY(2),MXY(3))
              ENDIF
          ELSE
              IF (MWK(START(MA)) < 0) THEN
                  CALL FMI2M(1,MXY(3))
                  CALL FMSQR(MXY(2),MXY(4))
                  CALL FMDIV_R2(MXY(3),MXY(4))
                  CALL FMABS(MXY(2),MXY(3))
                  CALL FMLN(MXY(3),MXY(2))
                  CALL FMADD_R1(MXY(2),MXY(4))
                  IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
                      MWK(START(MXY(2))) = -MWK(START(MXY(2)))
              ELSE
                  CALL FMI2M(1,MXY(3))
                  CALL FMSQR(MXY(2),MXY(4))
                  CALL FMDIV_R2(MXY(3),MXY(4))
                  CALL FMLN(MXY(2),MXY(3))
                  CALL FMADD(MXY(3),MXY(4),MXY(2))
              ENDIF
          ENDIF
      ELSE IF (MWK(START(MXY(1))+2) > 0) THEN
          IF (MWK(START(MA)) < 0) THEN
              CALL FMSQR(MXY(1),MXY(3))
              CALL FMI2M(1,MXY(2))
              CALL FMADD_R1(MXY(3),MXY(2))
              CALL FMSQRT_R1(MXY(3))
              CALL FMSUB_R1(MXY(3),MXY(1))
              CALL FMLN(MXY(3),MXY(2))
              IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
                  MWK(START(MXY(2))) = -MWK(START(MXY(2)))
          ELSE
              CALL FMSQR(MXY(1),MXY(3))
              CALL FMI2M(1,MXY(2))
              CALL FMADD_R1(MXY(3),MXY(2))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD_R2(MXY(1),MXY(3))
              CALL FMLN(MXY(3),MXY(2))
          ENDIF
      ELSE
          CALL FMSQR(MXY(1),MXY(3))
          CALL FMI2M(1,MXY(2))
          CALL FMADD_R1(MXY(3),MXY(2))
          CALL FMSQRT_R1(MXY(3))
          CALL FMDIV_R2(MXY(1),MXY(3))
          CALL FMATANH(MXY(3),MXY(2))
      ENDIF

      NAMEST(NCALL) = 'FMASINH'
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMASINH

      SUBROUTINE FMATAN(MA,MB)

!  MB = ARCTAN(MA)

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA,MB
      INTEGER :: NSTACK(49)
      REAL (KIND(1.0D0)) :: MA1,MACCA,MACMAX,MAS,MAXV,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,J2,K,K2,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KST,KTWO,KWRNSV,  &
                 NDSAV1,NDSAVE,NDSV,NMETHD,NTERM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KWRNSV = KWARN

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),-3,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE IF (MWK(START(MA)) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = KWRNSV
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (KROUND /= 1 .AND. MWK(START(MA)+2) > NDIG .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
          KRAD /= 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          KWARN = 0
          IF (MWK(START(MA)) < 0) THEN
              IF (MWK(START(MA)+2) /= MEXPOV) THEN
                  CALL FMI2M(180,MXY(1))
                  CALL FMPI(MXY(2))
                  CALL FMDIV(MXY(1),MXY(2),MXY(3))
                  CALL FMDIV(MXY(3),MA,MXY(2))
                  CALL FMI2M(-90,MXY(1))
                  CALL FMSUB(MXY(1),MXY(2),MXY(3))
              ELSE
                  CALL FMI2M(-90,MXY(1))
                  CALL FMTINY(MXY(2))
                  CALL FMADD(MXY(1),MXY(2),MXY(3))
              ENDIF
          ELSE
              IF (MWK(START(MA)+2) /= MEXPOV) THEN
                  CALL FMI2M(180,MXY(1))
                  CALL FMPI(MXY(2))
                  CALL FMDIV(MXY(1),MXY(2),MXY(3))
                  CALL FMDIV(MXY(3),MA,MXY(2))
                  CALL FMI2M(90,MXY(1))
                  CALL FMSUB(MXY(1),MXY(2),MXY(3))
              ELSE
                  CALL FMI2M(90,MXY(1))
                  CALL FMTINY(MXY(2))
                  CALL FMSUB(MXY(1),MXY(2),MXY(3))
              ENDIF
          ENDIF
          CALL FMEQ(MXY(3),MB)
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = KWRNSV
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMATAN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMATAN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NDIG = NDIG + NDIG/100
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(1,MXY(1))
          CALL FMSUB(MXY(3),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('45',MXY(5))
              GO TO 160
          ENDIF
          CALL FMADD(MXY(3),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('-45',MXY(5))
              GO TO 160
          ENDIF
      ENDIF

!             If MA >= 1 work with 1/MA.

      MA1 = MWK(START(MA)+2)
      MAS = MWK(START(MA))
      MWK(START(MXY(3))) = 1
      IF (MA1 >= 1) THEN
          CALL FMI2M(1,MXY(5))
          CALL FMDIV_R2(MXY(5),MXY(3))
      ENDIF

      KRSAVE = KRAD
      KRAD = 1
      X = MWK(START(MXY(3))+2)

!             In case pi has not been computed at the current precision and will be needed here,
!             get it to full precision first to avoid repeated calls at increasing precision during
!             Newton iteration.

      IF (MA1 >= 1 .OR. KRSAVE == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(5))
              NDIG = NDSV
          ENDIF
      ENDIF

      NMETHD = 1
      IF (NDIG*ALOGMT > 2000) NMETHD = 2
      IF (MWK(START(MXY(3))+2) < -NDIG) NMETHD = 1
      IF (NMETHD == 2) GO TO 140

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atan(x) = x - x^3 / 3 + x^5 / 5 - ...

      K2 = MAX(2,INT(0.67*(NDIG*ALOGMT)**0.3333 + 0.4))
      K2 = MAX(K2,3)
      IF (MWK(START(MXY(3))+2) <= -NDIG/3) THEN
          K2 = 0
      ELSE
          IF (MWK(START(MXY(3))+2)*DLOGMB < LOG(2.0D0**(-K2))) THEN
              K2 = 0
          ELSE
              CALL FMM2DP(MXY(3),X)
              K = K2 + 1
              DO J = 0, K
                 IF (X < 0.375D0/2.0D0**(J)) THEN
                     K2 = K2 - 1
                     IF (K2 <= 0) EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL FMEQ(MXY(3),MXY(1))
      CALL FMI2M(1,MXY(4))
      DO J = 1, K2
         CALL FMSQR(MXY(1),MXY(2))
         CALL FMADD_R2(MXY(4),MXY(2))
         CALL FMSQRT_R1(MXY(2))
         CALL FMSUB_R1(MXY(2),MXY(4))
         CALL FMDIV_R2(MXY(2),MXY(1))
      ENDDO

      J2 = INT(0.96*(NDIG*ALOGMT)**0.3333 - 1.7)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      NTERM = 1
      DO J = 1, J2
         IF (NTERM > 1) THEN
             CALL FMCSDIVI(MXY(1),NTERM,MJSUMS(J))
         ELSE
             CALL FMEQ(MXY(1),MJSUMS(J))
         ENDIF
         NTERM = NTERM + 2
      ENDDO
      NDSAV1 = NDIG
      CALL FMEQ(MXY(1),MXY(4))
      CALL FMSQR_R1(MXY(1))
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 130
      CALL FMIPWR(MXY(1),J2,MXY(2))

  120 CALL FMCSMPY_R1(MXY(4),MXY(2))
      DO J = 1, J2
         CALL FMCSDIVI(MXY(4),NTERM,MXY(5))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(5))
         IF (KFLAG /= 0) GO TO 130
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(5))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(5))
      IF (MWK(START(MXY(1))+2) /= MUNKNO .AND. MWK(START(MXY(1))+3) /= 0)  &
          MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(1))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO

!             Reverse the argument reduction.

      KTWO = 1
      MAXV = MXBASE/2
      DO J = 1, K2
         KTWO = 2*KTWO
         IF (KTWO > MAXV) THEN
             CALL FMCSMPYI_R1(MXY(5),KTWO)
             KTWO = 1
         ENDIF
      ENDDO
      IF (KTWO > 1) CALL FMCSMPYI_R1(MXY(5),KTWO)

      GO TO 150

!             Method 2.  Newton iteration.

  140 CALL FMI2M(0,MXY(1))
      CALL FMI2M(0,MXY(2))
      CALL FMI2M(0,MXY(4))

      IF (MWK(START(MXY(3))+2)*DLOGMB < -46) THEN
          CALL FMEQ(MXY(3),MXY(5))
      ELSE
          CALL FMM2DP(MXY(3),X)
          X = ATAN(X)
          CALL FMDPM(X,MXY(5))
      ENDIF
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMSIN(MXY(5),MXY(4))
         IF (2*MWK(START(MXY(5))+2) <= -NDIG) THEN
             CALL FMI2M(1,MXY(2))
             CALL FMSUB(MXY(2),MXY(4),MXY(1))
             CALL FMADD_R1(MXY(2),MXY(4))
             CALL FMMPY_R1(MXY(1),MXY(2))
             CALL FMSQRT(MXY(1),MXY(2))
             CALL FMDIV_R2(MXY(4),MXY(2))
             CALL FMSUB_R1(MXY(2),MXY(3))
             CALL FMMPY_R2(MXY(1),MXY(2))
             CALL FMSUB_R1(MXY(5),MXY(2))
         ELSE
             CALL FMSQR(MXY(4),MXY(1))
             CALL FMI2M(1,MXY(2))
             CALL FMSUB_R2(MXY(2),MXY(1))
             CALL FMSQRT(MXY(1),MXY(2))
             CALL FMDIV_R2(MXY(4),MXY(2))
             CALL FMSUB_R1(MXY(2),MXY(3))
             CALL FMMPY_R2(MXY(1),MXY(2))
             CALL FMSUB_R1(MXY(5),MXY(2))
         ENDIF
      ENDDO
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)

!             If MA >= 1 use pi/2 - ATAN(1/MA)

  150 IF (MA1 >= 1) THEN
          CALL FMDIVI(MPISAV,2,MXY(4))
          CALL FMSUB_R2(MXY(4),MXY(5))
      ENDIF

!             Convert to degrees if necessary, round and return.

      KRAD = KRSAVE
      IF (KRAD == 0) THEN
          CALL FMMPYI_R1(MXY(5),180)
          CALL FMDIV_R1(MXY(5),MPISAV)
      ENDIF
      IF (MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0 .AND. MAS < 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

  160 IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KFLAG == 1) KFLAG = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMATAN

      SUBROUTINE FMATANH(MA,MB)

!  MB = ARCTANH(MA)      Inverse hyperbolic tangent.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MAXV,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,J2,K,K2,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,K_RETURN_CODE,KRSAVE,KTWO,  &
                 KWRNSV,NDSAV1,NDSAVE,NMETHD,NTERM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(10),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KWRNSV = KWARN

      IF (MBLOGS /= MBASE) CALL FMCONS
      MAS = MWK(START(MA))
      K = 0
      K_RETURN_CODE = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),3,MXY(2))
          IF (MWK(START(MXY(2))+2) < -NDIG) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MXY(3))
          CALL FMDIVI(MXY(3),3,MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MXY(9))
                  IF (MWK(START(MXY(9))+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9))
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9))
                          ENDIF
                      ENDIF
                  ENDIF
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ELSE IF (MWK(START(MXY(4))+2) == MEXPUN) THEN
              IF (KRSAVE == 2 .AND. MWK(START(MA)) == 1) THEN
                  CALL FMTINY(MXY(9))
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
                  K_RETURN_CODE = 1
              ENDIF
              IF (KRSAVE == -1 .AND. MWK(START(MA)) == -1) THEN
                  CALL FMTINY(MXY(9))
                  MWK(START(MXY(9))) = -1
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
                  K_RETURN_CODE = 1
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMATANH'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMATANH  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMATANH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NDIG = NDIG + NDIG/100
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(3))) = 1

!             Check for special cases.

      IF (MWK(START(MXY(3))+2) >= 1) THEN
          CALL FMST2M('UNKNOWN',MXY(5))
          KFLAG = -4
          GO TO 160
      ELSE IF (MWK(START(MXY(3))+3) == 0) THEN
          CALL FMI2M(0,MXY(5))
          GO TO 160
      ELSE IF (MWK(START(MXY(3))+2) == MEXPUN) THEN
          CALL FMEQ(MXY(3),MXY(5))
          IF (MWK(START(MA)) < 0) MWK(START(MXY(5))) = -1
          KFLAG = -6
          GO TO 160
      ENDIF

      NMETHD = 1
      CALL FMM2DP(MXY(3),X)
      IF (MWK(START(MXY(3))+2) >= -NDIG) THEN
          IF (ABS(X) >= 1234.0/(NDIG*ALOGMT)**2) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 140

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atanh(x) = x + x^3 / 3 + x^5 / 5 + ...

      K2 = MAX(2,INT(0.67*(NDIG*ALOGMT)**0.3333 + 0.4))
      K2 = MAX(K2,3)
      IF (MWK(START(MXY(3))+2) <= -NDIG/3) THEN
          K2 = 0
      ELSE
          IF (MWK(START(MXY(3))+2)*DLOGMB < LOG(2.0D0**(-K2))) THEN
              K2 = 0
          ELSE
              K = K2 + 1
              DO J = 0, K
                 IF (X < 0.375D0/2.0D0**(J)) THEN
                     K2 = K2 - 1
                     IF (K2 <= 0) EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL FMEQ(MXY(3),MXY(1))
      CALL FMI2M(1,MXY(4))
      DO J = 1, K2
         CALL FMSQR(MXY(1),MXY(2))
         CALL FMSUB_R2(MXY(4),MXY(2))
         CALL FMSQRT_R1(MXY(2))
         CALL FMSUB_R2(MXY(4),MXY(2))
         CALL FMDIV_R2(MXY(2),MXY(1))
      ENDDO

      J2 = INT(0.96*(NDIG*ALOGMT)**0.3333 - 1.7)
      J2 = MAX(1,MIN(J2,LJSUMS))

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      NTERM = 1
      DO J = 1, J2
         IF (NTERM > 1) THEN
             CALL FMCSDIVI(MXY(1),NTERM,MJSUMS(J))
         ELSE
             CALL FMEQ(MXY(1),MJSUMS(J))
         ENDIF
         NTERM = NTERM + 2
      ENDDO
      NDSAV1 = NDIG
      CALL FMEQ(MXY(1),MXY(4))
      CALL FMSQR_R1(MXY(1))
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 130
      CALL FMIPWR(MXY(1),J2,MXY(2))

  120 CALL FMCSMPY_R1(MXY(4),MXY(2))
      DO J = 1, J2
         CALL FMCSDIVI(MXY(4),NTERM,MXY(5))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(5))
         IF (KFLAG /= 0) GO TO 130
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(5))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(5))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(1))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO

!             Reverse the argument reduction.

      KTWO = 1
      MAXV = MXBASE/2
      DO J = 1, K2
         KTWO = 2*KTWO
         IF (KTWO > MAXV) THEN
             CALL FMCSMPYI_R1(MXY(5),KTWO)
             KTWO = 1
         ENDIF
      ENDDO
      IF (KTWO > 1) CALL FMCSMPYI_R1(MXY(5),KTWO)

      GO TO 150

!             Method 2.  Atanh(x) =  ln( (1+x) / (1-x) ) / 2

  140 IEXTRA = -MWK(START(MXY(3))+2)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
          NDIG = NDIG + IEXTRA
      ENDIF
      CALL FMI2M(1,MXY(1))
      CALL FMADD(MXY(1),MXY(3),MXY(4))
      CALL FMSUB(MXY(1),MXY(3),MXY(5))
      CALL FMDIV(MXY(4),MXY(5),MXY(2))
      CALL FMLN(MXY(2),MXY(5))
      CALL FMDIVI_R1(MXY(5),2)

  150 IF (MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0 .AND. MAS < 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

      IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
  160 CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KFLAG == 1) KFLAG = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMATANH

      SUBROUTINE FMATN2(MA,MB,MC)

!  MC = ATAN2(MA,MB)

!  MC is returned as the angle between -pi and pi (or -180 and 180 if degree mode is selected) for
!  which TAN(MC) = MA/MB.  MC is an angle for the point (MB,MA) in polar coordinates.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JQUAD,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MB)) >= 0 .AND. KRAD == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KL = KROUND
          KROUND = 1
          NCALL = NCALL + 1
          CALL FMDIV(MA,MB,MXY(1))
          NCALL = NCALL - 1
          KROUND = KL
          IF (MWK(START(MXY(1))+2) < -NDIG) THEN
              NTRACE = J
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  CALL FMNTR(2,MA,MB,2,1)
                  NCALL = NCALL - 1
              ENDIF
              NTRACE = 0
              IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
                  CALL FMEQ(MXY(1),MXY(3))
              ELSE
                  CALL FMSQR(MXY(1),MXY(2))
                  CALL FMMPY_R1(MXY(2),MXY(1))
                  CALL FMDIVI_R1(MXY(2),3)
                  IF (MWK(START(MXY(2))+2) /= MEXPUN) THEN
                      CALL FMSUB(MXY(1),MXY(2),MXY(3))
                  ELSE IF (MWK(START(MXY(1))) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                      KL = MWK(START(MXY(1))+2)
                      MWK(START(MXY(1))+2) = 0
                      CALL FMULP(MXY(1),MXY(2))
                      CALL FMSUB(MXY(1),MXY(2),MXY(4))
                      MWK(START(MXY(4))+2) = KL + MWK(START(MXY(4))+2)
                      CALL FMEQ(MXY(4),MXY(3))
                  ELSE IF (MWK(START(MXY(1))) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                      KL = MWK(START(MXY(1))+2)
                      MWK(START(MXY(1))+2) = 0
                      CALL FMULP(MXY(1),MXY(2))
                      CALL FMSUB(MXY(1),MXY(2),MXY(4))
                      MWK(START(MXY(4))+2) = KL + MWK(START(MXY(4))+2)
                      CALL FMEQ(MXY(4),MXY(3))
                  ELSE
                      CALL FMEQ(MXY(1),MXY(3))
                  ENDIF
              ENDIF
              KFLAG = 0
              NTRACE = J
              KWARN = K
              CALL FMEQ(MXY(3),MC)
              IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
                  MWK(START(MB)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  KFLAG = -4
                  CALL FMWARN
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV .AND.  &
                       ABS(MWK(START(MB)+2))  < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
                  CALL FMWARN
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  CALL FMNTR(1,MC,MC,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NTRACE = J
          KWARN = K
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB) THEN
          CALL FMENTR('FMATN2   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMATN2'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

      KWRNSV = KWARN
      KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
         (MWK(START(MA)+3) == 0 .AND. MWK(START(MB)+3) == 0)) THEN
          CALL FMST2M('UNKNOWN',MXY(5))
          KFLAG = -4
          GO TO 120
      ENDIF
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(3))
          ELSE IF (MWK(START(MA)+2) == MEXPOV) THEN
              CALL FMBIG(MXY(3))
          ELSE
              CALL FMEQ(MXY(1),MXY(3))
          ENDIF
          MWK(START(MXY(3))) = MWK(START(MA))
          IF (MWK(START(MB)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(4))
          ELSE IF (MWK(START(MB)+2) == MEXPOV) THEN
              CALL FMBIG(MXY(4))
          ELSE
              CALL FMEQ(MXY(2),MXY(4))
          ENDIF
          MWK(START(MXY(4))) = MWK(START(MB))
          IF (MWK(START(MXY(3))+2) > MWK(START(MXY(4))+2)+NDIG) THEN
              IF (MWK(START(MA)) > 0) THEN
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(90,MXY(3))
                  CALL FMSUB(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
              IF (MWK(START(MA)) < 0) THEN
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(-90,MXY(3))
                  CALL FMSUB(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
          IF (MWK(START(MXY(4))+2) > MWK(START(MXY(3))+2)+NDIG .AND. MWK(START(MB)) < 0) THEN
              IF (MWK(START(MA)) > 0) THEN
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(180,MXY(3))
                  CALL FMADD(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
              IF (MWK(START(MA)) < 0) THEN
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(-180,MXY(3))
                  CALL FMADD(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
      ENDIF

      IF (MWK(START(MB)+3) == 0 .AND. MWK(START(MA)) > 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),2)
          ENDIF
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+3) == 0 .AND. MWK(START(MA)) < 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(-90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),-2)
          ENDIF
          GO TO 120
      ENDIF

      MXEXP1 = INT(MXEXP2/2.01D0)
      IF (MWK(START(MA)+2) == MEXPOV .AND. MWK(START(MB)+2) < MXEXP1-NDIG-2) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),2)
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN .AND. (-MWK(START(MB)+2)) < MXEXP1-NDIG-2 .AND.  &
                                 MWK(START(MB)) < 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(180,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+2) == MEXPOV .AND. MWK(START(MA)+2) < MXEXP1-NDIG-2 .AND.  &
                                MWK(START(MB)) < 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(180,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+2) == MEXPUN .AND. MWK(START(MA)+3) == 0) THEN
          IF (MWK(START(MB)) < 0) THEN
              IF (KRAD == 0) THEN
                  CALL FMI2M(180,MXY(5))
              ELSE
                  CALL FMPI(MXY(5))
              ENDIF
          ELSE
              CALL FMI2M(0,MXY(5))
          ENDIF
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+2) == MEXPUN .AND. (-MWK(START(MA)+2)) < MXEXP1-NDIG-2) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),2)
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

!             Determine the quadrant for the result, then use FMATAN.

      IF (MWK(START(MA)) >= 0 .AND. MWK(START(MB)) > 0) JQUAD = 1
      IF (MWK(START(MA)) >= 0 .AND. MWK(START(MB)) < 0) JQUAD = 2
      IF (MWK(START(MA))  < 0 .AND. MWK(START(MB)) < 0) JQUAD = 3
      IF (MWK(START(MA))  < 0 .AND. MWK(START(MB)) > 0) JQUAD = 4

      CALL FMDIV(MXY(1),MXY(2),MXY(4))
      MWK(START(MXY(4))) = 1
      CALL FMATAN(MXY(4),MXY(5))

      IF (JQUAD == 2 .OR. JQUAD == 3) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(180,MXY(3))
              CALL FMSUB_R2(MXY(3),MXY(5))
          ELSE
              CALL FMPI(MXY(3))
              CALL FMSUB_R2(MXY(3),MXY(5))
          ENDIF
      ENDIF

      IF ((JQUAD == 3 .OR. JQUAD == 4) .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(5))+3) /= 0) MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Round the result and return.

  120 IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACCB,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMATN2

      SUBROUTINE FMBIG(MA)

!     MA = The biggest representable FM number using the current base and precision.
!          The smallest positive number is then 1.0/MA.
!          In some rounding modes, 1.0/(1.0/MA) may then overflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,N1

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMBIG'

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1
      DO J = 2, N1
         MWK(START(MA)+J+1) = MBASE - 1
      ENDDO
      MWK(START(MA)+2) = MXEXP + 1
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA)) = 1

      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBIG

      SUBROUTINE FMCAT(MA,NCAT)

!  NCAT is returned as the category of MA.  This is used by the various arithmetic routines to
!  handle special cases such as: 'number greater than 1' + 'underflowed result' is the first
!  argument, 'overflowed result' / 'overflowed result' is 'unknown'.

!  NCAT       range

!   1.         -OV                OV stands for overflowed results.
!   2.   (-OV   , -OVTH)             ( MWK(START(MA)+2) >= MAXEXP+2 )
!   3.   (-OVTH ,    -1)
!   4.         -1                 OVTH stands for a representable
!   5.   (-1    , -UNTH)               number near the overflow
!   6.   (-UNTH ,   -UN)               threshold.
!   7.         -UN                     ( MWK(START(MA)+2) >= MAXEXP-NDIG+1 )
!   8.          0
!   9.         +UN                UN stands for underflowed results.
!  10.   (+UN   , +UNTH)             ( MWK(START(MA)+2) <= -MAXEXP-1 )
!  11.   (+UNTH ,    +1)
!  12.         +1                 UNTH stands for a representable
!  13.   (+1    , +OVTH)               number near the underflow
!  14.   (+OVTH ,   +OV)               threshold.
!  15.         +OV                     ( MWK(START(MA)+2) <= -MAXEXP+NDIG-1 )
!  16.       UNKNOWN

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: NCAT

      REAL (KIND(1.0D0)) :: MA2,MXEXP1
      INTEGER :: J,NLAST
      INTENT (IN) :: MA
      INTENT (INOUT) :: NCAT

!             Check for special symbols.

      NCAT = 16
      IF (MWK(START(MA)+2) == MUNKNO) RETURN

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          NCAT = 15
          IF (MWK(START(MA)) < 0) NCAT = 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          NCAT = 9
          IF (MWK(START(MA)) < 0) NCAT = 7
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          NCAT = 8
          RETURN
      ENDIF

!             Check for +1 or -1.

      MA2 = ABS(MWK(START(MA)+3))
      IF (MWK(START(MA)+2) == 1 .AND. MA2 == 1) THEN
          NLAST = NDIG + 1
          IF (NLAST >= 3) THEN
              DO J = 3, NLAST
                 IF (MWK(START(MA)+J+1) /= 0) GO TO 110
              ENDDO
          ENDIF
          NCAT = 12
          IF (MWK(START(MA)) < 0) NCAT = 4
          RETURN
      ENDIF

  110 MXEXP1 = INT(MXEXP)
      IF (MWK(START(MA)+2) >= MXEXP1-NDIG+2) THEN
          NCAT = 14
          IF (MWK(START(MA)) < 0) NCAT = 2
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) >= 1) THEN
          NCAT = 13
          IF (MWK(START(MA)) < 0) NCAT = 3
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) >= -MXEXP1+NDIG) THEN
          NCAT = 11
          IF (MWK(START(MA)) < 0) NCAT = 5
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) >= -MXEXP1) THEN
          NCAT = 10
          IF (MWK(START(MA)) < 0) NCAT = 6
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE FMCAT

      SUBROUTINE FMCHANGEBASE(MA,MB,NEW_MBASE,NEW_NDIG)

!  Change the internal representation of a number from one base to another.
!  MA is given with NDIG digits in base MBASE (the current precision and base).
!  MB is returned as the same number, approximated with NEW_NDIG digits in base NEW_MBASE.

!  Note NDIG and MBASE are unchanged after calling FMCHANGEBASE, but if MB is to be used
!  in further operations, NDIG and MBASE should be changed to the new values in the calling program.
!
!  This routine is primarily meant to be used by the input and output conversion routines when the
!  base being used is not a power of ten.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NEW_MBASE,NEW_NDIG
      INTENT (IN) :: MA,NEW_MBASE,NEW_NDIG
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE,IEXTRA,J,K,KL,KRSAVE,KR_RETRY,NDSAVE,MBPOWERS(9)
      REAL (KIND(1.0D0)) :: MBSAVE
      DOUBLE PRECISION :: ERR

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MBPOWERS = -2
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMCHANGEB'

!             The change of base is done by summing this series in the new base:
!                 d(1)/b + d(2)/b**2 + ... + d(k)/b**k
!             where d(i) is the i-th digit in the old base, b.

      NDSAVE = NDIG
      MBSAVE = MBASE
      MBASE = NEW_MBASE
      CALL FMCONS
      NDIG = NEW_NDIG + NGRD52

!             If the exponent is large, raise the precision.

      IEXTRA = MAX(0,ABS(INT(LOG(MAX(1.0D0,DBLE(ABS(MWK(START(MA)+2)))))/LOG(DBLE(MBSAVE))))+1)
      NDIG = NDIG + IEXTRA

      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      KRSAVE = KROUND
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

!             Initialize the array of powers of the base.

      CALL IMI2M2(1,MXY(3))
      DO K = 1, 9
         CALL IMMPYI2(MXY(3),INT(MBSAVE),MBPOWERS(K))
         CALL IMEQ(MBPOWERS(K),MXY(3))
      ENDDO

      CALL FMCHANGEBASE_TQ(MA,MBSAVE,0,NDSAVE-1,MXY(1),MXY(2),MBPOWERS)

      KROUND = 1
      CALL IMI2FM(MXY(1),MXY(3))
      CALL IMI2FM(MXY(2),MXY(4))
      CALL FMDIV2(MXY(3),MXY(4),MXY(2))

!             Put the exponent and sign on MB.

      K = MBSAVE
      CALL FMIM(K,MXY(3))
      K = MWK(START(MA)+2)
      IF (K /= 0) THEN
          CALL FMIPWR2(MXY(3),K,MXY(4))
          CALL FMMPY2(MXY(2),MXY(4),MXY(1))
          CALL FMEQ(MXY(1),MXY(2))
      ENDIF
      MWK(START(MXY(2))) = MWK(START(MA))
      IF (KRSAVE /= 1) THEN
          K = (NDIG + NEW_NDIG) / 2
          KROUND = 1
          CALL FMEQU(MXY(2),MB,NDIG,K)
          KROUND = KRSAVE
          CALL FMEQU_R1(MB,K,NEW_NDIG)
      ELSE
          KROUND = KRSAVE
          CALL FMEQU(MXY(2),MB,NDIG,NEW_NDIG)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL >= 1) THEN
          KL = MIN(NDIG-NEW_NDIG,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NEW_NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NEW_NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      MBASE = MBSAVE
      CALL FMCONS
      NDIG = NDSAVE

      NUMBER_USED = NUMBER_USED_SAVE
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHANGEBASE

      RECURSIVE SUBROUTINE FMCHANGEBASE_TQ(MA,MBSAVE,A,B,MT,MQ,MBPOWERS)

!  This routine does the binary splitting for computing a change of base.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MT,MQ
      INTEGER :: A,B
      REAL (KIND(1.0D0)) :: MBSAVE
      INTENT (IN) :: MA,A,B,MBSAVE
      INTENT (INOUT) :: MT,MQ
      INTEGER :: MXY(4),NUMBER_USED_SAVE,DIGIT,J,K,M,OLD_BASE,MBPOWERS(9)
      REAL (KIND(0.0D0)) :: DA,DB,DM

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      DM = MBSAVE
      OLD_BASE = MBSAVE
      RESULT_SIZE = ( (DB-DA+1)*LOG(DM) + 5 ) / DLOGMB + 8
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      IF (MQ <= 0) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 9) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          DIGIT = MWK(START(MA)+A+3)
          CALL IMI2M2(DIGIT,MT)
          DO J = A+1, B
             CALL IMMPYI2(MT,OLD_BASE,MXY(2))
             DIGIT = MWK(START(MA)+J+3)
             CALL IMI2M2(DIGIT,MXY(1))
             CALL IMADD2(MXY(2),MXY(1),MT)
          ENDDO

!             There may be thousands of calls, all with K = 5,6,7,8,9.
!             These powers are saved instead of re-computing them each time.

          K = B - A + 1
          CALL IMEQ(MBPOWERS(K),MQ)
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMCHANGEBASE_TQ(MA,MBSAVE,A,M-1,MXY(1),MXY(2),MBPOWERS)
      CALL FMCHANGEBASE_TQ(MA,MBSAVE,M,B,MXY(3),MXY(4),MBPOWERS)
      CALL IMMPY2(MXY(1),MXY(4),MQ)
      CALL IMADD2(MXY(3),MQ,MT)

      CALL IMMPY2(MXY(2),MXY(4),MQ)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHANGEBASE_TQ

      SUBROUTINE FMCHSH(MA,MB,MC)

!  MB = COSH(MA),    MC = SINH(MA)

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  FMCOSH and FMSINH.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      KR_RETRY = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCHSH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMCOSH(MA,MB)
          CALL FMSINH(MA,MC)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCHSH'
              CALL FMNTR(1,MB,MB,1,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL FMNTRJ(MC,NDIG)
                  ELSE
                      CALL FMPRNT(MC)
                  ENDIF
              ENDIF
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          NCSAVE = NCALL
          CALL FMENTR('FMCHSH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCSAVE + 1
          CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MXY(3))) = 1
          CALL FMCOSH(MXY(3),MXY(4))
          CALL FMSINH(MXY(3),MXY(5))
          GO TO 120
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCHSH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(3))) = 1

      K = 1
      IF (MWK(START(MXY(3))+2) == 0 .AND. MWK(START(MXY(3))+3) /= 0) THEN
          IF (MBASE/MWK(START(MXY(3))+3) >= 100) K = 2
      ENDIF
      IF (MWK(START(MXY(3))+2) >= 0 .AND. MWK(START(MXY(3))+3) /= 0 .AND. K == 1) THEN
          CALL FMCOSH(MXY(3),MXY(4))
          IF (MWK(START(MXY(4))+2) > NDIG) THEN
              CALL FMEQ(MXY(4),MXY(5))
              GO TO 120
          ENDIF
          CALL FMSQR(MXY(4),MXY(2))
          CALL FMI2M(-1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT(MXY(2),MXY(5))
      ELSE
          CALL FMSINH(MXY(3),MXY(5))
          CALL FMSQR(MXY(5),MXY(2))
          CALL FMI2M(1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT(MXY(2),MXY(4))
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEQU(MXY(5),MC,NDIG,NDSAVE)
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(4))+3))+1))/0.69315)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACCA,MACMAX)
      IF (KOVUN == 2) THEN
          KWRNSV = KWARN
          KWARN = 0
      ENDIF
      CALL FMEXIT(MXY(4),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KOVUN == 2) THEN
          KWARN = KWRNSV
      ENDIF
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHSH

      FUNCTION FMCOMP(MA,LREL,MB)

!  Logical comparison of FM numbers MA and MB.

!  LREL is a CHARACTER description of the comparison to be done:
!  LREL = 'EQ' returns FMCOMP = .TRUE. if MA == MB
!       = 'NE', 'GE', 'GT', 'LE', 'LT' also work like a logical IF.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

!  For comparisons involving 'UNKNOWN' or two identical special symbols such as
!  +OVERFLOW,'EQ',+OVERFLOW, FMCOMP is returned FALSE and a KFLAG = -4 error condition is returned.

      USE FMVALS
      IMPLICIT NONE

      LOGICAL :: FMCOMP
      CHARACTER(*) :: LREL
      CHARACTER(2) :: JREL
      INTEGER :: MA,MB

      INTEGER :: J,JCOMP,NLAST
      INTENT (IN) :: MA,LREL,MB

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMCOMP'

      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 2) THEN
          WRITE (KW,"(' Input to FMCOMP')")

          IF (NTRACE > 0) THEN
              CALL FMPRNT(MA)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL FMPRNT(MB)
          ELSE
              CALL FMNTRJ(MA,NDIG)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL FMNTRJ(MB,NDIG)
          ENDIF
      ENDIF

!             JCOMP will be 1 if MA > MB
!                           2 if MA == MB
!                           3 if MA < MB

!             Check for special cases.

      JREL = LREL
      IF (LREL /= 'EQ' .AND. LREL /= 'NE' .AND. LREL /= 'LT' .AND.  &
          LREL /= 'GT' .AND. LREL /= 'LE' .AND. LREL /= 'GE') THEN
          IF (LREL == 'eq' .OR. LREL == '==') THEN
              JREL = 'EQ'
          ELSE IF (LREL == 'ne' .OR. LREL == '/=') THEN
              JREL = 'NE'
          ELSE IF (LREL == 'lt' .OR. LREL == '<') THEN
              JREL = 'LT'
          ELSE IF (LREL == 'gt' .OR. LREL == '>') THEN
              JREL = 'GT'
          ELSE IF (LREL == 'le' .OR. LREL == '<=') THEN
              JREL = 'LE'
          ELSE IF (LREL == 'ge' .OR. LREL == '>=') THEN
              JREL = 'GE'
          ELSE
              FMCOMP = .FALSE.
              KFLAG = -4
              IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
              IF (KWARN <= 0) GO TO 120
              WRITE (KW,                                                     &
                     "(/' Error of type KFLAG = -4 in FM package in',"   //  &
                     "' routine FMCOMP'//1X,A,' is not one of the six'," //  &
                     "' recognized comparisons.'//' .FALSE. has been',"  //  &
                     "' returned.'/)"                                        &
                    ) LREL
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          FMCOMP = .FALSE.
          KFLAG = -4
          GO TO 120
      ENDIF

      IF (ABS(MWK(START(MA)+2)) == MEXPOV .AND. MWK(START(MA)+2) == MWK(START(MB)+2) .AND.  &
          MWK(START(MA)+3) == MWK(START(MB)+3) .AND. MWK(START(MA)) == MWK(START(MB))) THEN
          FMCOMP = .FALSE.
          KFLAG = -4
          IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
          IF (KWARN <= 0) GO TO 120
          WRITE (KW,                                                           &
                 "(/' Error of type KFLAG = -4 in FM package in routine'," //  &
                 "' FMCOMP'//' Two numbers in the same overflow or',"      //  &
                 "' underflow category cannot be compared.'//"             //  &
                 "' .FALSE. has been returned.'/)"                             &
                 )
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          GO TO 120
      ENDIF

!             Check for zero.

      KFLAG = 0
      IF (MWK(START(MA)+3) == 0) THEN
          JCOMP = 2
          IF (MWK(START(MB)+3) == 0) GO TO 110
          IF (MWK(START(MB)) < 0) JCOMP = 1
          IF (MWK(START(MB)) > 0) JCOMP = 3
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          JCOMP = 1
          IF (MWK(START(MA)) < 0) JCOMP = 3
          GO TO 110
      ENDIF

!             Check for opposite signs.

      IF (MWK(START(MA)) > 0 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)) > 0 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
          GO TO 110
      ENDIF

!             See which one is larger in absolute value.

      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
          GO TO 110
      ENDIF
      NLAST = NDIG + 1

      DO J = 2, NLAST
         IF (ABS(MWK(START(MA)+J+1)) > ABS(MWK(START(MB)+J+1))) THEN
             JCOMP = 1
             GO TO 110
         ENDIF
         IF (ABS(MWK(START(MB)+J+1)) > ABS(MWK(START(MA)+J+1))) THEN
             JCOMP = 3
             GO TO 110
         ENDIF
      ENDDO

      JCOMP = 2

!             Now match the JCOMP value to the requested comparison.

  110 IF (JCOMP == 1 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
      ELSE IF (JCOMP == 3 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
      ENDIF

      FMCOMP = .FALSE.
      IF (JCOMP == 1 .AND. (JREL == 'GT' .OR. JREL == 'GE' .OR. JREL == 'NE')) FMCOMP = .TRUE.
      IF (JCOMP == 2 .AND. (JREL == 'EQ' .OR. JREL == 'GE' .OR. JREL == 'LE')) FMCOMP = .TRUE.
      IF (JCOMP == 3 .AND. (JREL == 'NE' .OR. JREL == 'LT' .OR. JREL == 'LE')) FMCOMP = .TRUE.

  120 CONTINUE
      IF (NTRACE /= 0) THEN
          IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 1) THEN
              IF (KFLAG == 0) THEN
                  WRITE (KW,                                                   &
                         "(' FMCOMP',15X,'Call level =',I2,5X,'MBASE =',"  //  &
                         "I10,5X,'NDIG =',I10)"                                &
                        ) NCALL,INT(MBASE),NDIG
              ELSE
                  WRITE (KW,                                                  &
                         "(' FMCOMP',6X,'Call level =',I2,4X,'MBASE =',"  //  &
                         "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"               &
                        ) NCALL,INT(MBASE),NDIG,KFLAG
              ENDIF
              IF (FMCOMP) THEN
                  WRITE (KW,"(7X,'.TRUE.')")
              ELSE
                  WRITE (KW,"(7X,'.FALSE.')")
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      RETURN
      END FUNCTION FMCOMP

      SUBROUTINE FMCONS

!  Set several saved machine precision constants.

      USE FMVALS
      IMPLICIT NONE

      MBLOGS = MBASE
      ALOGMB = LOG(REAL(MBASE))
      ALOGM2 = ALOGMB/LOG(2.0)
      ALOGMX = LOG(REAL(MAXINT))
      ALOGMT = ALOGMB/LOG(10.0)
      NGRD21 = INT(2.0/ALOGMT + 1.0)
      NGRD52 = INT(5.0/ALOGMT + 2.0)
      NGRD22 = INT(2.0/ALOGMT + 2.0)
      IF (MBASE < 1000) THEN
          NGRD21 = 2*NGRD21
          NGRD52 = 4*NGRD52
          NGRD22 = 2*NGRD22
      ELSE
          NGRD21 = NGRD21 + 1
          NGRD52 = NGRD52 + 1
          NGRD22 = NGRD22 + 1
      ENDIF
      MEXPAB = AINT (MXEXP2/5)
      DLOGMB = LOG(DBLE(MBASE))
      DLOGTN = LOG(10.0D0)
      DLOGTW = LOG(2.0D0)
      DPPI = 4.0D0*ATAN(1.0D0)
      DLOGTP = LOG(2.0D0*DPPI)
      DLOGPI = LOG(DPPI)
      DLOGEB = -LOG(DPEPS)/DLOGMB

      RETURN
      END SUBROUTINE FMCONS

      SUBROUTINE FMCOS(MA,MB)

!  MB = COS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOS'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          IF (KRAD == 0) THEN
              CALL FMPI(MXY(2))
              CALL FMSQR(MXY(2),MXY(3))
              CALL FMDIVI_R1(MXY(3),32400)
              CALL FMMPY_R1(MXY(1),MXY(3))
          ENDIF
          CALL FMDIVI(MXY(1),-2,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(3),MB)
          ELSE IF (KROUND == -1 .OR. KROUND == 0) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMDP2M(0.9D0,MXY(2))
              CALL FMULP(MXY(2),MXY(3))
              CALL FMSUB(MXY(1),MXY(3),MB)
          ELSE
              CALL FMI2M(1,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOS'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMCOS    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCOS'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(6),NDSAVE,NDIG)
      MWK(START(MXY(6))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(6))) = 1
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(6))
          GO TO 120
      ENDIF
      CALL FMEQ(MXY(6),MXY(5))
      KWRNSV = KWARN
      KWARN = 0

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1))
          CALL FMSUB(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0 .AND. JSWAP == 1) THEN
              CALL FMST2M('0.5',MXY(1))
              CALL FMMPYI(MXY(1),JCOS,MXY(6))
              GO TO 120
          ENDIF
      ENDIF
      KWARN = KWRNSV
      IF (MWK(START(MXY(6))+2) == MUNKNO) THEN
          IF (KRAD /= 1 .OR. JSWAP == 1) THEN
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
              GO TO 120
          ENDIF
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(3))
              NDIG = NDSV
          ENDIF
          CALL FMDIV(MXY(5),MPISAV,MXY(3))
          CALL FMNINT(MXY(3),MXY(2))
          CALL FMMPY(MXY(2),MPISAV,MXY(1))
          CALL FMSUB_R2(MXY(5),MXY(1))
          IF (MWK(START(MXY(1))+3) == 0) CALL FMULP(MXY(5),MXY(1))
          CALL FMI2M(1,MXY(3))
          CALL FMSQR_R1(MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMSUB_R2(MXY(3),MXY(1))
          CALL FMSUB_R1(MXY(1),MXY(3))
          IF (MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(JCOS,MXY(6))
          ELSE
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
          ENDIF
          GO TO 120
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(4))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(6),MPISAV)
          CALL FMDIVI_R1(MXY(6),180)
      ENDIF
      IF (MWK(START(MXY(6))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              CALL FMCOS2(MXY(6),MXY(4))
              CALL FMEQ(MXY(4),MXY(6))
          ELSE
              IF (MWK(START(MXY(6))+2) < 0 .OR. NDIG <= 50) THEN
                  CALL FMSIN2(MXY(6),MXY(4))
                  CALL FMEQ(MXY(4),MXY(6))
              ELSE
                  CALL FMCOS2(MXY(6),MXY(4))
                  CALL FMI2M(1,MXY(2))
                  CALL FMSQR(MXY(4),MXY(6))
                  CALL FMSUB_R2(MXY(2),MXY(6))
                  CALL FMSQRT_R1(MXY(6))
              ENDIF
          ENDIF
      ENDIF

!             Append the sign, round, and return.

      IF (MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0 .AND. JCOS == -1)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))
  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOS

      SUBROUTINE FMCOS2(MA,MB)

!  Internal subroutine for MB = COS(MA) where 0 <= MA <= 1.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K2,KTWO,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG2,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(1,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series:  COS(X) = 1 - X**2/2! + X**4/4! - ...

!             The argument will be divided by 2**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

!             Since X is small when the series is summed, COS(X) - 1 is computed.  Then a version of
!             the recovery formula can be used that does not suffer from severe cancellation.

      B = REAL(MBASE)
      T = MAX(NDIG-NGRD52,2)
      ALOG2 = LOG(2.0)
      ALOGT = LOG(T)
      TJ = 0.69*(NDIG*ALOGMT)**0.3333
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      IF (NDIG > 2000) THEN
          J2 = -4.0 + 3.0*ALOGT
      ENDIF
      K2 = MAX(2,INT(1.25*(NDIG*ALOGMT)**0.3333 - 3.4))


      TJ = -(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
             REAL(MWK(START(MA)+4))/(B*B)))/ALOG2 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (NDIG > 2000) THEN
          K2 = 5.8*ALOGMB - 263 + (35 - 0.58*ALOGMB)*ALOGT
      ENDIF
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/ALOGMB)
      NDIG = NDIG + MAX(L2,0)
      NDSAV1 = NDIG
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))

!             Divide the argument by 2**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTWO = 1
      MAXV = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTWO)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMCSDIVI_R1(MXY(1),KTWO)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      NTERM = 2
      CALL FMI2M(1,MXY(2))
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMCSDIVI_R1(MXY(2),NBOT)
         CALL FMEQ(MXY(2),MJSUMS(J))
         NTERM = NTERM + 2
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMSQR_R1(MXY(1))
      CALL FMIPWR(MXY(1),J2,MXY(3))
      IF (MWK(START(MXY(3))+2) < -NDIG) GO TO 120

  110 CALL FMCSMPY_R1(MXY(2),MXY(3))
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(3))
      IF (MWK(START(MXY(1))+2) /= MUNKNO .AND. MWK(START(MXY(1))+3) /= 0)  &
          MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
      ENDDO
      CALL FMCSMPY_R1(MXY(3),MXY(1))

!             Reverse the effect of reducing the argument to compute COS(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1))
              DO J = 1, K2
                 CALL FMADD(MXY(3),MXY(1),MXY(2))
                 CALL FMCSMPY_R1(MXY(2),MXY(3))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2))
                 CALL FMADD(MXY(3),MXY(3),MXY(1))
                 CALL FMADD_R1(MXY(2),MXY(1))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(2))
      CALL FMADD_R2(MXY(2),MXY(3))

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOS2

      SUBROUTINE FMCOSH(MA,MB)

!  MB = COSH(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOSH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),2,MXY(2))
          IF (MWK(START(MXY(2))+2) > MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(2),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(2),MB)
          ELSE IF (KROUND == 2) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
          ELSE
              CALL FMI2M(1,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOSH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMCOSH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCOSH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(2))) = 1
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(1,MXY(2))
          GO TO 120
      ENDIF

!             Use a series for small arguments, FMEXP for large ones.

      IF (MWK(START(MXY(2))+2) == MUNKNO) GO TO 120
      IF (MBASE > 99) THEN
          IF (MWK(START(MXY(2))+2) <= 0) THEN
              NMETHD = 1
          ELSE IF (MWK(START(MXY(2))+2) >= 2) THEN
              NMETHD = 2
          ELSE IF (ABS(MWK(START(MXY(2))+3)) < 10) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(2))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          CALL FMCSH2(MXY(2),MXY(1))
          CALL FMEQ(MXY(1),MXY(2))
      ELSE
          CALL FMEXP(MXY(2),MXY(1))
          CALL FMEQ(MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+2) == MEXPOV) THEN
              GO TO 120
          ENDIF
          IF (INT(MWK(START(MXY(2))+2)) <= (NDIG+1)/2) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMDIV_R1(MXY(1),MXY(2))
              CALL FMADD_R1(MXY(2),MXY(1))
          ENDIF
          CALL FMDIVI_R1(MXY(2),2)
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(2))+3))+1))/0.69315)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOSH

      SUBROUTINE FMCSADD_R1(MA,MB)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: J,JMA,JMB,K,KP2,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB .OR.                          &
          ABS(MWK(START(MB)+2)) >= MEXPAB .OR. MWK(START(MA)+2) < MWK(START(MB)+2) .OR.  &
          MWK(START(MA)) < 0 .OR. MWK(START(MB)) < 0 .OR. MWK(START(MA)+3) == 0 .OR.     &
          MWK(START(MB)+3) == 0) THEN
          CALL FMADD_R1(MA,MB)
          RETURN
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1
      K = MWK(START(MA)+2) - MWK(START(MB)+2)

!             Add MA and MB.

      KP2 = K + 2
      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K

      DO J = KP2, N1
         MWK(JMA+J) = MWK(JMA+J) + MWK(JMB+J)
      ENDDO

!             Normalize.  Fix any digit not less than MBASE.

      IF (MWK(START(MA)+3) >= MBASE) THEN
          MWK(START(MA)+2) = MWK(START(MA)+2) + 1
          IF (MWK(JMA+N1) >= MBASE) MWK(JMA+NDIG) = MWK(JMA+NDIG) + 1
          DO J = NDIG, 3, -1
             IF (MWK(JMA+J) >= MBASE) THEN
                 MWK(JMA+J+1) = MWK(JMA+J) - MBASE
                 MWK(JMA+J-1) = MWK(JMA+J-1) + 1
             ELSE
                 MWK(JMA+J+1) = MWK(JMA+J)
             ENDIF
          ENDDO
          MWK(JMA+3) = MWK(JMA+2) - MBASE
          MWK(JMA+2) = 1
      ELSE
          DO J = N1, 3, -1
             IF (MWK(JMA+J) >= MBASE) THEN
                 MWK(JMA+J) = MWK(JMA+J) - MBASE
                 MWK(JMA+J-1) = MWK(JMA+J-1) + 1
             ENDIF
          ENDDO
          IF (MWK(JMA+2) >= MBASE) THEN
              DO J = N1, 4, -1
                 MWK(JMA+J) = MWK(JMA+J-1)
              ENDDO
              MWK(JMA+3) = MWK(JMA+2) - MBASE
              MWK(JMA+2) = 1
              MWK(START(MA)+2) = MWK(START(MA)+2) + 1
          ENDIF
      ENDIF

      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) >= NDIG) KFLAG = 1

      RETURN
      END SUBROUTINE FMCSADD_R1

      SUBROUTINE FMCSADDNN_R1(MA,MB)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: J,JMA,JMB,K,KP2,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB .OR. ABS(MWK(START(MB)+2)) >= MEXPAB  &
          .OR. MWK(START(MA)+2) < MWK(START(MB)+2) .OR. MWK(START(MA)+3) == 0                    &
          .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMCSNORM(MA)
          CALL FMADD_R1(MA,MB)
          RETURN
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1
      K = MWK(START(MA)+2) - MWK(START(MB)+2)

!             Add MA and MB.

      KP2 = K + 2
      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      DO J = KP2, N1
         MWK(JMA+J) = MWK(JMA+J) + MWK(JMB+J)
      ENDDO

!             See if the result is equal to one of the input arguments.

      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) >= NDIG) KFLAG = 1

      RETURN
      END SUBROUTINE FMCSADDNN_R1

      SUBROUTINE FMCSDIV(MA,MB,MC)

!  Internal division routine.  MC = MA/MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MAXMWA,MBP1,MCARRY,MKT,MLMAX,MQD
      REAL :: C
      INTEGER :: J,JB,JL,JMB,JMWA,KA,KB,KL,KPTMWA,N1,NG,NL,NMBWDS,NZDMB
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      C = 3100
      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB  .OR. ABS(MWK(START(MB)+2)) >= MEXPAB  &
          .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0 .OR. MBASE < 1000                 &
          .OR. NDIG >= C) THEN
          CALL FMDIV(MA,MB,MC)
          RETURN
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1
      NG = NDIG + NGRD21
      NL = NG + 4
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1
      MWK(START(MWA)+3) = 0
      DO J = 2, N1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      NL = N1 + NGRD21 + 3
      DO J = NDIG+3, NL
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) THEN
          XB = XB + DBLE(MWK(START(MB)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MB.

      DO J = N1, 2, -1
         IF (MWK(START(MB)+J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = MIN(KA+NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMB = START(MB) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMB+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA <= NG) GO TO 120
      IF (MWK(START(MWA)+3) == 0 .AND. KPTMWA <= NG+1) GO TO 120

      KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1
      MWK(START(MWA)+KPTMWA+1) = MQD
      MWK(START(MWA)+KPTMWA+2) = 0
      MWK(START(MWA)+KPTMWA+3) = 0

!             Final normalization.

      IF (KPTMWA > 2*NDIG) THEN
          DO J = 2*NDIG+1, KPTMWA
             IF (MWK(START(MWA)+J+1) /= MBASE-1) EXIT
             IF (J == KPTMWA) MWK(START(MWA)+J+1) = MBASE
          ENDDO
      ENDIF
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO
      CALL FMMOVE(MWA,MC)
      MWK(START(MC)) = MWK(START(MA)) * MWK(START(MB))
      MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))

      RETURN
      END SUBROUTINE FMCSDIV

      SUBROUTINE FMCSDIVI(MA,IVAL,MB)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MKT,MODINT,MVALP
      INTEGER :: J,JMA,JMWA,KA,KB,KL,KPT,KPTWA,N1,NMVAL,NV2
      INTENT (INOUT) :: MB
      INTENT (IN) :: MA,IVAL

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB .OR. MWK(START(MA)+3) == 0 .OR.  &
          IVAL == 0 .OR. ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMDIVI(MA,IVAL,MB)
          RETURN
      ENDIF
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          CALL FMEQ(MA,MB)
          MWK(START(MB)) = MWK(START(MA))*IVAL
          RETURN
      ENDIF

!             Find the first significant digit of the quotient.

      KFLAG = 0
      N1 = NDIG + 1
      MVALP = ABS(IVAL)
      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 120
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 120
         ENDIF
      ENDDO
      KPT = N1

  110 KPT = KPT + 1
      MKT = MKT*MBASE
      IF (MKT < MVALP) GO TO 110

!             Do the rest of the division.

  120 KA = KPT + 1
      MWK(START(MB)) = MWK(START(MA))*IVAL/ABS(IVAL)
      MWK(START(MB)+1) = MWK(START(MA)+1)
      MWK(START(MB)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MB)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MB)+3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MB) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1
      DO J = KA, KB
         MKT = MODINT*MBASE
         MWK(START(MB)+J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWK(START(MB)+J+1)*MVALP
      ENDDO

      RETURN
      END SUBROUTINE FMCSDIVI

      SUBROUTINE FMCSDIVI_R1(MA,IVAL)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MKT,MODINT,MVALP
      INTEGER :: J,JMA,JMWA,KA,KB,KL,KPT,KPTWA,N1,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB .OR. MWK(START(MA)+3) == 0 .OR.  &
          IVAL == 0 .OR. ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMDIVI_R1(MA,IVAL)
          RETURN
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          MWK(START(MA)) = MWK(START(MA))*IVAL
          RETURN
      ENDIF

!             Find the first significant digit of the quotient.

      KFLAG = 0
      N1 = NDIG + 1
      MVALP = ABS(IVAL)
      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 120
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 120
         ENDIF
      ENDDO
      KPT = N1

  110 KPT = KPT + 1
      MKT = MKT*MBASE
      IF (MKT < MVALP) GO TO 110

!             Do the rest of the division.

  120 KA = KPT + 1
      MWK(START(MA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MA)+3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1
      DO J = KA, KB
         MKT = MODINT*MBASE
         MWK(START(MA)+J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWK(START(MA)+J+1)*MVALP
      ENDDO
      IF (IVAL < 0) MWK(START(MA)) = -MWK(START(MA))

      RETURN
      END SUBROUTINE FMCSDIVI_R1

      SUBROUTINE FMCSH2(MA,MB)

!  Internal subroutine for MB = COSH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K,K2,KEXP,KTWO,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG2,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(1,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series:  COSH(X) = 1 + X**2/2! + X**4/4! - ...

!             The argument will be divided by 2**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

!             Since X is small when the series is summed, COSH(X) - 1 is computed.  Then a version
!             of the recovery formula can be used that does not suffer from severe cancellation.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG2 = LOG(2.0)
      ALOGT = LOG(T)
      TJ = 0.65*(NDIG*ALOGMT)**0.3333 - 2.0
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      K2 = INT(1.38*(NDIG*ALOGMT)**0.3333 - 1.8)

      TJ = -(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
             REAL(MWK(START(MA)+4))/(B*B)))/ALOG2 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)

!             Divide the argument by 2**K2.

      KTWO = 1
      MAXV = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTWO)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMCSDIVI_R1(MXY(1),KTWO)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMSQR_R1(MXY(1))
      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 2
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMCSDIVI_R1(MXY(2),NBOT)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3))

  110 CALL FMCSMPY_R1(MXY(2),MXY(3))
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(3))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
      ENDDO

!             Reverse the effect of reducing the argument to compute COSH(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1))
              DO J = 1, K2
                 KEXP = MWK(START(MXY(3))+2)
                 IF (MBASE == 2 .OR. KEXP > 0) THEN
                     CALL FMADD(MXY(3),MXY(1),MXY(2))
                 ELSE
                     DO K = 0, 3-KEXP
                        MWK(START(MXY(2))+K) = MWK(START(MXY(1))+K)
                     ENDDO
                     DO K = 4-KEXP, NDIG+2
                        MWK(START(MXY(2))+K) = MWK(START(MXY(3))+K+KEXP-1)
                     ENDDO
                 ENDIF
                 CALL FMCSMPY_R1(MXY(2),MXY(3))
                 CALL FMCSMPYI(MXY(2),2,MXY(3))
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2))
                 CALL FMADD(MXY(3),MXY(3),MXY(1))
                 CALL FMADD_R1(MXY(2),MXY(1))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(2))
      CALL FMADD_R2(MXY(2),MXY(3))

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCSH2

      SUBROUTINE FMCSMPY_R1(MA,MB)

!  Internal multiplication of MA*MB.  The result is returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKT,MMAX,MT
      REAL :: C
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KI,KJ,KL,KNZ,KWA,L,N1,NGUARD
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      C = 900
      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB  .OR. ABS(MWK(START(MB)+2)) >= MEXPAB  &
          .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0 .OR. MBASE < 1000                 &
          .OR. NDIG >= C) THEN
          CALL FMMPY_R1(MA,MB)
          RETURN
      ENDIF
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1
      NGUARD = NGRD22
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 2, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)
                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = J+1, J+KL-1
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO
      ENDIF

      IF (MWK(START(MA))*MWK(START(MB)) < 0) THEN
          MWK(START(MA)) = -1
      ELSE
          MWK(START(MA)) = 1
      ENDIF
      MWK(START(MA)+2) = MWK(START(MWA)+2)
      IF (MWK(START(MWA)+3) == 0) THEN
          MWK(START(MA)+2) = MWK(START(MA)+2) - 1
          DO J = 3, N1+1
             MWK(START(MA)+J) = MWK(START(MWA)+J+1)
          ENDDO
      ELSE
          DO J = 3, N1+1
             MWK(START(MA)+J) = MWK(START(MWA)+J)
          ENDDO
      ENDIF

      RETURN
      END SUBROUTINE FMCSMPY_R1

      SUBROUTINE FMCSMPYI(MA,IVAL,MB)

!  Internal multiply by integer routine.  MB = MA * IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MVAL
      INTEGER :: J,KSHIFT,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB .OR. MWK(START(MA)+3) == 0 .OR.  &
          ABS(IVAL) <= 1 .OR. ABS(IVAL) > MXBASE) THEN
          CALL FMMPYI(MA,IVAL,MB)
          RETURN
      ENDIF
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

!             Work with positive numbers.

      KFLAG = 0
      MAS = MWK(START(MA))
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MB.

      KSHIFT = 0
      MKT = MWK(START(MA)+3) * MVAL
      DO J = 1, 100
         IF (MKT < MBASE) EXIT
         KSHIFT = KSHIFT + 1
         MKT = INT(MKT/MBASE)
      ENDDO

      IF (KSHIFT > NDIG .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMMPYI(MA,IVAL,MB)
          RETURN
      ENDIF
      MWK(START(MB)+2) = MWK(START(MA)+2) + KSHIFT

      MCARRY = 0
      DO J = NDIG, NDIG-KSHIFT+1, -1
         MKT = MWK(START(MA)+J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/MBASE)
      ENDDO
      DO J = NDIG-KSHIFT, 1, -1
         MKT = MWK(START(MA)+J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/MBASE)
         MWK(START(MB)+J+KSHIFT+2) = MKT - MCARRY*MBASE
      ENDDO
      DO J = KSHIFT, 1, -1
         MKT = MCARRY
         MCARRY = INT(MKT/MBASE)
         MWK(START(MB)+J+2) = MKT - MCARRY*MBASE
      ENDDO
      IF (MCARRY > 0) THEN
          MWK(START(MB)+2) = MWK(START(MB)+2) + 1
          DO J = NDIG, 2, -1
             MWK(START(MB)+J+2) = MWK(START(MB)+J+1)
          ENDDO
          MWK(START(MB)+3) = MCARRY
      ENDIF

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MB)) = JRSIGN
      MWK(START(MB)+1) = MWK(START(MA)+1)

      RETURN
      END SUBROUTINE FMCSMPYI

      SUBROUTINE FMCSMPYI_R1(MA,IVAL)

!  Internal multiply by integer routine.  MA = MA * IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MVAL
      INTEGER :: J,KSHIFT,NMVAL,NV2
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      IF (NTRACE /= 0 .OR. ABS(MWK(START(MA)+2)) >= MEXPAB .OR. MWK(START(MA)+3) == 0 .OR.  &
          ABS(IVAL) <= 1 .OR. ABS(IVAL) > MXBASE) THEN
          CALL FMMPYI_R1(MA,IVAL)
          RETURN
      ENDIF

!             Work with positive numbers.

      KFLAG = 0
      MAS = MWK(START(MA))
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places.

      KSHIFT = 0
      MKT = MWK(START(MA)+3) * MVAL
      DO J = 1, 100
         IF (MKT < MBASE) EXIT
         KSHIFT = KSHIFT + 1
         MKT = INT(MKT/MBASE)
      ENDDO

      IF (KSHIFT > NDIG .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMMPYI_R1(MA,IVAL)
          RETURN
      ENDIF
      MWK(START(MA)+2) = MWK(START(MA)+2) + KSHIFT

      MCARRY = 0
      DO J = NDIG, NDIG-KSHIFT+1, -1
         MKT = MWK(START(MA)+J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/MBASE)
      ENDDO
      DO J = NDIG-KSHIFT, 1, -1
         MKT = MWK(START(MA)+J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/MBASE)
         MWK(START(MA)+J+KSHIFT+2) = MKT - MCARRY*MBASE
      ENDDO
      DO J = KSHIFT, 1, -1
         MKT = MCARRY
         MCARRY = INT(MKT/MBASE)
         MWK(START(MA)+J+2) = MKT - MCARRY*MBASE
      ENDDO
      IF (MCARRY > 0) THEN
          MWK(START(MA)+2) = MWK(START(MA)+2) + 1
          DO J = NDIG, 2, -1
             MWK(START(MA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MA)+3) = MCARRY
      ENDIF

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MA)) = JRSIGN

      RETURN
      END SUBROUTINE FMCSMPYI_R1

      SUBROUTINE FMCSMPYIN_R1(MA,JB,JE)

!  Internal routine for  MA = MA * JB**JE

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,JB,JE,J,KJ
      REAL (KIND(1.0D0)) :: MAXV
      INTENT (IN) :: JB,JE
      INTENT (INOUT) :: MA

      KJ = 1
      MAXV = MXBASE/JB
      IF (JE > 0) THEN
          DO J = 1, JE
             KJ = JB*KJ
             IF (KJ > MAXV) THEN
                 CALL FMCSMPYI_R1(MA,KJ)
                 KJ = 1
             ENDIF
          ENDDO
          IF (KJ > 1) CALL FMCSMPYI_R1(MA,KJ)
      ENDIF

      END SUBROUTINE FMCSMPYIN_R1

      SUBROUTINE FMCSNORM(MA)

!  Internal routine to normalize the digits of ma.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: K,KSHIFT,MA
      REAL (KIND(1.0D0)) :: MKT
      INTENT (INOUT) :: MA

      DO K = START(MA)+NDIG+2, START(MA)+4, -1
         MKT = INT (MWK(K)/MBASE)
         MWK(K-1) = MWK(K-1) + MKT
         MWK(K) = MWK(K) - MKT*MBASE
      ENDDO
      IF (MWK(START(MA)+3) >= MBASE) THEN
          MKT = MWK(START(MA)+3)
          KSHIFT = 1
          DO
             MKT = INT (MKT/MBASE)
             IF (MKT < MBASE) EXIT
             KSHIFT = KSHIFT + 1
          ENDDO
          DO K = START(MA)+NDIG+2, START(MA)+3+KSHIFT, -1
             MWK(K) = MWK(K-KSHIFT)
          ENDDO
          DO K = START(MA)+3+KSHIFT, START(MA)+4, -1
             MKT = INT (MWK(K)/MBASE)
             MWK(K-1) = MKT
             MWK(K) = MWK(K) - MKT*MBASE
          ENDDO
          MWK(START(MA)+2) = MWK(START(MA)+2) + KSHIFT
      ENDIF

      END SUBROUTINE FMCSNORM

      SUBROUTINE FMCSNSUMS(J2,MJSUMS)

!  Internal routine to normalize mjsums.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J,J2,MJSUMS(J2)
      INTENT (IN) :: J2
      INTENT (INOUT) :: MJSUMS

      DO J = 1, J2
         CALL FMCSNORM(MJSUMS(J))
      ENDDO

      RETURN
      END SUBROUTINE FMCSNSUMS

      SUBROUTINE FMCSSN(MA,MB,MC)

!  MB = COS(MA),    MC = SIN(MA)

!  If both the sine and cosine are needed, this routine is faster than calling both FMCOS and FMSIN.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NCSAVE,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(7),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      KR_RETRY = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCSSN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMCOS(MA,MB)
          CALL FMSIN(MA,MC)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCSSN'
              CALL FMNTR(1,MB,MB,1,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL FMNTRJ(MC,NDIG)
                  ELSE
                      CALL FMPRNT(MC)
                  ENDIF
              ENDIF
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          NCSAVE = NCALL
          CALL FMENTR('FMCSSN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCSAVE + 1
          CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MXY(3))) = 1
          IF (MWK(START(MA)+2) == MEXPOV) THEN
              KFLAG = -4
              CALL FMST2M('UNKNOWN',MXY(5))
              CALL FMST2M('UNKNOWN',MXY(6))
          ELSE
              CALL FMCOS(MXY(3),MXY(5))
              CALL FMSIN(MXY(3),MXY(6))
          ENDIF
          GO TO 120
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCSSN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MXY(5))
          CALL FMST2M('UNKNOWN',MXY(6))
          GO TO 120
      ENDIF

      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(5))) = 1
      CALL FMEQ(MXY(5),MXY(7))

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the functions.

      CALL FMRDC(MXY(5),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1))
          CALL FMSUB(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMCOS(MXY(7),MXY(5))
              CALL FMSIN(MXY(7),MXY(6))
              GO TO 120
          ENDIF
      ENDIF
      IF (MWK(START(MXY(5))+2) == MUNKNO) THEN
          CALL FMCOS(MXY(7),MXY(5))
          CALL FMSIN(MXY(7),MXY(6))
          GO TO 120
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(6))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(5),MPISAV)
          CALL FMDIVI_R1(MXY(5),180)
      ENDIF
      IF (MWK(START(MXY(5))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
                  CALL FMSQR(MXY(6),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4))
                  CALL FMEQ(MXY(4),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
                  CALL FMSQR(MXY(5),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
              ENDIF
          ELSE
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4))
                  CALL FMEQ(MXY(4),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
                  CALL FMSQR(MXY(5),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
                  CALL FMSQR(MXY(6),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
              ENDIF
          ENDIF
      ELSE
          CALL FMEQ(MXY(5),MXY(6))
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1 .AND. MWK(START(MA)+2) /= MEXPOV .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(6))+2) /= MUNKNO) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1 .AND. MWK(START(MA)+2) /= MEXPOV .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(6))+2) /= MUNKNO) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (KOVUN == 2) THEN
          KWRNSV = KWARN
          KWARN = 0
      ENDIF
      NDSV = NDIG
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      CALL FMEQU(MXY(6),MC,NDSV,NDSAVE)
      IF (KOVUN == 2) THEN
          KWARN = KWRNSV
      ENDIF
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCSSN

      SUBROUTINE FMDBL(A,B,C)

!  C = A + B.  All are double precision.  This routine tries to force the compiler to round C to
!  double precision accuracy. Some compilers allow double precision loops like the one in FMDM to
!  be done in extended precision, which defeats the routine's attempt to determine double precision
!  accuracy.  This can lead to doing too few Newton steps and failing to get sufficient accuracy in
!  several FM routines.

      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: A,B,C
      INTENT (IN) :: A,B
      INTENT (INOUT) :: C
      C = A + B
      RETURN
      END SUBROUTINE FMDBL

      SUBROUTINE FMDEFINE(MA)

!  Assign space in the FM work area, MWK, for a new multiple precision number.
!  Before being defined the first time, MA must have one of these values, to indicate what
!  type of multiple precision number MA will represent, and how much space it will need:

!      -1 for derived type FM, IM, ZM temporary numbers
!      -2 for internal FM temporary multiple precision numbers
!      -3 for user saved derived type variables or FM saved constants (pi, e, ...)
!      -4 for bigger saved FM work areas (MWA, ...)
!      -5 for multiple precision temporary numbers in packed format

!  After calling FMDEFINE with MA from -5 to -1, the returned value of MA is positive, giving an
!  "index" value.  Then START(MA) gives the starting location in array MWK for the multiple
!  precision number, and SIZE_OF(MA) gives the number of array elements in MWK that are assigned
!  to multiple precision number MA.

!  FMDEFINE will also be called when MA is positive but precision has changed, causing the
!  previously defined value of SIZE_OF(MA) to be too small for the new precision.  MA will
!  then be returned with a new index and more space in MWK.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTEGER :: I,J,K,L,L1,L2,NEW_SIZE,NFREE,N_RESIZE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      N_RESIZE = 0
      IF (MA > SIZE_OF_START) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In FMDEFINE the index value of MA is too large.'
          WRITE (KW,*) '               Index =',MA,' cannot be greater than ',SIZE_OF_START,'.'
          WRITE (KW,*) '               Usually this means a low-level FM, IM, or ZM routine has'
          WRITE (KW,*) '               been called directly with an undefined argument.'
          WRITE (KW,*) ' '
          STOP
      ENDIF

!             If MA has already been defined at a lower precision, MA will be positive here.
!             Re-define it with a new index and more space in MWK.

!             TEMPV(L) is set to the -1, ..., -5 input value of MA when MA is defined (= L) the
!             first time, so that a record is preserved of which type of multiple precision number
!             MA represents.
!             TEMPV(L) is set to -6 if MA gets re-defined at higher precision.  MA then has a new
!             index value and more space in MWK, and the -6 TEMPV value marks the old index as
!             unused.
!             If MWK runs out of space for new multiple precision numbers, it is re-allocated at a
!             bigger size.  When that is done, the unused space in MWK corresponding to any
!             TEMPV = -6 index values is deleted, and then those TEMPV elements are set to -7 to
!             mark those indexes as deleted.

      IF (MA > 0) THEN
          N_RESIZE = RESIZE(MA)
          RESIZE(MA) = 0
          L = MA
          MA = TEMPV(L)
          TEMPV(L) = -6
          IF (L >= LOWEST_SAVED_AREA_INDEX) THEN
              TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
              IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                  N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                  FMTEMP6(N_FMTEMP6) = L
              ELSE
                  NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                  FMTEMP6(NMAX_FMTEMP6) = L
              ENDIF
          ENDIF
          N_RESIZE = N_RESIZE + 1
      ELSE IF (MA == 0 .OR. MA < -5) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In FMDEFINE the index value of MA must be positive or in'
          WRITE (KW,*) '               the range -5, ..., -1.  MA is ',MA
          WRITE (KW,*) '               Usually this means a low-level FM, IM, or ZM routine has'
          WRITE (KW,*) '               been called directly with an undefined argument.'
          WRITE (KW,*) ' '
          STOP
      ENDIF
      NEW_SIZE = NDIG + 3
      IF (MA == -4) NEW_SIZE = 2*NDIG + 30
      IF (MA == -5) NEW_SIZE = NDIG/2 + 4
      IF (N_RESIZE > 10) NEW_SIZE = 2*NEW_SIZE

!             L1    is the last word used on the left of MWK.
!             L2    is the first word used on the right of MWK.
!             NFREE is the number of free words in the middle.

      L1 = 1
      IF (NUMBER_USED > 0) L1 = START(NUMBER_USED)+SIZE_OF(NUMBER_USED)
      L2 = SIZE_OF_MWK
      IF (LOWEST_SAVED_AREA_INDEX <= SIZE_OF_START) L2 = START_OF_MWK_SAVED_AREA
      NFREE = L2 - L1 - 1

!             If MWK runs out of space, try to re-allocate it with a bigger size.

      IF (NEW_SIZE > NFREE) CALL FMDEFINE_RESIZE(NEW_SIZE)

      IF (MA == -3 .OR. MA == -4) GO TO 110

!             Store temporary variables from the beginning of MWK.

      IF (NUMBER_USED <= 0) THEN
          NUMBER_USED = 1
          START(1) = 1
          SIZE_OF(1) = NDIG + 3
          IF (MA == -5) SIZE_OF(1) = NDIG/2 + 4
      ELSE
          IF (LOWEST_SAVED_AREA_INDEX <= SIZE_OF_START) THEN
              L1 = START_OF_MWK_SAVED_AREA
          ELSE
              L1 = SIZE_OF_MWK
          ENDIF
          IF (NUMBER_USED+1 >= LOWEST_SAVED_AREA_INDEX) THEN
              CALL FMDEFINE_ERROR(2)
          ENDIF
          NUMBER_USED = NUMBER_USED + 1
          START(NUMBER_USED) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
          SIZE_OF(NUMBER_USED) = NDIG + 3
          IF (MA == -5) SIZE_OF(NUMBER_USED) = NDIG/2 + 4
      ENDIF
      MAXIMUM_NUMBER_USED = MAX(MAXIMUM_NUMBER_USED,NUMBER_USED)
      L1 = NDIG + 3
      IF (MA == -5) L1 = NDIG/2 + 4
      MAXIMUM_MWK_USED = MAX(MAXIMUM_MWK_USED,START(NUMBER_USED)+L1)
      TEMPV(NUMBER_USED) = MA

      MA = NUMBER_USED
      RESIZE(MA) = N_RESIZE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             Store saved variables from the end of MWK.

  110 IF (LOWEST_SAVED_AREA_INDEX > SIZE_OF_START) THEN
          LOWEST_SAVED_AREA_INDEX = SIZE_OF_START
          IF (MA == -3) THEN
              START(LOWEST_SAVED_AREA_INDEX) = SIZE_OF_MWK - NDIG - 2
              SIZE_OF(LOWEST_SAVED_AREA_INDEX) = NDIG + 3
              START_OF_MWK_SAVED_AREA = SIZE_OF_MWK - NDIG - 2
          ELSE
              START(LOWEST_SAVED_AREA_INDEX) = SIZE_OF_MWK - (2*NDIG+30) + 1
              SIZE_OF(LOWEST_SAVED_AREA_INDEX) = 2*NDIG + 30
              START_OF_MWK_SAVED_AREA = SIZE_OF_MWK - (2*NDIG+30) + 1
          ENDIF
          TEMPV(LOWEST_SAVED_AREA_INDEX) = MA
          MA = LOWEST_SAVED_AREA_INDEX
      ELSE
          L1 = START_OF_MWK_SAVED_AREA
          IF (NUMBER_USED > 0) THEN
              L2 = START(NUMBER_USED) + SIZE_OF(NUMBER_USED)
          ELSE
              L2 = 1
          ENDIF
          IF (MA == -3) THEN
              NEW_SIZE = NDIG + 3
          ELSE
              NEW_SIZE = 2*NDIG + 30
          ENDIF
          L = -1
          IF (NMAX_FMTEMP6 == 0) THEN
              IF (NMAX_IMTEMP6 > 0) THEN
                  DO J = 1, NMAX_IMTEMP6
                     IF (SIZE_OF(IMTEMP6(J)) >= NEW_SIZE) THEN
                         TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                         IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                             N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                             FMTEMP6(N_FMTEMP6) = IMTEMP6(J)
                         ELSE
                             NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                             FMTEMP6(NMAX_FMTEMP6) = IMTEMP6(J)
                         ENDIF
                         DO I = J, NMAX_IMTEMP6 - 1
                            IMTEMP6(I) = IMTEMP6(I+1)
                         ENDDO
                         TOTAL_IMTEMP6 = TOTAL_IMTEMP6 - 1
                         NMAX_IMTEMP6 = NMAX_IMTEMP6 - 1
                         N_IMTEMP6 = MAX(N_IMTEMP6 - 1, 0)
                         EXIT
                     ENDIF
                  ENDDO
              ELSE IF (TOTAL_FMTEMP6 + TOTAL_IMTEMP6 > 0) THEN
                  DO J = LOWEST_SAVED_AREA_INDEX, SIZE_OF_START
                     IF (TEMPV(J) == -6) THEN
                         IF (SIZE_OF(J) >= NEW_SIZE) THEN
                             IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                                 N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                                 FMTEMP6(N_FMTEMP6) = J
                             ELSE
                                 NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                                 FMTEMP6(NMAX_FMTEMP6) = J
                             ENDIF
                             IF (NMAX_FMTEMP6 > TOTAL_FMTEMP6) THEN
                                 TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                                 TOTAL_IMTEMP6 = TOTAL_IMTEMP6 - 1
                             ENDIF
                             IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6 .OR.  &
                                 NMAX_FMTEMP6 >= TOTAL_FMTEMP6 + TOTAL_IMTEMP6) EXIT
                         ENDIF
                     ENDIF
                  ENDDO
              ENDIF
          ENDIF
          DO J = 1, NMAX_FMTEMP6
             IF (TEMPV(FMTEMP6(J)) /= -6) THEN
                 CYCLE
             ENDIF
             IF (SIZE_OF(FMTEMP6(J)) == NEW_SIZE) THEN
                 L = FMTEMP6(J)
                 EXIT
             ELSE IF (SIZE_OF(FMTEMP6(J)) > NEW_SIZE) THEN
                 IF (L < 0) THEN
                     L = FMTEMP6(J)
                 ELSE
                     IF (SIZE_OF(FMTEMP6(J)) < SIZE_OF(L)) THEN
                         L = FMTEMP6(J)
                     ENDIF
                 ENDIF
             ENDIF
          ENDDO
          IF (L > 0) THEN
              K = 0
              DO J = 1, NMAX_FMTEMP6 - 1
                 IF (FMTEMP6(J) == L) K = 1
                 IF (K == 1) FMTEMP6(J) = FMTEMP6(J+1)
              ENDDO
              TOTAL_FMTEMP6 = TOTAL_FMTEMP6 - 1
              NMAX_FMTEMP6 = NMAX_FMTEMP6 - 1
              N_FMTEMP6 = MAX(N_FMTEMP6 - 1, 0)
          ENDIF
          IF (L < 0) THEN
              IF (NUMBER_USED+1 >= LOWEST_SAVED_AREA_INDEX .OR. L2+NEW_SIZE >= L1) THEN
                  CALL FMDEFINE_ERROR(2)
              ENDIF
              IF (TOTAL_TEMP7 <= 0 .AND. LOWEST_SAVED_AREA_INDEX-1 < START_RESIZE) THEN
                  CALL FMDEFINE_START
              ENDIF
              IF (TOTAL_TEMP7 > 0) THEN
                  L = TEMP7(TOTAL_TEMP7)
                  TOTAL_TEMP7 = TOTAL_TEMP7 - 1
                  START_OF_MWK_SAVED_AREA = START_OF_MWK_SAVED_AREA - NEW_SIZE
                  START(L) = START_OF_MWK_SAVED_AREA
                  SIZE_OF(L) = NEW_SIZE
                  TEMPV(L) = MA
                  MA = L
              ELSE
                  LOWEST_SAVED_AREA_INDEX = LOWEST_SAVED_AREA_INDEX - 1
                  START(LOWEST_SAVED_AREA_INDEX) = START_OF_MWK_SAVED_AREA - NEW_SIZE
                  START_OF_MWK_SAVED_AREA = START_OF_MWK_SAVED_AREA - NEW_SIZE
                  SIZE_OF(LOWEST_SAVED_AREA_INDEX) = NEW_SIZE
                  TEMPV(LOWEST_SAVED_AREA_INDEX) = MA
                  MA = LOWEST_SAVED_AREA_INDEX
              ENDIF
          ELSE
              TEMPV(L) = MA
              MA = L
          ENDIF
      ENDIF
      MINIMUM_SAVED_CONSTANTS_USED = MIN(MINIMUM_SAVED_CONSTANTS_USED,LOWEST_SAVED_AREA_INDEX)
      RESIZE(MA) = N_RESIZE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDEFINE

      SUBROUTINE FMDEFINE_ERROR(KERR)

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KERR

      IF (KERR <= 1) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  Out of memory for the database of multiple precision numbers'
          WRITE (KW,*) '               or character strings to format FM output.'
          WRITE (KW,*) '               Allocation of more memory failed.'
          WRITE (KW,*) ' '
      ELSE
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  More than ',SIZE_OF_START,' type (FM), (ZM), (IM) numbers'
          WRITE (KW,*) '               have been defined.  Variable  SIZE_OF_START  in file'
          WRITE (KW,*) '               FMSAVE.f95  defines this value.'
          WRITE (KW,*) '               Possible causes of this error and remedies:'
          WRITE (KW,*) '               (1) Make sure all subroutines (also functions that do not'
          WRITE (KW,*) '                   return type FM, ZM, or IM function values) have'
          WRITE (KW,*) '                       CALL FM_ENTER_USER_ROUTINE'
          WRITE (KW,*) '                   at the start and '
          WRITE (KW,*) '                       CALL FM_EXIT_USER_ROUTINE'
          WRITE (KW,*) '                   at the end and before any other return, and all'
          WRITE (KW,*) '                   functions returning an FM, ZM, or IM function value have'
          WRITE (KW,*) '                       CALL FM_ENTER_USER_FUNCTION(F)'
          WRITE (KW,*) '                   at the start and '
          WRITE (KW,*) '                       CALL FM_EXIT_USER_FUNCTION(F)'
          WRITE (KW,*) '                   at the end and before any other return, where the actual'
          WRITE (KW,*) '                   function name replaces  F  above.'
          WRITE (KW,*) '                   Otherwise that routine could be leaking memory, and'
          WRITE (KW,*) '                   worse, could get wrong results because of deleting some'
          WRITE (KW,*) '                   FM, ZM, or IM temporary variables too soon.'
          WRITE (KW,*) '               (2) Make sure all subroutines and functions declare any'
          WRITE (KW,*) '                   local type FM, ZM, or IM variables as saved.  Otherwise'
          WRITE (KW,*) '                   some compilers create new instances of those variables'
          WRITE (KW,*) '                   with each call, leaking memory.'
          WRITE (KW,*) '                   For example:'
          WRITE (KW,*) '                       SUBROUTINE SUB(A,B,C,X,Y,RESULT)'
          WRITE (KW,*) '                       TYPE (FM) :: A,B,C,X,Y,RESULT,ERR,TOL,H'
          WRITE (KW,*) '                   Here A,B,C,X,Y,RESULT are the input variables and'
          WRITE (KW,*) '                   ERR,TOL,H are local variables.  The fix is:'
          WRITE (KW,*) '                       SUBROUTINE SUB(A,B,C,X,Y,RESULT)'
          WRITE (KW,*) '                       TYPE (FM) :: A,B,C,X,Y,RESULT'
          WRITE (KW,*) '                       TYPE (FM), SAVE :: ERR,TOL,H'
          WRITE (KW,*) '               (3) Since = assignments for multiple precision variables are'
          WRITE (KW,*) '                   the trigger for cleaning up temporary multiple precision'
          WRITE (KW,*) '                   variables, a loop with subroutine calls that has no ='
          WRITE (KW,*) '                   assignments can run out of space to store temporaries.'
          WRITE (KW,*) '                   For example:'
          WRITE (KW,*) '                       DO J = 1, N'
          WRITE (KW,*) '                          CALL SUB(A,B,C,TO_FM(0),TO_FM(1),RESULT)'
          WRITE (KW,*) '                       ENDDO'
          WRITE (KW,*) '                   Most compilers will create two temporary variables with'
          WRITE (KW,*) '                   each call, to hold the TO_FM values.'
          WRITE (KW,*) '                   One fix is to put an assignment into the loop:'
          WRITE (KW,*) '                       DO J = 1, N'
          WRITE (KW,*) '                          ZERO = TO_FM(0)'
          WRITE (KW,*) '                          CALL SUB(A,B,C,ZERO,TO_FM(1),RESULT)'
          WRITE (KW,*) '                       ENDDO'
          WRITE (KW,*) '               (4) If a routine uses allocatable type FM, ZM, or IM arrays'
          WRITE (KW,*) '                   and allocates and deallocates with each call, then after'
          WRITE (KW,*) '                   many calls this limit on number of variables could be '
          WRITE (KW,*) '                   exceeded, since new FM variable index numbers are'
          WRITE (KW,*) '                   generated for each call to the routine.'
          WRITE (KW,*) '                   A fix for this is to call FM_DEALLOCATE before actually'
          WRITE (KW,*) '                   deallocating each array, so those index numbers can be'
          WRITE (KW,*) '                   re-used.  For example:'
          WRITE (KW,*) '                       DEALLOCATE(T)'
          WRITE (KW,*) '                   becomes:'
          WRITE (KW,*) '                       CALL FM_DEALLOCATE(T)'
          WRITE (KW,*) '                       DEALLOCATE(T)'
          WRITE (KW,*) '               (5) If none of this helps, try running this program again'
          WRITE (KW,*) '                   after increasing the value of  SIZE_OF_START  and'
          WRITE (KW,*) '                   re-compiling.'
          WRITE (KW,*) ' '
      ENDIF
      STOP
      END SUBROUTINE FMDEFINE_ERROR

      SUBROUTINE FMDEFINE_RESIZE(NEW_SIZE)

!  MWK, the main work area for FM variables, will be cleaned up by removing space used by inactive
!  variables (TEMPV = -6).  It will also be enlarged if more space is needed (NEW_SIZE > 0).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NEW_SIZE
      INTENT (IN) :: NEW_SIZE
      INTEGER :: J,K,LAST_J,NEW_K,NEW_SIZE_OF_MWK,NEW_START

      IF (NEW_SIZE == 0) THEN
          IF (TOTAL_FMTEMP6 + TOTAL_IMTEMP6 < 500) RETURN
      ENDIF
      IF (SIZE_OF_MWK > 0) THEN
          ALLOCATE(MOVE_MWK(SIZE_OF_MWK),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          DO J = 1, SIZE_OF_MWK
             MOVE_MWK(J) = MWK(J)
          ENDDO
          DEALLOCATE(MWK)
          NEW_SIZE_OF_MWK = MAX(10000,2*SIZE_OF_MWK,SIZE_OF_MWK+NEW_SIZE+30)
          IF (NEW_SIZE <= 0) NEW_SIZE_OF_MWK = SIZE_OF_MWK
          ALLOCATE(MWK(NEW_SIZE_OF_MWK),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          IF (NUMBER_USED > 0) THEN
              NEW_START = START(NUMBER_USED)
              LAST_J = NUMBER_USED
              NEW_K = 0
              DO J = 1, NUMBER_USED
                 IF (TEMPV(J) > -6) THEN
                     NEW_START = NEW_K + 1
                     DO K = START(J), START(J)+SIZE_OF(J)-1
                        NEW_K = NEW_K + 1
                        MWK(NEW_K) = MOVE_MWK(K)
                     ENDDO
                     START(J) = NEW_START
                     LAST_J = J
                 ELSE
                     TEMPV(J) = -7
                     TOTAL_FMTEMP6 = 0
                     NMAX_FMTEMP6 = 0
                     N_FMTEMP6 = 0
                     TOTAL_IMTEMP6 = 0
                     NMAX_IMTEMP6 = 0
                     N_IMTEMP6 = 0
                 ENDIF
              ENDDO
              START(NUMBER_USED) = NEW_START
              SIZE_OF(NUMBER_USED) = SIZE_OF(LAST_J)
          ENDIF
          IF (LOWEST_SAVED_AREA_INDEX <= SIZE_OF_START) THEN
              NEW_K = NEW_SIZE_OF_MWK + 1
              DO J = SIZE_OF_START, LOWEST_SAVED_AREA_INDEX, -1
                 IF (TEMPV(J) > -6) THEN
                     DO K = START(J)+SIZE_OF(J)-1, START(J), -1
                        NEW_K = NEW_K - 1
                        MWK(NEW_K) = MOVE_MWK(K)
                     ENDDO
                     START(J) = NEW_K
                     LAST_J = J
                 ELSE
                     IF (TEMPV(J) == -6) THEN
                         TEMPV(J) = -7
                         TOTAL_TEMP7 = TOTAL_TEMP7 + 1
                         TEMP7(TOTAL_TEMP7) = J
                     ENDIF
                     TOTAL_FMTEMP6 = 0
                     NMAX_FMTEMP6 = 0
                     N_FMTEMP6 = 0
                     TOTAL_IMTEMP6 = 0
                     NMAX_IMTEMP6 = 0
                     N_IMTEMP6 = 0
                 ENDIF
              ENDDO
              IF (NEW_K <= NEW_SIZE_OF_MWK) THEN
                  START(LOWEST_SAVED_AREA_INDEX) = NEW_K
                  START_OF_MWK_SAVED_AREA = NEW_K
                  SIZE_OF(LOWEST_SAVED_AREA_INDEX) = SIZE_OF(LAST_J)
              ENDIF
          ENDIF
          DEALLOCATE(MOVE_MWK)
          SIZE_OF_MWK = NEW_SIZE_OF_MWK
      ELSE
          NEW_SIZE_OF_MWK = MAX(10000,NEW_SIZE+30)
          ALLOCATE(MWK(NEW_SIZE_OF_MWK),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          SIZE_OF_MWK = NEW_SIZE_OF_MWK
          DO J = 1, SIZE_OF_MWK
             MWK(J) = MUNKNO
          ENDDO

          K = 0
          ALLOCATE(START(SIZE_OF_START), RESIZE(SIZE_OF_START), SIZE_OF(SIZE_OF_START),  &
                   TEMPV(SIZE_OF_START), TEMP7(SIZE_OF_START), STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          START   = -1
          TEMPV   =  1
          RESIZE  =  0
          SIZE_OF =  0
          TEMP7   =  0
      ENDIF

      RETURN
      END SUBROUTINE FMDEFINE_RESIZE

      SUBROUTINE FMDEFINE_START

!  Increase the size of array START, holding the locations within MWK for multiple precision
!  numbers, and related arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J,NEW_SIZE

      NEW_SIZE = 2 * SIZE_OF_START

      DO J = 1, SIZE_OF_START
         TEMP7(J) = START(J)
      ENDDO
      DEALLOCATE(START)
      ALLOCATE(START(NEW_SIZE),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      DO J = 1, SIZE_OF_START
         START(J) = TEMP7(J)
         START(SIZE_OF_START+J) = -1
      ENDDO

      DO J = 1, SIZE_OF_START
         TEMP7(J) = RESIZE(J)
      ENDDO
      DEALLOCATE(RESIZE)
      ALLOCATE(RESIZE(NEW_SIZE),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      DO J = 1, SIZE_OF_START
         RESIZE(J) = TEMP7(J)
         RESIZE(SIZE_OF_START+J) = 0
      ENDDO

      DO J = 1, SIZE_OF_START
         TEMP7(J) = SIZE_OF(J)
      ENDDO
      DEALLOCATE(SIZE_OF)
      ALLOCATE(SIZE_OF(NEW_SIZE),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      DO J = 1, SIZE_OF_START
         SIZE_OF(J) = TEMP7(J)
         SIZE_OF(SIZE_OF_START+J) = 0
      ENDDO

      DO J = 1, SIZE_OF_START
         TEMP7(J) = TEMPV(J)
      ENDDO
      DEALLOCATE(TEMPV)
      ALLOCATE(TEMPV(NEW_SIZE),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      DO J = 1, SIZE_OF_START
         TEMPV(J) = TEMP7(J)
         TEMPV(SIZE_OF_START+J) = -7
      ENDDO

      DEALLOCATE(TEMP7)
      ALLOCATE(TEMP7(NEW_SIZE),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      TOTAL_TEMP7 = SIZE_OF_START
      DO J = 1, SIZE_OF_START
         TEMP7(J) = SIZE_OF_START + J
         TEMP7(SIZE_OF_START+J) = 0
      ENDDO

      SIZE_OF_START = NEW_SIZE

      RETURN
      END SUBROUTINE FMDEFINE_START

      SUBROUTINE FMDIG(NSTACK,KST)

!  Compute the number of intermediate digits to be used in Newton iteration.  This assumes that a
!  starting approximation that is accurate to double precision is used, and the root is simple.

!  KST is the number of iterations needed for final accuracy NDIG.
!  NSTACK(J) holds the value of NDIG to be used for the Jth iteration.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NSTACK(49),KST
      INTENT (INOUT) :: NSTACK,KST

      DOUBLE PRECISION :: Y
      INTEGER :: J,JT,L,ND,NDT,NE

      IF (MBLOGS /= MBASE) CALL FMCONS

!             NE is the maximum number of base MBASE digits that can be used in the first
!                Newton iteration.

      NE = INT(1.9D0*DLOGEB)

!             Fill the intermediate digit stack (backwards).

      KST = 1
      ND = NDIG
      NSTACK(1) = ND
      IF (ND < NE .OR. ND <= 2) RETURN

  110 Y = ND

!             The 1.9 accounts for the fact that the number of correct digits approximately doubles
!             at each iteration.

      NDT = INT(Y/1.9D0)
      IF (2*NDT <= ND) NDT = NDT + 1
      ND = NDT
      KST = KST + 1
      NSTACK(KST) = ND
      IF (ND > NE .AND. ND > 2) GO TO 110

!             Reverse the stack.

      L = KST/2
      DO J = 1, L
         JT = NSTACK(J)
         NSTACK(J) = NSTACK(KST+1-J)
         NSTACK(KST+1-J) = JT
      ENDDO

      RETURN
      END SUBROUTINE FMDIG

      SUBROUTINE FMDIM(MA,MB,MC)

!  MC = DIM(MA,MB)

!  Positive difference.  MC = MA - MB  if MA >= MB,
!                           = 0        otherwise.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE
      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB) THEN
          CALL FMENTR('FMDIM    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMDIM'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          KASAVE = KACCSW
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE

      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      IF (FMCOMP(MXY(1),'<',MXY(2))) THEN
          CALL FMI2M(0,MXY(3))
      ELSE
          NCALL = NCALL - 1
          CALL FMSUB(MXY(1),MXY(2),MXY(3))
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMDIM'
      ENDIF

      IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACCB,MACMAX)
      CALL FMEXIT(MXY(3),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIM

      SUBROUTINE FMDIV(MA,MB,MC)

!  MC = MA / MB

!  This routine performs the trace printing for division.  FMDIV2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIV'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMDIV2(MA,MB,MC)

          CALL FMNTR(1,MC,MC,1,1)
      ELSE
          CALL FMDIV2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV

      SUBROUTINE FMDIV2(MA,MB,MC)

!  Internal division routine.  MC = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMDIV'
              CALL FMRSLT(MA,MB,MC,KRESLT)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          IF (MWK(START(MB)+3) == 0) THEN
              NAMEST(NCALL) = 'FMDIV'
              CALL FMIM(0,MC)
              KFLAG = -4
              CALL FMWARN
              MWK(START(MC)+2) = MUNKNO
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MA)+3) == 0) THEN
              CALL FMIM(0,MC)
              MWK(START(MC)+1) = MIN(MACCA,MACCB)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+2
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          NG = NDIG + NGRDN + 1
          IF (MWK(START(MPMA)+3) >= MWK(START(MPMB)+3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, NDIG+1
             MWK(START(MWA)+J+2) = MWK(START(MPMA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          DO J = NDIG+3, NG+4
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG)
          IF (MWK(START(MWA)+3) >= MBASEL) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J)
              ENDDO
              MWK(START(MWA)+3) = 0
              MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          ENDIF
          KT3 = N21 - 1
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 2+NDIG+NGRDN, 3, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K-KT3+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          NL = N1 + NGUARD + 3
          DO J = NDIG+3, NL
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWK(START(MWA)+3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MC)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIV'
          CALL FMWARN
      ENDIF

      MWK(START(MC)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
          MWK(START(MC)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MC)+3))+1))/0.69315)
          MWK(START(MC)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MC)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV2

      SUBROUTINE FMDIV_R1(MA,MB)

!  MA = MA / MB

!  This routine performs the trace printing for division.  FMDIV2_R1 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIV_R1'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMDIV2_R1(MA,MB)

          NAMEST(NCALL) = 'FMDIV_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMDIV2_R1(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV_R1

      SUBROUTINE FMDIV2_R1(MA,MB)

!  Internal division routine.  MA = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMDIV_R1'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MA)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          IF (MWK(START(MB)+3) == 0) THEN
              NAMEST(NCALL) = 'FMDIV_R1'
              CALL FMIM(0,MA)
              KFLAG = -4
              CALL FMWARN
              MWK(START(MA)+2) = MUNKNO
              MWK(START(MA)+3) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MA)+3) == 0) THEN
              CALL FMIM(0,MA)
              MWK(START(MA)+1) = MIN(MACCA,MACCB)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+2
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          NG = NDIG + NGRDN + 1
          IF (MWK(START(MPMA)+3) >= MWK(START(MPMB)+3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, NDIG+1
             MWK(START(MWA)+J+2) = MWK(START(MPMA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          DO J = NDIG+3, NG+4
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG)
          IF (MWK(START(MWA)+3) >= MBASEL) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J)
              ENDDO
              MWK(START(MWA)+3) = 0
              MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          ENDIF
          KT3 = N21 - 1
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 2+NDIG+NGRDN, 3, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K-KT3+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          NL = N1 + NGUARD + 3
          DO J = NDIG+3, NL
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWK(START(MWA)+3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIV_R1'
          CALL FMWARN
      ENDIF

      MWK(START(MA)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0)  &
          MWK(START(MA)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MA)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV2_R1

      SUBROUTINE FMDIV_R2(MA,MB)

!  MB = MA / MB

!  This routine performs the trace printing for division.  FMDIV2_R2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIV_R2'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMDIV2_R2(MA,MB)

          NAMEST(NCALL) = 'FMDIV_R2'
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMDIV2_R2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV_R2

      SUBROUTINE FMDIV2_R2(MA,MB)

!  Internal division routine.  MB = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMDIV_R2'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MB)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          IF (MWK(START(MB)+3) == 0) THEN
              NAMEST(NCALL) = 'FMDIV_R2'
              CALL FMIM(0,MB)
              KFLAG = -4
              CALL FMWARN
              MWK(START(MB)+2) = MUNKNO
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MA)+3) == 0) THEN
              CALL FMIM(0,MB)
              MWK(START(MB)+1) = MIN(MACCA,MACCB)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+2
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          NG = NDIG + NGRDN + 1
          IF (MWK(START(MPMA)+3) >= MWK(START(MPMB)+3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, NDIG+1
             MWK(START(MWA)+J+2) = MWK(START(MPMA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          DO J = NDIG+3, NG+4
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG)
          IF (MWK(START(MWA)+3) >= MBASEL) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J)
              ENDDO
              MWK(START(MWA)+3) = 0
              MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          ENDIF
          KT3 = N21 - 1
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 2+NDIG+NGRDN, 3, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K-KT3+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          NL = N1 + NGUARD + 3
          DO J = NDIG+3, NL
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWK(START(MWA)+3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIV_R2'
          CALL FMWARN
      ENDIF

      MWK(START(MB)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
          MWK(START(MB)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MB)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV2_R2

      SUBROUTINE FMDIV3(MB,NG)

!  Internal division routine.  Divide MA/MB and return the quotient in MWA.
!  MA has already been copied into MWA.
!  NG is the number of guard digits used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MB

      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MAXMWA,MBP1,MCARRY,MKT,MLMAX,MQD
      INTEGER :: J,JB,JL,JMB,JMWA,KA,KB,KL,KPTMWA,N1,NG,NL,NMBWDS,NMETHD,NZDMB
      REAL :: C
      INTENT (IN) :: MB

      N1 = NDIG + 1
      NL = NG + 4

!             Check for using an FFT-based method if precision is very high.

      C = 3100
      IF (NDIG >= C) THEN
          NZDMB = 0
          DO J = 2, NDIG
             IF (MWK(START(MB)+J+2) == 0) NZDMB = NZDMB + 1
          ENDDO
          IF (NDIG-NZDMB < 50 .OR. REAL(NZDMB)/NDIG > 0.8 ) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMDIVFFT(MB)
          RETURN
      ENDIF

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) THEN
          XB = XB + DBLE(MWK(START(MB)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MB.

      DO J = N1, 2, -1
         IF (MWK(START(MB)+J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = MIN(KA+NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMB = START(MB) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMB+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA <= NG) GO TO 120
      IF (MWK(START(MWA)+3) == 0 .AND. KPTMWA <= NG+1) GO TO 120

      KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1
      MWK(START(MWA)+KPTMWA+1) = MQD
      MWK(START(MWA)+KPTMWA+2) = 0
      MWK(START(MWA)+KPTMWA+3) = 0

!             Final normalization.

      IF (KPTMWA > 2*NDIG) THEN
          DO J = 2*NDIG+1, KPTMWA
             IF (MWK(START(MWA)+J+1) /= MBASE-1) EXIT
             IF (J == KPTMWA) MWK(START(MWA)+J+1) = MBASE
          ENDDO
      ENDIF
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

      RETURN
      END SUBROUTINE FMDIV3

      SUBROUTINE FMDIVD(MA,MB,MC,MD,ME)

!  Double division routine.  MD = MA / MC,   ME = MB / MC

!  It is usually slightly faster to do two divisions that have a common denominator with one call.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD,ME

      REAL (KIND(1.0D0)) :: MA2P,MACCA,MACCB,MACCC,MAS,MAXMWA,MB2P,MBP1,MBS,MC2P,MCARRY,MCS,MD2B,  &
                            MKT,MLMAX,MLR,MQDMWA,MQDMWD,MTEMP
      DOUBLE PRECISION :: ERR,XB,XBR,XBASE,XMWA,XMWD
      REAL :: C
      INTEGER :: J,JB,JL,JMC,JMWA,JMWD,JRSSAV,KA,KB,KL,KOVUN,KPTMW,N1,NG,NGUARD,NL,  &
                 NMBWDS,NZDMB
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD,ME
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MD <= 0) THEN
          CALL FMDEFINE(MD)
      ELSE IF (SIZE_OF(MD) < NDIG+3) THEN
          CALL FMDEFINE(MD)
      ENDIF
      IF (ME <= 0) THEN
          CALL FMDEFINE(ME)
      ELSE IF (SIZE_OF(ME) < NDIG+3) THEN
          CALL FMDEFINE(ME)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      IF (MWD <= 0) THEN
          CALL FMDEFINE(MWD)
      ELSE IF (SIZE_OF(MWD) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWD)
      ENDIF

      NCALL = NCALL + 1
      JRSSAV = JRSIGN
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIVD'
          CALL FMNTR(2,MA,MB,2,1)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      MACCC = MWK(START(MC)+1)
      C = 3100
      IF (NDIG >= C .OR.                                                           &
          ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MC)+2)) > MEXPAB .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN .OR.  &
              MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.  &
              MWK(START(MC)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
              MWK(START(MC)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMDIV2(MA,MC,MWD)
          KB = KFLAG
          CALL FMDIV2(MB,MC,ME)
          NCALL = NCALL - 1
          IF (((KFLAG < 0 .OR. KB < 0) .AND. KOVUN == 0) .OR.  &
              ((KFLAG == -4 .OR. KB == -4) .AND. KOVUN == 1)) THEN
              IF (KFLAG == -4 .OR. KB == -4) THEN
                  KFLAG = -4
              ELSE IF (KFLAG == -5 .OR. KB == -5) THEN
                  KFLAG = -5
              ELSE
                  KFLAG = MIN(KFLAG,KB)
              ENDIF
              NAMEST(NCALL) = 'FMDIVD'
              CALL FMWARN
          ENDIF
          CALL FMEQ(MWD,MD)
          GO TO 150
      ENDIF
      IF (MWK(START(MC)+3) == 0) THEN
          NAMEST(NCALL) = 'FMDIVD'
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MD)
          CALL FMST2M('UNKNOWN',ME)
          GO TO 150
      ENDIF
      IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMDIV2(MA,MC,MWD)
          CALL FMDIV2(MB,MC,ME)
          CALL FMEQ(MWD,MD)
          GO TO 150
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      MA2P = ABS(MWK(START(MA)+3))
      MB2P = ABS(MWK(START(MB)+3))
      MC2P = ABS(MWK(START(MC)+3))
      IF ((MC2P >= MA2P .OR. MC2P >= MB2P) .AND. NGUARD < 2) NGUARD = 2
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Copy MA and MB into the working arrays.

      DO J = 3, N1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
         MWK(START(MWD)+J+2) = MWK(START(MB)+J+1)
      ENDDO
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MC)+2) + 1
      MWK(START(MWD)+2) = MWK(START(MB)+2) - MWK(START(MC)+2) + 1
      MWK(START(MWA)+3) = 0
      MWK(START(MWD)+3) = 0
      NL = N1 + NGUARD + 3
      DO J = NDIG+3, NL
         MWK(START(MWA)+J+1) = 0
         MWK(START(MWD)+J+1) = 0
      ENDDO

!             Save the signs and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MCS = MWK(START(MC))
      MWK(START(MWA)+4) = MWK(START(MA)+3)
      MWK(START(MWD)+4) = MWK(START(MB)+3)

!             NMBWDS is the number of words used to compute the estimated quotient digits.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MC used in selecting estimated quotients.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) XB = XB + DBLE(MWK(START(MC)+JL+2))/XBASE
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MC.

      DO J = N1, 2, -1
         IF (MWK(START(MC)+J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMW points to the next digit in the quotient.

      KPTMW = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in selecting estimated
!             quotients.

  120 KL = KPTMW + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMW+1))*XBASE + DBLE(MWK(START(MWA)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMW+4))
          XMWD = ((DBLE(MWK(START(MWD)+KPTMW+1))*XBASE + DBLE(MWK(START(MWD)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWD)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWD)+KPTMW+4))
          DO J = KPTMW+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMW+1))
          XMWD = DBLE(MWK(START(MWD)+KPTMW+1))
          DO J = KPTMW+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
                 XMWD = XMWD*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQDMWA and MQDMWD are the estimated quotient digits.

      MQDMWA = AINT(XMWA*XBR)
      IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
      MQDMWD = AINT(XMWD*XBR)
      IF (MQDMWD < 0) MQDMWD = MQDMWD - 1

      MAXMWA = MAXMWA + MAX(ABS(MQDMWA),ABS(MQDMWD))

!             See if MWA and MWD must be normalized.

      KA = KPTMW + 1
      KB = MIN(KA+NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
             IF (MWK(START(MWD)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWD)+J+1)-1)/MBASE) + 1
                 MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
                 MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
             ELSE IF (MWK(START(MWD)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWD)+J+1)/MBASE)
                 MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
                 MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          XMWD = 0
          IF (KL <= NL) THEN
              DO J = KPTMW, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
              ENDDO
          ELSE
              DO J = KPTMW, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                     XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                     XMWD = XMWD*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQDMWA = AINT(XMWA*XBR)
          IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
          MQDMWD = AINT(XMWD*XBR)
          IF (MQDMWD < 0) MQDMWD = MQDMWD - 1
          MAXMWA = MAX(ABS(MQDMWA),ABS(MQDMWD))
      ENDIF

!             Subtract MQDMWA*MC from MWA and MQDMWD*MC from MWD.

      JB = KA - 2

!             Major (Inner Loop)

      JMC = START(MC) + 1 - JB
      JMWA = START(MWA) + 1
      JMWD = START(MWD) + 1
      DO J = KA, KB
         MTEMP = MWK(JMC+J)
         MWK(JMWA+J) = MWK(JMWA+J) - MQDMWA*MTEMP
         MWK(JMWD+J) = MWK(JMWD+J) - MQDMWD*MTEMP
      ENDDO

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWD)+KA+1) = MWK(START(MWD)+KA+1) + MWK(START(MWD)+KA)*MBASE
      MWK(START(MWA)+KPTMW+1) = MQDMWA
      MWK(START(MWD)+KPTMW+1) = MQDMWD

      KPTMW = KPTMW + 1
      IF (KPTMW <= NG) GO TO 120

      KL = KPTMW + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMW+1))*XBASE + DBLE(MWK(START(MWA)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMW+4))
          XMWD = ((DBLE(MWK(START(MWD)+KPTMW+1))*XBASE + DBLE(MWK(START(MWD)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWD)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWD)+KPTMW+4))
          DO J = KPTMW+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMW+1))
          XMWD = DBLE(MWK(START(MWD)+KPTMW+1))
          DO J = KPTMW+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
                 XMWD = XMWD*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQDMWA = AINT(XMWA*XBR)
      IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
      MQDMWD = AINT(XMWD*XBR)
      IF (MQDMWD < 0) MQDMWD = MQDMWD - 1
      MWK(START(MWA)+KPTMW+1) = MQDMWA
      MWK(START(MWA)+KPTMW+2) = 0
      MWK(START(MWA)+KPTMW+3) = 0
      MWK(START(MWD)+KPTMW+1) = MQDMWD
      MWK(START(MWD)+KPTMW+2) = 0
      MWK(START(MWD)+KPTMW+3) = 0

!             Final normalization.

      DO J = KPTMW-1, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
         IF (MWK(START(MWD)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWD)+J+1)-1)/MBASE) + 1
             MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
             MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
         ELSE IF (MWK(START(MWD)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWD)+J+1)/MBASE)
             MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
             MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
         ENDIF
      ENDDO

!             Round, affix the sign, and return.

      IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MA,MC,MD)
                  GO TO 130
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MA,MC,MD)
                  GO TO 130
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MD)

  130 IF ((MBS > 0 .AND. MCS > 0) .OR. (MBS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWD)+3) == 0) THEN
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWD)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MB,MC,ME)
                  GO TO 140
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWD)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWD,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWD)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWD)+N1+2) = MWK(START(MWD)+N1+2) + 1
                      MWK(START(MWD)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWD,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWD)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MB,MC,ME)
                  GO TO 140
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWD)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWD,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWD)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWD)+N1+1) = MWK(START(MWD)+N1+1) + 1
                      MWK(START(MWD)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWD,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,ME)

  140 IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIVD'
          CALL FMWARN
      ENDIF

      MWK(START(MD)) = 1
      IF (MAS*MCS < 0 .AND. MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
          MWK(START(MD)) = -1
      MWK(START(ME)) = 1
      IF (MBS*MCS < 0 .AND. MWK(START(ME)+2) /= MUNKNO .AND. MWK(START(ME)+3) /= 0)  &
          MWK(START(ME)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MD)+3))+1))/0.69315)
          MWK(START(MD)+1) = MIN(MACCA,MACCC,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(ME)+3))+1))/0.69315)
          MWK(START(ME)+1) = MIN(MACCB,MACCC,MD2B)
      ELSE
          MWK(START(MD)+1) = MIN(MACCA,MACCC)
          MWK(START(ME)+1) = MIN(MACCB,MACCC)
      ENDIF

  150 IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MD,MD,1,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(ME,NDIG)
              ELSE
                  CALL FMPRNT(ME)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          IF (TEMPV(ME) == -1) TEMPV(ME) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVD

      SUBROUTINE FMDIVFFT(MB)
      USE FMVALS
      IMPLICIT NONE

!  Internal division routine MA/MB for very high precision.
!  MA has already been moved to MWA before this routine is called.
!  Fast Fourier transforms are used, and the number of digits carried is usually
!  raised slightly, because the FFT is faster when N has only small prime factors.

      INTEGER :: MB
      INTENT (IN) :: MB
      DOUBLE PRECISION :: XB
      REAL (KIND(1.0D0)) :: MWA1
      INTEGER :: J,K,KST,ND2,NDSAVE,NSTACK(49)
      INTEGER :: MXY(10),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      NDSAVE = NDIG

!             Save low precision copies of the numerator and denominator.

      NDIG = 20
      CALL FMIM(1,MXY(7))
      DO J = 1, SIZE_OF(MXY(7))-3
         MWK(START(MXY(7))+J+2) = MWK(START(MWA)+J+3)
      ENDDO
      MWK(START(MXY(7))+2) = MWK(START(MWA)+2) + MWK(START(MB)+2) - 1
      CALL FMEQU(MB,MXY(8),NDSAVE,20)
      NDIG = NDSAVE

!             Use Newton iteration and the routine FMMPYFFT, with the formula
!                 x = x + x*(1 - b*x)
!             to converge to 1/b.

      K = MAX(NGRD52-1,2)
      NDIG = MAX(NDIG+K,2)

!             Generate the first approximation.

      CALL FMIM(1,MXY(1))
      DO J = 1, NDSAVE
         MWK(START(MXY(1))+J+2) = MWK(START(MWA)+J+3)
      ENDDO
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(1))+2) = 0
      MWK(START(MXY(2))) = 1
      MWK(START(MXY(2))+2) = 0
      KST = MWK(START(MWA)+2)

!             FMADD2 will negate MXY(2) and add.

      KSUB = 1
      CALL FMADD2(MXY(1),MXY(2),MXY(3))
      KSUB = 0
      IF (MWK(START(MXY(3))) >= 0) THEN
          MWA1 = KST
      ELSE
          MWA1 = KST - 1
      ENDIF
      CALL FMMD(MXY(2),XB)
      XB = 1.0D0/XB
      CALL FMDM(XB,MXY(3))

!             Initialize.

      CALL FMIM(0,MXY(4))
      CALL FMIM(0,MXY(5))
      CALL FMIM(1,MXY(6))
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST-1
         NDIG = NSTACK(J)
         CALL FMMPY2(MXY(2),MXY(3),MXY(4))
         KSUB = 1
         CALL FMADD2_R2(MXY(6),MXY(4))
         KSUB = 0
         NDIG = NSTACK(MAX(1,J-1))
         CALL FMMPY2(MXY(3),MXY(4),MXY(5))
         NDIG = NSTACK(J)
         CALL FMADD2_R1(MXY(3),MXY(5))
      ENDDO

!             Karp's trick:
!             The standard last step would give 1/b and then a final full precision
!             multiply by a would be done.  That does 2 full mpy's at the final precision,
!             and one at next-to-last (1/2 of final) precision.

!             Instead combine the a* step into the last iteration and get
!             y = a*x   at 1/2 precision, then
!             y = y + x*(a - b*y)
!             where the x* mpy is at 1/2 precision and only b*y is at final precision.

      NDIG = NSTACK(MAX(1,KST-1))
      CALL FMMPY2(MXY(1),MXY(3),MXY(4))
      NDIG = NSTACK(KST)
      CALL FMMPY2(MXY(2),MXY(4),MXY(5))
      KSUB = 1
      CALL FMADD2(MXY(1),MXY(5),MXY(6))
      KSUB = 0
      NDIG = NSTACK(MAX(1,KST-1))
      CALL FMMPY2(MXY(3),MXY(6),MXY(5))
      NDIG = NSTACK(KST)
      CALL FMADD2(MXY(4),MXY(5),MXY(6))

      MWK(START(MXY(6))+2) = MWA1

!             Because of rounding errors in the Newton iteration, if the quotient is very close
!             to a power of MBASE the exponent of the result might be off by one.
!             Check by doing low precision multiplications.

      ND2 = NDIG
      MWK(START(MXY(7))) = -1
      MWK(START(MXY(8))) = 1
      CALL FMEQU(MXY(6),MXY(4),NDSAVE,20)
      MWK(START(MXY(4))) = 1
      NDIG = 20
      CALL FMMPY2(MXY(8),MXY(4),MXY(5))
      CALL FMADD2(MXY(5),MXY(7),MXY(9))
      MWK(START(MXY(9))) = 1
      MWK(START(MXY(4))+2) = MWK(START(MXY(4))+2) + 1
      CALL FMMPY2(MXY(8),MXY(4),MXY(5))
      CALL FMADD2(MXY(5),MXY(7),MXY(10))
      IF (MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -1
      CALL FMADD2(MXY(10),MXY(9),MXY(5))
      IF (MWK(START(MXY(5))) == 1) THEN
          CALL FMEQ(MXY(10),MXY(9))
          MWK(START(MXY(6))+2) = MWK(START(MXY(6))+2) + 1
      ENDIF
      MWK(START(MXY(4))+2) = MWK(START(MXY(4))+2) - 2
      CALL FMMPY2(MXY(8),MXY(4),MXY(5))
      CALL FMADD2(MXY(5),MXY(7),MXY(10))
      IF (MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -1
      CALL FMADD2(MXY(10),MXY(9),MXY(5))
      IF (MWK(START(MXY(5))) == 1) THEN
          MWK(START(MXY(6))+2) = MWK(START(MXY(6))+2) - 1
      ENDIF
      NDIG = ND2

      CALL FMEQ(MXY(6),MWA)
      IF (KFLAG == 1) KFLAG = 0
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVFFT

      SUBROUTINE FMDIVI(MA,IVAL,MB)

!  MB = MA / IVAL

!  Divide FM number MA by one word integer IVAL.

!  This routine is faster than FMDIV when the divisor is less than MXBASE (the square root of the
!  largest integer).
!  When IVAL is not less than MXBASE, FMDIV2 is used.  In this case, if IVAL is known to be a
!  product of two integers less than MXBASE, it is usually faster to make two calls to FMDIVI
!  with half-word factors than one call with their product.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MD2B
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIVI'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMDIVN(MA,IVAL,MB)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
              MWK(START(MB)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MB)+1) = MACCA
          ENDIF
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMDIVN(MA,IVAL,MB)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
              MWK(START(MB)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MB)+1) = MACCA
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVI

      SUBROUTINE FMDIVI_R1(MA,IVAL)

!  MA = MA / IVAL

!  Divide FM number MA by one word integer IVAL.

!  This routine is faster than FMDIV when the divisor is less than MXBASE (the square root of the
!  largest integer).
!  When IVAL is not less than MXBASE, FMDIV2 is used.  In this case, if IVAL is known to be a
!  product of two integers less than MXBASE, it is usually faster to make two calls to FMDIVI
!  with half-word factors than one call with their product.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MD2B
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIVI_R1'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMDIVN_R1(MA,IVAL)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
              MWK(START(MA)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MA)+1) = MACCA
          ENDIF
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMDIVN_R1(MA,IVAL)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
              MWK(START(MA)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MA)+1) = MACCA
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVI_R1

      SUBROUTINE FMDIVN(MA,IVAL,MB)

!  Internal divide by integer routine.  MB = MA / IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MA1,MAS,MKT,MLR,MODINT,MVALP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMWA,JRSSAV,KA,KB,KL,KPT,KPTWA,KR_RETRY,N1,NGUARD,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      KR_RETRY = 0

!             Check for special cases.

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      N1 = NDIG + 1
      IF (MWK(START(MA)+2) == MUNKNO .OR. IVAL == 0) THEN
          MA1 = MWK(START(MA)+2)
          CALL FMIM(0,MB)
          MWK(START(MB)+1) = NINT(10**7*ALOGM2)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          KFLAG = -4
          IF (MA1 /= MUNKNO) THEN
              NAMEST(NCALL) = 'FMDIVI'
              CALL FMWARN
          ENDIF
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (ABS(IVAL) == 1) THEN
          DO J = 0, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MB)) = MWK(START(MA))*IVAL
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          MAS = MWK(START(MA))
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MEXPUN
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MB)) = -1
          KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          NAMEST(NCALL) = 'FMDIVI'
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -4
          CALL FMWARN
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
      ELSE
          NGUARD = NGRD52
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10

!             If ABS(IVAL) >= MXBASE use FMDIV.

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMDIV2(MA,MXY(1),MB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

      MAS = MWK(START(MA))

!             Find the first significant digit of the quotient.

      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO
      KPT = N1

  120 KPT = KPT + 1
      MKT = MKT*MBASE
      IF (MKT < MVALP) GO TO 120

!             Do the rest of the division.

  130 KA = KPT + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MWA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MWA)+3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1 + NGUARD
      DO J = KA, KB
         MKT = MODINT*MBASE
         MWK(START(MWA)+J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWK(START(MWA)+J+1)*MVALP
      ENDDO

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result, put the sign on MB and return.

      MLR = 2*MWK(START(MWA)+NDIG+3) + 1
      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,0)
      ELSE IF (MLR >= MBASE) THEN
          IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                  MWK(START(MWA)+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIVI'
          CALL FMWARN
      ENDIF
      MWK(START(MB)) = JRSIGN
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVN

      SUBROUTINE FMDIVN_R1(MA,IVAL)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MA1,MAS,MKT,MLR,MODINT,MVALP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMWA,JRSSAV,KA,KB,KL,KPT,KPTWA,KR_RETRY,N1,NGUARD,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      KR_RETRY = 0

!             Check for special cases.

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      N1 = NDIG + 1
      IF (MWK(START(MA)+2) == MUNKNO .OR. IVAL == 0) THEN
          MA1 = MWK(START(MA)+2)
          CALL FMIM(0,MA)
          MWK(START(MA)+1) = NINT(10**7*ALOGM2)
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          KFLAG = -4
          IF (MA1 /= MUNKNO) THEN
              NAMEST(NCALL) = 'FMDIVI_R1'
              CALL FMWARN
          ENDIF
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (ABS(IVAL) == 1) THEN
          MWK(START(MA)) = MWK(START(MA))*IVAL
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          MAS = MWK(START(MA))
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MEXPUN
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MA)) = -1
          KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          NAMEST(NCALL) = 'FMDIVI_R1'
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -4
          CALL FMWARN
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
      ELSE
          NGUARD = NGRD52
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10

!             If ABS(IVAL) >= MXBASE use FMDIV.

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMDIV2_R1(MA,MXY(1))
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

      MAS = MWK(START(MA))

!             Find the first significant digit of the quotient.

      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO
      KPT = N1

  120 KPT = KPT + 1
      MKT = MKT*MBASE
      IF (MKT < MVALP) GO TO 120

!             Do the rest of the division.

  130 KA = KPT + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MWA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MWA)+3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1 + NGUARD
      DO J = KA, KB
         MKT = MODINT*MBASE
         MWK(START(MWA)+J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWK(START(MWA)+J+1)*MVALP
      ENDDO

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result, put the sign on MA and return.

      MLR = 2*MWK(START(MWA)+NDIG+3) + 1
      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,0)
      ELSE IF (MLR >= MBASE) THEN
          IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                  MWK(START(MWA)+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIVI_R1'
          CALL FMWARN
      ENDIF
      MWK(START(MA)) = JRSIGN
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVN_R1

      SUBROUTINE FMDM(X,MA)

!  Internal routine for converting double precision to multiple precision.  Called by FMDPM.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA

      DOUBLE PRECISION :: ONE,XBASE,Y,Y2,YT
      REAL (KIND(1.0D0)) :: MK,MN
      INTEGER :: J,K,N1,NE
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      ONE = 1.0D0
      XBASE = MBASE
      K = 0

!             NE-1 is the number of words at the current precision and base roughly equal to
!             machine precision.

      NE = INT(DLOGEB) + 3
      Y = X
      IF (X < 0.0) Y = -X

      IF (X == 0.0) THEN
          DO J = 1, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
          GO TO 160
      ENDIF

!             Get the exponent.

      IF (Y > ONE) THEN
          IF (Y/XBASE < Y) THEN
  110         K = K + 1
              Y = Y/XBASE
              IF (Y > ONE) GO TO 110
              IF (Y < ONE) THEN
                  MWK(START(MA)+2) = K
                  GO TO 140
              ENDIF
              GO TO 130
          ELSE
              KFLAG = -4
              CALL FMWARN
              DO J = 1, N1
                 MWK(START(MA)+J+1) = 0
              ENDDO
              MWK(START(MA)+2) = MUNKNO
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      IF (Y < ONE) THEN
          IF (Y*XBASE > Y) THEN
  120         K = K - 1
              Y = Y*XBASE
              IF (Y < ONE) GO TO 120
              IF (Y > ONE) THEN
                  K = K + 1
                  Y = Y/XBASE
                  MWK(START(MA)+2) = K
                  GO TO 140
              ENDIF
          ELSE
              KFLAG = -4
              CALL FMWARN
              DO J = 1, N1
                 MWK(START(MA)+J+1) = 0
              ENDDO
              MWK(START(MA)+2) = MUNKNO
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

  130 MWK(START(MA)+2) = K + 1
      MWK(START(MA)+3) = 1
      DO J = 3, N1
         MWK(START(MA)+J+1) = 0
      ENDDO
      GO TO 160

!             Build the rest of the number.

  140 DO J = 2, NE
         Y = Y*XBASE
         MK = AINT(Y)
         YT = -MK
         CALL FMDBL(Y,YT,Y2)
         Y = Y2
         MWK(START(MA)+J+1) = MK
         IF (J >= N1) GO TO 150
      ENDDO
      K = NE + 1
      DO J = K, N1
         MWK(START(MA)+J+1) = 0
      ENDDO

!             Normalize.

  150 IF (ABS(MWK(START(MA)+3)) >= MBASE) THEN
          K = N1 + 1
          DO J = 3, N1
             K = K - 1
             MWK(START(MA)+K+1) = MWK(START(MA)+K)
          ENDDO
          MN = AINT (MWK(START(MA)+3)/MBASE)
          MWK(START(MA)+4) = MWK(START(MA)+3) - MN*MBASE
          MWK(START(MA)+3) = MN
          MWK(START(MA)+2) = MWK(START(MA)+2) + 1
          GO TO 160
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+1) = MWK(START(MA)+J+2)
          ENDDO
          MWK(START(MA)+2) = MWK(START(MA)+2) - 1
          MWK(START(MA)+N1+1) = 0
      ENDIF

  160 MWK(START(MA)) = 1
      IF (X < 0.0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1
      MWK(START(MA)+1) = MIN(NINT((NE-1)*ALOGM2),NINT(NDIG*ALOGM2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDM

      SUBROUTINE FMDM2(X,MA)

!  Internal routine for converting double precision to multiple precision.  Called by FMDP2M.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA
      DOUBLE PRECISION :: F1,F2,Y,Y1,Y2,TWO20
      INTEGER :: J,J1,J2,JD,JEXP,K,KEXP,L,NDSAVE
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD21,1)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0

!             Special case for X = 0.

      IF (X == 0.0D0) THEN
          DO J = 1, NDSAVE+1
             MWK(START(MA)+J+1) = 0
          ENDDO
          GO TO 140
      ENDIF

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, NDSAVE
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDSAVE*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          NDIG = NDSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Special case for MBASE = 2.

      IF (MBASE == 2 .AND. RADIX(X) == 2) THEN
          NDIG = MAX(NDIG,DIGITS(X))
          Y = FRACTION(ABS(X))
          CALL FMI2M(0,MXY(5))
          DO J = 1, MIN(DIGITS(X),NDIG)
             Y = Y + Y
             MWK(START(MXY(5))+J+2) = INT(Y)
             Y = Y - INT(Y)
          ENDDO
          MWK(START(MXY(5))+2) = EXPONENT(X)
          CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
          GO TO 140
      ENDIF

!             Special case for MBASE = 10**L.

      K = MBASE
      L = 0
      DO
         IF (MOD(K,10) == 0) THEN
             L = L + 1
             K = K/10
             IF (K == 1) EXIT
         ELSE
             L = 0
             EXIT
         ENDIF
      ENDDO
      IF (L > 0) THEN
          NDIG = MAX(NDIG,INT(DIGITS(X)*0.30103/L)+1)
          Y = FRACTION(ABS(X))
          CALL FMI2M(0,MXY(5))
          DO J = 1, NDIG

!             Multiply by 10**L to get the next digit in base MBASE.
!             To avoid any rounding errors in double precision, do each multiply by 10 as
!             one multiply by 8 and one by 2, and keep two integer and two fraction results.
!             So 10*y is broken into 8*y + 2*y, since there will be no rounding with either
!             term in double precision on a binary machine.

             JD = 0
             DO K = 1, L
                Y1 = 8*Y
                Y2 = 2*Y
                J1 = Y1
                J2 = Y2
                F1 = Y1 - J1
                F2 = Y2 - J2
                JD = 10*JD + J1 + J2
                Y = F1 + F2
                IF (Y >= 1.0D0) THEN
                    JD = JD + 1
                    Y = Y - 1
                ENDIF
             ENDDO
             MWK(START(MXY(5))+J+2) = JD
             IF (Y == 0) EXIT
          ENDDO
          K = INTMAX
          IF (MAXINT/MBASE < K) K = MAXINT/MBASE
          K = K/2
          J2 = 1
          JEXP = EXPONENT(X)
          DO J = 1, ABS(JEXP)
             J2 = 2*J2
             IF (J2 >= K .OR. J == ABS(JEXP)) THEN
                 IF (JEXP > 0) THEN
                     CALL FMMPYI_R1(MXY(5),J2)
                 ELSE
                     CALL FMDIVI_R1(MXY(5),J2)
                 ENDIF
                 J2 = 1
             ENDIF
          ENDDO
          CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
          GO TO 140
      ENDIF

      Y = ABS(X)
      TWO20 = 1048576.0D0

!             If this power of two is not representable at the current base and precision, use a
!             smaller one.

      IF (INT(NDIG*ALOGM2) < 20) THEN
          K = INT(NDIG*ALOGM2)
          TWO20 = 1.0D0
          DO J = 1, K
             TWO20 = TWO20*2.0D0
          ENDDO
      ENDIF

      KEXP = 0
      IF (Y > TWO20) THEN
  110     Y = Y/TWO20
          KEXP = KEXP + 1
          IF (Y > TWO20) GO TO 110
      ELSE IF (Y < 1.0D0) THEN
  120     Y = Y*TWO20
          KEXP = KEXP - 1
          IF (Y < 1.0D0) GO TO 120
      ENDIF

      K = INT(TWO20)
      CALL FMI2M(K,MXY(3))
      K = INT(Y)
      CALL FMI2M(K,MXY(1))
      Y = (Y-DBLE(K))*TWO20
      JEXP = 0

  130 K = INT(Y)
      CALL FMI2M(K,MXY(2))
      CALL FMMPY_R1(MXY(1),MXY(3))
      JEXP = JEXP + 1
      CALL FMADD_R1(MXY(1),MXY(2))
      Y = (Y-DBLE(K))*TWO20
      IF (JEXP <= 1000 .AND. Y /= 0.0D0) GO TO 130

      K = KEXP - JEXP
      IF (K >= 0) THEN
          IF (K == 0) THEN
              CALL FMEQ(MXY(1),MXY(5))
          ELSE IF (K == 1) THEN
              CALL FMMPY(MXY(1),MXY(3),MXY(5))
          ELSE IF (K == 2) THEN
              CALL FMSQR(MXY(3),MXY(2))
              CALL FMMPY(MXY(1),MXY(2),MXY(5))
          ELSE
              CALL FMIPWR(MXY(3),K,MXY(2))
              CALL FMMPY(MXY(1),MXY(2),MXY(5))
          ENDIF
      ELSE
          IF (K == -1) THEN
              CALL FMDIV(MXY(1),MXY(3),MXY(5))
          ELSE IF (K == -2) THEN
              CALL FMSQR(MXY(3),MXY(2))
              CALL FMDIV(MXY(1),MXY(2),MXY(5))
          ELSE
              CALL FMIPWR(MXY(3),-K,MXY(2))
              CALL FMDIV(MXY(1),MXY(2),MXY(5))
          ENDIF
      ENDIF
      CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)

  140 MWK(START(MA)) = 1
      IF (X < 0.0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1
      MWK(START(MA)+1) = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDM2

      SUBROUTINE FMDP2M(X,MA)

!  MA = X

!  Convert a double precision floating point number to FM format.

!  This version tries to convert the double precision machine number to FM with accuracy of nearly
!  full FM precision. If conversion to FM with approximately double precision accuracy is good
!  enough, FMDPM is faster and uses less scratch space.

!  This routine assumes the machine's base for double precision is a power of two.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMDP2M'
      IF (NTRACE /= 0) CALL FMNTRR(2,X,1)

      CALL FMDM2(X,MA)

      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDP2M

      SUBROUTINE FMDPM(X,MA)

!  MA = X

!  Convert a double precision floating point number to FM format.

!  In general, the relative accuracy of the FM number returned is only the relative accuracy of a
!  machine precision number.  This may be true even if X can be represented exactly in the machine
!  floating point number system.

!  This version is faster than FMDP2M, but often less accurate.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA

      DOUBLE PRECISION :: Y,YT
      INTEGER :: J,K
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMDPM'
      IF (NTRACE /= 0) CALL FMNTRR(2,X,1)

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          GO TO 110
      ENDIF

!             Check to see if X is exactly a small integer.  If so, converting as an integer is
!             better.  Also see if X is exactly a small integer divided by a small power of two.

      Y = 1048576.0D0
      IF (ABS(X) < Y) THEN
          K = INT(X)
          Y = K
          IF (Y == X) THEN
              CALL FMIM(K,MA)
              GO TO 110
          ENDIF
      ENDIF
      IF (ABS(X) < 1.0D0) THEN
          Y = 4096.0D0*X
          K = INT(Y)
          YT = K
          IF (Y == YT) THEN
              CALL FMIM(K,MA)
              CALL FMDIVI_R1(MA,4096)
              GO TO 110
          ENDIF
      ENDIF

      CALL FMDM(X,MA)

  110 IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDPM

      SUBROUTINE FMENTR(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision and overflow threshold upon entry to an
!  FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result
!           immediately (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow
!           or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KASAVE,KOVUN

      REAL (KIND(1.0D0)) :: MACCAB
      INTEGER :: K
      INTENT (IN) :: NROUTN,MA,MB,NARGS,KNAM
      INTENT (INOUT) :: MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM)
      CALL FMARGS(NROUTN,NARGS,MA,MB,KRESLT)

      IF (MBLOGS /= MBASE) CALL FMCONS
      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          MACCAB = MWK(START(MA)+1)
          IF (NARGS == 2) MACCAB = MIN(MACCAB,MWK(START(MB)+1))
          IF (KRESLT == 9 .OR. KRESLT == 10 .OR. KRESLT >= 13) THEN
              IF (KRAD == 1) THEN
                  CALL FMPI(MXY(1))
              ELSE
                  CALL FMI2M(180,MXY(1))
              ENDIF
              IF (KRESLT <= 10) CALL FMDIVI_R1(MXY(1),2)
              IF (KRESLT >= 14) CALL FMDIVI_R1(MXY(1),4)
              IF ((KRESLT == 9 .OR. KRESLT == 14) .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
                  MWK(START(MXY(1))+3) /= 0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
              CALL FMEQU(MXY(1),MC,NDIG,NDSAVE)
              NDIG = NDSAVE
              MWK(START(MC)+1) = MACCAB
              IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
              NUMBER_USED = NUMBER_USED_SAVE
              KASAVE = KACCSW
              MXSAVE = MXEXP
              NCALL = NCALL - 1
              RETURN
          ENDIF

          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
          NUMBER_USED = NUMBER_USED_SAVE
          KASAVE = KACCSW
          MXSAVE = MXEXP
          NCALL = NCALL - 1
          RETURN
      ENDIF

      KASAVE = KACCSW
      KACCSW = 0
      NUMBER_USED = NUMBER_USED_SAVE

!             Extend the overflow/underflow threshold.

      MXSAVE = MXEXP
      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE FMENTR

      SUBROUTINE FMENTR2(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision and overflow threshold upon entry to a
!  low-level FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result
!           immediately (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow
!           or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KASAVE,KOVUN

      REAL (KIND(1.0D0)) :: MACCAB
      INTEGER :: K
      INTENT (IN) :: NROUTN,MA,MB,NARGS,KNAM
      INTENT (INOUT) :: MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN

      NCALL = NCALL + 1
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM)
      CALL FMARGS(NROUTN,NARGS,MA,MB,KRESLT)

      IF (MBLOGS /= MBASE) CALL FMCONS
      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          MACCAB = MWK(START(MA)+1)
          IF (NARGS == 2) MACCAB = MIN(MACCAB,MWK(START(MB)+1))
          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
          KASAVE = KACCSW
          MXSAVE = MXEXP
          NCALL = NCALL - 1
          RETURN
      ENDIF

      KASAVE = KACCSW
      KACCSW = 0

!             Extend the overflow/underflow threshold.

      MXSAVE = MXEXP
      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE FMENTR2

      SUBROUTINE FMEQ(MA,MB)

!  MB = MA

!  This is the standard form of equality, where MA and MB both have precision NDIG.
!  Use FMEQU for assignments that also change precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: J
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure MA has a valid definition.

      IF (MA <= 0) CALL FMINPUT_ERROR(1)
      IF (MA > NUMBER_USED .AND. MA < LOWEST_SAVED_AREA_INDEX) CALL FMINPUT_ERROR(2)
      IF (MA > SIZE_OF_START) CALL FMINPUT_ERROR(3)
      IF (START(MA) < 0 .OR. START(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(4)
      IF (SIZE_OF(MA) < 0 .OR. SIZE_OF(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(5)
      IF (START(MA)+SIZE_OF(MA)-1 > SIZE_OF_MWK) CALL FMINPUT_ERROR(6)
      IF (SIZE_OF(MA) < NDIG+3) CALL FMINPUT_ERROR(7)

!             Copy MA to MB.

      DO J = -1, NDIG+1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO

!             Check for overflow or underflow.

      IF (ABS(MWK(START(MB)+2)) > MXEXP) THEN
          IF (MWK(START(MB)+2) /= MUNKNO .OR. MWK(START(MB)+3) /= 1) THEN
              NCALL = NCALL + 1
              CALL FMTRAP(MB)
              NCALL = NCALL - 1
          ENDIF
          IF (MWK(START(MB)+2) == MUNKNO) KFLAG = -4
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEQ

      SUBROUTINE FMEQU(MA,MB,NDA,NDB)

!  Set MB (having NDB digits) equal to MA (having NDA digits).

!  If MB has less precision than MA the result is rounded to NDB digits.

!  If MB has more precision the result has zero digits padded on the right.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NDA,NDB
      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: M2,MACCA,MBS,MKT
      INTEGER :: J,JT,K,KB,L,N1
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FMEQU.'
          WRITE (KW,*) ' MA is not defined on input.'
          WRITE (KW,*) ' Call stack: '
          WRITE (KW,"(10(3X,A))") (NAMEST(J),J=1,NCALL)
          WRITE (KW,*) ' '
          STOP
      ENDIF
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,NDB+3)
      ENDIF
      IF (SIZE_OF(MB) < NDB+3) THEN
          CALL IMDEFINE(MB,NDB+3)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure MA has a valid definition.

      IF (MA <= 0) CALL FMINPUT_ERROR(1)
      IF (MA > NUMBER_USED .AND. MA < LOWEST_SAVED_AREA_INDEX) CALL FMINPUT_ERROR(2)
      IF (MA > SIZE_OF_START) CALL FMINPUT_ERROR(3)
      IF (START(MA) < 0 .OR. START(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(4)
      IF (SIZE_OF(MA) < 0 .OR. SIZE_OF(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(5)
      IF (START(MA)+SIZE_OF(MA)-1 > SIZE_OF_MWK) CALL FMINPUT_ERROR(6)
      IF (SIZE_OF(MA) < NDA+3) CALL FMINPUT_ERROR(7)

!             Check for precision in range.

      IF (NDA < 1 .OR. NDB < 1) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEQU'
          KFLAG = -1
          CALL FMWARN
          WRITE (KW,                                                     &
                 "(/' The two precisions in FMEQU were NDA =',I19,"  //  &
                  "' NDB =',I19/)"                                       &
                ) NDA,NDB
          DO J = 2, NDB
             MWK(START(MB)+J+2) = 0
          ENDDO
          KFLAG = -1
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDB*ALOGM2)
          MWK(START(MB)) = 1
          NCALL = NCALL - 1
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MBS = MWK(START(MA))
      MWK(START(MB)) = MBS

!             Check for special symbols.

      KFLAG = 0
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) THEN
          DO J = 2, NDB
             MWK(START(MB)+J+2) = 0
          ENDDO
          MWK(START(MB)+2) = MWK(START(MA)+2)
          MWK(START(MB)+3) = MWK(START(MA)+3)
          GO TO 150
      ENDIF

      IF (NDB == NDA) GO TO 130

      IF (NDB > NDA) GO TO 140

!             Round to NDB digits.

      N1 = NDB + 1
      DO J = 1, N1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      IF (KROUND == -1 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) > 0) GO TO 150
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 150
      ENDIF
      IF (KROUND == 2 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) < 0) GO TO 150
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 150
      ENDIF
      IF (KROUND == 0 .AND. NCALL <= 1) GO TO 150

      IF (INT(MBASE-AINT (MBASE/2)*2) /= 0) THEN
          M2 = AINT (MBASE/2)
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) /= M2) EXIT
             IF (J == NDA+1) GO TO 110
          ENDDO
      ENDIF
      L = NDB + 2
      IF (2*(MWK(START(MA)+L+1)+1) < MBASE) GO TO 150
      M2 = 2
      IF (INT(MBASE-AINT (MBASE/M2)*M2) == 0) THEN
          IF (2*MWK(START(MA)+L+1) < MBASE) GO TO 150
          IF (2*MWK(START(MA)+L+1) == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (MWK(START(MA)+J+2) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MWK(START(MB)+N1+1)-AINT (MWK(START(MB)+N1+1)/M2)*M2) == 0) GO TO 150
          ENDIF
      ELSE
          IF (2*MWK(START(MA)+L+1)+1 == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (2*(MWK(START(MA)+J+2)+1) < MBASE) GO TO 150
                     IF (2*MWK(START(MA)+J+2) > MBASE) GO TO 110
                  ENDDO
                  GO TO 150
              ENDIF
          ENDIF
      ENDIF

  110 MWK(START(MB)+NDB+2) = MWK(START(MB)+NDB+2) + 1

!             Check whether there was a carry in the rounded digit.

      KB = NDB + 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MWK(START(MB)+K+1) < MBASE) GO TO 120
             MKT = AINT (MWK(START(MB)+K+1)/MBASE)
             MWK(START(MB)+K) = MWK(START(MB)+K) + MKT
             MWK(START(MB)+K+1) = MWK(START(MB)+K+1) - MKT*MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MWK(START(MB)+3) < MBASE) GO TO 120
      IF (KB >= 4) THEN
          K = KB + 1
          DO J = 4, KB
             K = K - 1
             MWK(START(MB)+K+1) = MWK(START(MB)+K)
          ENDDO
      ENDIF

      MKT = AINT (MWK(START(MB)+3)/MBASE)
      IF (KB >= 3) MWK(START(MB)+4) = MWK(START(MB)+3) - MKT*MBASE
      MWK(START(MB)+3) = MKT
      MWK(START(MB)+2) = MWK(START(MB)+2) + 1

  120 IF (MBS < 0 .AND. MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
      GO TO 150

!             MA and MB have the same precision.

  130 DO J = 1, NDA+1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      GO TO 150

!             Extend to NDB digits by padding with zeros.

  140 DO J = 1, NDA+1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      DO J = NDA+2, NDB+1
         MWK(START(MB)+J+1) = 0
      ENDDO

!             Check for overflow or underflow.

  150 IF (ABS(MWK(START(MB)+2)) > MXEXP) THEN
          IF (MWK(START(MB)+2) /= MUNKNO .OR. MWK(START(MB)+3) /= 1) THEN
              IF (MWK(START(MB)+2) > MXEXP+1) THEN
                  IF (MWK(START(MB)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPOV
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = 1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPOV
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = -1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -5
              ENDIF
              IF (MWK(START(MB)+2) < -MXEXP) THEN
                  IF (MWK(START(MB)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPUN
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = 1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPUN
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = -1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -6
              ENDIF
          ENDIF
          IF (MWK(START(MB)+2) == MUNKNO) KFLAG = -4
      ENDIF

      IF (KACCSW == 1) THEN
          JT = NINT(LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          IF (NDB > NDA) THEN
              MWK(START(MB)+1) = NINT((NDB-1)*ALOGM2 + JT)
          ELSE
              MWK(START(MB)+1) = MIN(NINT((NDB-1)*ALOGM2+JT),INT(MACCA))
          ENDIF
      ELSE
          MWK(START(MB)+1) = MWK(START(MA)+1)
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEQU

      SUBROUTINE FMEQU_R1(MA,NDA,NDB)

!  Change precision of MA from NDA digits on input to NDB digits on output.

!  If NDB is less than NDA the result is rounded to NDB digits.

!  If NDB is greater than NDA the result has zero digits padded on the right.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: NDA,NDB

      REAL (KIND(1.0D0)) :: M2,MACCA,MBS,MKT
      REAL (KIND(1.0D0)), DIMENSION(:), ALLOCATABLE :: MA_COPY
      INTEGER :: J,JT,K,KB,L,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: NDA,NDB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FMEQU_R1.'
          WRITE (KW,*) ' MA is not defined on input.'
          WRITE (KW,*) ' Call stack: '
          WRITE (KW,"(10(3X,A))") (NAMEST(J),J=1,NCALL)
          WRITE (KW,*) ' '
          STOP
      ENDIF
      IF (SIZE_OF(MA) < NDB+3) THEN
          ALLOCATE(MA_COPY(NDA+3),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          DO J = -1, NDA+1
             MA_COPY(2+J) = MWK(START(MA)+J+1)
          ENDDO
          CALL IMDEFINE(MA,NDB+3)
          DO J = -1, NDA+1
             MWK(START(MA)+J+1) = MA_COPY(2+J)
          ENDDO
          DEALLOCATE(MA_COPY)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure MA has a valid definition.

      IF (MA <= 0) CALL FMINPUT_ERROR(1)
      IF (MA > NUMBER_USED .AND. MA < LOWEST_SAVED_AREA_INDEX) CALL FMINPUT_ERROR(2)
      IF (MA > SIZE_OF_START) CALL FMINPUT_ERROR(3)
      IF (START(MA) < 0 .OR. START(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(4)
      IF (SIZE_OF(MA) < 0 .OR. SIZE_OF(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(5)
      IF (START(MA)+SIZE_OF(MA)-1 > SIZE_OF_MWK) CALL FMINPUT_ERROR(6)
      IF (SIZE_OF(MA) < NDA+3) CALL FMINPUT_ERROR(7)

!             Check for precision in range.

      IF (NDA < 1 .OR. NDB < 1) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEQU'
          KFLAG = -1
          CALL FMWARN
          WRITE (KW,                                                     &
                 "(/' The two precisions in FMEQU were NDA =',I19,"  //  &
                  "' NDB =',I19/)"                                       &
                ) NDA,NDB
          DO J = 2, NDB
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -1
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDB*ALOGM2)
          MWK(START(MA)) = 1
          NCALL = NCALL - 1
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MBS = MWK(START(MA))

!             Check for special symbols.

      KFLAG = 0
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) THEN
          DO J = 2, NDB
             MWK(START(MA)+J+2) = 0
          ENDDO
          GO TO 140
      ENDIF

      IF (NDB == NDA) GO TO 140

      IF (NDB > NDA) GO TO 130

!             Round to NDB digits.

      N1 = NDB + 1
      IF (KROUND == -1 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) > 0) GO TO 140
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 140
      ENDIF
      IF (KROUND == 2 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) < 0) GO TO 140
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 140
      ENDIF
      IF (KROUND == 0 .AND. NCALL <= 1) GO TO 140

      IF (INT(MBASE-AINT (MBASE/2)*2) /= 0) THEN
          M2 = AINT (MBASE/2)
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) /= M2) EXIT
             IF (J == NDA+1) GO TO 110
          ENDDO
      ENDIF
      L = NDB + 2
      IF (2*(MWK(START(MA)+L+1)+1) < MBASE) GO TO 140
      M2 = 2
      IF (INT(MBASE-AINT (MBASE/M2)*M2) == 0) THEN
          IF (2*MWK(START(MA)+L+1) < MBASE) GO TO 140
          IF (2*MWK(START(MA)+L+1) == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (MWK(START(MA)+J+2) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MWK(START(MA)+N1+1)-AINT (MWK(START(MA)+N1+1)/M2)*M2) == 0) GO TO 140
          ENDIF
      ELSE
          IF (2*MWK(START(MA)+L+1)+1 == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (2*(MWK(START(MA)+J+2)+1) < MBASE) GO TO 140
                     IF (2*MWK(START(MA)+J+2) > MBASE) GO TO 110
                  ENDDO
                  GO TO 140
              ENDIF
          ENDIF
      ENDIF

  110 MWK(START(MA)+NDB+2) = MWK(START(MA)+NDB+2) + 1
      MWK(START(MA)+NDB+3) = 0

!             Check whether there was a carry in the rounded digit.

      KB = NDB + 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MWK(START(MA)+K+1) < MBASE) GO TO 120
             MKT = AINT (MWK(START(MA)+K+1)/MBASE)
             MWK(START(MA)+K) = MWK(START(MA)+K) + MKT
             MWK(START(MA)+K+1) = MWK(START(MA)+K+1) - MKT*MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MWK(START(MA)+3) < MBASE) GO TO 120
      IF (KB >= 4) THEN
          K = KB + 1
          DO J = 4, KB
             K = K - 1
             MWK(START(MA)+K+1) = MWK(START(MA)+K)
          ENDDO
      ENDIF

      MKT = AINT (MWK(START(MA)+3)/MBASE)
      IF (KB >= 3) MWK(START(MA)+4) = MWK(START(MA)+3) - MKT*MBASE
      MWK(START(MA)+3) = MKT
      MWK(START(MA)+2) = MWK(START(MA)+2) + 1

  120 IF (MBS < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1
      GO TO 140

!             Extend to NDB digits by padding with zeros.

  130 DO J = NDA+2, NDB+1
         MWK(START(MA)+J+1) = 0
      ENDDO

!             Check for overflow or underflow.

  140 IF (ABS(MWK(START(MA)+2)) > MXEXP) THEN
          IF (MWK(START(MA)+2) /= MUNKNO .OR. MWK(START(MA)+3) /= 1) THEN
              IF (MWK(START(MA)+2) > MXEXP+1) THEN
                  IF (MWK(START(MA)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPOV
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = 1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPOV
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = -1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -5
              ENDIF
              IF (MWK(START(MA)+2) < -MXEXP) THEN
                  IF (MWK(START(MA)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPUN
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = 1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPUN
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = -1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -6
              ENDIF
          ENDIF
          IF (MWK(START(MA)+2) == MUNKNO) KFLAG = -4
      ENDIF

      IF (KACCSW == 1) THEN
          JT = NINT(LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          IF (NDB > NDA) THEN
              MWK(START(MA)+1) = NINT((NDB-1)*ALOGM2 + JT)
          ELSE
              MWK(START(MA)+1) = MIN(NINT((NDB-1)*ALOGM2+JT),INT(MACCA))
          ENDIF
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEQU_R1

      SUBROUTINE FMEXIT(MT,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Upon exit from an FM routine the result MT (having precision NDIG) is rounded and returned in MC
!  (having precision NDSAVE).  The values of NDIG, MXEXP, and KACCSW are restored.  KOVUN is nonzero
!  if one of the routine's input arguments was overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT,NDSAVE,MXSAVE,KASAVE,KOVUN
      INTENT (INOUT) :: MC

      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      CALL FMEQU(MT,MC,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF ((MWK(START(MC)+2) == MUNKNO .AND. KFLAG /= -9)     &
         .OR. (MWK(START(MC)+2) == MEXPUN .AND. KOVUN == 0)  &
         .OR. (MWK(START(MC)+2) == MEXPOV .AND. KOVUN == 0)) CALL FMWARN
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      KACCSW = KASAVE
      RETURN
      END SUBROUTINE FMEXIT

      SUBROUTINE FMEXP(MA,MB)

!  MB = EXP(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      CHARACTER(155) :: STRING
      REAL (KIND(1.0D0)) :: M1,MA1,MA2,MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KT,KWRNSV,L,NDMB,NDSAVE,NDSV,NMETHD
      REAL :: XMA,XOV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (NDIG > 1000) THEN
          NDSAVE = NDIG
          NDIG = NDIG + 100 + NDIG/100
          IF (MWA <= 0) THEN
              CALL FMDEFINE(MWA)
          ELSE IF (SIZE_OF(MWA) < 2*NDIG + 30) THEN
              CALL FMDEFINE(MWA)
          ENDIF
          NDIG = NDSAVE
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMEXP'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMI2M(1,MXY(1))
          CALL FMADD(MXY(1),MA,MB)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMEXP'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMEXP    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEXP'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MA1 = MWK(START(MA)+2)
      MA2 = MWK(START(MA)+3)
      MAS = MWK(START(MA))

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Check for obvious underflow or overflow.
!             XOV is LN(LN(slightly above overflow))
!             XMA is LN(LN(EXP(MA))) approximately.

      XOV = LOG(1.01*REAL(MXEXP)) + LOG(ALOGMB)
      M1 = 1
      XMA = LOG(REAL(MAX(ABS(MA2),M1))) - ALOGMB + REAL(MA1)*ALOGMB

  120 IF (XMA >= XOV) THEN
          CALL FMIM(0,MXY(2))
          IF (MAS > 0) THEN
              KFLAG = -5
              CALL FMST2M('OVERFLOW',MXY(2))
          ELSE
              KFLAG = -6
              CALL FMST2M('UNDERFLOW',MXY(2))
          ENDIF
          CALL FMEQU(MXY(2),MB,NDIG,NDSAVE)
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          CALL FMWARN
          IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Split MA into integer and fraction parts.  Work with a positive argument.
!             MXY(1) = integer part of ABS(MA)
!             MXY(2) = fraction part of ABS(MA)

      MWK(START(MXY(2))) = 1
      CALL FMINT(MXY(2),MXY(1))
      CALL FMSUB_R1(MXY(2),MXY(1))

!             If the integer part is not zero, use FMIPWR to compute E**(MXY(1)).  If MXY(1) is too
!             large to represent as a one word integer, the definition of MXEXP insures that
!             E**(MXY(1)) overflows or underflows.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),KT)
      KWARN = KWRNSV
      IF (KFLAG /= 0) THEN
          XMA = XOV
          GO TO 120
      ENDIF
      IF (KT > 0) THEN

!             Compute IEXTRA, the number of extra digits required to get EXP(KT) correct to the
!             current precision.

          IEXTRA = INT(LOG(REAL(KT))/ALOGMB + 0.5)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA

!             Check whether the current precision of e is large enough.

          IF (MBSE /= MBASE .OR. NDIG > NDIGE) THEN
              NDMB = INT(150.0*2.302585/ALOGMB)
              IF (NDMB >= NDIG) THEN
                  NDSV = NDIG
                  NDIG = NDMB
                  IF (MESAV > 0) THEN
                      IF (SIZE_OF(MESAV) < NDIG+3) THEN
                          L = -3
                          CALL FMDEFINE(L)
                          TEMPV(MESAV) = -6
                          TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                          IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                              N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                              FMTEMP6(N_FMTEMP6) = MESAV
                          ELSE
                              NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                              FMTEMP6(NMAX_FMTEMP6) = MESAV
                          ENDIF
                          MESAV = L
                      ENDIF
                  ENDIF
                  STRING = '2.718281828459045235360287471352662497757247'//  &
                  '09369995957496696762772407663035354759457138217852516'//  &
                  '6427427466391932003059921817413596629043572900334295261'
                  CALL FMST2M(STRING,MESAV)
                  MWK(START(MESAV)+1) = NINT(NDIG*ALOGM2)
                  MBSE = MBASE
                  NDIGE = NDIG
                  IF (ABS(MWK(START(MESAV)+2)) > 10) NDIGE = 0
                  NDIG = NDSV
              ELSE
                  NDSV = NDIG
                  NDIG = NDIG + 2 + NDIG/100
                  IF (MESAV > 0) THEN
                      IF (SIZE_OF(MESAV) < NDIG+3) THEN
                          L = -3
                          CALL FMDEFINE(L)
                          TEMPV(MESAV) = -6
                          TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                          IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                              N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                              FMTEMP6(N_FMTEMP6) = MESAV
                          ELSE
                              NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                              FMTEMP6(NMAX_FMTEMP6) = MESAV
                          ENDIF
                          MESAV = L
                      ENDIF
                  ENDIF
                  CALL FMI2M(1,MESAV)
                  CALL FMEXP2(MESAV,MXY(4))
                  CALL FMEQ(MXY(4),MESAV)
                  MWK(START(MESAV)+1) = NINT(NDIG*ALOGM2)
                  MBSE = MBASE
                  NDIGE = NDIG
                  IF (ABS(MWK(START(MESAV)+2)) > 10) NDIGE = 0
                  NDIG = NDSV
              ENDIF
          ENDIF
      ENDIF

!             Now do the fraction part of MA and combine the results.

      KWRNSV = KWARN
      KWARN = 0
      NMETHD = 1
      IF (NDIG > 50) NMETHD = 2
      IF (MWK(START(MXY(2))+3) /= 0 .AND. KT > 0 .AND. NMETHD == 1) THEN
          CALL FMEXP2(MXY(2),MXY(4))
          CALL FMIPWR(MESAV,KT,MXY(3))
          CALL FMMPY(MXY(4),MXY(3),MXY(2))
      ELSE IF (MWK(START(MXY(2))+3) /= 0 .AND. KT == 0 .AND. NMETHD == 1) THEN
          CALL FMEXP2(MXY(2),MXY(4))
          CALL FMEQ(MXY(4),MXY(2))
      ELSE IF (MWK(START(MXY(2))+3) /= 0 .AND. KT > 0 .AND. NMETHD == 2) THEN
          NDSV = NDIG
          NDIG = NDIG + NGRD21
          CALL FMEQU_R1(MXY(2),NDSV,NDIG)
          IF (MWK(START(MXY(2))+2) >= 0) THEN
              CALL FMCSH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(-1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ELSE
              CALL FMSNH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ENDIF
          NDIG = NDSV
          CALL FMIPWR(MESAV,KT,MXY(3))
          CALL FMMPY_R1(MXY(2),MXY(3))
      ELSE IF (MWK(START(MXY(2))+3) /= 0 .AND. KT == 0 .AND. NMETHD == 2) THEN
          NDSV = NDIG
          NDIG = NDIG + NGRD21
          CALL FMEQU_R1(MXY(2),NDSV,NDIG)
          IF (MWK(START(MXY(2))+2) >= 0) THEN
              CALL FMCSH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(-1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ELSE
              CALL FMSNH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ENDIF
          NDIG = NDSV
      ELSE IF (MWK(START(MXY(2))+3) == 0 .AND. KT > 0) THEN
          CALL FMIPWR(MESAV,KT,MXY(2))
      ELSE
          CALL FMI2M(1,MXY(2))
      ENDIF

!             Invert if MA was negative.

      IF (MAS < 0) THEN
          CALL FMI2M(1,MXY(1))
          CALL FMDIV_R2(MXY(1),MXY(2))
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(2))+3))+1))/0.69315)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEXP

      SUBROUTINE FMEXP2(MA,MB)

!  MB = EXP(MA)

!  Internal exponential routine (called with 0 < MA <= 1).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      REAL (KIND(0.0D0)) :: X1,X2,X3,F1,F2,F3,PI
      INTEGER :: J,J2,K,K2,KEXP,KTWO,L,L2,N2,NBIG,NBOT,NDSAV1,NDSAVE,NTERM,NTOP
      REAL :: ALOG2,ALOGT,B,T,TJ,XN
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      NDSAVE = NDIG
      IF (MWK(START(MA)+2) == 1) THEN

!             Here the special case EXP(1.0) is computed.

          T = NDIG
          XN = T*ALOGMB/LOG(T)
          K = INT(LOG(XN)/ALOGMB)
          NDIG = MAX(NDIG+K,2)
          NDSAV1 = NDIG

          IF (NDSAVE < 100) THEN

!             If precision is not very high, use the direct series  e = 1/0! + 1/1! + 1/2! + ...
!             Do as much of the work as possible using small integers to minimize the number of
!             FM calls.  Reduce NDIG while computing each term in the sum as the terms get smaller.

              CALL FMI2M(2,MXY(2))
              CALL FMI2M(1,MXY(1))
              J = 2
              NBIG = INT(MXBASE)

  110         NTOP = 1
              NBOT = J
  120         IF (NBOT > NBIG/(J+1)) GO TO 130
              J = J + 1
              NTOP = J*NTOP + 1
              NBOT = J*NBOT
              GO TO 120

  130         CALL FMCSDIVI_R1(MXY(1),NBOT)
              IF (NTOP > 1) THEN
                  CALL FMCSMPYI(MXY(1),NTOP,MXY(3))
                  NDIG = NDSAV1
                  CALL FMADD_R1(MXY(2),MXY(3))
                  NDIG = NDSAV1 - INT(MWK(START(MXY(2))+2)-MWK(START(MXY(3))+2))
              ELSE
                  NDIG = NDSAV1
                  CALL FMADD_R1(MXY(2),MXY(1))
                  NDIG = NDSAV1 - INT(MWK(START(MXY(2))+2)-MWK(START(MXY(1))+2))
              ENDIF
              IF (NDIG < NGRD22) NDIG = NGRD22
              IF (KFLAG /= 1) THEN
                  J = J + 1
                  GO TO 110
              ENDIF
              NDIG = NDSAVE
              KFLAG = 0
              CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
          ELSE

!             If precision is high, use the binary splitting method for summing the direct series.

!             Determine K, the number of terms to sum in the series for e.

              X1 = 1.184*NDIG*DLOGMB/LOG(NDIG*DLOGMB) + 1.95*NDIG**0.777 + 10
              PI = ACOS(-1.0D0)
              F1 = NDIG*DLOGMB - (X1 + 0.5)*LOG(X1) + X1 - LOG(2.0*PI)/2 - 1/(12.0*X1)
              IF (F1 < 0) THEN
                  X2 = 0.9*X1
              ELSE
                  X2 = 1.1*X1
              ENDIF
              F2 = NDIG*DLOGMB - (X2 + 0.5)*LOG(X2) + X2 - LOG(2.0*PI)/2 - 1/(12.0*X2)
              DO J = 1, 5
                 X3 = X2 - F2*(X2 - X1)/(F2 - F1)
                 F3 = NDIG*DLOGMB - (X3 + 0.5)*LOG(X3) + X3 - LOG(2.0*PI)/2 - 1/(12.0*X3)
                 IF (ABS(X3-X2) < 0.1) EXIT
                 X1 = X2
                 F1 = F2
                 X2 = X3
                 F2 = F3
              ENDDO

              K = X3 + 10
              CALL FMEXP2_TQ(0,K,MXY(1),MXY(2))
              IF (MWK(START(MXY(1))+2) >= NDIG .AND. MWK(START(MXY(2))+2) >= NDIG) THEN
                  CALL FMDIV_R2(MXY(1),MXY(2))
                  NDIG = NDSAVE
                  KFLAG = 0
                  CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
              ELSE
                  CALL IMI2FM(MXY(1),MXY(3))
                  CALL IMI2FM(MXY(2),MXY(4))
                  CALL FMDIV(MXY(3),MXY(4),MXY(2))
                  NDIG = NDSAVE
                  KFLAG = 0
                  CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
              ENDIF
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Here is the general case.  Compute EXP(MA) where 0 < MA < 1.

!             Use the direct series
!                  EXP(X) = 1 + X + X**2/2! + X**3/3! + ...

!             The argument will be halved K2 times before the series is summed.  The series will be
!             added as J2 concurrent series.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG2 = REAL(DLOGTW)
      ALOGT = LOG(T)
      TJ = 0.87*(NDIG*ALOGMT)**0.3333 - 1.3
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      K2 = MAX(2,INT(2.0*(NDIG*ALOGMT)**0.3333 - 0.5))

      TJ = -(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
             REAL(MWK(START(MA)+4))/(B*B)))/ALOG2 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Halve the argument K2 times.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTWO = 1
      MAXV = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTWO)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMCSDIVI_R1(MXY(1),KTWO)
      ENDIF

!             Sum the series X + X**2/2! + X**3/3! + ....
!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 1
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(2),NTERM)
         NTERM = NTERM + 1
         CALL FMEQ(MXY(2),MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 150
      CALL FMIPWR(MXY(1),J2,MXY(3))

  140 CALL FMCSMPY_R1(MXY(2),MXY(3))
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(2),NTERM)
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 150
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 140

!             Put the J2 separate sums back together.

  150 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(3))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
      ENDDO

!             Reverse the effect of halving the argument to compute EXP(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1))
              DO J = 1, K2
                 KEXP = MWK(START(MXY(3))+2)
                 IF (MBASE == 2 .OR. KEXP > 0) THEN
                     CALL FMADD(MXY(3),MXY(1),MXY(2))
                 ELSE
                     DO K = 0, 3-KEXP
                        MWK(START(MXY(2))+K) = MWK(START(MXY(1))+K)
                     ENDDO
                     DO K = 4-KEXP, NDIG+2
                        MWK(START(MXY(2))+K) = MWK(START(MXY(3))+K+KEXP-1)
                     ENDDO
                 ENDIF
                 CALL FMCSMPY_R1(MXY(3),MXY(2))
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2))
                 CALL FMADD(MXY(3),MXY(3),MXY(1))
                 CALL FMADD(MXY(2),MXY(1),MXY(3))
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(1))
      CALL FMADD(MXY(1),MXY(3),MXY(2))

      CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEXP2

      RECURSIVE SUBROUTINE FMEXP2_TQ(A,B,MT,MQ)

!  This routine does the binary splitting for computing the constant e.
!  When A is zero, e is approximated by MT/MQ.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT,MQ
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MT,MQ
      INTEGER :: MXY(4),NUMBER_USED_SAVE,J,KQ,KT,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 25) THEN
          RESULT_SIZE = ( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) + 10 ) / DLOGMB + 8
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MT <= 0) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ENDIF
          IF (MQ <= 0) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ENDIF
          NUMBER_USED_SAVE = NUMBER_USED
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMI2M(1,MT)
          CALL IMI2M(1,MXY(1))
          DO J = 0, B-A-2, 2
             CALL IMMPYI(MXY(1),B-J,MXY(2))
             CALL IMADD(MT,MXY(2),MXY(3))
             CALL IMMPYI(MXY(2),B-J-1,MXY(1))
             CALL IMADD(MXY(3),MXY(1),MT)
          ENDDO
          IF (MOD(B-A,2) == 1) THEN
              CALL IMMPYI(MXY(1),A+1,MXY(2))
              CALL IMADD(MT,MXY(2),MXY(3))
              CALL IMEQ(MXY(3),MT)
          ENDIF

          IF (A == 0) THEN
              CALL IMI2M(1,MQ)
          ELSE
              CALL IMI2M(A,MQ)
          ENDIF
          DO J = A+1, B-1, 2
             CALL IMMPYI(MQ,J,MXY(1))
             CALL IMMPYI(MXY(1),J+1,MQ)
          ENDDO
          IF (MOD(B-A+1,2) == 0) THEN
              CALL IMMPYI(MQ,B,MXY(1))
              CALL IMEQ(MXY(1),MQ)
          ENDIF
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMEXP2_TQ(A,M-1,MXY(1),MXY(2))
      CALL FMEXP2_TQ(M,B,MXY(3),MXY(4))

      CALL IM_OR_FM_MPY(MXY(2),MXY(4),MQ)

      CALL IM_OR_FM_MPY(MXY(1),MXY(4),MXY(2))
      CALL IM_OR_FM_ADD(MXY(3),MXY(2),MT)

!             Move MQ and MT to the front of the unused area of MWK and save them.

      NUMBER_USED = NUMBER_USED_SAVE + 1
      KQ = MQ
      MQ = NUMBER_USED
      IF (NUMBER_USED <= 1) THEN
          START(MQ) = 1
      ELSE
          START(MQ) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      ENDIF
      SIZE_OF(MQ) = SIZE_OF(KQ)
      DO J = 1, SIZE_OF(MQ)
         MWK(START(MQ)+J-1) = MWK(START(KQ)+J-1)
      ENDDO
      TEMPV(MQ) = -2
      NUMBER_USED = NUMBER_USED + 1
      KT = MT
      MT = NUMBER_USED
      START(MT) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      SIZE_OF(MT) = SIZE_OF(KT)
      DO J = 1, SIZE_OF(MT)
         MWK(START(MT)+J-1) = MWK(START(KT)+J-1)
      ENDDO
      TEMPV(MT) = -2
      NUMBER_USED_SAVE = NUMBER_USED

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEXP2_TQ

      FUNCTION FMFI(N)

!  Format integers for trace output.

      IMPLICIT NONE
      CHARACTER(40) :: FMFI,TEMP
      INTEGER :: J,N

      FMFI = ' '
      WRITE (TEMP,*) N
      DO J = 1, 40
         IF (TEMP(J:J) /= ' ') THEN
             FMFI(1:41-J) = TEMP(J:40)
             RETURN
         ENDIF
      ENDDO

      END FUNCTION FMFI

      SUBROUTINE FMFLAG(K)

!  Return the internal condition variable KFLAG to the user.

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: K
      K = KFLAG
      RETURN
      END SUBROUTINE FMFLAG

      SUBROUTINE FMFFT_INIT(ROOTS_OF_UNITY,N)

!  Initialize roots of unity.

      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: ROOTS_OF_UNITY(0:N-1), S, ST
      DOUBLE PRECISION :: PI, T
      INTEGER :: ITS, J, JS, JSTEP, K, L, LEVEL, NR, N_DEF

      IF (N <= 100000) THEN
          RETURN
      ELSE
          L = NINT(2*LOG10(DBLE(N))-8)
          K = 2**L
          DO J = L, 1, -1
             IF (MOD(N,K) == 0) THEN
                 LEVEL = J
                 EXIT
             ENDIF
             K = K / 2
             LEVEL = 1
          ENDDO
      ENDIF

      N_DEF = N / 2**LEVEL
      IF (N < N_DEF) N_DEF = N
      ITS = NINT( LOG( DBLE(N) / N_DEF ) / LOG(2.0D0) )

      PI = ACOS(-1.0D0)
      T = 2*PI/N
      ST = CMPLX(-2*SIN(PI/N)**2,SIN(2*PI/N), KIND(0.0D0) )
      NR = N/2
      JSTEP = 32
      DO K = 0, NR/JSTEP - 1
         JS = K*JSTEP
         S = CMPLX( COS(JS*T) , SIN(JS*T) , KIND(0.0D0) )
         DO J = 0, JSTEP - 1
            ROOTS_OF_UNITY(J+JS) = S
            S = S + ST*S
         ENDDO
      ENDDO
      K = (NR/JSTEP)*JSTEP
      DO J = K, NR-1
         ROOTS_OF_UNITY(J) = CMPLX( COS(J*T) , SIN(J*T) , KIND(0.0D0) )
      ENDDO
      L = NR - 1
      DO J = 2, ITS
         JSTEP = 2**(J-1)
         DO K = 0, NR-1, JSTEP
            L = L + 1
            ROOTS_OF_UNITY(L) = ROOTS_OF_UNITY(K)
         ENDDO
      ENDDO

      END SUBROUTINE FMFFT_INIT

      SUBROUTINE FMFFT(A,N,ROOTS_OF_UNITY,A2)

!  A is returned as the FFT of the input array A(1:N)

!  This is not a general fft subroutine.  It is designed to be called by FM's multiplication
!  routines, and may not give correct results for arbitrary N.

      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: A(N), A2(N), ROOTS_OF_UNITY(0:N-1)
      INTEGER :: H, ITS, J, JLISTS, JS, JSTEP, K, K1, K2, L, LEVEL, LG, NL
      INTEGER, ALLOCATABLE :: FIRST(:)

      IF (N <= 100000) THEN
          CALL FMFFT2(A,N,A2)
          RETURN
      ELSE
          L = NINT(2*LOG10(DBLE(N))-8)
          K = 2**L
          DO J = L, 1, -1
             IF (MOD(N,K) == 0) THEN
                 LEVEL = J
                 EXIT
             ENDIF
             K = K / 2
             LEVEL = 1
          ENDDO
      ENDIF

      NL = 2**LEVEL
      LG = N/NL
      ALLOCATE( FIRST(NL) )

      JLISTS = 1
      FIRST(1) = 1
      H = 1
      DO J = 1, LEVEL
         DO K = JLISTS, 1, -1
            FIRST(2*K-1) = FIRST(K)
            FIRST(2*K)   = FIRST(K) + H
         ENDDO
         H = 2*H
         JLISTS = 2*JLISTS
      ENDDO

      DO J = 1, NL
         DO K = 0, LG-1
            A2(1+K+(J-1)*LG) = A(FIRST(J)+K*H)
         ENDDO
      ENDDO

      DO J = 1, NL
         CALL FMFFT2(A2(1+(J-1)*LG),LG,A)
      ENDDO

      ITS = NINT( LOG( DBLE(NL) ) / LOG(2.0D0) )
      JSTEP = ITS + 1
      DO L = 2, ITS, 2

         JSTEP = JSTEP - 1
         JS = -1
         IF (JSTEP > 1) JS = (N / 2**(JSTEP-1)) * (2**(JSTEP-1) - 1) - 1
         DO K = 2, NL, 2
            K1 = (K-2)*LG
            K2 = K1 + LG
            DO J = 1, LG
               A(J+K1) = A2(J+K1) + ROOTS_OF_UNITY(J+JS) * A2(J+K2)
               A(J+K2) = A2(J+K1) - ROOTS_OF_UNITY(J+JS) * A2(J+K2)
            ENDDO
         ENDDO

         LG = 2 * LG
         NL = NL / 2
         JSTEP = JSTEP - 1
         JS = -1
         IF (JSTEP > 1) JS = (N / 2**(JSTEP-1)) * (2**(JSTEP-1) - 1) - 1
         DO K = 2, NL, 2
            K1 = (K-2)*LG
            K2 = K1 + LG
            DO J = 1, LG
               A2(J+K1) = A(J+K1) + ROOTS_OF_UNITY(J+JS) * A(J+K2)
               A2(J+K2) = A(J+K1) - ROOTS_OF_UNITY(J+JS) * A(J+K2)
            ENDDO
         ENDDO

         LG = 2 * LG
         NL = NL / 2

      ENDDO

      IF (MOD(ITS,2) == 0) THEN
          DO J = 1, N
             A(J) = A2(J)
          ENDDO
      ELSE
          JSTEP = JSTEP - 1
          JS = -1
          IF (JSTEP > 1) JS = (N / 2**(JSTEP-1)) * (2**(JSTEP-1) - 1) - 1
          DO K = 2, NL, 2
             K1 = (K-2)*LG
             K2 = K1 + LG
             DO J = 1, LG
                A(J+K1) = A2(J+K1) + ROOTS_OF_UNITY(J+JS) * A2(J+K2)
                A(J+K2) = A2(J+K1) - ROOTS_OF_UNITY(J+JS) * A2(J+K2)
             ENDDO
          ENDDO
      ENDIF

      DEALLOCATE( FIRST )

      END SUBROUTINE FMFFT

      SUBROUTINE FMFFT2(A,N,W)

!  Internal routine used during very high precision multiplication.

!  A is returned as the FFT of the input array A(1:N).
!  W is a scratch array.
!  This is a slightly modified version of a Fast Fourier Transform routine found at www.netlib.org.

      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: A(N),W(N),S,S1,S2,S3,S4,ST,T
      REAL (KIND(0.0D0)) :: PI
      INTEGER D,E,F,G,H,I,J,K,L,M,O
      INTEGER, PARAMETER :: P(25) = (/ 2,3,5,7,11,13,17,19,23,29,31,37,41,  &
                                      43,47,53,59,61,67,71,73,79,83,89,97 /)
      INTEGER, PARAMETER :: NP = 25
      M = N
      F = 0
      PI = ACOS(-1.0D0)
  110 IF ( M == 1 ) GO TO 910
      DO I = 1,NP
         IF ( (M/P(I))*P(I) == M ) GO TO 120
      ENDDO
      L = M
      GO TO 130
  120 L = P(I)
  130 O = M
      M = M/L
      ST = CMPLX(-2*SIN(M*PI/N)**2,SIN(2*M*PI/N), KIND(1.0D0) )
      S1 = (1.0D0,0.0D0)
      S = S1
      S2 = (0.0D0,0.0D0)
      H = 0
      IF ( F == 1 ) GO TO 520
      IF ( L == 2 ) GO TO 140
      IF ( L == 3 ) GO TO 250
      GO TO 360
  140 IF ( M == 1 ) GO TO 230
      IF ( M == 2 ) GO TO 210
      IF ( M == 3 ) GO TO 190
      IF ( M == 4 ) GO TO 170
  150 J = -H
  160 I = H + 1
      H = H + M
      E = J + M
      IF (ABS(S-(1.0D0,0.0D0)) < 10*EPSILON(1.0D0)) THEN
          DO K = I, H
             W(K) = A(J+K) + A(E+K)
          ENDDO
      ELSE IF (ABS(S-(-1.0D0,0.0D0)) < 10*EPSILON(1.0D0)) THEN
          DO K = I, H
             W(K) = A(J+K) - A(E+K)
          ENDDO
      ELSE
          DO K = I, H
             W(K) = A(J+K) + S*A(E+K)
          ENDDO
      ENDIF
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 160
      IF ( H < N ) GO TO 150
      F = 1
      GO TO 110
  170 J = -H
  180 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 180
      IF ( H < N ) GO TO 170
      F = 1
      GO TO 110
  190 J = -H
  200 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 200
      IF ( H < N ) GO TO 190
      F = 1
      GO TO 110
  210 J = -H
  220 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 220
      IF ( H < N ) GO TO 210
      F = 1
      GO TO 110
  230 J = -H
  240 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 240
      IF ( H < N ) GO TO 230
      F = 1
      GO TO 110
  250 IF ( M == 1 ) GO TO 340
      IF ( M == 2 ) GO TO 320
      IF ( M == 3 ) GO TO 300
      IF ( M == 4 ) GO TO 280
  260 J = -H
  270 I = H + 1
      H = H + M
      E = J + M
      D = E + M
      T = S*S
      DO K = I, H
         W(K) = A(J+K) + S*A(E+K) + T*A(D+K)
      ENDDO
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 270
      IF ( H < N ) GO TO 260
      F = 1
      GO TO 110
  280 J = -H
  290 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 290
      IF ( H < N ) GO TO 280
      F = 1
      GO TO 110
  300 J = -H
  310 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 310
      IF ( H < N ) GO TO 300
      F = 1
      GO TO 110
  320 J = -H
  330 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 330
      IF ( H < N ) GO TO 320
      F = 1
      GO TO 110
  340 J = -H
  350 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 350
      IF ( H < N ) GO TO 340
      F = 1
      GO TO 110
  360 IF ( M == 1 ) GO TO 490
      IF ( M == 2 ) GO TO 460
      IF ( M == 3 ) GO TO 430
      IF ( M == 4 ) GO TO 400
  370 J = -H
  380 I = H + 1
      H = H + M
      G = J + O
      DO K = I, H
         W(K) = A(J+K)
      ENDDO
      T = S
      J = J + M
  390 DO K = I, H
         W(K) = W(K) + T*A(J+K)
      ENDDO
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 390
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 380
      IF ( H < N ) GO TO 370
      F = 1
      GO TO 110
  400 J = -H
  410 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      D = E + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(E) = (0.0D0,0.0D0)
      W(D) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  420 W(I) = W(I) + T*A(J+I)
      W(E) = W(E) + T*A(J+E)
      W(D) = W(D) + T*A(J+D)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 420
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 410
      IF ( H < N ) GO TO 400
      F = 1
      GO TO 110
  430 J = -H
  440 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(E) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  450 W(I) = W(I) + T*A(J+I)
      W(E) = W(E) + T*A(J+E)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 450
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 440
      IF ( H < N ) GO TO 430
      F = 1
      GO TO 110
  460 J = -H
  470 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  480 W(I) = W(I) + T*A(J+I)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 480
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 470
      IF ( H < N ) GO TO 460
      F = 1
      GO TO 110
  490 J = -H
  500 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
  510 W(I) = W(I) + T*A(J+I)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 510
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 500
      IF ( H < N ) GO TO 490
      F = 1
      GO TO 110
  520 IF ( L == 2 ) GO TO 530
      IF ( L == 3 ) GO TO 640
      GO TO 750
  530 IF ( M == 1 ) GO TO 620
      IF ( M == 2 ) GO TO 600
      IF ( M == 3 ) GO TO 580
      IF ( M == 4 ) GO TO 560
  540 J = -H
  550 I = H + 1
      H = H + M
      E = J + M
      DO K = I, H
         A(K) = W(J+K) + S*W(E+K)
      ENDDO
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 550
      IF ( H < N ) GO TO 540
      F = 0
      GO TO 110
  560 J = -H
  570 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 570
      IF ( H < N ) GO TO 560
      F = 0
      GO TO 110
  580 J = -H
  590 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 590
      IF ( H < N ) GO TO 580
      F = 0
      GO TO 110
  600 J = -H
  610 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 610
      IF ( H < N ) GO TO 600
      F = 0
      GO TO 110
  620 J = -H
  630 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 630
      IF ( H < N ) GO TO 620
      F = 0
      GO TO 110
  640 IF ( M == 1 ) GO TO 730
      IF ( M == 2 ) GO TO 710
      IF ( M == 3 ) GO TO 690
      IF ( M == 4 ) GO TO 670
  650 J = -H
  660 I = H + 1
      H = H + M
      E = J + M
      D = E + M
      T = S*S
      DO K = I, H
         A(K) = W(J+K) + S*W(E+K) + T*W(D+K)
      ENDDO
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 660
      IF ( H < N ) GO TO 650
      F = 0
      GO TO 110
  670 J = -H
  680 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 680
      IF ( H < N ) GO TO 670
      F = 0
      GO TO 110
  690 J = -H
  700 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 700
      IF ( H < N ) GO TO 690
      F = 0
      GO TO 110
  710 J = -H
  720 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 720
      IF ( H < N ) GO TO 710
      F = 0
      GO TO 110
  730 J = -H
  740 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 740
      IF ( H < N ) GO TO 730
      F = 0
      GO TO 110
  750 IF ( M == 1 ) GO TO 880
      IF ( M == 2 ) GO TO 850
      IF ( M == 3 ) GO TO 820
      IF ( M == 4 ) GO TO 790
  760 J = -H
  770 I = H + 1
      H = H + M
      G = J + O
      DO K = I, H
         A(K) =  W(J+K)
      ENDDO
      T = S
      J = J + M
  780 DO K = I, H
         A(K) = A(K) + T*W(J+K)
      ENDDO
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 780
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 770
      IF ( H < N ) GO TO 760
      F = 0
      GO TO 110
  790 J = -H
  800 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      D = E + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(E) = (0.0D0,0.0D0)
      A(D) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  810 A(I) = A(I) + T*W(J+I)
      A(E) = A(E) + T*W(J+E)
      A(D) = A(D) + T*W(J+D)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 810
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 800
      IF ( H < N ) GO TO 790
      F = 0
      GO TO 110
  820 J = -H
  830 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(E) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  840 A(I) = A(I) + T*W(J+I)
      A(E) = A(E) + T*W(J+E)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 840
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 830
      IF ( H < N ) GO TO 820
      F = 0
      GO TO 110
  850 J = -H
  860 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  870 A(I) = A(I) + T*W(J+I)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 870
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 860
      IF ( H < N ) GO TO 850
      F = 0
      GO TO 110
  880 J = -H
  890 I = H + 1
      H = H + M
      G = J + O
      A(I) = W(J+I)
      T = S
      J = J + M
  900 A(I) = A(I) + T*W(J+I)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 900
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 890
      IF ( H < N ) GO TO 880
      F = 0
      GO TO 110
  910 IF ( F /= 0 ) THEN
          DO I = 1, N
             A(I) = W(I)
          ENDDO
      ENDIF
      RETURN
      END SUBROUTINE FMFFT2

      SUBROUTINE FMFORM(FORM,MA,STRING)

!  Convert an FM number (MA) to a character string base 10 (STRING) using character string
!  FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

!  If Iw format is used and MA is not exactly an integer, then the nearest integer to MA is printed.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTENT (IN) :: FORM,MA
      INTENT (INOUT) :: STRING
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KSAVE,KWD,KWI,LAST,LB,LENGFM,LENGST,LFIRST,ND,NEXP
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMFORM'

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      STRING = ' '
      LENGFM = LEN(FORM)
      LENGST = LEN(STRING)
      KWI = 75
      KWD = 40

      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = LENGST
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 21
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 STRING(J:J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid showing
!             no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(REAL(MWK(START(MA)+2)))+1)*LOG10(REAL(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
                      ALLOCATE(CMBUFF(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFF = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 STRING(J:J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
          DO J = KWI, 1, -1
             IF (J > LENGST) THEN
                 IF (CMBUFF(J) /= ' ') GO TO 110
             ELSE
                 STRING(J:J) = CMBUFF(J)
             ENDIF
          ENDDO
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
          DO J = KWI, 1, -1
             IF (J > LENGST) THEN
                 IF (CMBUFF(J) /= ' ') GO TO 110
             ELSE
                 STRING(J:J) = CMBUFF(J)
             ENDIF
          ENDDO
      ELSE
          GO TO 110
      ENDIF
      GO TO 120

!             Error condition.

  110 KFLAG = -8
      DO J = 1, LENGST
         STRING(J:J) = '*'
      ENDDO

  120 KFLAG = KSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMFORM

      SUBROUTINE FMFPRT(FORM,MA)

!  Print an FM number (MA) on unit KW using character string FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

!  If Iw format is used and MA is not exactly an integer, then the nearest integer to MA is printed.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      CHARACTER(20) :: FORM2
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K,K1,K2,K3,KD,KSAVE,KWD,KWI,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: FORM,MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMFPRT'

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40

      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 21
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid showing
!             no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(REAL(MWK(START(MA)+2)))+1)*LOG10(REAL(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
                      ALLOCATE(CMBUFF(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFF = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE
          GO TO 110
      ENDIF
      GO TO 120

!             Error condition.

  110 KFLAG = -8
      DO J = 1, KWI
         CMBUFF(J) = '*'
      ENDDO

  120 LAST = KWI + 1
      WRITE (FORM2,"(' (6X,',I3,'A1) ')") KSWIDE-7
      IF (KFLAG /= -8) KFLAG = KSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      DO J = KWI, 1, -1
         IF (CMBUFF(J) /= ' ' .OR. J == 1) THEN
             WRITE (KW,FORM2) (CMBUFF(K),K=1,J)
             NCALL = NCALL - 1
             NUMBER_USED = NUMBER_USED_SAVE
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFPRT

      SUBROUTINE FMGCDI(N1,N2)

!  Find the Greatest Common Divisor of N1 and N2, and return both having been divided by their GCD.
!  Both must be positive.

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: K1,K2,K3,N1,N2
      INTENT (INOUT) :: N1,N2

      K1 = MAX(N1,N2)
      K2 = MIN(N1,N2)
  110 K3 = MOD(K1,K2)
      IF (K3 == 0) THEN
          N1 = N1/K2
          N2 = N2/K2
          RETURN
      ELSE
          K1 = K2
          K2 = K3
          GO TO 110
      ENDIF
      END SUBROUTINE FMGCDI

      SUBROUTINE FMHTBL

!  Initialize two hash tables that are used for character look-up during input conversion.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J,KPT

      CHARACTER :: LCHARS(21) = (/                                  &
                  '+','-','0','1','2','3','4','5','6','7','8','9',  &
                  '.','E','D','Q','M','e','d','q','m' /)
      INTEGER :: LTYPES(21) = (/ 1,1,2,2,2,2,2,2,2,2,2,2,3,4,4,4,4,4,4,4,4 /)
      INTEGER :: LVALS(21) = (/ 1,-1,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0 /)

      DO J = LHASH1, LHASH2
         KHASHT(J) = 5
         KHASHV(J) = 0
      ENDDO
      DO J = 1, 21
         KPT = ICHAR(LCHARS(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LCHARS(J),KPT,LHASH1,LHASH2
         ELSE
             KHASHT(KPT) = LTYPES(J)
             KHASHV(KPT) = LVALS(J)
         ENDIF
      ENDDO
      LHASH = 1
      RETURN
      END SUBROUTINE FMHTBL

      SUBROUTINE FMHYPOT(MA,MB,MC)

!  MC = sqrt( x^2 + y^2 )

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,NDSAVE,MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMHYPOT  '
      NDSAVE = NDIG
      NDIG = NDIG + NGRD52
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MXY(1))
          GO TO 110
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(1))
          GO TO 110
      ENDIF

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      CALL FMSQR_R1(MXY(1))
      CALL FMSQR_R1(MXY(2))
      CALL FMADD_R1(MXY(1),MXY(2))
      CALL FMSQRT_R1(MXY(1))

  110 MXEXP = MXSAVE
      CALL FMEQU(MXY(1),MC,NDIG,NDSAVE)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMHYPOT

      SUBROUTINE FMI2M(IVAL,MA)

!  MA = IVAL

!  Convert an integer to FM format.

!  The conversion is exact if IVAL is less than MBASE**NDIG, otherwise the result is
!  an approximation.

!  This routine performs the trace printing for the conversion.  FMIM is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMI2M'
          CALL FMNTRI(2,IVAL,1)

          CALL FMIM(IVAL,MA)

          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMIM(IVAL,MA)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMI2M

      SUBROUTINE FMIM(IVAL,MA)

!  MA = IVAL.  Internal integer conversion routine.

!  The conversion is exact if IVAL is less than MBASE**NDIG, otherwise FMDM is used to get
!  an approximation.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: MK,ML,MVAL
      INTEGER :: J,JM2,KB,KB1,N1,NMVAL,NV2
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1

      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIMS(IVAL,MA)
          GO TO 120
      ENDIF

!             Check for small IVAL.

      IF (MVAL < MBASE) THEN
          DO J = 3, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
          IF (IVAL >= 0) THEN
              MWK(START(MA)+3) = IVAL
              MWK(START(MA)) = 1
          ELSE
              MWK(START(MA)+3) = -IVAL
              MWK(START(MA)) = -1
          ENDIF
          IF (IVAL == 0) THEN
              MWK(START(MA)+2) = 0
          ELSE
              MWK(START(MA)+2) = 1
          ENDIF
          GO TO 120
      ENDIF

!             Compute and store the digits, right to left.

      MWK(START(MA)+2) = 0
      J = NDIG + 1

  110 MK = AINT (MVAL/MBASE)
      ML = MVAL - MK*MBASE
      MWK(START(MA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MA)+J+1) = ML
      IF (MK > 0) THEN
          MVAL = MK
          J = J - 1
          IF (J >= 2) GO TO 110

!             Here IVAL cannot be expressed exactly.

          X = IVAL
          CALL FMDM(X,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Normalize MA.

      KB = N1 - J + 2
      JM2 = J - 2
      DO J = 2, KB
         MWK(START(MA)+J+1) = MWK(START(MA)+J+JM2+1)
      ENDDO
      KB1 = KB + 1
      IF (KB1 <= N1) THEN
          DO J = KB1, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
      ENDIF

      MWK(START(MA)) = 1
      IF (IVAL < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1

  120 MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIM

      SUBROUTINE FMIMS(IVAL,MA)

!  MA = IVAL.  Internal integer conversion routine.

!  This routine is called when M-variable precision is less than Integer precision.  This often
!  happens when single precision is chosen for M-variables.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: ML
      INTEGER :: J,JM2,KB,KB1,KBASE,KMK,KVAL,N1
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1

!             Check for small IVAL.

      KVAL = ABS(IVAL)
      KBASE = INT(MBASE)
      IF (KVAL < KBASE) THEN
          DO J = 3, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
          IF (IVAL >= 0) THEN
              MWK(START(MA)+3) = IVAL
              MWK(START(MA)) = 1
          ELSE
              MWK(START(MA)+3) = -IVAL
              MWK(START(MA)) = -1
          ENDIF
          IF (IVAL == 0) THEN
              MWK(START(MA)+2) = 0
          ELSE
              MWK(START(MA)+2) = 1
          ENDIF
          GO TO 120
      ENDIF

!             Compute and store the digits, right to left.

      MWK(START(MA)+2) = 0
      J = NDIG + 1

  110 KMK = (KVAL/KBASE)
      ML = KVAL - KMK*KBASE
      MWK(START(MA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MA)+J+1) = ML
      IF (KMK > 0) THEN
          KVAL = KMK
          J = J - 1
          IF (J >= 2) GO TO 110

!             Here IVAL cannot be expressed exactly.

          X = IVAL
          CALL FMDM(X,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Normalize MA.

      KB = N1 - J + 2
      JM2 = J - 2
      DO J = 2, KB
         MWK(START(MA)+J+1) = MWK(START(MA)+J+JM2+1)
      ENDDO
      KB1 = KB + 1
      IF (KB1 <= N1) THEN
          DO J = KB1, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
      ENDIF

      MWK(START(MA)) = 1
      IF (IVAL < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1

  120 MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIMS

      SUBROUTINE FMINP(LINE,MA,LA,LB)

!  Convert an array of characters to floating point multiple precision format.

!  LINE is an A1 character array of length LB to be converted to FM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.  This allows
!     more than one number to be stored in an array and converted in place.
!  LB is a pointer to the last character of the field for that number.

!  The input number may be in integer or any real format.

!  KESWCH = 1  causes input to FMINP with no digits before the exponent letter to be treated as if
!              there were a leading '1'.  This is sometimes better for interactive input:
!              'E7' converts to 10.0**7.
!         = 0  causes a leading zero to be assumed.  This gives compatibility with Fortran:
!              'E7' converts to 0.0.

!  In exponential format the 'E' may also be 'D', 'Q', or 'M'.

!  So that FMINP will convert any output from FMOUT, LINE is tested to see if the input is one of
!  the special symbols +OVERFLOW, -OVERFLOW, +UNDERFLOW, -UNDERFLOW, or UNKNOWN.
!  For user input the abbreviations OVFL, UNFL, UNKN may be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA

      REAL (KIND(1.0D0)) :: MBSAVE,MXSAV1,MXSAV2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KMN,KOF,KPOWER,KPT,KR_RETRY,KSPEC,KSTART,KSTOP,  &
                 KTYPE,KUF,KUK,KWRNSV,L,ND,NDSAV1,NDSAVE,NEW_MBASE,NEW_NDIG,NTRSAV
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA

      CHARACTER :: KOVFL(4) = (/ 'O','V','F','L' /)
      CHARACTER :: KUNFL(4) = (/ 'U','N','F','L' /)
      CHARACTER :: KUNKN(4) = (/ 'U','N','K','N' /)
      CHARACTER :: LOVFL(4) = (/ 'o','v','f','l' /)
      CHARACTER :: LUNFL(4) = (/ 'u','n','f','l' /)
      CHARACTER :: LUNKN(4) = (/ 'u','n','k','n' /)
      CHARACTER(9) :: NAMEST_SAVE(0:50)
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             To avoid recursion, FMINP calls only internal arithmetic routines (FMADD2,
!             FMMPY2, ...), so no trace printout is done during a call to FMINP.

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMINP'
      NDSAVE = NDIG
      KASAVE = KACCSW
      KACCSW = 0
      KWRNSV = KWARN
      KWARN = 0
      KR_RETRY = 0
      KFLAG = 0
      MXSAV1 = MXEXP
      MXSAV2 = MXEXP2
      IF (MXEXP < 100000) THEN
          MXEXP  = 201000
          MXEXP2 = 201000
      ELSE
          MXEXP = MXEXP2
      ENDIF

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Check for special symbols.

      KSPEC = 0
      KMN = 1
      KOF = 1
      KUF = 1
      KUK = 1
      DO J = LA, LB
         KPT = ICHAR(LINE(J))
         IF (KPT >= LHASH1 .AND. KPT <= LHASH2) THEN
             KTYPE = KHASHT(KPT)
             IF (KTYPE == 2) GO TO 110
         ENDIF
         IF (LINE(J) == '-') KMN = -1
         IF (LINE(J) == KOVFL(KOF) .OR. LINE(J) == LOVFL(KOF)) THEN
             KOF = KOF + 1
             IF (KOF == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5))
                 MWK(START(MXY(5))+2) = MEXPOV
                 MWK(START(MXY(5))+3) = 1
                 MWK(START(MXY(5))) = KMN
                 MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
                 GO TO 130
             ENDIF
         ENDIF
         IF (LINE(J) == KUNFL(KUF) .OR. LINE(J) == LUNFL(KUF)) THEN
             KUF = KUF + 1
             IF (KUF == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5))
                 MWK(START(MXY(5))+2) = MEXPUN
                 MWK(START(MXY(5))+3) = 1
                 MWK(START(MXY(5))) = KMN
                 MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
                 GO TO 130
             ENDIF
         ENDIF
         IF (LINE(J) == KUNKN(KUK) .OR. LINE(J) == LUNKN(KUK)) THEN
             KUK = KUK + 1
             IF (KUK == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5))
                 MWK(START(MXY(5))+2) = MUNKNO
                 MWK(START(MXY(5))+3) = 1
                 MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
                 GO TO 130
             ENDIF
         ENDIF
      ENDDO

!             Increase the working precision.

  110 K = NGRD52
      NDIG = MAX(NDIG+K,2)

  120 IF (KR_RETRY >= 1) THEN
          NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NDSAV1 = NDIG
      KSTART = LA
      KSTOP = LB

!             If MBASE is a power of ten then call FMINP2 for faster input conversion.

      KPOWER = INT(LOG10(DBLE(MBASE)) + 0.5D0)
      IF (MBASE == 10**KPOWER) THEN
          K = 0
          DO J = LA, LB
             IF (LINE(J) /= ' ') THEN
                 DO L = LB, LA, -1
                    IF (LINE(L) /= ' ') THEN
                        K = (L-J+1)*LOG(10.0D0)/LOG(DBLE(MBASE))
                        EXIT
                    ENDIF
                 ENDDO
                 EXIT
             ENDIF
          ENDDO
          IF (NDIG <= K+9) THEN
              NDIG = K + 10
              NDSAV1 = NDIG
          ENDIF
          CALL FMIM(0,MXY(1))
          CALL FMIM(0,MXY(2))
          CALL FMIM(0,MXY(3))
          CALL FMIM(0,MXY(4))
          CALL FMIM(0,MXY(5))
          CALL FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER)
          IF (MWK(START(MXY(5))+2) == MUNKNO) GO TO 140
          GO TO 130
      ENDIF

!             If MBASE is not a power of ten then call FMINP2 first using a power of ten base,
!             then change to base MBASE.

      MBSAVE = MBASE
      KPOWER = INT(LOG10(DBLE(MXBASE)/4) + 0.5D0)
      MBASE = 10**KPOWER
      NDIG = NDSAV1*LOG(DBLE(MBSAVE))/LOG(DBLE(MBASE)) + 3
      K = 0
      DO J = LA, LB
         IF (LINE(J) /= ' ') THEN
             DO L = LB, LA, -1
                IF (LINE(L) /= ' ') THEN
                    K = (L-J+1)*LOG(10.0D0)/LOG(DBLE(MBASE))
                    EXIT
                ENDIF
             ENDDO
             EXIT
         ENDIF
      ENDDO
      IF (NDIG <= K+9) THEN
          NDIG = K + 10
      ENDIF
      CALL FMCONS
      CALL FMIM(0,MXY(1))
      CALL FMIM(0,MXY(2))
      CALL FMIM(0,MXY(3))
      CALL FMIM(0,MXY(4))
      CALL FMIM(0,MXY(5))
      J = MXEXP2
      K = J*LOG(DBLE(MBSAVE))/LOG(DBLE(MBASE)) + 0.5
      MXEXP2 = K
      CALL FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER)
      MXEXP2 = J
      NEW_MBASE = MBSAVE
      NEW_NDIG = MAX(NDSAV1,NDIG*NINT(LOG(DBLE(MBASE))/LOG(DBLE(MBSAVE))))
      ND = 2
      DO J = NDIG, 3, -1
         IF (MWK(START(MXY(5))+J+2) /= 0) THEN
             ND = J
             EXIT
         ENDIF
      ENDDO
      NDIG = ND
      NTRSAV = NTRACE
      NTRACE = 0
      J = NCALL
      NAMEST_SAVE(0:NCALL) = NAMEST(0:NCALL)
      NCALL = 0
      IF (ABS(MWK(START(MXY(5))+2)) < MEXPOV) THEN
          CALL FMCHANGEBASE(MXY(5),MXY(4),NEW_MBASE,NEW_NDIG)
      ELSE
          CALL FMEQU(MXY(5),MXY(4),NDIG,NEW_NDIG)
      ENDIF
      NCALL = J
      NAMEST(0:NCALL) = NAMEST_SAVE(0:NCALL)
      NTRACE = NTRSAV
      MBASE = MBSAVE
      NDIG = NEW_NDIG
      CALL FMCONS
      CALL FMEQ(MXY(4),MXY(5))
      IF (MWK(START(MXY(5))+2) == MUNKNO) GO TO 140

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (KSPEC == 0) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF
      MXEXP = MXSAV1
      MXEXP2 = MXSAV2
      IF (INT(MBASE-AINT (MBASE/2)*2) == 0) THEN
          CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
      ELSE
          CALL FMEQU(MXY(5),MA,NDIG-1,NDSAVE)
      ENDIF
      IF (KSPEC == 0) THEN
          IF (MWK(START(MA)+2) == MUNKNO) GO TO 140
      ELSE
          KFLAG = 0
      ENDIF
      NDIG = NDSAVE
      KACCSW = KASAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (MWK(START(MA)+3) == 0) MWK(START(MA)) = 1
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             Error in converting the number.

  140 CALL FMIM(0,MXY(5))
      CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
      MWK(START(MA)+2) = MUNKNO
      MWK(START(MA)+3) = 1
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      KWARN = KWRNSV
      KFLAG = -7
      NAMEST(NCALL) = 'FMINP'
      CALL FMWARN
      NDIG = NDSAVE
      KACCSW = KASAVE
      MXEXP = MXSAV1
      MXEXP2 = MXSAV2
      IF (KFLAG == 1) KFLAG = 0
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (MWK(START(MA)+3) == 0) MWK(START(MA)) = 1
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMINP

      SUBROUTINE FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER)

!  Internal routine for input conversion for a power of ten MBASE.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MXY(5)
      INTEGER :: KSTART,KSTOP,KPOWER
      CHARACTER :: LINE(KSTOP)

      INTEGER :: J,JSTATE,K,KDFLAG,KEXP,KF1,KF1DIG,KF2,KF2DIG,KF2PT,KNZDIG,KPT,KSHIFT,KSIGN,  &
                 KSIGNX,KTYPE,KVAL,LARGE,LNZD
      INTENT (IN) :: LINE,KSTART,KSTOP,KPOWER
      INTENT (INOUT) :: MXY

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States of the machine:

!  1.  Initial entry to the subroutine
!  2.  Sign of the number
!  3.  Scanning digits before a decimal point
!  4.  Decimal point
!  5.  Scanning digits after a decimal point
!  6.  E, D, Q, or M -- precision indicator before the exponent
!  7.  Sign of the exponent
!  8.  Scanning exponent
!  9.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (E,D,Q,M)
!  5.  Illegal character for number

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state JSTATE and a character of type JTYPE is encountered the new state of the
!  machine is given by JTRANS(JSTATE,JTYPE).

!  In this initialization, the array is loaded by columns.

!          State   1  2  3  4  5  6  7  8

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      JSTATE = 1
      KDFLAG = 0
      KSIGN = 1
      KSIGNX = 1
      KF1 = 0
      KNZDIG = 0
      LNZD = 0
      KF1DIG = 0
      KF2 = 0
      KF2DIG = 0
      KF2PT = 2
      KEXP = 0
      LARGE = INT(INTMAX/10)

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == ' ') CYCLE
         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF

         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDFLAG = 1
             KF1 = 10*KF1 + KVAL
             IF (KVAL > 0) LNZD = 1
             IF (KVAL > 0 .OR. KNZDIG /= 0) THEN
                 KNZDIG = 1
                 KF1DIG = KF1DIG + 1
             ENDIF
             IF (KF1DIG == KPOWER) THEN
                 MWK(START(MXY(2))+2) = MWK(START(MXY(2))+2) + 1
                 K = MWK(START(MXY(2))+2)
                 IF (K < NDIG) THEN
                     MWK(START(MXY(2))+K+2) = KF1
                 ENDIF
                 KF1 = 0
                 KF1DIG = 0
             ENDIF

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDFLAG = 1
             IF (KVAL > 0) LNZD = 1
             IF (KF2PT > NDIG+1) CYCLE
             KF2 = 10*KF2 + KVAL
             KF2DIG = KF2DIG + 1
             IF (KF2DIG == KPOWER) THEN
                 MWK(START(MXY(3))+KF2PT+1) = KF2
                 IF (KF2 == 0 .AND. KF2PT == 2) THEN
                     MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) - 1
                 ELSE
                     KF2PT = KF2PT + 1
                 ENDIF
                 KF2 = 0
                 KF2DIG = 0
             ENDIF

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDFLAG == 0 .AND. KESWCH == 1) THEN
                 LNZD = 1
                 CALL FMIM(1,MXY(2))
             ENDIF

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             IF (KEXP >= LARGE) THEN
                 IF (LNZD == 0) THEN
                     CALL FMIM(0,MXY(5))
                     RETURN
                 ENDIF
                 CALL FMINP3(LINE,KSTART,KSTOP,MXY(5))
                 RETURN
             ENDIF
             KEXP = 10*KEXP + KVAL
             IF (KEXP >= 0.75D0*MXEXP2*DLOGMB/DLOGTN .AND. LNZD /= 0) THEN
                 CALL FMINP3(LINE,KSTART,KSTOP,MXY(5))
                 RETURN
             ENDIF

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Form the number and return.  MXY(5) = KSIGN*(MXY(2) + MXY(3))*10.0**(KSIGNX*KEXP)

      IF (KF1DIG /= 0) THEN
          MWK(START(MXY(2))+2) = MWK(START(MXY(2))+2) + 1
          KSHIFT = 10**(KPOWER-KF1DIG)
          K = MWK(START(MXY(2))+2)
          IF (K < NDIG) MWK(2+INT(K)+START(MXY(2))) = KF1*KSHIFT
          IF (KSHIFT > 1) THEN
              CALL FMDIVN_R1(MXY(2),KSHIFT)
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+3) == 0) THEN
          MWK(START(MXY(2))) = 1
          MWK(START(MXY(2))+2) = 0
      ELSE
          MWK(START(MXY(2))) = 1
      ENDIF

      IF (KF2DIG /= 0) THEN
          KSHIFT = 10**(KPOWER-KF2DIG)
          MWK(START(MXY(3))+KF2PT+1) = KF2*KSHIFT
      ENDIF
      IF (MWK(START(MXY(3))+3) == 0) THEN
          MWK(START(MXY(3))) = 1
          MWK(START(MXY(3))+2) = 0
      ELSE
          MWK(START(MXY(3))) = 1
      ENDIF

      IF (KEXP /= 0) THEN
          IF (KSIGNX == 1) THEN
              MWK(START(MXY(4))+2) = INT(KEXP/KPOWER) + 1
              MWK(START(MXY(4))+3) = 10**(MOD(KEXP,KPOWER))
          ELSE
              MWK(START(MXY(4))+2) = -INT((KEXP-1)/KPOWER)
              KSHIFT = 10**(MOD(KEXP,KPOWER))
              IF (KSHIFT > 1) THEN
                  MWK(START(MXY(4))+3) = MBASE/KSHIFT
              ELSE
                  MWK(START(MXY(4))+3) = 1
              ENDIF
          ENDIF
      ENDIF

      CALL FMADD2(MXY(2),MXY(3),MXY(5))

      IF (KEXP > 0) CALL FMMPY2_R1(MXY(5),MXY(4))
      MWK(START(MXY(5))) = KSIGN

      RETURN

!             Error in converting the number.

  110 CALL FMIM(0,MXY(5))
      MWK(START(MXY(5))+2) = MUNKNO
      MWK(START(MXY(5))+3) = 1
      MWK(START(MXY(5))) = 1
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      KFLAG = -7
      RETURN
      END SUBROUTINE FMINP2

      SUBROUTINE FMINP3(LINE,KSTART,KSTOP,MA)

!  Internal routine to see if the input character string in LINE would overflow or underflow
!  with the current base and precision.

!  MA is returned as + or - over/underflow or unknown.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KSTART,KSTOP,MA
      CHARACTER :: LINE(KSTOP)
      INTEGER :: J,JSTATE,KDIGFL,KPT,KSIGN,KSIGNX,KTYPE,KVAL,N1,N2
      DOUBLE PRECISION :: X,F1,F2,FEXP,FLARGE

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      CHARACTER :: KBLANK = ' '
      INTENT (IN) :: LINE,KSTART,KSTOP
      INTENT (INOUT) :: MA

!             X will approximate the log of the magnitude of the number represented by LINE.

      JSTATE = 1
      KSIGN = 1
      F1 = 0
      F2 = 0
      N1 = 0
      N2 = 0
      KSIGNX = 1
      FEXP = 0
      FLARGE = HUGE(F1)/31

!             KDIGFL will be 1 if any digits are found before 'E'.

      KDIGFL = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == KBLANK) CYCLE
         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF
         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDIGFL = 1
             IF (F1 < FLARGE) THEN
                 F1 = 10.0D0*F1 + KVAL
             ELSE
                 N1 = N1 + 1
             ENDIF

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDIGFL = 1
             IF (F2 < FLARGE) THEN
                 F2 = 10.0D0*F2 + KVAL
                 N2 = N2 + 1
             ENDIF

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDIGFL == 0) F1 = 1.0D0

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             IF (FEXP < FLARGE) THEN
                 FEXP = 10*FEXP + KVAL
             ENDIF

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Check to see if the number would over/underflow.

      IF (F1 > 0) THEN
          X = LOG(F1) + (FEXP+N1)*LOG(10.0D0)
      ELSE IF (F2 > 0) THEN
          X = LOG(F2) - N2*LOG(10.0D0) + FEXP*LOG(10.0D0)
      ENDIF
      IF (X > (MXEXP2/2.0D0)*LOG(DBLE(MBASE)) .AND. KSIGNX > 0) THEN
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MEXPOV
          MWK(START(MA)+3) = 1
          MWK(START(MA)) = KSIGN
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -5
      ELSE IF (X > (MXEXP2/2.0D0)*LOG(DBLE(MBASE)) .AND. KSIGNX < 0) THEN
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MEXPUN
          MWK(START(MA)+3) = 1
          MWK(START(MA)) = KSIGN
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -6
      ELSE
          GO TO 110
      ENDIF

      RETURN

!             Error in converting the number.

  110 CALL FMIM(0,MA)
      MWK(START(MA)+2) = MUNKNO
      MWK(START(MA)+3) = 1
      MWK(START(MA)) = 1
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      KFLAG = -7
      RETURN
      END SUBROUTINE FMINP3

      SUBROUTINE FMINPUT_ERROR(J)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: J
      WRITE (*,*) ' '
      WRITE (*,*) ' '
      WRITE (*,*) ' ***  Error in a program using the FM package  ***'
      WRITE (*,*) ' '
      WRITE (*,*) ' A multiple precision number is undefined in an expression or as an input'
      WRITE (*,*) ' argument to a subprogram.'
      WRITE (*,*) ' '
      IF (J == 1) THEN
          WRITE (*,*) ' Negative variable index.'
          WRITE (*,*) ' This usually means trying to use an undefined multiple precision variable'
      ELSE IF (J == 2) THEN
          WRITE (*,*) ' (Variable index between temp zone and saved zone)'
      ELSE IF (J == 3) THEN
          WRITE (*,*) ' (Variable index larger than SIZE_OF_START)'
      ELSE IF (J == 4) THEN
          WRITE (*,*) ' (START(.) is not between 0 and SIZE_OF_MWK)'
      ELSE IF (J == 5) THEN
          WRITE (*,*) ' (SIZE_OF(.) is not between 0 and SIZE_OF_MWK)'
      ELSE IF (J == 6) THEN
          WRITE (*,*) ' (START(.)+SIZE_OF(.) is greater than SIZE_OF_MWK)'
      ELSE IF (J == 7) THEN
          WRITE (*,*) ' (SIZE_OF(.) < NDIG+3 -- too small for current precision)'
      ENDIF
      WRITE (*,*) ' '
      WRITE (*,*) ' To help isolate the code that caused this error, this error message is followed'
      WRITE (*,*) ' by an illegal out-of-range array reference.  Many compilers have an option for'
      WRITE (*,*) ' checking array bounds and will give a traceback with the line number in the'
      WRITE (*,*) ' calling program where the error originated.'
      WRITE (*,*) ' '
      WRITE (*,*) ' The program has been stopped.'
      WRITE (*,*) ' '
      IF (MWK(-NDIG) > -314159) WRITE (*,*) ' Negative array subscript.'
      STOP
      END SUBROUTINE FMINPUT_ERROR

      SUBROUTINE FMINT(MA,MB)

!  MB = INT(MA)

!  The integer part of MA is computed and returned in MB as a multiple precision floating
!  point number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACMAX
      INTEGER :: J,KA,KB,KRESLT,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMINT'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('FMINT    ',1,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              CALL FMRSLT(MA,MA,MB,KRESLT)
              IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      N1 = NDIG + 1

!             If MA is less than one in magnitude, return zero.

      IF (MWK(START(MA)+2) <= 0) THEN
          DO J = 1, N1
             MWK(START(MB)+J+1) = 0
          ENDDO
          GO TO 110
      ENDIF

!             If the radix point is off the right end of MA then MA is already an integer.
!             Return MA.

      IF (MWK(START(MA)+2) >= NDIG) THEN
          DO J = 1, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          GO TO 110
      ENDIF

!             Here MA has both integer and fraction parts.  Replace the digits right of the
!             radix point by zeros.

      KA = INT(MWK(START(MA)+2)) + 2
      KB = KA - 1
      DO J = 1, KB
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO

      DO J = KA, N1
         MWK(START(MB)+J+1) = 0
      ENDDO

  110 IF (KACCSW == 1) THEN
          MACMAX = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MACMAX)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF
      MWK(START(MB)) = MWK(START(MA))
      IF (MWK(START(MB)+3) == 0) MWK(START(MB)) = 1
      IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMINT

      SUBROUTINE FMIPWR(MA,IVAL,MB)

!  MB = MA ** IVAL

!  This routine performs the trace printing for integer power.  FMIPWR2 is used to do
!  the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMIPWR'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)

          CALL FMIPWR2(MA,IVAL,MB)

          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMIPWR2(MA,IVAL,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIPWR

      SUBROUTINE FMIPWR2(MA,IVAL,MB)

!  MB = MA ** IVAL

!  Raise an FM number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * LOG2(IVAL) multiplications.
!  MA may be negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MACMAX
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JSIGN,K,KL,KR_RETRY,KWRNSV,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. (IVAL <= 0 .AND. MWK(START(MA)+3) == 0)) THEN
          KFLAG = -4
          IF (IVAL <= 0 .AND. MWK(START(MA)+3) == 0) THEN
              NAMEST(NCALL) = 'FMIPWR'
              CALL FMWARN
          ENDIF
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(1,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          KWRNSV = KWARN
          KWARN = 0
          IF (IVAL == 1) THEN
              CALL FMEQ(MA,MB)
          ELSE
              CALL FMIM(1,MXY(1))
              CALL FMDIV2(MXY(1),MA,MB)
          ENDIF
          KWARN = KWRNSV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          JSIGN = 1
          IF (MWK(START(MA)) < 0) JSIGN = -1
          CALL FMIM(0,MB)
          IF (IVAL > 0) THEN
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPOV
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -5
          ELSE
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPUN
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -6
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          JSIGN = 1
          IF (MWK(START(MA)) < 0) JSIGN = -1
          CALL FMIM(0,MB)
          IF (IVAL > 0) THEN
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPUN
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -6
          ELSE
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPOV
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -5
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KR_RETRY = 0

!             Increase the working precision.

      NDSAVE = NDIG
  110 IF (NCALL == 1) THEN
          XVAL = ABS(IVAL)
          K = INT((5.0*REAL(DLOGTN) + LOG(XVAL))/ALOGMB + NGRD52 - 1)
          NDIG = MAX(NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              NDIG = MAX(NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = ABS(IVAL)
          IF (XVAL > 10.0 .OR. REAL(MBASE) <= 999.0) THEN
              K = INT(LOG(XVAL)/ALOGMB + 1.0)
              NDIG = NDIG + K
          ENDIF
      ENDIF

!             Initialize.

      K = ABS(IVAL)
      KWRNSV = KWARN
      KWARN = 0
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Handle small exponents by hand.

      IF (K == 2) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          GO TO 130
      ENDIF
      IF (K == 3) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          CALL FMMPY2_R1(MXY(2),MXY(1))
          GO TO 130
      ENDIF
      IF (K == 4) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          CALL FMSQR2_R1(MXY(2))
          GO TO 130
      ENDIF
      IF (K == 5) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          CALL FMSQR2_R1(MXY(2))
          CALL FMMPY2_R1(MXY(2),MXY(1))
          GO TO 130
      ENDIF

      IF (MOD(K,2) == 0) THEN
          CALL FMIM(1,MXY(2))
      ELSE
          CALL FMEQ(MXY(1),MXY(2))
      ENDIF

!             This is the multiplication loop.

  120 K = K/2
      CALL FMSQR2_R1(MXY(1))
      IF (MOD(K,2) == 1) CALL FMMPY2_R2(MXY(1),MXY(2))
      IF (K > 1) GO TO 120

!             Invert if the exponent is negative.

  130 IF (IVAL < 0) THEN
          CALL FMIM(1,MXY(1))
          CALL FMDIV2_R2(MXY(1),MXY(2))
      ENDIF
      KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result and return.

      CALL FMEQU(MXY(2),MB,NDIG,NDSAVE)
      NDIG = NDSAVE
      IF (KACCSW == 1) THEN
          MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MWK(START(MB)+1),MACCA,MACMAX)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF
      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMIPWR'
          CALL FMWARN
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIPWR2

      SUBROUTINE FMLG10(MA,MB)

!  MB = LOG10(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR('FMLG10   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMLG10'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

      IF (MWK(START(MA)+2) == 0 .OR. MWK(START(MA)+2) == 1) THEN
          X = REAL(MBASE)
          X = X**(INT(MWK(START(MA)+2))-1)*(REAL(MWK(START(MA)+3))+REAL(MWK(START(MA)+4))/X)
      ELSE
          X = 2.0
      ENDIF
      IF (X > 0.9 .AND. X < 1.1) NDIG = NDIG + 1

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      CALL FMLN(MXY(2),MXY(3))
      IF (MBASE /= MBSLI .OR. NDIG > NDIGLI) THEN
          CALL FMLNI(10,MXY(1))
      ELSE
          CALL FMADD(MLN2,MLN5,MXY(1))
      ENDIF
      CALL FMDIV(MXY(3),MXY(1),MXY(2))

!             Round the result and return.

      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(2))+3))+1))/0.69315)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLG10

      SUBROUTINE FMLN(MA,MB)

!  MB = LOG(MA)     (Natural logarithm)

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: Y
      INTEGER :: MA,MB
      INTEGER :: JEXP(8,4),KEXP(4),NSTACK(49)
      REAL (KIND(1.0D0)) :: MA1,MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,XV(8)
      INTEGER :: IEXTRA,IVAL,J,J2,K,K2,K2EXP,KASAVE,KE1,KL,KM1,KR_RETRY,KOVUN,KRESLT,KSCALE,KST,  &
                 KWRNSV,L,LAST,M,N1,N3,NDSAV1,NDSAVE,NDSV,NMETHD,NTERM
      REAL :: TJ,X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR('FMLN     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMLN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MA1 = MWK(START(MA)+2)
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)

!             Check to see if the argument is a small integer.  If so use FMLNI.

      KM1 = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(5),IVAL)
      KWARN = KWRNSV
      IF (KFLAG == 0 .AND. IVAL < MXBASE) THEN
          CALL FMLNI(IVAL,MXY(6))
          GO TO 180
      ENDIF

!             See if the argument can be scaled to a small integer.

      N3 = NDIG + 3
      N1 = NDIG + 1
      DO J = 2, N1
         IF (MWK(START(MXY(5))+N3-J+1) /= 0) THEN
             LAST = N3 - J - 1
             GO TO 120
         ENDIF
      ENDDO

  120 KSCALE = INT(MA1) - LAST
      MWK(START(MXY(5))+2) = LAST
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(5),IVAL)
      KWARN = KWRNSV
      IF (KFLAG == 0 .AND. IVAL < MXBASE) THEN
          CALL FMLNI(IVAL,MXY(4))
          IF (IVAL == 1) KM1 = 1
          K2EXP = 0
          GO TO 170
      ENDIF

      NMETHD = 1
      IF (NDIG*DLOGMB/DLOGTN > 110000) NMETHD = 2
      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 160

!             Method 1.  Convert MA to a value x close to 1, then use the Taylor series:
!                        Ln(x) = 2*( t + t^3/3 + t^5/5 + ...), where t = (x-1)/(x+1).

!             The argument will be moved closer to 1 by removing the base mbase exponent, and then
!             multiplying by powers of 2, 3, 5, 7 before the series is summed.  The series will be
!             added as J2 concurrent series.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),Y)
      KE1 = 0
      IF (Y*MBASE < 1 + 1.0D-7) THEN
          Y = Y * MBASE
          MWK(START(MXY(2))+2) = 1
          KE1 = 1
      ENDIF
      JEXP(1,1:4) = (/    1,   1,  -1,   0 /)
      JEXP(2,1:4) = (/    2,   2,  -1,  -1 /)
      JEXP(3,1:4) = (/    6,   0,  -5,   2 /)
      JEXP(4,1:4) = (/   -5,  -1,  -2,   4 /)
      JEXP(5,1:4) = (/    3, -13,  10,  -2 /)
      JEXP(6,1:4) = (/   51, -13,  -1, -10 /)
      JEXP(7,1:4) = (/    9, -28,  37, -18 /)
      JEXP(8,1:4) = (/ -193,  -6,   5,  68 /)
      KEXP(1:4) = 0
      XV(1:8) = (/ 1.2000000000000000D0, 1.0285714285714286D0, 1.0035200000000000D0,  &
                   1.0004166666666667D0, 1.0000406160495965D0, 1.0000070529094230D0,  &
                   1.0000006193987026D0, 1.0000001178537107D0  /)
      DO
         IF (7*Y <= 1 + 1.0D-7) THEN
             Y = 7*Y
             KEXP(4) = KEXP(4) + 1
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (5*Y <= 1 + 1.0D-7) THEN
          Y = 5*Y
          KEXP(3) = KEXP(3) + 1
      ENDIF
      IF (3*Y <= 1 + 1.0D-7) THEN
          Y = 3*Y
          KEXP(2) = KEXP(2) + 1
      ENDIF
      IF (2*Y <= 1 + 1.0D-7) THEN
          Y = 2*Y
          KEXP(1) = KEXP(1) + 1
      ENDIF
      K2 = 5 + SQRT(NDSAVE*DLOGMB/DLOGTN)/15
      IF (K2 < 5) K2 = 5
      IF (K2 > 8) K2 = 8
      DO J = 1, K2
         K = -LOG(Y)/LOG(XV(J))
         Y = Y * 2.0D0**(K*JEXP(J, 1))
         KEXP(1) = KEXP(1) + K*JEXP(J, 1)
         Y = Y * 3.0D0**(K*JEXP(J, 2))
         KEXP(2) = KEXP(2) + K*JEXP(J, 2)
         Y = Y * 5.0D0**(K*JEXP(J, 3))
         KEXP(3) = KEXP(3) + K*JEXP(J, 3)
         Y = Y * 7.0D0**(K*JEXP(J, 4))
         KEXP(4) = KEXP(4) + K*JEXP(J, 4)
      ENDDO
      CALL FMI2M(1,MXY(3))
      IF (KEXP(1) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),2,KEXP(1))
      ELSE IF (KEXP(1) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),2,-KEXP(1))
      ENDIF
      IF (KEXP(2) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),3,KEXP(2))
      ELSE IF (KEXP(2) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),3,-KEXP(2))
      ENDIF
      IF (KEXP(3) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),5,KEXP(3))
      ELSE IF (KEXP(3) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),5,-KEXP(3))
      ENDIF
      IF (KEXP(4) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),7,KEXP(4))
      ELSE IF (KEXP(4) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),7,-KEXP(4))
      ENDIF
      IF (KEXP(1) < 0 .OR. KEXP(2) < 0 .OR. KEXP(3) < 0 .OR. KEXP(4) < 0) THEN
          CALL FMDIV_R1(MXY(2),MXY(3))
      ENDIF
      CALL FMI2M(1,MXY(3))
      CALL FMSUB(MXY(2),MXY(3),MXY(4))
      CALL FMADD(MXY(2),MXY(3),MXY(5))
      CALL FMDIV(MXY(4),MXY(5),MXY(1))

      TJ = 1.25D0 + (NDSAVE*DLOGMB/DLOGTN)**0.6D0/18
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMI2M(1,MXY(2))
      NTERM = 1
      DO J = 1, J2
         CALL FMCSDIVI(MXY(2),NTERM,MJSUMS(J))
         NTERM = NTERM + 2
      ENDDO
      CALL FMIPWR(MXY(1),2*J2,MXY(3))

  130 IF (NTERM > 2*J2+1) THEN
          CALL FMCSMPY_R1(MXY(2),MXY(3))
      ELSE
          CALL FMEQ(MXY(3),MXY(2))
      ENDIF
      DO J = 1, J2
         CALL FMCSDIVI(MXY(2),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMSQR(MXY(1),MXY(4))
      CALL FMEQ(MJSUMS(J2),MXY(3))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(4))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
      ENDDO
      CALL FMMPY(MXY(3),MXY(1),MXY(6))
      CALL FMMPYI_R1(MXY(6),2)
      K = MWK(START(MA)+2) - KE1
      J = NDIG
      NDIG = NDIG + NGRD21
      CALL FMEQU_R1(MXY(6),J,NDIG)
      IF (K /= 0) THEN
          IF (NDIGLB >= NDIG .AND. MBASE == MBSLB) THEN
              CALL FMMPYI(MLBSAV,K,MXY(5))
          ELSE
              CALL FMLNI(INT(MBASE),MLBSAV)
              MBSLB = MBASE
              NDIGLB = NDIG
              CALL FMMPYI(MLBSAV,K,MXY(5))
          ENDIF
          CALL FMADD_R1(MXY(6),MXY(5))
      ENDIF
      IF (NDIGLI < NDIG .OR. MBASE /= MBSLI) THEN
          CALL FMLNI(210,MXY(2))
      ENDIF
      IF (KEXP(1) /= 0) THEN
          CALL FMCSMPYI(MLN2,KEXP(1),MXY(3))
          CALL FMSUB_R1(MXY(6),MXY(3))
      ENDIF
      IF (KEXP(2) /= 0) THEN
          CALL FMCSMPYI(MLN3,KEXP(2),MXY(3))
          CALL FMSUB_R1(MXY(6),MXY(3))
      ENDIF
      IF (KEXP(3) /= 0) THEN
          CALL FMCSMPYI(MLN5,KEXP(3),MXY(3))
          CALL FMSUB_R1(MXY(6),MXY(3))
      ENDIF
      IF (KEXP(4) /= 0) THEN
          CALL FMCSMPYI(MLN7,KEXP(4),MXY(3))
          CALL FMSUB_R1(MXY(6),MXY(3))
      ENDIF
      GO TO 180

!             Method 2.  Use AGM iteration.

  150 CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(1))+2) = 0
      CALL FMM2DP(MXY(1),Y)
      M = MAX(1,INT((NDIG*DLOGMB/36 - LOG(Y))/DLOGTW + 1))
      CALL FMCSMPYIN_R1(MXY(1),2,M)
      CALL FMI2M(1,MXY(2))
      CALL FMDIV(MXY(2),MXY(1),MXY(4))
      CALL FMEQ(MXY(4),MXY(2))
      CALL FMSQR(MXY(2),MXY(5))
      CALL FMSQR(MXY(5),MXY(3))
      CALL FMSQR(MXY(3),MXY(5))
      CALL FMMPY(MXY(4),MXY(5),MXY(6))
      CALL FMADD_R1(MXY(2),MXY(6))
      CALL FMSQR_R1(MXY(5))
      CALL FMADD_R1(MXY(3),MXY(5))
      CALL FMMPY_R1(MXY(5),MXY(6))
      CALL FMADD_R1(MXY(2),MXY(5))
      CALL FMMPYI_R1(MXY(2),2)
      CALL FMMPYI_R1(MXY(3),2)
      CALL FMI2M(1,MXY(5))
      CALL FMADD_R1(MXY(3),MXY(5))
      CALL FMMPY(MXY(2),MXY(3),MXY(5))
      CALL FMSQR_R1(MXY(2))
      CALL FMSQR_R1(MXY(3))
      CALL FMADD(MXY(2),MXY(3),MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(2))
      CALL FMEQ(MXY(5),MXY(3))
      DO
         CALL FMSUB(MXY(3),MXY(2),MXY(4))
         IF (MWK(START(MXY(4))+3) == 0 .OR.  &
             MWK(START(MXY(4))+2) - MAX(MWK(START(MXY(2))+2),MWK(START(MXY(3))+2)) <= -NDIG+1) EXIT
         CALL FMDIVI_R1(MXY(4),2)
         CALL FMMPY(MXY(2),MXY(3),MXY(5))
         CALL FMSQRT(MXY(5),MXY(3))
         CALL FMADD_R1(MXY(2),MXY(4))
      ENDDO

      CALL FMPI(MXY(1))
      CALL FMMPYI_R1(MXY(2),4)
      CALL FMDIV_R1(MXY(1),MXY(2))
      IF (NDIGLI >= NDIG .AND. MBASE == MBSLI) THEN
          CALL FMMPYI(MLN2,M,MXY(3))
      ELSE
          CALL FMLNI(2,MXY(2))
          CALL FMMPYI(MXY(2),M,MXY(3))
      ENDIF
      CALL FMSUB(MXY(1),MXY(3),MXY(6))
      K = MWK(START(MA)+2)
      IF (K /= 0) THEN
          IF (NDIGLB >= NDIG .AND. MBASE == MBSLB) THEN
              CALL FMMPYI(MLBSAV,K,MXY(5))
          ELSE
              CALL FMLNI(INT(MBASE),MLBSAV)
              MBSLB = MBASE
              NDIGLB = NDIG
              CALL FMMPYI(MLBSAV,K,MXY(5))
          ENDIF
          CALL FMADD_R1(MXY(6),MXY(5))
      ENDIF
      GO TO 180

!             Method 3.  Use Newton iteration.

  160 MA1 = MWK(START(MA)+2)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)

!             Compute IEXTRA, the number of extra digits required.

      CALL FMI2M(1,MXY(4))
      CALL FMSUB_R1(MXY(4),MXY(5))
      IF (MWK(START(MA)+2) == 0 .OR. MWK(START(MA)+2) == 1) THEN
          X = REAL(MBASE)
          X = X**(INT(MWK(START(MA)+2))-1)*(REAL(MWK(START(MA)+3))+REAL(MWK(START(MA)+4))/X)
      ELSE
          X = 2.0
      ENDIF
      IEXTRA = MAX(0-INT(MWK(START(MXY(4))+2)),0)
      IF (X > 0.9 .AND. X < 1.1) IEXTRA = IEXTRA + 1
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(5),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Scale the argument to lie between e/2 and e to speed up the calls to FMEXP.

      MWK(START(MXY(5))+2) = 1
      KSCALE = INT(MA1) - 1
      CALL FMM2DP(MXY(5),Y)
      K2EXP = INT(LOG(2.0*REAL(Y)/2.71828)/0.693147)
      IF (Y < 1.359141) THEN
          K2EXP = -1
          CALL FMMPYI_R1(MXY(5),2)
          Y = 2.0D0*Y
      ELSE
          K2 = 2**K2EXP
          CALL FMDIVI_R1(MXY(5),K2)
          Y = Y/K2
      ENDIF

!             Generate the initial approximation.

      CALL FMI2M(0,MXY(2))
      CALL FMI2M(0,MXY(6))
      Y = LOG(Y)
      CALL FMDPM(Y,MXY(4))
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMEXP(MXY(4),MXY(6))
         CALL FMSUB(MXY(5),MXY(6),MXY(2))
         CALL FMDIV_R2(MXY(2),MXY(6))
         CALL FMADD_R1(MXY(4),MXY(6))
      ENDDO
      MWK(START(MXY(4))+1) = NINT(NDIG*ALOGM2)

!             Compute LN(MBASE**KSCALE).

  170 IF ((MBSLB /= MBASE .OR. NDIGLB < NDIG) .AND. KSCALE /= 0) THEN
          NDSV = NDIG
          NDIG = NDIG + 2 + NDIG/100
          IF (MLBSAV > 0) THEN
              IF (SIZE_OF(MLBSAV) < NDIG+3) THEN
                  L = -3
                  CALL FMDEFINE(L)
                  TEMPV(MLBSAV) = -6
                  TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                  IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                      N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                      FMTEMP6(N_FMTEMP6) = MLBSAV
                  ELSE
                      NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                      FMTEMP6(NMAX_FMTEMP6) = MLBSAV
                  ENDIF
                  MLBSAV = L
              ENDIF
          ENDIF
          CALL FMLNI(INT(MBASE),MLBSAV)
          MBSLB = MBASE
          NDIGLB = NDIG
          IF (ABS(MWK(START(MLBSAV)+2)) > 10) NDIGLB = 0
          NDIG = NDSV
      ENDIF

      IF (KSCALE /= 0 .AND. KM1 == 0) THEN
          CALL FMMPYI(MLBSAV,KSCALE,MXY(6))
          CALL FMADD_R2(MXY(4),MXY(6))
      ELSE IF (KSCALE /= 0 .AND. KM1 == 1) THEN
          CALL FMMPYI(MLBSAV,KSCALE,MXY(6))
      ELSE IF (KSCALE == 0 .AND. KM1 == 0) THEN
          CALL FMEQ(MXY(4),MXY(6))
      ELSE IF (KSCALE == 0 .AND. KM1 == 1) THEN
          CALL FMI2M(0,MXY(6))
      ENDIF

      IF (K2EXP /= 0) THEN
          IF (MBASE /= MBSLI .OR. NDIG > NDIGLI) THEN
              CALL FMLNI(2,MXY(4))
          ENDIF
          CALL FMMPYI(MLN2,K2EXP,MXY(4))
          CALL FMADD_R1(MXY(6),MXY(4))
      ENDIF

!             Round the result and return.

  180 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KFLAG == 1) KFLAG = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLN

      SUBROUTINE FMLNI(IVAL,MA)

!  MA = LOG(IVAL)

!  Compute the natural logarithm of an integer IVAL.

!  If IVAL has only powers of 2, 3, 5, and 7 in its factorization then FMLNI is faster than FMLN.
!  Otherwise, if IVAL >= MXBASE (i.e., IVAL does not fit in 1/2 word) then FMLN is usually faster.

!  Use FMLN instead of FMLNI if 10*IVAL would cause integer overflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      CHARACTER(155) :: STRING
      INTEGER :: INT2,J,J2,J3,J5,J7,JTEMP2,JTEMP3,JTEMP5,JTEMP7,K,K2,K3,K5,K7,KASAVE,KDELTA,KL,  &
                 KR_RETRY,L,LAST,N,ND,NDMB,NDSAVE,NDSV,NT
      REAL :: XVAL
      DOUBLE PRECISION :: ERR
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMLNI'
      IF (NTRACE /= 0) CALL FMNTRI(2,IVAL,1)

!             Check for special cases.

      IF (IVAL <= 0) THEN
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MA)
          IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 1) THEN
          CALL FMI2M(0,MA)
          IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = NGRD52
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0

!             Find integers K2, K3, K5, and K7 such that
!                NT = 2**K2 * 3**K3 * 5**K5 * 7**K7
!             is a good approximation of IVAL.
!             KDELTA = ABS(IVAL - NT).

      INT2 = IVAL
      IF (IVAL > INTMAX/100) INT2 = IVAL/100
      KDELTA = INT2
      NT = 0
      K2 = 0
      K3 = 0
      K5 = 0
      K7 = 0

!             Start the search loop.

      XVAL = INT2
      LAST = INT(LOG(DBLE(XVAL))/DLOGTW + 2.0D0)

      JTEMP7 = 1
      DO J7 = 1, LAST
         IF (JTEMP7 > INT2 .AND. ABS(JTEMP7-INT2) > KDELTA) GO TO 150

         JTEMP5 = JTEMP7
         DO J5 = 1, LAST
            IF (JTEMP5 > INT2 .AND. ABS(JTEMP5-INT2) > KDELTA) GO TO 140

            JTEMP3 = JTEMP5
            DO J3 = 1, LAST
               IF (JTEMP3 > INT2 .AND. ABS(JTEMP3-INT2) > KDELTA) GO TO 130

               JTEMP2 = JTEMP3
               DO J2 = 1, LAST
                  IF (ABS(JTEMP2-INT2) <= KDELTA) THEN
                      IF (ABS(JTEMP2-INT2) == KDELTA .AND. JTEMP2 < INT2) GO TO 120
                      KDELTA = ABS(JTEMP2-INT2)
                      NT = JTEMP2
                      K2 = J2 - 1
                      K3 = J3 - 1
                      K5 = J5 - 1
                      K7 = J7 - 1
                      IF (KDELTA == 0) GO TO 150
                  ENDIF
                  IF (JTEMP2 > INT2) GO TO 120

                  JTEMP2 = 2*JTEMP2
               ENDDO

  120          JTEMP3 = 3*JTEMP3
            ENDDO

  130       JTEMP5 = 5*JTEMP5
         ENDDO

  140    JTEMP7 = 7*JTEMP7
      ENDDO

!             If IVAL was too close to the integer overflow limit, restore NT to an
!             approximation of IVAL.

  150 IF (INT2 /= IVAL) THEN
          IF (NT <= INT2) THEN
              NT = NT*100
              K2 = K2 + 2
              K5 = K5 + 2
          ELSE IF (NT <= IVAL/98) THEN
              NT = NT*98
              K2 = K2 + 1
              K7 = K7 + 2
          ELSE
              NT = NT*70
              K2 = K2 + 1
              K5 = K5 + 1
              K7 = K7 + 1
          ENDIF
      ENDIF

!             End of the search.
!             Now compute LN(NT) as a linear combination of LN(2), LN(3), LN(5), and LN(7).

      IF (MBASE /= MBSLI .OR. NDIG > NDIGLI) THEN
          NDMB = INT(150.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              IF (MLN2 > 0) THEN
                  IF (SIZE_OF(MLN2) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN2) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN2
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN2
                      ENDIF
                      MLN2 = L
                  ENDIF
              ENDIF
              STRING = '0.693147180559945309417232121458176568075500'//  &
              '13436025525412068000949339362196969471560586332699641'//  &
              '8687542001481020570685733685520235758130557032670751635'
              CALL FMST2M(STRING,MLN2)
              IF (MLN3 > 0) THEN
                  IF (SIZE_OF(MLN3) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN3) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN3
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN3
                      ENDIF
                      MLN3 = L
                  ENDIF
              ENDIF
              STRING = '1.098612288668109691395245236922525704647490'//  &
              '55782274945173469433363749429321860896687361575481373'//  &
              '2088787970029065957865742368004225930519821052801870767'
              CALL FMST2M(STRING,MLN3)
              IF (MLN5 > 0) THEN
                  IF (SIZE_OF(MLN5) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN5) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN5
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN5
                      ENDIF
                      MLN5 = L
                  ENDIF
              ENDIF
              STRING = '1.609437912434100374600759333226187639525601'//  &
              '35426851772191264789147417898770765776463013387809317'//  &
              '9610799966303021715562899724005229324676199633616617464'
              CALL FMST2M(STRING,MLN5)
              IF (MLN7 > 0) THEN
                  IF (SIZE_OF(MLN7) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN7) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN7
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN7
                      ENDIF
                      MLN7 = L
                  ENDIF
              ENDIF
              STRING = '1.945910149055313305105352743443179729637084'//  &
              '72958186118845939014993757986275206926778765849858787'//  &
              '1526993061694205851140911723752257677786843148958095164'
              CALL FMST2M(STRING,MLN7)
              MBSLI = MBASE
              NDIGLI = NDIG
              IF (ABS(MWK(START(MLN2)+2)) > 10 .OR. ABS(MWK(START(MLN3)+2)) > 10 .OR.  &
                  ABS(MWK(START(MLN5)+2)) > 10 .OR. ABS(MWK(START(MLN7)+2)) > 10) NDIGLI = 0
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2 + NDIG/100
              MBSLI = MBASE
              NDIGLI = NDIG
              IF (MLN2 > 0) THEN
                  IF (SIZE_OF(MLN2) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN2) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN2
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN2
                      ENDIF
                      MLN2 = L
                  ENDIF
              ENDIF
              IF (MLN3 > 0) THEN
                  IF (SIZE_OF(MLN3) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN3) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN3
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN3
                      ENDIF
                      MLN3 = L
                  ENDIF
              ENDIF
              IF (MLN5 > 0) THEN
                  IF (SIZE_OF(MLN5) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN5) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN5
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN5
                      ENDIF
                      MLN5 = L
                  ENDIF
              ENDIF
              IF (MLN7 > 0) THEN
                  IF (SIZE_OF(MLN7) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN7) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MLN7
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MLN7
                      ENDIF
                      MLN7 = L
                  ENDIF
              ENDIF

!                 If precision is high, use the binary splitting method.

              IF (NDIG < 40) THEN

                  CALL FMLNI2(1,126,MLN2)
                  CALL FMLNI2(1,225,MLN3)
                  CALL FMLNI2(1,2401,MLN5)
                  CALL FMLNI2(1,4375,MLN7)

!                    Get Ln(2).

                  CALL FMMPYI_R1(MLN2,-72)
                  CALL FMMPYI(MLN3,-27,MXY(3))
                  CALL FMADD_R1(MLN2,MXY(3))
                  CALL FMMPYI(MLN5,19,MXY(3))
                  CALL FMADD_R1(MLN2,MXY(3))
                  CALL FMMPYI(MLN7,-31,MXY(3))
                  CALL FMADD_R1(MLN2,MXY(3))

!                    Get Ln(3).

                  CALL FMMPYI_R1(MLN3,-3)
                  CALL FMMPYI(MLN2,19,MXY(3))
                  CALL FMADD_R1(MLN3,MXY(3))
                  CALL FMSUB_R1(MLN3,MLN5)
                  CALL FMADD_R1(MLN3,MLN7)
                  CALL FMDIVI_R1(MLN3,12)

!                    Get Ln(5).

                  CALL FMSUB_R1(MLN5,MLN2)
                  CALL FMMPYI(MLN3,27,MXY(3))
                  CALL FMADD_R1(MLN5,MXY(3))
                  CALL FMMPYI(MLN7,-4,MXY(3))
                  CALL FMADD_R1(MLN5,MXY(3))
                  CALL FMDIVI_R1(MLN5,18)

!                    Get Ln(7).

                  CALL FMSUB_R2(MLN2,MLN7)
                  CALL FMMPYI(MLN3,7,MXY(3))
                  CALL FMADD_R1(MLN7,MXY(3))
                  CALL FMMPYI(MLN5,-4,MXY(3))
                  CALL FMADD_R1(MLN7,MXY(3))
              ELSE
                  CALL FMLNI3
              ENDIF
          ENDIF
          MWK(START(MLN2)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MLN3)+1) = MWK(START(MLN2)+1)
          MWK(START(MLN5)+1) = MWK(START(MLN2)+1)
          MWK(START(MLN7)+1) = MWK(START(MLN2)+1)
          IF (ABS(MWK(START(MLN2)+2)) > 10 .OR. ABS(MWK(START(MLN3)+2)) > 10 .OR.  &
              ABS(MWK(START(MLN5)+2)) > 10 .OR. ABS(MWK(START(MLN7)+2)) > 10) NDIGLI = 0
          NDIG = NDSV
      ENDIF

!             If NT /= IVAL then the final step is to compute LN(IVAL/NT) and then use
!             LN(IVAL) = LN(IVAL/NT) + LN(NT).

      IF (NT /= IVAL) THEN
          ND = NT - IVAL
          IF (NDIG < 40) THEN
              CALL FMLNI2(ND,NT,MXY(3))
          ELSE
              IF (IVAL == NT-1) THEN
                  N = 2*IVAL + 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),-2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE IF (IVAL == NT+1) THEN
                  N = 2*IVAL - 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE IF (IVAL == NT-2) THEN
                  N = IVAL + 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),-2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE IF (IVAL == NT+2) THEN
                  N = IVAL - 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE
                  CALL FMLNI4(IVAL,NT,MXY(3))
              ENDIF
          ENDIF
      ENDIF

      CALL FMMPYI(MLN2,K2,MXY(2))
      CALL FMMPYI(MLN3,K3,MXY(1))
      CALL FMADD_R1(MXY(2),MXY(1))
      CALL FMMPYI(MLN5,K5,MXY(1))
      CALL FMADD_R1(MXY(2),MXY(1))
      CALL FMMPYI(MLN7,K7,MXY(1))
      IF (NT /= IVAL) CALL FMADD_R1(MXY(2),MXY(3))
      CALL FMADD(MXY(2),MXY(1),MXY(3))

!             Round and move the result to MA.

      KACCSW = KASAVE

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEQU(MXY(3),MA,NDIG,NDSAVE)
      NDIG = NDSAVE
      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI

      SUBROUTINE FMLNI2(INT1,INT2,MA)

!  MA = LN(1 - INT1/INT2)

!  Taylor series for computing the logarithm of a rational number near 1.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: INT1,INT2
      INTEGER :: MA
      INTEGER :: J,NDSAVE
      INTENT (IN) :: INT1,INT2
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMI2M(INT1,MXY(2))
      CALL FMDIVI_R1(MXY(2),INT2)
      CALL FMEQ(MXY(2),MA)
      NDSAVE = NDIG
      J = 1

  110 J = J + 1
      IF (INT1 /= 1) CALL FMMPYI_R1(MXY(2),INT1)
      CALL FMDIVI_R1(MXY(2),INT2)
      CALL FMDIVI(MXY(2),J,MXY(1))
      NDIG = NDSAVE
      CALL FMADD_R1(MA,MXY(1))
      NDIG = NDSAVE - INT(MWK(START(MA)+2)-MWK(START(MXY(1))+2))
      IF (NDIG < NGRD22) NDIG = NGRD22
      IF (KFLAG /= 1) GO TO 110

      NDIG = NDSAVE
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -MWK(START(MA))
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI2

      SUBROUTINE FMLNI3

!  Binary splitting version.  Faster for large NDIG.

!  Compute the four saved constants Ln(2), Ln(3), Ln(5), Ln(7).

      USE FMVALS
      IMPLICIT NONE

      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: K,KASAVE,NDSAVE,N
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Determine K, the number of terms to sum in the series for
!             Ln( (N+1) / (N-1) ) = (2/N)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = N**2.
!             Four calls are made:  N = 251, 449, 4801, 8549.

      N = 251
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN2)
      NUMBER_USED = NUMBER_USED_SAVE
      MXY = -2

      N = 449
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN3)
      NUMBER_USED = NUMBER_USED_SAVE
      MXY = -2

      N = 4801
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN5)
      NUMBER_USED = NUMBER_USED_SAVE
      MXY = -2

      N = 8749
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN7)

!             Get Ln(2).

      CALL FMMPYI_R1(MLN2,72)
      CALL FMMPYI(MLN3,27,MXY(3))
      CALL FMADD_R1(MLN2,MXY(3))
      CALL FMMPYI(MLN5,-19,MXY(3))
      CALL FMADD_R1(MLN2,MXY(3))
      CALL FMMPYI(MLN7,31,MXY(3))
      CALL FMADD_R1(MLN2,MXY(3))

!             Get Ln(3).

      CALL FMMPYI_R1(MLN3,3)
      CALL FMMPYI(MLN2,19,MXY(3))
      CALL FMADD_R1(MLN3,MXY(3))
      CALL FMADD_R1(MLN3,MLN5)
      CALL FMSUB_R1(MLN3,MLN7)
      CALL FMDIVI_R1(MLN3,12)

!             Get Ln(5).

      CALL FMADD_R1(MLN5,MLN2)
      CALL FMMPYI(MLN3,27,MXY(3))
      CALL FMSUB_R2(MXY(3),MLN5)
      CALL FMMPYI(MLN7,4,MXY(3))
      CALL FMADD_R1(MLN5,MXY(3))
      CALL FMDIVI_R1(MLN5,18)

!             Get Ln(7).

      CALL FMADD_R2(MLN2,MLN7)
      CALL FMMPYI(MLN3,7,MXY(3))
      CALL FMADD_R1(MLN7,MXY(3))
      CALL FMMPYI(MLN5,-4,MXY(3))
      CALL FMADD_R1(MLN7,MXY(3))

      MXEXP = MXSAVE
      NDIG = NDSAVE
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI3

      RECURSIVE SUBROUTINE FMLNI3_QBT(A,B,N,MQ,MB,MT)

!  This routine does the binary splitting for computing the constant Ln( (N+1) / (N-1) ).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MQ,MB,MT
      INTEGER :: A,B,N
      INTENT (IN) :: A,B,N
      INTENT (INOUT) :: MQ,MB,MT
      INTEGER :: MXY(6),NUMBER_USED_SAVE,J,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(N)**2) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MQ <= 0) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ENDIF
      J = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -          &
                      ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 +  &
                      (DB-DA+1)*LOG(2.0D0) ) / DLOGMB + 7
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = RESULT_SIZE + J
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 6) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)
          CALL IMI2M(N,MXY(2))
          CALL IMSQR(MXY(2),MXY(1))
          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MXY(1),MXY(2),MQ)

          CALL IMI2M(1,MB)
          DO J = A+1, B, 2
             CALL IMMPYI(MB,2*J-1,MXY(1))
             CALL IMMPYI(MXY(1),2*J+1,MB)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MB,2*B+1,MXY(1))
              CALL IMEQ(MXY(1),MB)
          ENDIF

!             MT is the sum
!             MXY(2) is (N*N)^(J+1)

          CALL IMDIVI(MB,2*B+1,MXY(1))
          CALL IMMPYI(MXY(1),N,MXY(2))
          CALL IMMPYI(MXY(2),N,MT)
          CALL IMI2M(N,MXY(1))
          CALL IMSQR(MXY(1),MXY(2))
          DO J = 1, B-A
             CALL IMDIVI(MB,2*B+1-2*J,MXY(3))
             CALL IMMPYI(MXY(2),N,MXY(4))
             CALL IMMPYI(MXY(4),N,MXY(2))
             CALL IMMPY(MXY(2),MXY(3),MXY(4))
             CALL IMADD(MT,MXY(4),MXY(5))
             CALL IMEQ(MXY(5),MT)
          ENDDO
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMLNI3_QBT(A,M-1,N,MXY(1),MXY(2),MXY(3))
      CALL FMLNI3_QBT(M,B,N,MXY(4),MXY(5),MXY(6))
      CALL IMMPY(MXY(1),MXY(4),MQ)
      CALL IMMPY(MXY(2),MXY(5),MB)
      CALL IMMPY(MXY(5),MXY(4),MT)
      CALL IMMPY(MXY(3),MT,MXY(1))
      CALL IMMPY(MXY(2),MXY(6),MXY(3))
      CALL IMADD(MXY(1),MXY(3),MT)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI3_QBT

      SUBROUTINE FMLNI4(IVAL,NT,MA)

!  Binary splitting version.  Faster for large NDIG.

!  MA = Ln(IVAL/NT).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL,NT
      INTENT (IN) :: IVAL,NT
      INTENT (INOUT) :: MA
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: A,B,K,KASAVE,NDSAVE
      INTEGER :: MXY(7),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Determine K, the number of terms to sum in the series for
!             Ln( (B+A) / (B-A) ) = (2*A/B)*( 1 + 1/(3*d) + 1/(5*d^2) + ...), with d = (B/A)^2.

      A = ABS(IVAL - NT)
      B = IVAL + NT
      CALL FMGCDI(A,B)
      IF (IVAL-NT < 0) A = -A
      K = NDIG*DLOGMB/LOG(DBLE(B)**2/DBLE(A)**2) + 10
      CALL FMLNI4_PQBT(0,K,A,B,MXY(1),MXY(2),MXY(3),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL IMI2FM(MXY(4),MXY(7))
      CALL FMDIV(MXY(7),MXY(6),MXY(2))
      CALL FMDIV(MXY(2),MXY(5),MXY(1))
      CALL FMMPYI(MXY(1),2*A,MXY(2))
      CALL FMDIVI(MXY(2),B,MXY(3))

      CALL FMEQU(MXY(3),MA,NDIG,NDSAVE)
      MXEXP = MXSAVE
      NDIG = NDSAVE
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI4

      RECURSIVE SUBROUTINE FMLNI4_PQBT(A,B,C,D,MP,MQ,MB,MT)

!  This routine does the binary splitting for computing the constant Ln( (B+A) / (B-A) ).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP,MQ,MB,MT
      INTEGER :: A,B,C,D
      INTENT (IN) :: A,B,C,D
      INTENT (INOUT) :: MP,MQ,MB,MT
      INTEGER :: MXY(8),NUMBER_USED_SAVE,J,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(C)**2) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(D)**2) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MQ <= 0) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ENDIF
      J = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -          &
                      ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 +  &
                      (DB-DA+1)*LOG(2.0D0) ) / DLOGMB + 7
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = RESULT_SIZE + J
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 6) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)
          CALL IMI2M(C,MXY(2))
          CALL IMSQR(MXY(2),MXY(1))
          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MXY(1),MXY(2),MP)

          CALL IMI2M(D,MXY(2))
          CALL IMSQR(MXY(2),MXY(1))
          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MXY(1),MXY(2),MQ)

          CALL IMI2M(1,MB)
          DO J = A+1, B, 2
             CALL IMMPYI(MB,2*J-1,MXY(1))
             CALL IMMPYI(MXY(1),2*J+1,MB)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MB,2*B+1,MXY(1))
              CALL IMEQ(MXY(1),MB)
          ENDIF

          CALL IMI2M(D,MXY(1))
          CALL IMSQR(MXY(1),MXY(2))
          CALL IMI2M(B-A+1,MXY(1))
          CALL IMPWR(MXY(2),MXY(1),MXY(3))

          CALL IMI2M(1,MXY(4))
          CALL IMI2M(0,MT)

          DO J = A, B
             CALL IMDIVI(MB,2*J+1,MXY(1))
             CALL IMMPY(MXY(1),MXY(3),MXY(2))
             CALL IMMPY(MXY(2),MXY(4),MXY(1))
             CALL IMADD(MT,MXY(1),MXY(5))
             CALL IMEQ(MXY(5),MT)
             CALL IMDIVI(MXY(3),D,MXY(5))
             CALL IMDIVI(MXY(5),D,MXY(3))
             CALL IMMPYI(MXY(4),C,MXY(5))
             CALL IMMPYI(MXY(5),C,MXY(4))
          ENDDO
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMLNI4_PQBT(A,M-1,C,D,MXY(1),MXY(2),MXY(3),MXY(4))
      CALL FMLNI4_PQBT(M,B,C,D,MXY(5),MXY(6),MXY(7),MXY(8))

!             MP is not needed in FMLNI4, so this multiplication can be skipped at the top level
!             of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IMMPY(MXY(1),MXY(5),MP)
      ELSE
          CALL IMI2M(0,MP)
      ENDIF
      CALL IMMPY(MXY(2),MXY(6),MQ)
      CALL IMMPY(MXY(3),MXY(7),MB)
      CALL IMMPY(MXY(6),MXY(7),MT)
      CALL IMMPY(MXY(4),MT,MXY(5))
      CALL IMMPY(MXY(1),MXY(3),MT)
      CALL IMMPY(MXY(8),MT,MXY(2))
      CALL IMADD(MXY(5),MXY(2),MT)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMLNI4_PQBT

      SUBROUTINE FMM2DP(MA,X)

!  X = MA

!  Convert an FM number to double precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's double
!  precision number system, change the definition of DPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: X

      INTEGER :: KRESLT
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMM2DP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('FMM2DP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.
!             Set X to some value that the user is likely to recognize as wrong.

          X = DBLE(RUNKNO)
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          IF (NTRACE /= 0) CALL FMNTRR(1,X,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      CALL FMMD(MA,X)

      IF (NTRACE /= 0) CALL FMNTRR(1,X,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE FMM2DP

      SUBROUTINE FMM2I(MA,IVAL)

!  IVAL = MA

!  Convert an FM number to integer.

!  KFLAG =  0 is returned if the conversion is exact.
!        = -4 is returned if MA is larger than INTMAX in magnitude.  IVAL = IUNKNO is returned
!             as an indication that IVAL could not be computed without integer overflow.
!        =  2 is returned if MA is smaller than INTMAX in magnitude but MA is not an integer.
!             The next integer toward zero is returned in IVAL.
!  It is sometimes convenient to call FMM2I to see if an FM number can be represented as a one-word
!  integer, by checking KFLAG upon return.  To avoid an unwanted error message being printed in the
!  KFLAG=-4 case, set KWARN=0 before the call to FMM2I and reset it after the call.

!  This routine performs the trace printing for the conversion.  FMMI is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMM2I'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)

      CALL FMMI(MA,IVAL)

      IF (NTRACE /= 0) CALL FMNTRI(1,IVAL,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE FMM2I

      SUBROUTINE FMM2SP(MA,X)

!  X = MA

!  Convert an FM number to single precision.

!  MA is converted and the result is returned in X.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's single
!  precision number system, change the definition of SPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      REAL :: X

      DOUBLE PRECISION :: Y
      INTEGER :: KRESLT
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMM2SP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('FMM2SP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.
!             Set X to some value that the user is likely to recognize as wrong.

          X = RUNKNO
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          Y = DBLE(X)
          IF (NTRACE /= 0) CALL FMNTRR(1,Y,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      CALL FMMD(MA,Y)
      X = REAL(Y)

      IF (NTRACE /= 0) THEN
          Y = DBLE(X)
          CALL FMNTRR(1,Y,1)
      ENDIF
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE FMM2SP

      SUBROUTINE FMMAX(MA,MB,MC)

!  MC = MAX(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMMAX'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (FMCOMP(MA,'<',MB)) THEN
          CALL FMEQ(MB,MC)
      ELSE
          CALL FMEQ(MA,MC)
      ENDIF

      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMAX

      SUBROUTINE FMMD(MA,X)

!  X = MA

!  Internal routine for conversion to double precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: X

      DOUBLE PRECISION :: AQ(2),XQ(2),YQ(2),Y1(2),Y2(2),XBASE,PMAX,DLOGDP,  &
                          A1,A2,C,C1,C2,C21,C22,Q1,Q2,T,Z1,Z2
      REAL (KIND(1.0D0)) :: MA1,MAS
      INTEGER :: J,K,KWRNSV,NCASE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

!             Check to see if MA is in range for single or double precision.

      IF (MBLOGS /= MBASE) CALL FMCONS
      PMAX = DPMAX
      IF (NCALL > 0) THEN
          IF (NAMEST(NCALL) == 'FMM2SP') PMAX = DBLE(SPMAX)
      ENDIF
      DLOGDP = LOG(PMAX)
      MA1 = MWK(START(MA)+2)
      NCASE = 0
      IF (DBLE(MWK(START(MA)+2)-1)*DLOGMB > DLOGDP) THEN
          KFLAG = -4
          X = DBLE(RUNKNO)
          CALL FMWARN
          RETURN
      ELSE IF (DBLE(MWK(START(MA)+2)+1)*DLOGMB > DLOGDP) THEN
          MA1 = MA1 - 2
          NCASE = 1
      ELSE IF (DBLE(MWK(START(MA)+2)+1)*DLOGMB < -DLOGDP) THEN
          KFLAG = -10
          X = 0.0D0
          CALL FMWARN
          RETURN
      ELSE IF (DBLE(MWK(START(MA)+2)-1)*DLOGMB < -DLOGDP) THEN
          MA1 = MA1 + 2
          NCASE = 2
      ENDIF

!             Try FMMI first so that small integers will be converted quickly.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMMI(MA,J)
      KWARN = KWRNSV
      IF (KFLAG == 0) THEN
          X = J
          RETURN
      ENDIF
      KFLAG = 0

!             General case.
!             In order to get the correctly rounded X, the arithmetic for computing X is done
!             with simulated quadruple-precision using the arrays of length 2.

      MAS = MWK(START(MA))
      XBASE = MBASE
      XQ = (/ 0.0D0 , 0.0D0 /)
      YQ = (/ 1.0D0 , 0.0D0 /)
      C = RADIX(X)**(DIGITS(X) - DIGITS(X)/2) + 1
      K = (LOG(DBLE(RADIX(X)))/DLOGMB)*DIGITS(X) + NGRD52
      DO J = 2, MIN(K+1,NDIG+1)
         Z1 = YQ(1) / XBASE
         T = XBASE*C
         A1 = (XBASE - T) + T
         A2 = XBASE - A1
         T = Z1*C
         C1 = (Z1 - T) + T
         C2 = Z1 - C1
         T = C2*C
         C21 = (C2 - T) + T
         C22 = C2 - C21
         Q1 = XBASE*Z1
         Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
         Z2 = ((((YQ(1)-Q1) - Q2) + YQ(2))) / XBASE
         YQ(1) = Z1 + Z2
         YQ(2) = (Z1-YQ(1)) + Z2
         T = YQ(1)*C
         A1 = (YQ(1) - T) + T
         A2 = YQ(1) - A1
         T = DBLE(MWK(START(MA)+J+1))*C
         C1 = (DBLE(MWK(START(MA)+J+1)) - T) + T
         C2 = DBLE(MWK(START(MA)+J+1)) - C1
         T = C2*C
         C21 = (C2 - T) + T
         C22 = C2 - C21
         Q1 = YQ(1)*DBLE(MWK(START(MA)+J+1))
         Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
         Z2 = YQ(2)*DBLE(MWK(START(MA)+J+1)) + Q2
         AQ(1) = Q1 + Z2
         AQ(2) = (Q1-AQ(1)) + Z2
         Z1 = XQ(1) + AQ(1)
         Q1 = XQ(1) - Z1
         Z2 = (((Q1+AQ(1)) + (XQ(1)-(Q1+Z1))) + XQ(2)) + AQ(2)
         XQ(1) = Z1 + Z2
         XQ(2) = (Z1-XQ(1)) + Z2
      ENDDO

      Y1 = (/ XBASE , 0.0D0 /)
      K = ABS(MA1)
      IF (MOD(K,2) == 0) THEN
          Y2 = (/ 1.0D0 , 0.0D0 /)
      ELSE
          Y2 = (/ XBASE , 0.0D0 /)
      ENDIF

  110 K = K/2
      T = Y1(1)*C
      A1 = (Y1(1) - T) + T
      A2 = Y1(1) - A1
      T = Y1(1)*C
      C1 = (Y1(1) - T) + T
      C2 = Y1(1) - C1
      T = C2*C
      C21 = (C2 - T) + T
      C22 = C2 - C21
      Q1 = Y1(1)*Y1(1)
      Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
      Z2 = ((Y1(1) + Y1(2))*Y1(2) + Y1(2)*Y1(1)) + Q2
      Y1(1) = Q1 + Z2
      Y1(2) = (Q1-Y1(1)) + Z2
      IF (MOD(K,2) == 1) THEN
          T = Y1(1)*C
          A1 = (Y1(1) - T) + T
          A2 = Y1(1) - A1
          T = Y2(1)*C
          C1 = (Y2(1) - T) + T
          C2 = Y2(1) - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = Y1(1)*Y2(1)
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((Y1(1) + Y1(2))*Y2(2) + Y1(2)*Y2(1)) + Q2
          Y2(1) = Q1 + Z2
          Y2(2) = (Q1-Y2(1)) + Z2
      ENDIF
      IF (K > 1) GO TO 110

      IF (MA1 < 0) THEN
          Z1 = XQ(1) / Y2(1)
          T = Y2(1)*C
          A1 = (Y2(1) - T) + T
          A2 = Y2(1) - A1
          T = Z1*C
          C1 = (Z1 - T) + T
          C2 = Z1 - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = Y2(1)*Z1
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((((XQ(1)-Q1) - Q2) + XQ(2)) - Z1*Y2(2)) / (Y2(1) + Y2(2))
          AQ(1) = Z1 + Z2
          AQ(2) = (Z1-AQ(1)) + Z2
      ELSE
          T = XQ(1)*C
          A1 = (XQ(1) - T) + T
          A2 = XQ(1) - A1
          T = Y2(1)*C
          C1 = (Y2(1) - T) + T
          C2 = Y2(1) - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = XQ(1)*Y2(1)
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((XQ(1) + XQ(2))*Y2(2) + XQ(2)*Y2(1)) + Q2
          AQ(1) = Q1 + Z2
          AQ(2) = (Q1-AQ(1)) + Z2
      ENDIF

      X = AQ(1) + AQ(2)

      IF (MAS < 0) X = -X

!             Check the result if it is near overflow or underflow.

      IF (NCASE == 1) THEN
          IF (X <= PMAX/(XBASE*XBASE)) THEN
              X = X*XBASE*XBASE
          ELSE
              KFLAG = -4
              X = DBLE(RUNKNO)
              CALL FMWARN
          ENDIF
      ELSE IF (NCASE == 2) THEN
          IF (X >= (1.0D0/PMAX)*XBASE*XBASE) THEN
              X = X/(XBASE*XBASE)
          ELSE
              KFLAG = -10
              X = 0.0D0
              CALL FMWARN
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMMD

      SUBROUTINE FMMI(MA,IVAL)

!  IVAL = MA.  Internal FM to integer conversion routine.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      INTEGER :: J,KA,KB,LARGE,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      KFLAG = 0
      N1 = NDIG + 1
      LARGE = INT(INTMAX/MBASE)
      IVAL = 0
      IF (MWK(START(MA)+2) <= 0) THEN
          IF (MWK(START(MA)+3) /= 0) KFLAG = 2
          RETURN
      ENDIF

      KB = INT(MWK(START(MA)+2)) + 1
      IVAL = INT(ABS(MWK(START(MA)+3)))
      IF (KB >= 3) THEN
          DO J = 3, KB
             IF (IVAL > LARGE) THEN
                 KFLAG = -4
                 IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
                 IVAL = IUNKNO
                 RETURN
             ENDIF
             IF (J <= N1) THEN
                 IVAL = IVAL*INT(MBASE)
                 IF (IVAL > INTMAX-MWK(START(MA)+J+1)) THEN
                     KFLAG = -4
                     IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
                     IVAL = IUNKNO
                     RETURN
                 ELSE
                     IVAL = IVAL + INT(MWK(START(MA)+J+1))
                 ENDIF
             ELSE
                 IVAL = IVAL*INT(MBASE)
             ENDIF
          ENDDO
      ENDIF

      IF (MWK(START(MA)) < 0) IVAL = -IVAL

!             Check to see if MA is an integer.

      KA = KB + 1
      IF (KA <= N1) THEN
          DO J = KA, N1
             IF (MWK(START(MA)+J+1) /= 0) THEN
                 KFLAG = 2
                 RETURN
             ENDIF
          ENDDO
      ENDIF

      RETURN
      END SUBROUTINE FMMI

      SUBROUTINE FMMIN(MA,MB,MC)

!  MC = MIN(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMMIN'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (FMCOMP(MA,'>',MB)) THEN
          CALL FMEQ(MB,MC)
      ELSE
          CALL FMEQ(MA,MC)
      ENDIF

      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMIN

      SUBROUTINE FMMOD(MA,MB,MC)

!  MC = MA(MOD MB).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MVB,MVC,MVY,MVZ,MXSAVE
      INTEGER :: J,K,KASAVE,KB,KE,KN,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB) THEN
          CALL FMENTR('FMMOD    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMMOD'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KWRNSV = KWARN
      KWARN = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)

      IF (MWK(START(MB)+2) > MWK(START(MA)+2) .AND. MWK(START(MB)+3) /= 0) THEN
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      ELSE

!             Special cases when MB is a small integer.

          CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
          MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MXY(2))) = 1
          MWK(START(MXY(3))) = 1

          CALL FMM2I(MXY(3),KB)
          IF (KFLAG == 0 .AND. KB < MXBASE) THEN
              IF (KB == 1 .OR. KB == -1) THEN
                  IF (MWK(START(MXY(2))+2) >= NDIG) THEN
                      CALL FMI2M(0,MXY(1))
                      GO TO 130
                  ELSE
                      CALL FMINT(MXY(2),MXY(3))
                      CALL FMSUB(MXY(2),MXY(3),MXY(1))
                      IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
                          MWK(START(MXY(1))+3) /= 0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
                      GO TO 130
                  ENDIF
              ELSE IF (MWK(START(MXY(2))+2) == MEXPOV .OR. KB == 0) THEN
                  KFLAG = -4
                  KWARN = KWRNSV
                  KACCSW = KASAVE
                  MXEXP = MXSAVE
                  CALL FMWARN
                  NDIG = NDSAVE
                  CALL FMST2M('UNKNOWN',MC)
                  IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ELSE IF (MWK(START(MXY(2))+2) > NDIG.AND.MOD(INT(MBASE),KB) == 0) THEN
                  CALL FMI2M(0,MXY(1))
                  GO TO 130
              ENDIF
              IF (MWK(START(MXY(2))+2) < NDIG) THEN
                  DO J = INT(MWK(START(MXY(2))+2))+1, NDIG+1
                     IF (MWK(START(MXY(2))+J+1) /= 0) GO TO 120
                  ENDDO
              ENDIF
              KE = MIN(INT(MWK(START(MXY(2))+2)),NDIG)
              MVB = KB
              MVC = MOD(MWK(START(MXY(2))+3),MVB)
              DO J = 3, KE+1
                 MVC = MOD(MVC*MBASE+MWK(START(MXY(2))+J+1),MVB)
              ENDDO
              IF (MVC == 0) THEN
                   CALL FMI2M(0,MXY(1))
                   GO TO 130
              ENDIF
              KN = INT(MWK(START(MXY(2))+2)) - KE
              MVY = MOD(MBASE,MVB)
              MVZ = 1
              IF (MOD(KN,2) == 1) MVZ = MVY

              IF (MVY /= 1) THEN
  110             KN = KN/2
                  MVY = MOD(MVY*MVY,MVB)
                  IF (MOD(KN,2) == 1) MVZ = MOD(MVZ*MVY,MVB)
                  IF (KN > 1) GO TO 110
              ENDIF
              MVZ = MOD(MVZ*MVC,MVB)
              KE = INT(MVZ)
              CALL FMI2M(KE,MXY(1))
              IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
                  MWK(START(MXY(1))+3) /= 0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
              GO TO 130
          ENDIF
          IF (MWK(START(MA)+2)-MWK(START(MB)+2) > 3*10**5) THEN
              KFLAG = -4
              CALL FMWARN
              CALL FMST2M('UNKNOWN',MXY(1))
              GO TO 130
          ENDIF

!             General case.

  120     IF (MWK(START(MA)+3) /= 0) THEN
              NDIG = NDIG + INT(MWK(START(MA)+2)-MWK(START(MB)+2))
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              KFLAG = -9
              IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.   &
                  MWK(START(MB)+3) == 0) KFLAG = -4
              KWARN = KWRNSV
              KACCSW = KASAVE
              MXEXP = MXSAVE
              CALL FMWARN
              NDIG = NDSAVE
              CALL FMST2M('UNKNOWN',MC)
              IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF

          CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
          MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)

          MWK(START(MXY(2))) = 1
          MWK(START(MXY(3))) = 1
          CALL FMDIV(MXY(2),MXY(3),MXY(1))
          CALL FMINT(MXY(1),MXY(4))
          CALL FMMPY_R1(MXY(4),MXY(3))
          CALL FMSUB(MXY(2),MXY(4),MXY(1))

!             Due to rounding, MXY(1) may not be between 0 and MB here.

          NTRSAV = NTRACE
          NTRACE = 0
          IF (FMCOMP(MXY(1),'>=',MXY(3))) THEN
              NTRACE = NTRSAV
              CALL FMSUB_R1(MXY(1),MXY(3))
          ENDIF
          NTRACE = NTRSAV
          IF (MWK(START(MXY(1))) < 0) CALL FMADD_R1(MXY(1),MXY(3))
          IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(1))+3) /=0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      ENDIF

  130 IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(1))+3))+1))/0.69315)
      MWK(START(MXY(1))+1) = MIN(MWK(START(MXY(1))+1),MACCA,MACCB,MACMAX)
      CALL FMEXIT(MXY(1),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMOD

      SUBROUTINE FMMOVE(MW,MA)

!  Move a result from a work area (MW) to MA.

!  If the result has MWK(START(MW)+3)=0, then it is shifted and the exponent adjusted when it is
!  moved to MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MW

      INTEGER :: J,JMA,JMW,N1,N2
      INTENT (IN) :: MW
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MWK(START(MW)+3) /= 0) THEN
          N1 = NDIG + 1

!             Major (Inner Loop)

          JMA = START(MA) + 1
          JMW = START(MW) + 1
          DO J = 1, N1
             MWK(JMA+J) = MWK(JMW+J)
          ENDDO
      ELSE
          N2 = NDIG + 2
          JMA = START(MA)
          JMW = START(MW) + 1
          DO J = 3, N2
             MWK(JMA+J) = MWK(JMW+J)
          ENDDO
          IF (MWK(START(MA)+3) /= 0) THEN
              MWK(START(MA)+2) = MWK(START(MW)+2) - 1
          ELSE
              MWK(START(MA)+2) = 0
          ENDIF
      ENDIF

      MWK(START(MA)) = 1
      IF (ABS(MWK(START(MA)+2)) > MXEXP) CALL FMTRAP(MA)

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMOVE

      SUBROUTINE FMMPY(MA,MB,MC)

!  MC = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPY'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMMPY2(MA,MB,MC)

          CALL FMNTR(1,MC,MC,1,1)
      ELSE
          CALL FMMPY2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY

      SUBROUTINE FMMPY2(MA,MB,MC)

!  Internal multiplication routine.  MC = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMMPY'
              CALL FMRSLT(MA,MB,MC,KRESLT)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+1) = MIN(MACCA,MACCB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = NDIG + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+1
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,NGRDN,KSHIFT)
          IF (MWK(START(MWA)+3) == 0) THEN
              DO J = 3, 1+NDIG+NGRDN
                 MWK(START(MWA)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MWA)+NDIG+NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 1+NDIG+NGRDN, 2, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 1+NDIG+NGRDN, 2, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,NGUARD,KSHIFT)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MC, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MC)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPY'
          CALL FMWARN
      ENDIF

      MWK(START(MC)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
          MWK(START(MC)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MC)+3))+1))/0.69315)
          MWK(START(MC)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MC)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY2

      SUBROUTINE FMMPY_R1(MA,MB)

!  MA = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2_R1 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPY_R1'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMMPY2_R1(MA,MB)

          NAMEST(NCALL) = 'FMMPY_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMMPY2_R1(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY_R1

      SUBROUTINE FMMPY2_R1(MA,MB)

!  Internal multiplication routine.  MA = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMMPY_R1'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MA)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMIM(0,MA)
          MWK(START(MA)+1) = MIN(MACCA,MACCB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = NDIG + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+1
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,NGRDN,KSHIFT)
          IF (MWK(START(MWA)+3) == 0) THEN
              DO J = 3, 1+NDIG+NGRDN
                 MWK(START(MWA)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MWA)+NDIG+NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 1+NDIG+NGRDN, 2, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 1+NDIG+NGRDN, 2, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,NGUARD,KSHIFT)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MA, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPY_R1'
          CALL FMWARN
      ENDIF

      MWK(START(MA)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0)  &
          MWK(START(MA)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MA)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY2_R1

      SUBROUTINE FMMPY_R2(MA,MB)

!  MB = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2_R2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPY_R2'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMMPY2_R2(MA,MB)

          NAMEST(NCALL) = 'FMMPY_R2'
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMMPY2_R2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY_R2

      SUBROUTINE FMMPY2_R2(MA,MB)

!  Internal multiplication routine.  MB = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMMPY_R2'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MB)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMIM(0,MB)
          MWK(START(MB)+1) = MIN(MACCA,MACCB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = NDIG + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+1
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,NGRDN,KSHIFT)
          IF (MWK(START(MWA)+3) == 0) THEN
              DO J = 3, 1+NDIG+NGRDN
                 MWK(START(MWA)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MWA)+NDIG+NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 1+NDIG+NGRDN, 2, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 1+NDIG+NGRDN, 2, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,NGUARD,KSHIFT)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MB, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPY_R2'
          CALL FMWARN
      ENDIF

      MWK(START(MB)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
          MWK(START(MB)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MB)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY2_R2

      SUBROUTINE FMMPY3(MA,MB,NGUARD,KSHIFT)

!  Internal multiplication of MA*MB.  The result is returned in MWA.  Both MA and MB are positive.

!  NGUARD is the number of guard digits that will be used.
!  KSHIFT = 1 is returned if a left shift is pending (i.e., MWK(START(MWA)+3)=0).  The shift will
!             be done in FMMOVE.  KSHIFT = 0 is returned if no shift is pending.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NGUARD,KSHIFT

      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKT,MMAX,MT
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KI,KJ,KL,KNZ,KWA,L,N1,NMETHD,NZDA,NZDB
      REAL :: C
      INTENT (IN) :: MA,MB,NGUARD
      INTENT (INOUT) :: KSHIFT

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)

!             Check for using an FFT-based method if precision is very high.

      C = 900
      IF (NDIG >= C) THEN
          NZDA = 2
          NZDB = NDIG
          DO J = NDIG, 2, -1
             IF (MWK(START(MA)+J+2) /= 0) THEN
                 NZDA = J
                 EXIT
             ENDIF
          ENDDO
          DO J = 2, NDIG
             IF (MWK(START(MB)+J+2) == 0) NZDB = NZDB - 1
          ENDDO
          C = 0.9 * C / LOG(C)
          IF (REAL(NZDA)*NZDB < C*NDIG*LOG(REAL(NDIG))) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPYFFT(MA,MB)
          IF (MWK(START(MWA)+3) == 0) THEN
              KSHIFT = 1
          ELSE
              KSHIFT = 0
          ENDIF
          RETURN
      ENDIF

      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 2, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = J+1, J+KL-1
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

      RETURN
      END SUBROUTINE FMMPY3

      SUBROUTINE FMMPYD(MA,MB,MC,MD,ME)

!  Double multiplication routine.  MD = MA * MB,   ME = MA * MC

!  It is usually slightly faster to do two multiplications that have a common factor with one call.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD,ME

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACCC,MAS,MAXMWA,MBS,MBJ,MBKJ,MBNORM,MBP1,MCJ,MCKJ,MCS,  &
                            MD2B,MKB,MKC,MKT,MMAX,MR,MT,MTEMP
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JMA,JMWA,JMWD,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KSHIFT,KWA,L,N1,NGUARD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD,ME
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MD <= 0) THEN
          CALL FMDEFINE(MD)
      ELSE IF (SIZE_OF(MD) < NDIG+3) THEN
          CALL FMDEFINE(MD)
      ENDIF
      IF (ME <= 0) THEN
          CALL FMDEFINE(ME)
      ELSE IF (SIZE_OF(ME) < NDIG+3) THEN
          CALL FMDEFINE(ME)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      IF (MWD <= 0) THEN
          CALL FMDEFINE(MWD)
      ELSE IF (SIZE_OF(MWD) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWD)
      ENDIF

      NCALL = NCALL + 1
      JRSSAV = JRSIGN
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYD'
          CALL FMNTR(2,MA,MB,2,1)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      MACCC = MWK(START(MC)+1)
      C = 1000
      IF (NDIG >= C .OR.                                                           &
          ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MC)+2)) > MEXPAB .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN .OR.  &
              MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.  &
              MWK(START(MC)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
              MWK(START(MC)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MB,MWD)
          KB = KFLAG
          CALL FMMPY2(MA,MC,ME)
          NCALL = NCALL - 1
          IF (((KFLAG < 0 .OR. KB < 0) .AND. KOVUN == 0) .OR.  &
              ((KFLAG == -4 .OR. KB == -4) .AND. KOVUN == 1)) THEN
              IF (KFLAG == -4 .OR. KB == -4) THEN
                  KFLAG = -4
              ELSE IF (KFLAG == -5 .OR. KB == -5) THEN
                  KFLAG = -5
              ELSE
                  KFLAG = MIN(KFLAG,KB)
              ENDIF
              NAMEST(NCALL) = 'FMMPYD'
              CALL FMWARN
          ENDIF
          CALL FMEQ(MWD,MD)
          GO TO 140
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMIM(0,MD)
          MWK(START(MD)+1) = MIN(MACCA,MACCB)
          CALL FMIM(0,ME)
          MWK(START(ME)+1) = MIN(MACCA,MACCC)
          GO TO 140
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          CALL FMMPY2(MA,MC,ME)
          CALL FMIM(0,MD)
          MWK(START(MD)+1) = MIN(MACCA,MACCB)
          GO TO 140
      ENDIF
      IF (MWK(START(MC)+3) == 0) THEN
          CALL FMMPY2(MA,MB,MD)
          CALL FMIM(0,ME)
          MWK(START(ME)+1) = MIN(MACCA,MACCC)
          GO TO 140
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (MBASE < 10**6) NGUARD = MIN(NGUARD+1,NDIG+2)
      ENDIF
      IF ((MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .OR.  &
           MWK(START(MA)+3)*MWK(START(MC)+3) < MBASE) .AND. NGUARD < 3) NGUARD = 3

!             Save the sign of MA, MB, and MC and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MCS = MWK(START(MC))

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      MWK(START(MWD)+2) = MWK(START(MA)+2) + MWK(START(MC)+2)
      L = NDIG + 1 + NGUARD
      MWK(START(MWA)+L+2) = 0
      MWK(START(MWD)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)
          MCJ = MWK(START(MC)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          MWK(START(MWD)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
             MWK(START(MWD)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          JMWD = START(MWD) + 2
          DO K = 2, N1
             MTEMP = MWK(JMA+K)
             MWK(JMWA+K) = MTEMP*MBJ
             MWK(JMWD+K) = MTEMP*MCJ
          ENDDO
          IF (MBJ > MCJ) THEN
              MAXMWA = MBJ
          ELSE
              MAXMWA = MCJ
          ENDIF
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             MCJ = MWK(START(MC)+J+1)
             IF (MBJ > MCJ) THEN
                 MAXMWA = MAXMWA + MBJ
             ELSE
                 MAXMWA = MAXMWA + MCJ
             ENDIF
             JM1 = J - 1
             KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

             JMA = START(MA) + 1 - JM1
             JMWA = START(MWA) + 1
             JMWD = START(MWD) + 1
             DO K = J+1, J+KL-1
                MTEMP = MWK(JMA+K)
                MWK(JMWA+K) = MWK(JMWA+K) + MTEMP*MBJ
                MWK(JMWD+K) = MWK(JMWD+K) + MTEMP*MCJ
             ENDDO

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                    MKT = INT (MWK(START(MWD)+KB+1)/MBASE)
                    MWK(START(MWD)+KB) = MWK(START(MWD)+KB) + MKT
                    MWK(START(MWD)+KB+1) = MWK(START(MWD)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          JMWD = START(MWD) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
             MKT = INT (MWK(JMWD+KB)/MBASE)
             MWK(JMWD+KB-1) = MWK(JMWD+KB-1) + MKT
             MWK(JMWD+KB) = MWK(JMWD+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
             MWK(START(MWD)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             MCKJ = MWK(START(MC)+KJ+1)
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MKB = 0
             MKC = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MKB
                MKB = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MKB
                MT = MWK(START(MA)+KI-K+1)*MCKJ + MWK(START(MWD)+KWA-K+1) + MKC
                MKC = INT (MT/MBASE)
                MWK(START(MWD)+KWA-K+1) = MT - MBASE*MKC
             ENDDO
             MWK(START(MWA)+KWA-KL) = MKB
             MWK(START(MWD)+KWA-KL) = MKC
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplications are complete.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MB,MD)
              GO TO 120
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MD)

  120 IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWD)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWD)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MC,ME)
              GO TO 130
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWD)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWD)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWD)+KSHIFT+N1+1) = MWK(START(MWD)+KSHIFT+N1+1) + 1
                  MWK(START(MWD)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,ME)

  130 IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYD'
          CALL FMWARN
      ENDIF

      MWK(START(MD)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
          MWK(START(MD)) = -1
      MWK(START(ME)) = 1
      IF (MAS*MCS < 0 .AND. MWK(START(ME)+2) /= MUNKNO .AND. MWK(START(ME)+3) /= 0)  &
          MWK(START(ME)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MD)+3))+1))/0.69315)
          MWK(START(MD)+1) = MIN(MACCA,MACCB,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(ME)+3))+1))/0.69315)
          MWK(START(ME)+1) = MIN(MACCA,MACCC,MD2B)
      ELSE
          MWK(START(MD)+1) = MIN(MACCA,MACCB)
          MWK(START(ME)+1) = MIN(MACCA,MACCC)
      ENDIF

  140 IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MD,MD,1,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(ME,NDIG)
              ELSE
                  CALL FMPRNT(ME)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          IF (TEMPV(ME) == -1) TEMPV(ME) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYD

      SUBROUTINE FMMPYE(MA,MB,MC,MD,ME,MF,MG)

!  Triple multiplication routine.

!      ME = MA * MB,   MF = MA * MC,   MG = MA * MD

!  It is usually slightly faster to do three multiplications that have a common factor with
!  one call.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD,ME,MF,MG

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACCC,MACCD,MAS,MAXJ,MAXMWA,MBS,MBJ,MBKJ,MBNORM,MBP1,  &
                            MCJ,MCKJ,MCS,MD2B,MDJ,MDKJ,MDS,MKB,MKC,MKD,MKT,MMAX,MR,MT,MTEMP
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JMA,JMWA,JMWD,JMWE,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KSHIFT,KWA,L,  &
                 N1,NGUARD
      INTENT (IN) :: MA,MB,MC,MD
      INTENT (INOUT) :: ME,MF,MG
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (ME <= 0) THEN
          CALL FMDEFINE(ME)
      ELSE IF (SIZE_OF(ME) < NDIG+3) THEN
          CALL FMDEFINE(ME)
      ENDIF
      IF (MF <= 0) THEN
          CALL FMDEFINE(MF)
      ELSE IF (SIZE_OF(MF) < NDIG+3) THEN
          CALL FMDEFINE(MF)
      ENDIF
      IF (MG <= 0) THEN
          CALL FMDEFINE(MG)
      ELSE IF (SIZE_OF(MG) < NDIG+3) THEN
          CALL FMDEFINE(MG)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      IF (MWD <= 0) THEN
          CALL FMDEFINE(MWD)
      ELSE IF (SIZE_OF(MWD) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWD)
      ENDIF
      IF (MWE <= 0) THEN
          CALL FMDEFINE(MWE)
      ELSE IF (SIZE_OF(MWE) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWE)
      ENDIF

      NCALL = NCALL + 1
      JRSSAV = JRSIGN
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYE'
          CALL FMNTR(2,MA,MB,2,1)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
                  CALL FMNTRJ(MD,NDIG)
              ELSE
                  CALL FMPRNT(MC)
                  CALL FMPRNT(MD)
              ENDIF
          ENDIF
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      MACCC = MWK(START(MC)+1)
      MACCD = MWK(START(MD)+1)
      C = 1000
      IF (NDIG >= C .OR.                                                           &
          ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MC)+2)) > MEXPAB .OR. ABS(MWK(START(MD)+2)) > MEXPAB .OR.  &
          MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN .OR.  &
              MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.  &
              MWK(START(MC)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPUN .OR.  &
              MWK(START(MD)+2) == MEXPOV .OR. MWK(START(MD)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
              MWK(START(MC)+2) == MUNKNO .OR. MWK(START(MD)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MB,MWD)
          KB = KFLAG
          CALL FMMPY2(MA,MC,MWE)
          KJ = KFLAG
          CALL FMMPY2(MA,MD,MG)
          NCALL = NCALL - 1
          IF (((KFLAG < 0 .OR. KB < 0 .OR. KJ < 0) .AND. KOVUN == 0)  &
              .OR. ((KFLAG == -4 .OR. KB == -4 .OR. KJ == -4) .AND.   &
              KOVUN == 1)) THEN
              IF (KFLAG == -4 .OR. KB == -4 .OR. KJ == -4) THEN
                  KFLAG = -4
              ELSE IF (KFLAG == -5 .OR. KB == -5 .OR. KJ == -5) THEN
                  KFLAG = -5
              ELSE
                  KFLAG = MIN(KFLAG,KB,KJ)
              ENDIF
              NAMEST(NCALL) = 'FMMPYE'
              CALL FMWARN
          ENDIF
          CALL FMEQ(MWD,ME)
          CALL FMEQ(MWE,MF)
          GO TO 150
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMIM(0,ME)
          MWK(START(ME)+1) = MIN(MACCA,MACCB)
          CALL FMIM(0,MF)
          MWK(START(MF)+1) = MIN(MACCA,MACCC)
          CALL FMIM(0,MG)
          MWK(START(MG)+1) = MIN(MACCA,MACCD)
          GO TO 150
      ENDIF
      IF (MWK(START(MB)+3) == 0 .OR. MWK(START(MC)+3) == 0 .OR. MWK(START(MD)+3) == 0) THEN
          CALL FMMPY2(MA,MB,MWD)
          CALL FMMPY2(MA,MC,MWE)
          CALL FMMPY2(MA,MD,MG)
          CALL FMEQ(MWD,ME)
          CALL FMEQ(MWE,MF)
          GO TO 150
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (MBASE < 10**6) NGUARD = MIN(NGUARD+1,NDIG+2)
      ENDIF
      IF ((MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .OR.  &
           MWK(START(MA)+3)*MWK(START(MC)+3) < MBASE .OR.  &
           MWK(START(MA)+3)*MWK(START(MD)+3) < MBASE) .AND. NGUARD < 3) NGUARD = 3

!             Save the signs and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MCS = MWK(START(MC))
      MDS = MWK(START(MD))

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      MWK(START(MWD)+2) = MWK(START(MA)+2) + MWK(START(MC)+2)
      MWK(START(MWE)+2) = MWK(START(MA)+2) + MWK(START(MD)+2)
      L = NDIG + 1 + NGUARD
      MWK(START(MWA)+L+2) = 0
      MWK(START(MWD)+L+2) = 0
      MWK(START(MWE)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)
          MCJ = MWK(START(MC)+3)
          MDJ = MWK(START(MD)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          MWK(START(MWD)+3) = 0
          MWK(START(MWE)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
             MWK(START(MWD)+K+1) = 0
             MWK(START(MWE)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          JMWD = START(MWD) + 2
          JMWE = START(MWE) + 2
          DO K = 2, N1
             MTEMP = MWK(JMA+K)
             MWK(JMWA+K) = MTEMP*MBJ
             MWK(JMWD+K) = MTEMP*MCJ
             MWK(JMWE+K) = MTEMP*MDJ
          ENDDO
          MAXMWA = MBJ
          IF (MCJ > MAXMWA) MAXMWA = MCJ
          IF (MDJ > MAXMWA) MAXMWA = MDJ
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             MCJ = MWK(START(MC)+J+1)
             MDJ = MWK(START(MD)+J+1)
             MAXJ = MBJ
             IF (MCJ > MAXJ) MAXJ = MCJ
             IF (MDJ > MAXJ) MAXJ = MDJ
             MAXMWA = MAXMWA + MAXJ
             JM1 = J - 1
             KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

             JMA = START(MA) + 1 - JM1
             JMWA = START(MWA) + 1
             JMWD = START(MWD) + 1
             JMWE = START(MWE) + 1
             DO K = J+1, J+KL-1
                MTEMP = MWK(JMA+K)
                MWK(JMWA+K) = MWK(JMWA+K) + MTEMP*MBJ
                MWK(JMWD+K) = MWK(JMWD+K) + MTEMP*MCJ
                MWK(JMWE+K) = MWK(JMWE+K) + MTEMP*MDJ
             ENDDO

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                    MKT = INT (MWK(START(MWD)+KB+1)/MBASE)
                    MWK(START(MWD)+KB) = MWK(START(MWD)+KB) + MKT
                    MWK(START(MWD)+KB+1) = MWK(START(MWD)+KB+1) - MKT*MBASE
                    MKT = INT (MWK(START(MWE)+KB+1)/MBASE)
                    MWK(START(MWE)+KB) = MWK(START(MWE)+KB) + MKT
                    MWK(START(MWE)+KB+1) = MWK(START(MWE)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          JMWD = START(MWD) + 1
          JMWE = START(MWE) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
             MKT = INT (MWK(JMWD+KB)/MBASE)
             MWK(JMWD+KB-1) = MWK(JMWD+KB-1) + MKT
             MWK(JMWD+KB) = MWK(JMWD+KB) - MKT*MBASE
             MKT = INT (MWK(JMWE+KB)/MBASE)
             MWK(JMWE+KB-1) = MWK(JMWE+KB-1) + MKT
             MWK(JMWE+KB) = MWK(JMWE+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
             MWK(START(MWD)+J+1) = 0
             MWK(START(MWE)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             MCKJ = MWK(START(MC)+KJ+1)
             MDKJ = MWK(START(MD)+KJ+1)
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MKB = 0
             MKC = 0
             MKD = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MKB
                MKB = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MKB
                MT = MWK(START(MA)+KI-K+1)*MCKJ + MWK(START(MWD)+KWA-K+1) + MKC
                MKC = INT (MT/MBASE)
                MWK(START(MWD)+KWA-K+1) = MT - MBASE*MKC
                MT = MWK(START(MA)+KI-K+1)*MDKJ + MWK(START(MWE)+KWA-K+1) + MKD
                MKD = INT (MT/MBASE)
                MWK(START(MWE)+KWA-K+1) = MT - MBASE*MKD
             ENDDO
             MWK(START(MWA)+KWA-KL) = MKB
             MWK(START(MWD)+KWA-KL) = MKC
             MWK(START(MWE)+KWA-KL) = MKD
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplications are complete.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MB,ME)
              GO TO 120
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,ME)

  120 IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWD)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWD)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MC,MF)
              GO TO 130
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWD)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWD)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWD)+KSHIFT+N1+1) = MWK(START(MWD)+KSHIFT+N1+1) + 1
                  MWK(START(MWD)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,MF)

  130 IF ((MAS > 0 .AND. MDS > 0) .OR. (MAS < 0 .AND. MDS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWE)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWE)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MD,MG)
              GO TO 140
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWE)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWE,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWE)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWE)+KSHIFT+N1+1) = MWK(START(MWE)+KSHIFT+N1+1) + 1
                  MWK(START(MWE)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWE,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWE,MG)

  140 IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYE'
          CALL FMWARN
      ENDIF

      MWK(START(ME)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(ME)+2) /= MUNKNO .AND. MWK(START(ME)+3) /= 0)  &
          MWK(START(ME)) = -1
      MWK(START(MF)) = 1
      IF (MAS*MCS < 0 .AND. MWK(START(MF)+2) /= MUNKNO .AND. MWK(START(MF)+3) /= 0)  &
          MWK(START(MF)) = -1
      MWK(START(MG)) = 1
      IF (MAS*MDS < 0 .AND. MWK(START(MG)+2) /= MUNKNO .AND. MWK(START(MG)+3) /= 0)  &
          MWK(START(MG)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(ME)+3))+1))/0.69315)
          MWK(START(ME)+1) = MIN(MACCA,MACCB,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MF)+3))+1))/0.69315)
          MWK(START(MF)+1) = MIN(MACCA,MACCC,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MG)+3))+1))/0.69315)
          MWK(START(MG)+1) = MIN(MACCA,MACCD,MD2B)
      ELSE
          MWK(START(ME)+1) = MIN(MACCA,MACCB)
          MWK(START(MF)+1) = MIN(MACCA,MACCC)
          MWK(START(MG)+1) = MIN(MACCA,MACCD)
      ENDIF

  150 IF (NTRACE /= 0) THEN
          CALL FMNTR(1,ME,ME,1,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MF,NDIG)
                  CALL FMNTRJ(MG,NDIG)
              ELSE
                  CALL FMPRNT(MF)
                  CALL FMPRNT(MG)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(ME) == -1) TEMPV(ME) = -2
          IF (TEMPV(MF) == -1) TEMPV(MF) = -2
          IF (TEMPV(MG) == -1) TEMPV(MG) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYE

      RECURSIVE SUBROUTINE FMMPYFFT(MA,MB)

!  Internal multiplication routine MA*MB for very high precision.
!  The result is returned in the internal work area MWA.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.

!  Use one of two methods, depending on the base MBASE.  When precision is high enough, the size of
!  the digits being convolved using FFT's must be reduced in order to keep the convolution products
!  from being too big to exactly recover the integer results.  The FFT operation has double
!  precision rounding errors, but the result of the convolution of two lists of integers is really
!  an integer.

!  For example, assume double precision carries 53 bits giving about 16 significant digit accuracy,
!  all the (positive) numbers in the two lists are less than K, and there are N numbers in each
!  list.  Then the convolution is an integer less than N*K*K.  A typical case might have MA and MB
!  in base 10**7 with 50,000 digits for about 350,000 significant digit precision.  This means
!  K = 10**7 and N = 5*10**4, so N*K*K = 5*10**18.  That is too big for this double precision.

!  Method 1:  If the base is a power of a small base ( MBASE = B**L for 2 <= B <= 19 ), then change
!             MA and MB to a base that is a smaller power of B to reduce the size of the individual
!             digits.  Changing to this smaller base is a fast O(N) operation.

!             In the example above, MA and MB could be changed to numbers with about 120,000 digits
!             in base 10**3.  Then N*K*K = 1.2*10**11, so even after losing 2 or 3 digits to
!             rounding in the FFT the results could be reliably rounded to the nearest integer.

!             This is the method used for the default FM power-of-ten base chosen in FMSET.
!             It is faster than method 2.

!  Method 2:  Here a fast change to a smaller base is not available, so each of MA and MB is split
!             into two pieces.  Each piece is a number with the same base and precision as MA and
!             MB have, but has artificially small digits.

!             Suppose the base is near 10**7 but not a power, say MBASE = B = 12345678, and MA or
!             MB is
!                       X = 1234567/B + 2345678/B**2 + ... + 9876543/B**N

!             Let K = SQRT(B) = 3513 be the upper bound on the size of the digits in the two
!             pieces, X1 and X2.  We write X = X1 + K*X2 by defining the digits of X1 to be the
!             digits of X mod K, and the digits of X2 to be the digits of X / K.  That gives

!                       X1 = 1504/B + 2507/B**2 + ... + 1500/B**N
!                       X2 =  351/B +  667/B**2 + ... + 2811/B**N

!             Now, X*Y = ( X1 + K*X2 ) ( Y1 + K*Y2 )
!                      =   X1*Y1 + K*(X1*Y2 + X2*Y1) + K**2*X2*Y2

!             Since the digits of X1 and X2 are formed one at a time from the corresponding digits
!             of X, generating X1 and X2 is a fast O(N) operation.

!             The terms in these products are still written in base b, but the digits are small,
!             no more than K.  These four multiplications are reduced to three, computing
!             X1*Y1, X2*Y2, and (X1+X2)*(Y1+Y2).
!             Then X1*Y2 + X2*Y1 = (X1+X2)*(Y1+Y2) - X1*Y1 - X2*Y2.  See Knuth, V 2, section 4.3.3.

!             Method 2 is recursive, since if N is large enough N*K*K may still be too large for
!             the double precision rounding errors.  In that case another splitting is done, giving
!             digits less than SQRT(AINT(SQRT(B))) = 59 in this example.

!             For B = 12345678 and 53-bit double precision, the first splitting is done for all N,
!             since B**2 > 10**14 is already too close to 16-digit integers.
!             A second splitting is done for N larger than about 4*10**5 (about 2.8 million decimal
!             digits), and a third for N > 1.4*10**9 (about 10 billion decimals).

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: J,K,L,MXY(8),NDSAVE
      DOUBLE PRECISION :: B,BL,D,DMAX

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2

!             Check to see if the base is a power of a small integer.

      DO J = 2, 19
         IF (J == 2 .OR. J == 10) THEN
             B = 12 - J
         ELSE
             B = J
         ENDIF
         BL = 1
         DO L = 1, 100
            BL = BL*B
            IF (MBASE == BL) THEN
                CALL FMMPYFFT1(MA,MB,B,L)
                MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
                TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                RETURN
            ENDIF
            IF (MBASE < BL) EXIT
         ENDDO
      ENDDO

!             Use method 2.

!             Find the maximum size of the digits in MA and MB.

      DMAX = 0
      DO J = 1, NDIG
         D = MWK(START(MA)+J+2)
         IF (D > DMAX) DMAX = D
         D = MWK(START(MB)+J+2)
         IF (D > DMAX) DMAX = D
      ENDDO

!             Check to see if splitting is needed.

      IF (DMAX**2 > 1/(4.0D3*NDIG*EPSILON(1.0D0))) THEN
          K = INT(SQRT(DMAX))
          NDSAVE = NDIG
          NDIG = 2*NDIG + 2
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(4),NDSAVE,NDIG)
          CALL FMIM(0,MXY(5))
          CALL FMIM(0,MXY(6))
          CALL FMIM(0,MXY(7))
          CALL FMIM(0,MXY(8))
          DO J = 1, NDIG
             L = MWK(START(MXY(1))+J+2)
             MWK(START(MXY(1))+J+2) = MOD(L,K)
             MWK(START(MXY(2))+J+2) = L/K
             L = MWK(START(MXY(3))+J+2)
             MWK(START(MXY(3))+J+2) = MOD(L,K)
             MWK(START(MXY(4))+J+2) = L/K
          ENDDO

!             Normalize any of these having a zero leading digit.

          IF (MWK(START(MXY(1))+3) == 0) CALL FMMPYFFT_NORM(MXY(1))
          IF (MWK(START(MXY(2))+3) == 0) CALL FMMPYFFT_NORM(MXY(2))
          IF (MWK(START(MXY(3))+3) == 0) CALL FMMPYFFT_NORM(MXY(3))
          IF (MWK(START(MXY(4))+3) == 0) CALL FMMPYFFT_NORM(MXY(4))

          NDIG = NDSAVE
          CALL FMMPYFFT(MXY(1),MXY(3))
          NDIG = 2*NDIG + 2
          CALL FMMOVE(MWA,MXY(5))
          NDIG = NDSAVE
          CALL FMMPYFFT(MXY(2),MXY(4))
          NDIG = 2*NDIG + 2
          CALL FMMOVE(MWA,MXY(6))
          CALL FMADD2(MXY(1),MXY(2),MXY(7))
          CALL FMADD2(MXY(3),MXY(4),MXY(8))
          NDIG = NDSAVE
          CALL FMMPYFFT(MXY(7),MXY(8))
          NDIG = 2*NDIG + 2
          CALL FMMOVE(MWA,MXY(7))
          KSUB = 1
          CALL FMADD2(MXY(7),MXY(5),MXY(1))
          CALL FMADD2(MXY(1),MXY(6),MXY(2))
          KSUB = 0
          CALL FMMPYFFTI(MXY(6),K,MXY(3))
          CALL FMADD2(MXY(3),MXY(2),MXY(4))
          CALL FMMPYFFTI(MXY(4),K,MXY(3))
          CALL FMADD2(MXY(3),MXY(5),MXY(4))
          MWK(START(MWA)) = MWK(START(MXY(4)))
          MWK(START(MWA)+1) = MWK(START(MXY(4))+1)
          MWK(START(MWA)+2) = MWK(START(MXY(4))+2)
          IF (MWK(START(MWA)+3) == 0) MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          NDIG = NDSAVE
      ELSE
          CALL FMMPYFFT2(MA,MB)
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      ENDIF

      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYFFT

      SUBROUTINE FMMPYFFT1(MA,MB,B,L)

      USE FMVALS
      IMPLICIT NONE

!  Internal multiplication routine MA*MB for very high precision.
!  The base for the arithmetic (MBASE) is a power of B, B**L, for 2 <= B <= 19.  This includes the
!  usual case where the default base chosen in FMSET is a power of 10.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.

      INTEGER :: MA,MB
      INTEGER :: J,K,K2,K3,K5,KA,L,L1,L2,L3,L5,N,N2,ND,NUM,NUMAR,NUMAI,NUMBR,NUMBI
      REAL (KIND(0.0D0)) :: D2,D3,DMIN,DPROD
      REAL (KIND(0.0D0)) :: B,BASE,C,D,T,T2,THETA,TMA,TMB
      COMPLEX (KIND(0.0D0)), DIMENSION(:), ALLOCATABLE :: CX,CY,CZ,ROOTS_OF_UNITY
      COMPLEX (KIND(0.0D0)) :: CI,H1,H2,ST,W0,W

!             Initialize guard digits in MWA.

      DO J = 2*NDIG, MIN(2*NDIG+30,SIZE_OF(MWA)-3)
         MWK(START(MWA)+J+2) = 0
      ENDDO

!             If the base and/or number of digits is too large, rounding errors in the FFT
!             calculation will cause the result to be wrong.
!             Reduce the base if necessary.

      ND = NDIG
      BASE = MBASE
      IF (MBASE**2 > 1/(1.0D3*ND*EPSILON(1.0D0))) THEN
          BASE = 1/SQRT(1.0D3*ND*EPSILON(1.0D0))
          K = LOG(BASE)/LOG(B)
          BASE = B**K
          ND = NDIG*DBLE(L)/K + 1
      ENDIF

!             Choose the number of digits to use for the FFT.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      L2 = LOG(10.0D0*ND)/LOG(2.0D0) + 2
      L3 = LOG(10.0D0*ND)/LOG(3.0D0) + 2
      L5 = 0
      IF (ND <= 100000) THEN
          L1 = 1
      ELSE
          L1 = MAX(2,NINT(2*LOG10(DBLE(ND))-8))
      ENDIF
      DMIN = HUGE(2.0D0)
      D2 = 2.0D0 ** L1
      DO K2 = L1, L2
         D3 = 1.0D0
         DO K3 = 0, L3
            DPROD = D2*D3
            DO K5 = 0, L5
               IF (DPROD > DMIN) EXIT
               IF (DPROD >= ND) THEN
                   IF (DPROD < DMIN) DMIN = DPROD
               ENDIF
               DPROD = 5*DPROD
            ENDDO
            D3 = 3*D3
         ENDDO
         D2 = 2*D2
      ENDDO
      N = DMIN
      N2 = N*2
      ALLOCATE(CX(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CY(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CZ(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(ROOTS_OF_UNITY(0:N-1),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      CALL FMFFT_INIT(ROOTS_OF_UNITY,N)

!             Pad the lists of digits with zeros, then pack the length 2*N real arrays into
!             length N complex arrays to speed up the FFT operations.

      IF (BASE == MBASE) THEN
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          DO J = 2, NDIG, 2
             CX(J/2) = CMPLX( MWK(START(MA)+J+1) , MWK(START(MA)+J+2) , KIND(0.0D0) )
             CY(J/2) = CMPLX( MWK(START(MB)+J+1) , MWK(START(MB)+J+2) , KIND(0.0D0) )
          ENDDO
          IF (MOD(NDIG,2) == 1) THEN
              CX(NDIG/2+1) = MWK(START(MA)+NDIG+2)
              CY(NDIG/2+1) = MWK(START(MB)+NDIG+2)
          ENDIF
      ELSE
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          D = MBASE/BASE
          C = MBASE*D
          TMA = MWK(START(MA)+3)*MBASE + MWK(START(MA)+4)
          NUMAR = TMA/C
          TMA = TMA - C*NUMAR
          TMB = MWK(START(MB)+3)*MBASE + MWK(START(MB)+4)
          NUMBR = TMB/C
          TMB = TMB - C*NUMBR
          K = 0
          DO J = 3, NDIG
  110        IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 TMA = TMA*MBASE + MWK(START(MA)+J+2)
                 TMB = TMB*MBASE + MWK(START(MB)+J+2)
                 C = C*MBASE
                 CYCLE
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
             GO TO 110
          ENDDO
          DO
             IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 NUMAI = TMA*(BASE/C)
                 NUMBI = TMB*(BASE/C)
                 IF (NUMAR < 0) THEN
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAI) , 0.0D0 , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBI) , 0.0D0 , KIND(0.0D0) )
                 ELSE
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 ENDIF
                 EXIT
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
          ENDDO
      ENDIF

!             Transform.

      CALL FMFFT(CX,N,ROOTS_OF_UNITY,CZ)
      IF (KSQR /= 1) THEN
          CALL FMFFT(CY,N,ROOTS_OF_UNITY,CZ)
      ENDIF

!             Unpack the two transforms.

      THETA = ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CX(J)+CONJG(CX(N+2-J)))
         H2 = -0.5D0*CI*(CX(J)-CONJG(CX(N+2-J)))
         CX(J) = H1 + W*H2
         CX(N+2-J) = CONJG(H1 - W*H2)
         IF (KSQR /= 1) THEN
             H1 = 0.5D0*(CY(J)+CONJG(CY(N+2-J)))
             H2 = -0.5D0*CI*(CY(J)-CONJG(CY(N+2-J)))
             CY(J) = H1 + W*H2
             CY(N+2-J) = CONJG(H1 - W*H2)
         ENDIF
         W = W + ST*W
      ENDDO
      CX(1) = CMPLX( REAL(CX(1))+AIMAG(CX(1)) , REAL(CX(1))-AIMAG(CX(1)) , KIND(0.0D0) )
      IF (KSQR /= 1) THEN
          CY(1) = CMPLX( REAL(CY(1))+AIMAG(CY(1)) , REAL(CY(1))-AIMAG(CY(1)) , KIND(0.0D0) )
      ENDIF

!             Multiply.

      IF (KSQR /= 1) THEN
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CY(1)) , AIMAG(CX(1))*AIMAG(CY(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CY(J)
          ENDDO
      ELSE
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CX(1)) , AIMAG(CX(1))*AIMAG(CX(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CX(J)
          ENDDO
      ENDIF

!             Pack the product for input to the final FFT.

      THETA = -ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CZ(J)+CONJG(CZ(N+2-J)))
         H2 = 0.5D0*CI*(CZ(J)-CONJG(CZ(N+2-J)))
         CZ(J) = H1 + W*H2
         CZ(N+2-J) = CONJG(H1 - W*H2)
         W = W + ST*W
      ENDDO
      CZ(1) = CMPLX( REAL(CZ(1))+AIMAG(CZ(1)) , REAL(CZ(1))-AIMAG(CZ(1)) , KIND(0.0D0) )*0.5D0

!             Transform the product to get the convolution of the original inputs.

      CALL FMFFT(CZ,N,ROOTS_OF_UNITY,CY)
      T = 1.0D0/N
      DO J = 1, N
         CZ(J) = CZ(J)*T
      ENDDO

!             Normalize the digits.

!             The CZ array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in CZ(1), then the next two
!             are in CZ(N), then CZ(N-1), ..., CZ(2).
!             The imaginary part of CZ(2) is zero (up to roundoff), for a total of 2*N-1
!             digits in the convolution.
!             These digits can be as big as N*BASE^2 here.
!
!             First normalize and unscramble.

      IF (BASE == MBASE) THEN
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N2
          IF (KA <= SIZE_OF(MWA)-3) THEN
              MWK(START(MWA)+KA+2) = T2
          ENDIF
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T
      ELSE
          CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N
          CX(KA) = CI*T2
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             CX(KA) = T2 + CX(KA)
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             CX(KA) = CI*T2
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          CX(KA) = T2 + CX(KA)
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          CX(KA) = T + CI*T2
          TMA = 0
          C = 1
          K = 0
          DO J = 1, N2
             IF (MOD(J,2) == 1) THEN
                 NUM = REAL(CX((J+1)/2))
             ELSE
                 NUM = AIMAG(CX((J+1)/2))
             ENDIF
             TMA = TMA*BASE + NUM
             C = C*BASE
             IF (C < MBASE) CYCLE
             C = C/MBASE
             NUM = TMA/C
             TMA = TMA - C*NUM
             K = K + 1
             IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) THEN
                 MWK(START(MWA)+K+2) = NUM
             ELSE
                 EXIT
             ENDIF
          ENDDO
          K = K + 1
          IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) MWK(START(MWA)+K+2) = TMA*(MBASE/C)
      ENDIF

      DEALLOCATE(CX,CY,CZ,ROOTS_OF_UNITY)
      RETURN
      END SUBROUTINE FMMPYFFT1

      SUBROUTINE FMMPYFFT2(MA,MB)
      USE FMVALS
      IMPLICIT NONE

!  Internal multiplication routine MA*MB for very high precision.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.
!  This routine is used for method 2 of FMMPYFFT, where the base is not a power of a small number
!  and a different kind of splitting is used to avoid fft convolutions becoming too large.

      INTEGER :: MA,MB
      INTEGER :: J,K,K2,K3,K5,KA,L1,L2,L3,L5,N,N2,ND,NUM,NUMAR,NUMAI,NUMBR,NUMBI
      REAL (KIND(0.0D0)) :: D2,D3,DMIN,DPROD
      REAL (KIND(0.0D0)) :: BASE,C,D,T,T2,THETA,TMA,TMB
      COMPLEX (KIND(0.0D0)), DIMENSION(:), ALLOCATABLE :: CX,CY,CZ,ROOTS_OF_UNITY
      COMPLEX (KIND(0.0D0)) :: CI,H1,H2,ST,W0,W

      ND = NDIG
      BASE = MBASE

!             Initialize guard digits in MWA.

      DO J = 2*NDIG, MIN(2*NDIG+30,SIZE_OF(MWA)-3)
         MWK(START(MWA)+J+2) = 0
      ENDDO

!             Choose the number of digits to use for the FFT.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      L2 = LOG(10.0D0*ND)/LOG(2.0D0) + 2
      L3 = LOG(10.0D0*ND)/LOG(3.0D0) + 2
      L5 = 0
      IF (ND <= 100000) THEN
          L1 = 1
      ELSE
          L1 = MAX(2,NINT(2*LOG10(DBLE(ND))-8))
      ENDIF
      DMIN = HUGE(2.0D0)
      D2 = 2.0D0
      DO K2 = L1, L2
         D3 = 1.0D0
         DO K3 = 0, L3
            DPROD = D2*D3
            DO K5 = 0, L5
               IF (DPROD > DMIN) EXIT
               IF (DPROD >= ND) THEN
                   IF (DPROD < DMIN) DMIN = DPROD
               ENDIF
               DPROD = 5*DPROD
            ENDDO
            D3 = 3*D3
         ENDDO
         D2 = 2*D2
      ENDDO
      N = DMIN
      N2 = N*2
      ALLOCATE(CX(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CY(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CZ(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(ROOTS_OF_UNITY(0:N-1),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      CALL FMFFT_INIT(ROOTS_OF_UNITY,N)

!             Pad the lists of digits with zeros, then pack the length 2*N real arrays into
!             length N complex arrays to speed up the FFT operations.

      IF (BASE == MBASE) THEN
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          DO J = 2, NDIG, 2
             CX(J/2) = CMPLX( MWK(START(MA)+J+1) , MWK(START(MA)+J+2) , KIND(0.0D0) )
             CY(J/2) = CMPLX( MWK(START(MB)+J+1) , MWK(START(MB)+J+2) , KIND(0.0D0) )
          ENDDO
          IF (MOD(NDIG,2) == 1) THEN
              CX(NDIG/2+1) = MWK(START(MA)+NDIG+2)
              CY(NDIG/2+1) = MWK(START(MB)+NDIG+2)
          ENDIF
      ELSE
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          D = MBASE/BASE
          C = MBASE*D
          TMA = MWK(START(MA)+3)*MBASE + MWK(START(MA)+4)
          NUMAR = TMA/C
          TMA = TMA - C*NUMAR
          TMB = MWK(START(MB)+3)*MBASE + MWK(START(MB)+4)
          NUMBR = TMB/C
          TMB = TMB - C*NUMBR
          K = 0
          DO J = 3, NDIG
  110        IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 TMA = TMA*MBASE + MWK(START(MA)+J+2)
                 TMB = TMB*MBASE + MWK(START(MB)+J+2)
                 C = C*MBASE
                 CYCLE
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
             GO TO 110
          ENDDO
          DO
             IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 NUMAI = TMA*(BASE/C)
                 NUMBI = TMB*(BASE/C)
                 IF (NUMAR < 0) THEN
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAI) , 0.0D0 , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBI) , 0.0D0 , KIND(0.0D0) )
                 ELSE
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 ENDIF
                 EXIT
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
          ENDDO
      ENDIF

!             Transform.

      CALL FMFFT(CX,N,ROOTS_OF_UNITY,CZ)
      IF (KSQR /= 1) THEN
          CALL FMFFT(CY,N,ROOTS_OF_UNITY,CZ)
      ENDIF

!             Unpack the two transforms.

      THETA = ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CX(J)+CONJG(CX(N+2-J)))
         H2 = -0.5D0*CI*(CX(J)-CONJG(CX(N+2-J)))
         CX(J) = H1 + W*H2
         CX(N+2-J) = CONJG(H1 - W*H2)
         IF (KSQR /= 1) THEN
             H1 = 0.5D0*(CY(J)+CONJG(CY(N+2-J)))
             H2 = -0.5D0*CI*(CY(J)-CONJG(CY(N+2-J)))
             CY(J) = H1 + W*H2
             CY(N+2-J) = CONJG(H1 - W*H2)
         ENDIF
         W = W + ST*W
      ENDDO
      CX(1) = CMPLX( REAL(CX(1))+AIMAG(CX(1)) , REAL(CX(1))-AIMAG(CX(1)) , KIND(0.0D0) )
      IF (KSQR /= 1) THEN
          CY(1) = CMPLX( REAL(CY(1))+AIMAG(CY(1)) , REAL(CY(1))-AIMAG(CY(1)) , KIND(0.0D0) )
      ENDIF

!             Multiply.

      IF (KSQR /= 1) THEN
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CY(1)) , AIMAG(CX(1))*AIMAG(CY(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CY(J)
          ENDDO
      ELSE
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CX(1)) , AIMAG(CX(1))*AIMAG(CX(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CX(J)
          ENDDO
      ENDIF

!             Pack the product for input to the final FFT.

      THETA = -ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CZ(J)+CONJG(CZ(N+2-J)))
         H2 = 0.5D0*CI*(CZ(J)-CONJG(CZ(N+2-J)))
         CZ(J) = H1 + W*H2
         CZ(N+2-J) = CONJG(H1 - W*H2)
         W = W + ST*W
      ENDDO
      CZ(1) = CMPLX( REAL(CZ(1))+AIMAG(CZ(1)) , REAL(CZ(1))-AIMAG(CZ(1)) , KIND(0.0D0) )*0.5D0

!             Transform the product to get the convolution of the original inputs.

      CALL FMFFT(CZ,N,ROOTS_OF_UNITY,CY)
      T = 1.0D0/N
      DO J = 1, N
         CZ(J) = CZ(J)*T
      ENDDO

!             Normalize the digits.

!             The CZ array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in CZ(1), then the next two
!             are in CZ(N), then CZ(N-1), ..., CZ(2).
!             The imaginary part of CZ(2) is zero (up to roundoff), for a total of 2*N-1
!             digits in the convolution.
!             These digits can be as big as N*BASE^2 here.
!
!             First normalize and unscramble.

      IF (BASE == MBASE) THEN
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N2
          IF (KA <= SIZE_OF(MWA)-3) THEN
              MWK(START(MWA)+KA+2) = T2
          ENDIF
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T
      ELSE
          CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N
          CX(KA) = CI*T2
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             CX(KA) = T2 + CX(KA)
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             CX(KA) = CI*T2
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          CX(KA) = T2 + CX(KA)
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          CX(KA) = T + CI*T2
          TMA = 0
          C = 1
          K = 0
          DO J = 1, N2
             IF (MOD(J,2) == 1) THEN
                 NUM = REAL(CX((J+1)/2))
             ELSE
                 NUM = AIMAG(CX((J+1)/2))
             ENDIF
             TMA = TMA*BASE + NUM
             C = C*BASE
             IF (C < MBASE) CYCLE
             C = C/MBASE
             NUM = TMA/C
             TMA = TMA - C*NUM
             K = K + 1
             IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) THEN
                 MWK(START(MWA)+K+2) = NUM
             ELSE
                 EXIT
             ENDIF
          ENDDO
          K = K + 1
          IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) MWK(START(MWA)+K+2) = TMA*(MBASE/C)
      ENDIF

      DEALLOCATE(CX,CY,CZ,ROOTS_OF_UNITY)
      RETURN
      END SUBROUTINE FMMPYFFT2

      SUBROUTINE FMMPYFFTI(MA,IVAL,MB)

!  MB = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is used during fft-based multiplication.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MAS,MCARRY,MD2B,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      KFLAG = 0
      N1 = NDIG + 1

!             Check for special cases.

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -4
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MB)
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          DO J = -1, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          MWK(START(MB)) = MWK(START(MA))*IVAL
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          MAS = MWK(START(MA))
          KFLAG = -5
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MEXPOV
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MB)) = -1
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          KFLAG = -4
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MWK(START(MA))
      MVAL = ABS(IVAL)

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)
      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).
!             Round the result and move it to MB.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,KSHIFT,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,KSHIFT,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

!             Put the sign on the result.

      MWK(START(MB)) = JRSIGN
      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF

      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYFFTI

      SUBROUTINE FMMPYFFT_NORM(MA)

!  Normalize a number formed by the x1,x2 splitting done in FMMPYFFT.

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: J,KZ,MA

      KZ = 0
      DO J = 1, NDIG
         IF (MWK(START(MA)+J+2) == 0) THEN
             KZ = J
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (KZ == 0) RETURN
      IF (KZ == NDIG) THEN
          CALL FMIM(0,MA)
          RETURN
      ENDIF
      DO J = 1, NDIG-KZ
         MWK(START(MA)+J+2) = MWK(START(MA)+J+KZ+2)
      ENDDO
      DO J = NDIG-KZ+1, NDIG
         MWK(START(MA)+J+2) = 0
      ENDDO
      MWK(START(MA)+2) = MWK(START(MA)+2) - KZ

      RETURN
      END SUBROUTINE FMMPYFFT_NORM

      SUBROUTINE FMMPYI(MA,IVAL,MB)

!  MB = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is faster than FMMPY when IVAL*MBASE is a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MAS,MCARRY,MD2B,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYI'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             Check for special cases.

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB)
          KFLAG = -4
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          DO J = -1, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          MWK(START(MB)) = MWK(START(MA))*IVAL
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          MAS = MWK(START(MA))
          KFLAG = -5
          CALL FMST2M('OVERFLOW',MB)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MB)) = -1
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          NAMEST(NCALL) = 'FMMPYI'
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MWK(START(MA))
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)

!             If IVAL is too big use FMMPY.

      IF (KSHIFT > NDIG .OR. MVAL > MAXINT/MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMMPY2(MA,MXY(1),MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).
!             Round the result and move it to MB.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,KSHIFT,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,KSHIFT,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYI'
          CALL FMWARN
      ENDIF

!             Put the sign on the result.

      MWK(START(MB)) = JRSIGN
      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF

      IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MB,MB,1,1)
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYI

      SUBROUTINE FMMPYI_R1(MA,IVAL)

!  MA = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is faster than FMMPY when IVAL*MBASE is a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MAS,MCARRY,MD2B,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYI_R1'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             Check for special cases.

      IF (MWK(START(MA)+3) == 0) THEN
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MA)
          KFLAG = -4
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MA)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          MWK(START(MA)) = MWK(START(MA))*IVAL
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          MAS = MWK(START(MA))
          KFLAG = -5
          CALL FMST2M('OVERFLOW',MA)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MA)) = -1
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          NAMEST(NCALL) = 'FMMPYI_R1'
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MA)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MWK(START(MA))
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)

!             If IVAL is too big use FMMPY.

      IF (KSHIFT > NDIG .OR. MVAL > MAXINT/MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMMPY2_R1(MA,MXY(1))
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).
!             Round the result and move it to MA.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,KSHIFT,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,KSHIFT,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYI_R1'
          CALL FMWARN
      ENDIF

!             Put the sign on the result.

      MWK(START(MA)) = JRSIGN
      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MA)+1) = MACCA
      ENDIF

      IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MA,MA,1,1)
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYI_R1

      SUBROUTINE FMNINT(MA,MB)

!  MB = NINT(MA)  --  MB is returned as the nearest integer to MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MA2,MXSAVE
      INTEGER :: K,KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMNINT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMNINT'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      IF (NDSAVE > INT(MWK(START(MA)+2))) THEN
          MA2 = MWK(START(MA))
          MWK(START(MXY(2))) = 1
          CALL FMI2M(1,MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMADD(MXY(2),MXY(1),MXY(3))
          CALL FMINT(MXY(3),MXY(2))
          IF (MA2 < 0 .AND. MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
              MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMNINT

      SUBROUTINE FMNORM2(X,N,MB)

!  MB = sqrt( x(1)^2 + x(2)^2 + ... + x(n)^2 )

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: X(N),MB,J,NDSAVE,MXSAVE
      INTENT (IN) :: X,N
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMNORM2  '
      NDSAVE = NDIG
      NDIG = NDIG + NGRD52
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Check for special cases.

      DO J = 1, N
         IF (MWK(START(X(J))+2) == MUNKNO) THEN
             CALL FMST2M('UNKNOWN',MXY(1))
             GO TO 110
         ENDIF
      ENDDO
      DO J = 1, N
         IF (MWK(START(X(J))+2) == MEXPOV) THEN
             CALL FMST2M('OVERFLOW',MXY(1))
             GO TO 110
         ENDIF
      ENDDO

      CALL FMI2M(0,MXY(2))
      DO J = 1, N
         CALL FMEQU(X(J),MXY(1),NDSAVE,NDIG)
         CALL FMSQR_R1(MXY(1))
         CALL FMADD_R1(MXY(2),MXY(1))
      ENDDO
      CALL FMSQRT_R1(MXY(2))

  110 MXEXP = MXSAVE
      CALL FMEQU(MXY(2),MB,NDIG,NDSAVE)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMNORM2

      FUNCTION FMNTERMS(Y,C1,C2,JN,CONV)

!  Internal routine for estimating the number of terms needed in a series.

      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: A,B,C,FB,FC,TOL,Y,Z,FMNTERMS
      DOUBLE PRECISION, EXTERNAL :: FMDPLG
      INTEGER :: C1,C2,JN,CONV

      IF (CONV /= 1) GO TO 110

!             Convergent series.

      Z = Y*LOG(Y) - FMDPLG(Y+1)
      C = 1
      IF (C2 == 1) THEN
          C = (SQRT(4*Y + JN**2) - JN)/2
          Z = C*LOG(Y) - FMDPLG(C+1) - FMDPLG(C+JN+1)
      ELSE IF (C2 == -1) THEN
          Z = (Y*Y/2)*LOG(Y) + FMDPLG(Y*Y/4+1) - FMDPLG(Y*Y/2+1)
      ENDIF
      IF (ABS(Y) < 1) Z = 0
      TOL = Z - NDIG*DLOGMB
      A = Y/C1
      IF (C2 == 1) THEN
          A = C
      ENDIF
      IF (A < 1) A = 1
      B = 2*A
      IF (C2 == 0) THEN
          FB = C1*B*LOG(Y) - FMDPLG(C1*B+1)
      ELSE IF (C2 == 1) THEN
          FB = C1*B*LOG(Y) - FMDPLG(C1*B+1) - FMDPLG(C1*(B+JN)+1)
      ELSE IF (C2 == -1) THEN
          FB = C1*B*LOG(Y) + FMDPLG(B+1) - FMDPLG(C1*B+1)
      ENDIF
      DO WHILE (FB > TOL)
         A = B
         B = 2*B
         IF (C2 == 0) THEN
             FB = C1*B*LOG(Y) - FMDPLG(C1*B+1)
         ELSE IF (C2 == 1) THEN
             FB = C1*B*LOG(Y) - FMDPLG(C1*B+1) - FMDPLG(C1*(B+JN)+1)
         ELSE IF (C2 == -1) THEN
             FB = C1*B*LOG(Y) + FMDPLG(B+1) - FMDPLG(C1*B+1)
         ENDIF
      ENDDO
      DO WHILE (B-A > 1)
         C = (A+B)/2
         IF (C2 == 0) THEN
             FC = C1*C*LOG(Y) - FMDPLG(C1*C+1)
         ELSE IF (C2 == 1) THEN
             FC = C1*C*LOG(Y) - FMDPLG(C1*C+1) - FMDPLG(C1*(C+JN)+1)
         ELSE IF (C2 == -1) THEN
             FC = C1*C*LOG(Y) + FMDPLG(C+1) - FMDPLG(C1*C+1)
         ELSE
             FC = C1*C*LOG(Y) - FMDPLG(C1*C+1)
         ENDIF
         IF (FC < TOL) THEN
             B = C
         ELSE
             A = C
         ENDIF
      ENDDO
      FMNTERMS = (A+B)/2
      RETURN

!             Asymptotic series.

  110 TOL = -NDIG*DLOGMB
      A = 1
      B = Y/C1
      IF (C2 == 1) THEN
          B = Y/2
      ENDIF
      IF (C2 == 0) THEN
          FB = FMDPLG(C1*B+1) - C1*B*LOG(Y)
      ELSE IF (C2 == 1) THEN
          IF (-C1*B + JN >= 0) THEN
              FB = FMDPLG(C1*B+JN+1) - C1*B*LOG(Y) - FMDPLG(C1*B+1) - FMDPLG(-C1*B+JN+1)
          ELSE
              FB = FMDPLG(C1*B+JN+1) + FMDPLG(C1*B-JN+1) - C1*B*LOG(Y) - FMDPLG(C1*B+1)
          ENDIF
      ENDIF
      DO WHILE (B-A > 1)
         IF (ABS(FB)/1.0D10 > ABS(TOL) .AND. B/1.0D10 > A*1.1) THEN
             C = B/1.0D10
         ELSE IF (ABS(FB)/1.0D2 > ABS(TOL) .AND. B/1.0D2 > A*1.1) THEN
             C = B/1.0D2
         ELSE
             C = (A+B)/2
         ENDIF
         IF (C2 == 0) THEN
             FC = FMDPLG(C1*C+1) - C1*C*LOG(Y)
         ELSE IF (C2 == 1) THEN
             IF (-C1*C + JN >= 0) THEN
                 FC = FMDPLG(C1*C+JN+1) - C1*C*LOG(Y) - FMDPLG(C1*C+1) - FMDPLG(-C1*C+JN+1)
             ELSE
                 FC = FMDPLG(C1*C+JN+1) + FMDPLG(C1*C-JN+1) - C1*C*LOG(Y) - FMDPLG(C1*C+1)
             ENDIF
         ENDIF
         IF (FC < TOL) THEN
             B = C
         ELSE
             A = C
         ENDIF
      ENDDO
      FMNTERMS = (A+B)/2

      END FUNCTION FMNTERMS

      SUBROUTINE FMNTR(NTR,MA,MB,NARG,KNAM)

!  Print FM numbers in base 10 format using FMOUT for conversion.
!  This is used for trace output from the FM routines.

!  NTR =  1 if a result of an FM call is to be printed.
!      =  2 to print input argument(s) to an FM call.

!  MA  -  the FM number to be printed.

!  MB  -  an optional second FM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be printed, and NARG = 2 if
!         both MA and MB are to be printed.

!  KNAM - positive if the routine name is to be printed.


!  NTRACE and LVLTRC (in module FMVALS) control trace printout.

!  NTRACE = 0        No printout except warnings and errors.

!  NTRACE = 1        The result of each call to one of the routines is printed in base 10,
!                    using FMOUT.

!  NTRACE = -1       The result of each call to one of the routines is printed in internal
!                    base MBASE format.

!  NTRACE = 2        The input arguments and result of each call to one of the routines is
!                    printed in base 10, using FMOUT.

!  NTRACE = -2       The input arguments and result of each call to one of the routines is
!                    printed in base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = K prints traces for FM routines with
!         call levels up to and including level K.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: KNAM,NTR,NARG

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MA,MB,NARG,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          IF (KNAM > 0) THEN
              NAME = NAMEST(NCALL)
              IF (KROUND == 1) THEN
                  WRITE (KW,"(' Input to ',A)") TRIM(NAME)
              ELSE IF (KROUND == 2) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
              ELSE IF (KROUND == 0) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
              ELSE IF (KROUND == -1) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
              ELSE
                  WRITE (KW,"(' Input to ',A)") TRIM(NAME)
              ENDIF
          ENDIF
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (NTRACE < 0) THEN
          CALL FMNTRJ(MA,NDIG)
          IF (NARG == 2) CALL FMNTRJ(MB,NDIG)
      ENDIF

!             Check for base 10 trace using FMOUT.

      IF (NTRACE > 0) THEN
          CALL FMPRNT(MA)

          IF (NARG == 2) THEN
              CALL FMPRNT(MB)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE FMNTR

      SUBROUTINE FMNTRI(NTR,N,KNAM)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I20)") N

      RETURN
      END SUBROUTINE FMNTRI

      SUBROUTINE FMNTRJ(MA,ND)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: ND

      CHARACTER(99) :: FORM
      CHARACTER(40), EXTERNAL :: FMFI
      CHARACTER(40) :: ST1,ST2,ST3
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(MBASE-1))) + 2
      N = (KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,'/"  //  &
                      "(22X,',I3,'I',I2,')) ')"                &
                ) L+2, N-1, L, N, L
      ENDIF

      ST1 = FMFI(INT(MWK(START(MA))))
      ST2 = FMFI(INT(MWK(START(MA)+1)))
      ST3 = FMFI(INT(MWK(START(MA)+2)))
      WRITE (KW,"(A,A,A,A,A,A,A)") '            Sign = ',TRIM(ST1),'   Accuracy = ',  &
                 TRIM(ST2),'   Exponent = ',TRIM(ST3),'   Digits:'
      WRITE (FORM,*) '(13X,', N, 'I', L, ')'
      WRITE (KW,FORM) (INT(MWK(START(MA)+J)),J=3,ND+2)

      RETURN
      END SUBROUTINE FMNTRJ

      SUBROUTINE FMNTRR(NTR,X,KNAM)

!  Internal routine for trace output of real variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Double precision value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      DOUBLE PRECISION :: X

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,X,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,D30.20)") X

      RETURN
      END SUBROUTINE FMNTRR

      SUBROUTINE FMOUT(MA,LINE,LB)

!  Convert a floating multiple precision number to a character array for output.

!  MA   is an FM number to be converted to an A1 character array in base 10 format.
!  LINE is the character(1) array in which the result is returned.
!  LB   is the length of LINE.

! JFORM1 and JFORM2 (in module FMVALS) determine the format of LINE.

! JFORM1 = 0  normal setting  ( .314159M+6 )
!        = 1  ES  format      ( 3.14159M+5 )
!        = 2  F   format      ( 314159.000 )

! JFORM2 = number of significant digits to display (if JFORM1 = 0, 1)
!        = number of digits after the decimal point (if JFORM1 = 2)

!          If JFORM2 == 0 and JFORM1 /= 2 then a default number of digits is chosen.
!          The default is roughly the full precision of MA.

!          If JFORM2 == 0 and JFORM1 == 2 then the number is returned in integer format with no
!          decimal point.  Rounding is done as with other settings, so the value displayed is the
!          nearest integer to MA.

!  If JFORM1 == 2 and MA is too large or too small to display in the requested format, it is
!  converted using JFORM1=0, JFORM2=0.

!  LINE should be dimensioned at least LOG10(MBASE)*NDIG + 15 on a 32-bit machine to allow for up to
!  10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit integers, ....

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: LB
      CHARACTER :: LINE(LB)

      CHARACTER :: KCHAR
      REAL (KIND(1.0D0)) :: MBSAVE,MEXP,MEXP10,MKT,MS1,MS2,MSD2,MT10,MXSAVE
      INTEGER :: J,JDPT,JF1SAV,JF2SAV,K,K1,K2,KA,KASAVE,KB,KC,KDIGIT,KEXP,KMS2SD,KWRNSV,L,  &
                 NEW_MBASE,NEW_NDIG,ND,NDE,NDE2,NDSAVE,NPOWER,NSD1,NSD2,NVAL,NTRSAV,        &
                 NWORD,NWORD1,NWORD2
      DOUBLE PRECISION :: X

      CHARACTER :: NUMB(10) = (/ '0','1','2','3','4','5','6','7','8','9' /)
      CHARACTER :: NUNKNO(12) = (/ ' ',' ',' ','U','N','K','N','O','W','N',' ',' ' /)
      CHARACTER :: NEXPOV(12) = (/ ' ',' ',' ','O','V','E','R','F','L','O','W',' ' /)
      CHARACTER :: NEXPUN(12) = (/ ' ',' ',' ','U','N','D','E','R','F','L','O','W' /)
      CHARACTER(9) :: NAMEST_SAVE(0:50)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

!             To avoid recursion, FMOUT calls only internal arithmetic routines
!             (FMADD2, FMMPY2, ...), so no trace printout is done during a call to FMOUT.

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMOUT'
      KWRNSV = KWARN
      KWARN = 0
      DO J = 1, LB
         LINE(J) = ' '
      ENDDO

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          DO J = 1, 12
             LINE(J) = NUNKNO(J)
          ENDDO
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV) THEN
          DO J = 1, 12
             LINE(J) = NEXPOV(J)
          ENDDO
          LINE(2) = '+'
          IF (MWK(START(MA)) < 0) LINE(2) = '-'
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF
      IF (MWK(START(MA)+2) == MEXPUN) THEN
          DO J = 1, 12
             LINE(J) = NEXPUN(J)
          ENDDO
          LINE(2) = '+'
          IF (MWK(START(MA)) < 0) LINE(2) = '-'
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF
      IF (MWK(START(MA)+3) == 0 .AND. JFORM1 == 2 .AND. JFORM2 == 0) THEN
          LINE(2) = '0'
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF

      KASAVE = KACCSW
      KACCSW = 0
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      MBSAVE = MBASE
      NDSAVE = NDIG
      MXSAVE = MXEXP

!             ND is the number of base 10 digits required.

  110 ND = JFORM2
      IF (JFORM1 == 2 .AND. MWK(START(MA)+2) > 0) THEN
          ND = JFORM2 + INT(REAL(MWK(START(MA)+2))*LOG10(REAL(MBASE))) + 1
          IF (ND <= 1 .AND. JFORM2 == 0) ND = 10
      ENDIF
      IF (ND <= 1) THEN
          K = INT(REAL(NDIG)*LOG10(REAL(MBASE)))
          ND = MAX(K,JFORM2)
      ENDIF
      IF (JFORM2 <= 0 .AND. JFORM1 <= 1) ND = INT(1.1 + REAL(NDIG-1)*LOG10(REAL(MBASE)))
      IF (ND < 2) ND = 2

      IF (LB < ND+6) THEN
          IF (JFORM1 == 2) THEN
              JFORM1 = 0
              JFORM2 = 0
              GO TO 110
          ENDIF
          GO TO 170
      ENDIF

!             Convert to the base that is the largest power of 10 less than MXBASE and build the
!             output number.

      NPOWER = INT(LOG10(REAL(MXBASE)/4))
      MXEXP = MXEXP2
      MBASE = 10**NPOWER
      IF (MBLOGS /= MBASE) CALL FMCONS
      NDIG = ND/NPOWER + 3
      K = NDSAVE*LOG(DBLE(MBSAVE))/LOG(DBLE(MBASE))
      IF (NDIG + 3000 < K) THEN
          NDIG = ND/NPOWER + 3000
      ELSE IF (NDIG < K) THEN
          NDIG = K
      ENDIF
      IF (NDIG < 2) NDIG = 2

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMIM(0,MXY(3))
          GO TO 120
      ENDIF

!             Check to see if MA is already in a base that is a power of ten.
!             If so, the conversion can be skipped.

      K = NPOWER
      DO J = 1, K
         MBASE = 10**J
         IF (MBASE == MBSAVE) THEN
             IF (MBLOGS /= MBASE) CALL FMCONS
             NPOWER = J
             NDIG = MAX(NDSAVE,ND/NPOWER+3)
             IF (NDIG < 2) NDIG = 2
             IF (NDIG > NDSAVE) THEN
                 CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
             ELSE
                 CALL FMIM(0,MXY(3))
                 DO K1 = 1, MIN(NDIG,Size_of(MA)-3)
                    MWK(START(MXY(3))+K1+2) = MWK(START(MA)+K1+2)
                 ENDDO
                 MWK(START(MXY(3))) = MWK(START(MA))
                 MWK(START(MXY(3))+1) = MWK(START(MA)+1)
                 MWK(START(MXY(3))+2) = MWK(START(MA)+2)
             ENDIF
             MWK(START(MXY(3))) = 1
             GO TO 120
         ENDIF
      ENDDO

      NEW_MBASE = MBASE
      NEW_NDIG = NDIG
      MBASE = MBSAVE
      NDIG = MIN(NDSAVE,NINT(NEW_NDIG*LOG(DBLE(NEW_MBASE))/LOG(DBLE(MBASE))))
      IF (MBLOGS /= MBASE) CALL FMCONS
      NTRSAV = NTRACE
      NTRACE = 0
      J = NCALL
      NAMEST_SAVE(0:NCALL) = NAMEST(0:NCALL)
      NCALL = 0
      CALL FMCHANGEBASE(MA,MXY(3),NEW_MBASE,NEW_NDIG)
      NCALL = J
      NAMEST(0:NCALL) = NAMEST_SAVE(0:NCALL)
      NTRACE = NTRSAV
      MBASE = NEW_MBASE
      NDIG = NEW_NDIG
      IF (MBLOGS /= MBASE) CALL FMCONS

!             Now MXY(3) is the value of MA converted to a power of ten base.

!             Convert it to a character string base 10 for output.

!             MEXP10 is the base 10 exponent.
!             KMS2SD is the number of base 10 significant digits in the first digit of MXY(3).

  120 MS1 = MWK(START(MXY(3))+2)
  130 MEXP10 = NPOWER*MWK(START(MXY(3))+2)
      KMS2SD = NPOWER
      K = INT(MBASE)
      DO J = 1, NPOWER
         K = K/10
         IF (MWK(START(MXY(3))+3) < K .AND. MWK(START(MXY(3))+3) /= 0) THEN
             MEXP10 = MEXP10 - 1
             KMS2SD = KMS2SD - 1
         ENDIF
      ENDDO

!             For printing using JFORM1 = 1, reduce the exponent to account for the fact that the
!             decimal point and first significant digit will later be swapped.

      IF (JFORM1 == 1 .AND. MWK(START(MXY(3))+3) /= 0) MEXP10 = MEXP10 - 1

!             Find the position in the unpacked number for rounding.
!             NWORD is the word in which rounding is done, or zero if no rounding is necessary.
!                   NWORD is set to -1 if JFORM1 is 2 (F format) but no significant digits would
!                   be printed.  This case defaults to JFORM1 = 0.
!             NVAL gives the position within that word where rounding occurs.
!             NSD1 is the maximum number of base 10 S.D.'s in NWORD digits of base 10**NPOWER.
!             NSD2 is the number of base 10 S.D.'s needed to get ND base 10 digits after
!                  the decimal.

      NSD2 = ND
      IF (JFORM1 == 2) THEN
          MSD2 = JFORM2 + MEXP10
          IF (MSD2 > ND) THEN
              NSD2 = ND
          ELSE
              NSD2 = INT(MSD2)
          ENDIF
          NWORD = (NSD2-KMS2SD-1+NPOWER)/NPOWER + 2
          IF (NWORD < 2) NWORD = -1
          IF (NWORD > NDIG) NWORD = 0
          IF (NWORD >= 2 .AND. NSD2 <= 0) NWORD = -1
      ELSE
          NWORD = (ND-KMS2SD-1+NPOWER)/NPOWER + 2
      ENDIF
      NSD1 = KMS2SD + NPOWER*(NWORD-2)
      IF (NWORD < 2) THEN
          NVAL = 0
      ELSE
          NVAL = 10**(NSD1-NSD2)
      ENDIF

!             Now do the base 10 rounding.

      IF (NWORD >= 2) THEN
          X = 0
          IF (NVAL > 1) X = MOD(INT(MWK(START(MXY(3))+NWORD+1)),NVAL)
          IF (NWORD < NDIG+1) THEN
              X = X + DBLE(MWK(START(MXY(3))+NWORD+2))/DBLE(MBASE)
          ENDIF
          X = X/NVAL
          IF (KROUND == 1 .AND. X < 0.5) GO TO 150
          IF (KROUND == 1 .AND. X == 0.5) THEN
              DO J = NWORD+1, NDIG
                 IF (MWK(START(MXY(3))+J+2) /= 0) GO TO 140
              ENDDO
              J = MOD(INT(MWK(START(MXY(3))+NWORD+1))/NVAL,10)
              IF (MOD(J,2) /= 0) GO TO 140
              GO TO 150
          ENDIF
          IF (KROUND == 0) GO TO 150
          IF (KROUND == -1 .AND. MWK(START(MA)) > 0) GO TO 150
          IF (KROUND ==  2 .AND. MWK(START(MA)) < 0) GO TO 150
          IF (KROUND == -1 .AND. X == 0.0) THEN
              DO J = NWORD+1, NDIG
                 IF (MWK(START(MXY(3))+J+2) /= 0) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
          IF (KROUND ==  2 .AND. X == 0.0) THEN
              DO J = NWORD+1, NDIG
                 IF (MWK(START(MXY(3))+J+2) /= 0) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     MS2 = MWK(START(MXY(3))+3)
          MWK(START(MXY(3))+NWORD+1) = INT(MWK(START(MXY(3))+NWORD+1)/NVAL)*NVAL
          IF (NWORD+3 <= SIZE_OF(MXY(3))) THEN
              MWK(START(MXY(3))+NWORD+2) = 0
              IF (NWORD+4 <= SIZE_OF(MXY(3))) THEN
                  MWK(START(MXY(3))+NWORD+3) = 0
              ENDIF
              IF (KROUND /= 1) THEN
                  DO J = NWORD, SIZE_OF(MXY(3))-3
                     MWK(START(MXY(3))+J+2) = 0
                  ENDDO
              ENDIF
          ENDIF
          MWK(START(MXY(3))+NWORD+1) = MWK(START(MXY(3))+NWORD+1) + NVAL
          IF (MWK(START(MXY(3))+NWORD+1) >= MBASE) THEN
              NWORD1 = NWORD - 1
              NWORD2 = NWORD - 2
              IF (NWORD > 2) THEN
                  CALL FMEQU_R1(MXY(3),NWORD1,NWORD2)
              ELSE
                  MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + 1
                  MWK(START(MXY(3))+3) = INT(MWK(START(MXY(3))+3)/MBASE)
                  MWK(START(MXY(3))+4) = 0
              ENDIF
          ENDIF
          IF (MWK(START(MXY(3))+2) /= MS1 .OR. MWK(START(MXY(3))+3) /= MS2) GO TO 130
      ENDIF

!             Build the base 10 character string.

  150 IF (MWK(START(MA)) < 0) LINE(1) = '-'
      LINE(2) = '.'
      K = 10**KMS2SD
      L = 2
      IF (NWORD == -1) NSD2 = ND
      DO J = 1, NSD2
         K = K/10
         IF (K == 0) THEN
             K = INT(MBASE)/10
             L = L + 1
         ENDIF
         KDIGIT = INT(MWK(START(MXY(3))+L+1))/K
         MWK(START(MXY(3))+L+1) = MOD(INT(MWK(START(MXY(3))+L+1)),K)
         LINE(J+2) = NUMB(KDIGIT+1)
      ENDDO

      KA = NSD2 + 3
      KB = ND + 2
      IF (KB >= KA) THEN
          DO J = KA, KB
             LINE(J) = NUMB(1)
          ENDDO
      ENDIF

      LINE(ND+3) = CMCHAR
      LINE(ND+4) = '+'
      IF (MEXP10 < 0) LINE(ND+4) = '-'
      IF (MWK(START(MA)+3) == 0) LINE(ND+4) = ' '

!             Build the digits of the base 10 exponent backwards, then reverse them.

      NDE = 1
      MEXP = ABS(MEXP10)
      MT10 = 10
      DO J = 1, LB
         MKT = AINT (MEXP/MT10)
         KDIGIT = INT(MEXP-MKT*MT10)
         LINE(ND+4+J) = NUMB(KDIGIT+1)
         MEXP = MKT
         IF (MEXP == 0) EXIT

         IF (ND+5+J > LB) THEN
             DO K = 1, LB
                LINE(K) = '*'
             ENDDO
             GO TO 160
         ENDIF

         NDE = NDE + 1
      ENDDO

      NDE2 = NDE/2
      IF (NDE2 < 1) GO TO 160
      K1 = ND + 4
      K2 = ND + 5 + NDE
      DO J = 1, NDE2
         K1 = K1 + 1
         K2 = K2 - 1
         KCHAR = LINE(K1)
         LINE(K1) = LINE(K2)
         LINE(K2) = KCHAR
      ENDDO

!             If JFORM1 is 1 put the first digit left of the decimal.

  160 IF (JFORM1 == 1) THEN
          KCHAR = LINE(2)
          LINE(2) = LINE(3)
          LINE(3) = KCHAR
      ENDIF

!             If JFORM1 is 2 put the number into fixed format.

      IF (JFORM1 == 2 .AND. JFORM2 >= 0) THEN
          IF (MEXP10 <= -JFORM2 .OR. MEXP10+2 > LB .OR. LINE(1) == '*') THEN
              JFORM1 = 0
              JFORM2 = 0
              MBASE = MBSAVE
              IF (MBLOGS /= MBASE) CALL FMCONS
              NDIG = NDSAVE
              MXEXP = MXSAVE
              DO J = 1, LB
                 LINE(J) = ' '
              ENDDO
              GO TO 110
          ENDIF
          KA = ND + 3
          DO J = KA, LB
             LINE(J) = NUMB(1)
          ENDDO

          KEXP = INT(MEXP10)
          IF (MEXP10 > 0) THEN
              DO J = 1, KEXP
                 LINE(J+1) = LINE(J+2)
              ENDDO
              LINE(KEXP+2) = '.'
          ENDIF

          IF (MEXP10 < 0) THEN
              KEXP = -INT(MEXP10)
              KA = 3 + KEXP
              KB = LB + 1
              KC = KB - KEXP
              DO J = KA, LB
                 KB = KB - 1
                 KC = KC - 1
                 LINE(KB) = LINE(KC)
                 LINE(KC) = NUMB(1)
              ENDDO
          ENDIF

          JDPT = 0
          DO J = 1, LB
             IF (LINE(J) == '.') JDPT = J
             IF (JDPT > 0 .AND. J > JDPT+JFORM2) LINE(J) = ' '
          ENDDO
          IF (JFORM2 == 0 .AND. JDPT > 0) LINE(KEXP+2) = ' '

      ENDIF

!             Restore values and return

      GO TO 180

!             LINE is not big enough to hold the number of digits specified.

  170 KFLAG = -8
      DO J = 1, LB
         LINE(J) = '*'
      ENDDO
      KWARN = KWRNSV
      CALL FMWARN

  180 MBASE = MBSAVE
      IF (MBLOGS /= MBASE) CALL FMCONS
      NDIG = NDSAVE
      MXEXP = MXSAVE
      KWARN = KWRNSV
      NCALL = NCALL - 1
      KACCSW = KASAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMOUT

      SUBROUTINE FMPACK(MA,MP)

!  MA is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MP <= 0) THEN
          CALL FMDEFINE(MP)
      ELSE IF (SIZE_OF(MP) < NDIG/2+4) THEN
          CALL FMDEFINE(MP)
      ENDIF

      KP = 2
      MWK(START(MP)) = MWK(START(MA))
      MWK(START(MP)+1) = MWK(START(MA)+1)
      MWK(START(MP)+2) = MWK(START(MA)+2)
      MWK(START(MP)+3) = ABS(MWK(START(MA)+3))*MBASE + MWK(START(MA)+4)
      IF (NDIG >= 4) THEN
          DO J = 4, NDIG, 2
             KP = KP + 1
             MWK(START(MP)+KP+1) = MWK(START(MA)+J+1)*MBASE + MWK(START(MA)+J+2)
          ENDDO
      ENDIF
      IF (MOD(NDIG,2) == 1) MWK(START(MP)+KP+2) = MWK(START(MA)+NDIG+2)*MBASE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPACK

      SUBROUTINE FMPI(MA)

!  MA = pi

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      CHARACTER(155) :: STRING
      INTEGER :: K,KASAVE,L,NDMB,NDSAVE,NDSV
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMPI'
      IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
          WRITE (KW,"(' Input to FMPI')")
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = NGRD52
          NDIG = MAX(NDIG+K,2)
      ENDIF

!             Check to see if pi has previously been computed in base MBASE with
!             sufficient precision.

      IF (MBSPI == MBASE .AND. NDIGPI >= NDIG) THEN
          KACCSW = KASAVE
          CALL FMEQU(MPISAV,MA,NDIGPI,NDSAVE)
      ELSE
          NDMB = INT(150.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              STRING = '3.141592653589793238462643383279502884197169'//  &
              '39937510582097494459230781640628620899862803482534211'//  &
              '7067982148086513282306647093844609550582231725359408128'
              IF (MPISAV > 0) THEN
                  IF (SIZE_OF(MPISAV) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MPISAV) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MPISAV
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MPISAV
                      ENDIF
                      MPISAV = L
                  ENDIF
              ENDIF
              CALL FMST2M(STRING,MPISAV)
              MWK(START(MPISAV)+1) = NINT(NDIG*ALOGM2)
              MBSPI = MBASE
              NDIGPI = NDIG
              IF (ABS(MWK(START(MPISAV)+2)) > 10) NDIGPI = 0
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2 + NDIG/100
              IF (MPISAV > 0) THEN
                  IF (SIZE_OF(MPISAV) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MPISAV) = -6
                      TOTAL_FMTEMP6 = TOTAL_FMTEMP6 + 1
                      IF (NMAX_FMTEMP6 >= SIZE_OF_TEMP6) THEN
                          N_FMTEMP6 = MOD( TOTAL_FMTEMP6, SIZE_OF_TEMP6 ) + 1
                          FMTEMP6(N_FMTEMP6) = MPISAV
                      ELSE
                          NMAX_FMTEMP6 = NMAX_FMTEMP6 + 1
                          FMTEMP6(NMAX_FMTEMP6) = MPISAV
                      ENDIF
                      MPISAV = L
                  ENDIF
              ENDIF
              CALL FMPI2(MPISAV)
              MWK(START(MPISAV)+1) = NINT(NDIG*ALOGM2)
              MBSPI = MBASE
              NDIGPI = NDIG
              IF (ABS(MWK(START(MPISAV)+2)) > 10) NDIGPI = 0
          ENDIF
          KACCSW = KASAVE
          CALL FMEQU(MPISAV,MA,NDIG,NDSAVE)
          NDIG = NDSV
      ENDIF

      NDIG = NDSAVE
      KACCSW = KASAVE
      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPI

      SUBROUTINE FMPI2(MPI)

!  Internal routine to compute pi.
!  The formula used is due to S. Ramanujan.  For low to moderate precision, this routine uses
!  the series
!                                                (4n)!(1103+26390n)
!  1/pi = (sqrt(8)/9801) * sum(n=0 to infinity) --------------------
!                                               ((n!)**4)(396**(4n))
!
!  For higher precision, see routine FMPI3.
!
!  The result is returned in MPI.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MPI
      INTENT (INOUT) :: MPI
      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: MX
      INTEGER :: NSTACK(49),J,K,KST,LARGE,N,NDIGRD,NDSAVE,NMETHD
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MPI <= 0) THEN
          CALL FMDEFINE(MPI)
      ELSE IF (SIZE_OF(MPI) < NDIG+3) THEN
          CALL FMDEFINE(MPI)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Check for using binary splitting if precision is high.

      IF (NDIG >= 100) THEN
          NMETHD = 2
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMPI3(MPI)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MPI) == -1) TEMPV(MPI) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      NDSAVE = NDIG
      N = -1
      CALL FMI2M(1103,MPI)
      CALL FMI2M(0,MXY(1))
      CALL FMI2M(1,MXY(2))
      CALL FMI2M(26390,MXY(3))
      CALL FMI2M(1103,MXY(4))
      MX = MXBASE**2/MBASE
      IF (MX > MXEXP2) MX = MXEXP2

  110 N = N + 1
      LARGE = INT(MX)/(4*N + 3)
      J = 4*N + 1
      IF (J > LARGE) THEN
          CALL FMMPYI_R1(MXY(2),J)
          J = J + 1
          CALL FMMPYI_R1(MXY(2),J)
          J = J + 1
          CALL FMMPYI_R1(MXY(2),J)
      ELSE IF (J*(J+1) > LARGE) THEN
          K = J*(J+1)
          CALL FMMPYI_R1(MXY(2),K)
          J = J + 2
          CALL FMMPYI_R1(MXY(2),J)
      ELSE
          K = J*(J+1)*(J+2)
          CALL FMMPYI_R1(MXY(2),K)
      ENDIF

      J = N + 1
      LARGE = INT(MXBASE)/J
      IF (J > LARGE) THEN
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),J)
      ELSE IF (J*J > LARGE) THEN
          K = J*J
          CALL FMDIVI_R1(MXY(2),K)
          CALL FMDIVI_R1(MXY(2),J)
      ELSE
          K = J*J*J
          CALL FMDIVI_R1(MXY(2),K)
      ENDIF

!             Break 4/396**4 into 1/(2178*2178*1296).

      J = 2178
      LARGE = INT(MXBASE)/J
      IF (J > LARGE) THEN
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),1296)
      ELSE
          K = J*J
          CALL FMDIVI_R1(MXY(2),K)
          CALL FMDIVI_R1(MXY(2),1296)
      ENDIF

      NDIGRD = NDIG
      NDIG = NDSAVE
      CALL FMADD_R2(MXY(3),MXY(4))
      NDIG = NDIGRD
      CALL FMMPY(MXY(2),MXY(4),MXY(1))

      NDIG = NDSAVE
      CALL FMADD_R1(MPI,MXY(1))
      NDIG = MAX(NGRD22,NDSAVE - INT(MWK(START(MPI)+2) - MWK(START(MXY(1))+2)))
      IF (KFLAG /= 1) GO TO 110
      NDIG = NDSAVE

      CALL FMI2M(8,MXY(2))
      X = 8
      X = SQRT(X)
      CALL FMDPM(X,MXY(4))
      CALL FMDIG(NSTACK,KST)
      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMDIV(MXY(2),MXY(4),MXY(1))
         CALL FMADD_R1(MXY(4),MXY(1))
         CALL FMDIVI_R1(MXY(4),2)
      ENDDO
      MWK(START(MXY(4))+1) = NINT(NDIG*ALOGM2)
      CALL FMI2M(9801,MXY(3))
      CALL FMMPY_R1(MPI,MXY(4))
      CALL FMDIV_R2(MXY(3),MPI)

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MPI) == -1) TEMPV(MPI) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPI2

      SUBROUTINE FMPI3(MPI)
      USE FMVALS
      IMPLICIT NONE

!  Internal pi routine for very high precision.

!  The algorithm used is Chudnovskys' Ramanujan-style series with binary splitting.

!                                                  (-1)**n*(6n)!(13591409+545140134*n)
!  1/pi = (12/640320**(3/2)) * sum(n=0 to infinity) -----------------------------------
!                                                     (n!)**3*(3*n)!*(640320**(3n))
!  The result is returned in MPI.

      INTEGER :: MPI
      INTENT (INOUT) :: MPI
      INTEGER :: K
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NDIG = NDIG + 100
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG + 30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NDIG = NDIG - 100
      NUMBER_USED_SAVE = NUMBER_USED

!             Determine K, the number of terms to sum in the series for pi.

      K = NDIG*DLOGMB/3.2654441D+1 + 10
      CALL FMPI3_PQT(0,K,MXY(1),MXY(2),MXY(3))

      IF (MWK(START(MXY(2))+2) >= NDIG .AND. MWK(START(MXY(3))+2) >= NDIG) THEN
          CALL FMDIV(MXY(2),MXY(3),MXY(1))
          CALL FMI2M(640320,MXY(2))
          CALL FMSQRT(MXY(2),MXY(3))
          CALL FMMPYI_R1(MXY(3),53360)
          CALL FMMPY(MXY(1),MXY(3),MPI)
      ELSE
          IF (MWK(START(MXY(2))+2) >= NDIG) THEN
              CALL FMEQ(MXY(2),MXY(1))
          ELSE
              CALL IMI2FM(MXY(2),MXY(1))
          ENDIF
          IF (MWK(START(MXY(3))+2) >= NDIG) THEN
              CALL FMEQ(MXY(3),MXY(4))
          ELSE
              CALL IMI2FM(MXY(3),MXY(4))
          ENDIF
          CALL FMDIV(MXY(1),MXY(4),MXY(3))
          CALL FMI2M(640320,MXY(1))
          CALL FMSQRT(MXY(1),MXY(2))
          CALL FMMPYI_R1(MXY(2),53360)
          CALL FMMPY(MXY(2),MXY(3),MPI)
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPI3

      RECURSIVE SUBROUTINE FMPI3_PQT(A,B,MP,MQ,MT)

!  This routine does the binary splitting for computing the constant pi.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP,MQ,MT
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP,MQ,MT
      INTEGER :: MXY(6),NUMBER_USED_SAVE,J,KA,KP,KQ,KT,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      NUMBER_USED_SAVE = NUMBER_USED
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 10) THEN
          RESULT_SIZE = ( (DB-DA)*4.276666 + 3*( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) ) * 1.01 / DLOGMB + 15
          RESULT_SIZE = MAX(5,RESULT_SIZE) + 5*LOG(DBLE(NDIG))/DLOGMB + 15
          IF (MP <= 0) THEN
              CALL IMDEFINE(MP,RESULT_SIZE)
          ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
              CALL IMDEFINE(MP,RESULT_SIZE)
          ENDIF
          RESULT_SIZE = ( (DB-DA)*36.93111 + 3*( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) ) * 1.01 / DLOGMB + 15
          RESULT_SIZE = MAX(5,RESULT_SIZE) + 5*LOG(DBLE(NDIG))/DLOGMB + 15
          IF (MQ <= 0) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ENDIF
          IF (MT <= 0) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ENDIF
          NUMBER_USED_SAVE = NUMBER_USED
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)
          CALL IMI2M(1,MP)
          KA = A
          IF (KA == 0) KA = 1
          DO J = KA, B
             CALL IMMPYI(MP,-(6*J-5),MXY(2))
             CALL IMMPYI(MXY(2),2*J-1,MXY(1))
             CALL IMMPYI(MXY(1),6*J-1,MP)
          ENDDO

          CALL IMI2M(640320,MXY(1))
          CALL IMSQR(MXY(1),MXY(3))
          CALL IMMPY(MXY(3),MXY(1),MXY(2))
          CALL IMDIVI(MXY(2),24,MXY(1))
          CALL IMI2M(1,MQ)
          DO J = KA, B
             CALL IMMPYI(MQ,J,MXY(3))
             CALL IMMPYI(MXY(3),J,MXY(2))
             CALL IMMPYI(MXY(2),J,MXY(3))
             CALL IMMPY(MXY(3),MXY(1),MQ)
          ENDDO

          CALL IMI2M(0,MT)
          IF (A == 0) THEN
              CALL IMMPYI(MQ,13591409,MT)
          ENDIF
          CALL IMEQ(MQ,MXY(2))
          DO J = KA, B
             CALL IMMPYI(MXY(2),-(6*J-5),MXY(3))
             CALL IMMPYI(MXY(3),2*J-1,MXY(4))
             CALL IMMPYI(MXY(4),6*J-1,MXY(2))
             CALL IMDIVI(MXY(2),J,MXY(3))
             CALL IMDIVI(MXY(3),J,MXY(4))
             CALL IMDIVI(MXY(4),J,MXY(3))
             CALL IMDIV(MXY(3),MXY(1),MXY(2))
             CALL IMI2M(545140134,MXY(3))
             CALL IMMPYI(MXY(3),J,MXY(4))
             CALL IMI2M(13591409,MXY(3))
             CALL IMADD(MXY(3),MXY(4),MXY(5))
             CALL IMMPY(MXY(2),MXY(5),MXY(3))
             CALL IMADD(MT,MXY(3),MXY(4))
             CALL IMEQ(MXY(4),MT)
          ENDDO

          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMPI3_PQT(A,M-1,MXY(1),MXY(2),MXY(3))
      CALL FMPI3_PQT(M,B,MXY(4),MXY(5),MXY(6))

!             MP is not needed in FMPI3, so this multiplication can be skipped at the top level
!             of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(1),MXY(4),MP)
      ELSE
          CALL IMI2M(0,MP)
      ENDIF
      CALL IM_OR_FM_MPY(MXY(2),MXY(5),MQ)

      CALL IM_OR_FM_MPY(MXY(5),MXY(3),MXY(2))
      CALL IM_OR_FM_MPY(MXY(1),MXY(6),MXY(4))
      CALL IM_OR_FM_ADD(MXY(2),MXY(4),MT)

!             Move MP, MQ, and MT to the front of the unused area of MWK and save them.

      NUMBER_USED = NUMBER_USED_SAVE + 1
      KP = MP
      MP = NUMBER_USED
      IF (NUMBER_USED <= 1) THEN
          START(MP) = 1
      ELSE
          START(MP) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      ENDIF
      SIZE_OF(MP) = SIZE_OF(KP)
      IF (SIZE_OF(MQ) == NDIG+3 .AND. SIZE_OF(MP) < NDIG+3) THEN
          SIZE_OF(MP) = SIZE_OF(MQ)
      ENDIF
      DO J = 1, SIZE_OF(KP)
         MWK(START(MP)+J-1) = MWK(START(KP)+J-1)
      ENDDO
      TEMPV(MP) = -2
      NUMBER_USED = NUMBER_USED + 1
      KQ = MQ
      MQ = NUMBER_USED
      START(MQ) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      SIZE_OF(MQ) = SIZE_OF(KQ)
      DO J = 1, SIZE_OF(MQ)
         MWK(START(MQ)+J-1) = MWK(START(KQ)+J-1)
      ENDDO
      TEMPV(MQ) = -2
      NUMBER_USED = NUMBER_USED + 1
      KT = MT
      MT = NUMBER_USED
      START(MT) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      SIZE_OF(MT) = SIZE_OF(KT)
      DO J = 1, SIZE_OF(MT)
         MWK(START(MT)+J-1) = MWK(START(KT)+J-1)
      ENDDO
      TEMPV(MT) = -2
      IF (SIZE_OF(MQ) == NDIG+3 .AND. SIZE_OF(KP) < NDIG+3) THEN
          DO J = SIZE_OF(KP)+1, SIZE_OF(MP)
             MWK(START(MP)+J-1) = 0
          ENDDO
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMPI3_PQT

      SUBROUTINE FMPRNT(MA)

!  Print MA in base 10 format.

!  FMPRNT can be called directly by the user for easy output in M format.
!  MA is converted using FMOUT and printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KSAVE,L,LAST,LB,ND,NEXP
      INTENT (IN) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMPRNT'
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = MAX(JFORM2+NEXP,ND+NEXP)
      IF (LB+50 > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB+50),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB + 50
      ENDIF
      CALL FMOUT(MA,CMBUFF,LB)
      KFLAG = KSAVE
      LAST = LB + 1
      WRITE (FORM,"(' (6X,',I3,'A1) ')") KSWIDE-7
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             WRITE (KW,FORM) (CMBUFF(K),K=1,L)
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPRNT

      SUBROUTINE FMPWR(MA,MB,MC)

!  MC = MA ** MB

!  If MB can be expressed exactly as a one word integer, then FMIPWR is used.  This is much faster
!  when MB is small, and using FMIPWR allows MA to be negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTMB,J,K,KASAVE,KFL,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Convert MB to an integer before changing NDIG.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMMI(MB,INTMB)
      KWARN = KWRNSV
      KFL = KFLAG
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)) >= 0 .AND. MWK(START(MA)+3) > 0 .AND.  &
          MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NCALL = NCALL + 1
          IF (MWK(START(MB)+2) == MEXPUN) THEN
              CALL FMEQ(MB,MXY(3))
              IF (MWK(START(MA)+2) <= 0) CALL FMMPYI_R1(MXY(3),-1)
          ELSE
              CALL FMLN(MA,MXY(1))
              CALL FMMPY(MXY(1),MB,MXY(3))
          ENDIF
          NCALL = NCALL - 1
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MXY(3))+2) < -NDIG) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPWR'
                  CALL FMNTR(2,MA,MB,2,1)
                  NCALL = NCALL - 1
              ENDIF
              J = NTRACE
              NTRACE = 0
              K = KWARN
              KWARN = 0
              CALL FMI2M(1,MXY(1))
              CALL FMSUB(MA,MXY(1),MXY(2))
              IF (MWK(START(MXY(2))+3) == 0) THEN
                  CALL FMI2M(1,MXY(2))
              ELSE
                  CALL FMADD(MXY(1),MXY(3),MXY(2))
              ENDIF
              IF (MWK(START(MXY(2))+2) /= MUNKNO) THEN
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  CALL FMEQ(MXY(2),MC)
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMPWR'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR('FMPWR    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMPWR'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

!             If the exponent is large or the base is very large, raise the precision.

      IF (MWK(START(MA)+2) /= 0) THEN
          IEXTRA = MAX(0,INT(MWK(START(MB)+2)))+INT(LOG(ABS(REAL(MWK(START(MA)+2))))/ALOGMB)
      ELSE
          IEXTRA = MAX(0,INT(MWK(START(MB)+2)))
      ENDIF
      IF (MWK(START(MB)+2)-NDIG > LOG(ALOGMB*REAL(MXEXP2))) THEN
          IEXTRA = 0
      ENDIF
      NDIG = NDIG + IEXTRA

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

!             If the exponent is a small integer, call FMIPWR.

      KWRNSV = KWARN
      KWARN = 0

      MACCA = MWK(START(MA)+1)
      MACCB = NINT(NDIG*ALOGM2)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      IF (KFL == 0) THEN
          CALL FMIPWR(MXY(2),INTMB,MXY(4))
      ELSE IF (MWK(START(MXY(2))+3) == 0 .OR. MWK(START(MXY(2))) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(4))
          KFLAG = -4
      ELSE
          CALL FMLN(MXY(2),MXY(3))
          MACCB = MWK(START(MB)+1)
          CALL FMEQU(MB,MXY(1),NDSAVE,NDIG)
          MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
          CALL FMMPY_R1(MXY(3),MXY(1))
          CALL FMEXP(MXY(3),MXY(4))
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(4))+3))+1))/0.69315)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACCA,MACCB,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(4),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPWR

      SUBROUTINE FMRDC(MA,JSIN,JCOS,JSWAP)

!  Reduce MA using various trigonometric identities to an equivalent angle between 0 and 45 degrees.
!  The reduction is done in radians if KRAD (in module FMVALS) is 1, in degrees if KRAD is 0.
!  JSIN and JCOS are returned +1 or -1 and JSWAP is returned to indicate that the sin and cos
!  functions have been interchanged as follows:

!  JSWAP = 0 means   SIN(MA) = JSIN*SIN(returned value of MA)
!                    COS(MA) = JCOS*COS(returned value of MA)

!  JSWAP = 1 means   SIN(MA) = JSIN*COS(returned value of MA)
!                    COS(MA) = JCOS*SIN(returned value of MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: JSIN,JCOS,JSWAP
      REAL (KIND(1.0D0)) :: MA0
      DOUBLE PRECISION :: X
      INTEGER :: J,KASAVE,NDSAVE,NDSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (INOUT) :: MA
      INTENT (INOUT) :: JSIN,JCOS,JSWAP
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JSIN = 1
      JCOS = 1
      JSWAP = 0
      NDSAVE = NDIG
      IF (KRAD == 0) THEN
          CALL FMI2M(360,MXY(2))
          CALL FMEQ(MA,MXY(4))
          CALL FMMOD(MXY(4),MXY(2),MA)
      ENDIF

      NDIG = NDIG + MAX(0,INT(MWK(START(MA)+2)))

      MA0 = MWK(START(MA)+1) + NINT(ALOGM2*REAL(MAX(0,INT(MWK(START(MA)+2)))))

!             If MA is less than 1/MBASE, no reduction is needed.

      IF (MWK(START(MA)+2) < 0) THEN
          NDIG = NDSAVE
          IF (MWK(START(MA)) < 0) THEN
              MWK(START(MA)) = 1
              JSIN = -1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF

      J = 1
      IF (KRAD == 1) THEN
  110     IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              KASAVE = KACCSW
              KACCSW = 0
              CALL FMPI(MXY(4))
              KACCSW = KASAVE
              NDIG = NDSV
          ENDIF
          CALL FMEQU(MA,MXY(4),NDSAVE,NDIG)
          MWK(START(MXY(4))+1) = MA0
          IF (MWK(START(MA)) < 0) JSIN = -1
          MWK(START(MXY(4))) = 1
          IF (MWK(START(MXY(4))+2) == 0) THEN
              CALL FMM2DP(MXY(4),X)
              IF (X <= 0.75) THEN
                  NDIG = NDSAVE
                  CALL FMEQ(MXY(4),MA)
                  NUMBER_USED = NUMBER_USED_SAVE
                  RETURN
              ENDIF
          ENDIF
          CALL FMADD(MPISAV,MPISAV,MXY(2))
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              CALL FMDIV(MXY(4),MXY(2),MXY(1))
              CALL FMINT(MXY(1),MXY(5))
              CALL FMMPY_R1(MXY(5),MXY(2))
              CALL FMSUB_R1(MXY(4),MXY(5))
          ENDIF
          CALL FMEQ(MPISAV,MXY(3))
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSIN = -JSIN
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF
          CALL FMDIVI_R1(MXY(2),4)
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              JCOS = -JCOS
              CALL FMSUB_R2(MXY(3),MXY(4))
          ENDIF
          CALL FMDIVI_R1(MXY(3),4)
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSWAP = 1
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF

!             If the reduced argument is close to zero, then cancellation has produced an
!             inaccurate value.
!             Raise NDIG and do the reduction again.

          IF (J == 1 .AND. (MWK(START(MXY(4))+2) < 0 .OR. MWK(START(MXY(4))+3) == 0)) THEN
              J = 2
              IF (MWK(START(MXY(4))+3) == 0) THEN
                  NDIG = 2*NDIG
              ELSE
                  NDIG = NDIG - INT(MWK(START(MXY(4))+2))
              ENDIF
              JSIN = 1
              JCOS = 1
              JSWAP = 0
              MA0 = MWK(START(MA)+1) + NINT(ALOGM2*REAL(-MWK(START(MXY(4))+2)))
              MXY = -2
              GO TO 110
          ENDIF

      ELSE

          CALL FMEQU(MA,MXY(4),NDSAVE,NDIG)
          MWK(START(MXY(4))+1) = MA0
          IF (MWK(START(MA)) < 0) JSIN = -1
          MWK(START(MXY(4))) = 1
          IF (MWK(START(MXY(4))+2) == 0) THEN
              CALL FMM2DP(MXY(4),X)
              IF (X <= 44.0) THEN
                  NDIG = NDSAVE
                  CALL FMEQ(MXY(4),MA)
                  NUMBER_USED = NUMBER_USED_SAVE
                  RETURN
              ENDIF
          ENDIF
          CALL FMI2M(360,MXY(2))
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              CALL FMDIV(MXY(4),MXY(2),MXY(1))
              CALL FMINT(MXY(1),MXY(5))
              CALL FMMPY_R1(MXY(5),MXY(2))
              CALL FMSUB_R1(MXY(4),MXY(5))
          ENDIF
          CALL FMI2M(180,MXY(3))
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSIN = -JSIN
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF
          CALL FMI2M(90,MXY(2))
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              JCOS = -JCOS
              CALL FMSUB_R2(MXY(3),MXY(4))
          ENDIF
          CALL FMI2M(45,MXY(3))
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSWAP = 1
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF

      ENDIF

!             Round the result and return.

      CALL FMEQU(MXY(4),MA,NDIG,NDSAVE)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMRDC

      SUBROUTINE FMREAD(KREAD,MA)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: KREAD

      CHARACTER :: LINE(132)
      INTEGER :: J,K,L2,LB,NDSAVE
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMREAD'
      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)
      LB = 0

  110 READ (KREAD,"(132A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 132
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFF) THEN

!                If CMBUFF runs out of space, try to re-allocate it with a bigger size.

                 IF (LMBUFF > 0) THEN
                     ALLOCATE(MOVE_CMBUFF(LMBUFF),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, LMBUFF
                        MOVE_CMBUFF(K) = CMBUFF(K)
                     ENDDO
                     DEALLOCATE(CMBUFF)
                     L2 = MAX(10000,2*LMBUFF)
                     ALLOCATE(CMBUFF(L2),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, L2
                        CMBUFF(K) = ' '
                     ENDDO
                     DO K = 1, LMBUFF
                        CMBUFF(K) = MOVE_CMBUFF(K)
                     ENDDO
                     DEALLOCATE(MOVE_CMBUFF)
                     LMBUFF = L2
                 ELSE
                     ALLOCATE(CMBUFF(10000),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     LMBUFF = 10000
                 ENDIF
             ENDIF
             CMBUFF(LB) = LINE(J)
         ENDIF
      ENDDO

      NCALL = NCALL - 1
      CALL FMINP(CMBUFF,MXY(1),1,LB)
      NCALL = NCALL + 1

      CALL FMEQU(MXY(1),MA,NDIG,NDSAVE)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 KFLAG = -4
      CALL FMWARN
      NDIG = NDSAVE
      CALL FMST2M('UNKNOWN',MA)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMREAD

      SUBROUTINE FMRND(MW,ND,NGUARD,KSHIFT)

!  Round MW to ND digits (base MBASE).

!  MW is non-negative and has ND+NGUARD+KSHIFT digits.

!  NGUARD is the number of guard digits carried.
!  KSHIFT is 1 if a left shift is pending when MWK(START(MW)+3)=0.

!  Round to position MWK(START(MW)+1+ND+1+KSHIFT) using the guard digits
!  MWK(START(MW)+1+ND+2+KSHIFT), ..., MWK(START(MW)+1+ND+1+NGUARD+KSHIFT).

!  This routine is designed to be called only from within the FM package.
!  The user should call FMEQU to round numbers.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MW
      INTEGER :: ND,NGUARD,KSHIFT

      REAL (KIND(1.0D0)) :: M2,MKT
      INTEGER :: J,K,KB,L
      INTENT (IN) :: ND,KSHIFT,NGUARD
      INTENT (INOUT) :: MW

      IF (KROUND == -1) THEN
          IF (JRSIGN == 1) RETURN
          DO J = ND+2+KSHIFT, ND+1+NGUARD+KSHIFT
             IF (MWK(START(MW)+J+1) > 0) THEN
                 MWK(START(MW)+KSHIFT+ND+2) = MWK(START(MW)+KSHIFT+ND+2) + 1
                 MWK(START(MW)+KSHIFT+ND+3) = 0
                 IF (MWK(START(MW)+KSHIFT+ND+2) < MBASE) RETURN
                 L = ND + 2 + KSHIFT
                 GO TO 120
             ENDIF
          ENDDO
          RETURN
      ENDIF

      IF (KROUND == 2) THEN
          IF (JRSIGN == -1) RETURN
          DO J = ND+2+KSHIFT, ND+1+NGUARD+KSHIFT
             IF (MWK(START(MW)+J+1) > 0) THEN
                 MWK(START(MW)+KSHIFT+ND+2) = MWK(START(MW)+KSHIFT+ND+2) + 1
                 MWK(START(MW)+KSHIFT+ND+3) = 0
                 IF (MWK(START(MW)+KSHIFT+ND+2) < MBASE) RETURN
                 L = ND + 2 + KSHIFT
                 GO TO 120
             ENDIF
          ENDDO
          RETURN
      ENDIF

      IF (KROUND == 0) RETURN
      L = ND + 2 + KSHIFT
      IF (2*(MWK(START(MW)+L+1)+1) < MBASE) RETURN
      IF (2*MWK(START(MW)+L+1) > MBASE) THEN
          MWK(START(MW)+L) = MWK(START(MW)+L) + 1
          MWK(START(MW)+L+1) = 0
          IF (MWK(START(MW)+L) < MBASE) RETURN
          GO TO 120
      ENDIF

!             If the first guard digit gives a value close to 1/2 then further guard digits must
!             be examined.

      M2 = 2
      IF (INT(MBASE-AINT (MBASE/M2)*M2) == 0) THEN
          IF (2*MWK(START(MW)+L+1) < MBASE) RETURN
          IF (2*MWK(START(MW)+L+1) == MBASE) THEN
              IF (NGUARD >= 2) THEN
                  DO J = 2, NGUARD
                     IF (MWK(START(MW)+J+L) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MWK(START(MW)+L)-AINT (MWK(START(MW)+L)/M2)*M2) == 0) RETURN
          ENDIF
      ELSE
          IF (2*MWK(START(MW)+L+1)+1 == MBASE) THEN
              IF (NGUARD >= 2) THEN
                  DO J = 2, NGUARD
                     IF (2*(MWK(START(MW)+J+L)+1) < MBASE) RETURN
                     IF (2*MWK(START(MW)+J+L) > MBASE) GO TO 110
                  ENDDO
                  IF (NGUARD <= NDIG) RETURN
                  M2 = 2
                  IF (INT(MWK(START(MW)+L)-AINT (MWK(START(MW)+L)/M2)*M2) == 0) THEN
                      RETURN
                  ELSE
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

!             Round up.

  110 MWK(START(MW)+L) = MWK(START(MW)+L) + 1
      MWK(START(MW)+L+1) = 0

!             Check whether there was a carry in the rounded digit.

  120 KB = L - 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MWK(START(MW)+K+1) < MBASE) RETURN
             MKT = AINT (MWK(START(MW)+K+1)/MBASE)
             MWK(START(MW)+K) = MWK(START(MW)+K) + MKT
             MWK(START(MW)+K+1) = MWK(START(MW)+K+1) - MKT*MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MWK(START(MW)+3) >= MBASE) THEN
          IF (KB >= 4) THEN
              K = KB + 1
              DO J = 4, KB
                 K = K - 1
                 MWK(START(MW)+K+1) = MWK(START(MW)+K)
              ENDDO
          ENDIF

          MKT = AINT (MWK(START(MW)+3)/MBASE)
          IF (KB >= 3) MWK(START(MW)+4) = MWK(START(MW)+3) - MKT*MBASE
          MWK(START(MW)+3) = MKT
          MWK(START(MW)+2) = MWK(START(MW)+2) + 1
      ENDIF

      RETURN
      END SUBROUTINE FMRND

      SUBROUTINE FMRPWR(MA,IVAL,JVAL,MB)

!  MB = MA ** (IVAL/JVAL)   rational exponentiation.

!  This routine is faster than FMPWR when IVAL and JVAL are small integers.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL,JVAL
      DOUBLE PRECISION :: X,F
      REAL (KIND(1.0D0)) :: MA1,MA2,MAS,MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: NSTACK(49),IJSIGN,INVERT,IVAL2,J,JVAL2,K,KASAVE,KL,KOVUN,KR_RETRY,KST,  &
                 KWRNSV,L,LVAL,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMRPWR'
      IF (NTRACE /= 0) THEN
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMNTRI(2,JVAL,0)
      ENDIF
      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      NDSAVE = NDIG
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

  110 IF (NCALL == 1) THEN
          XVAL = MAX(ABS(IVAL),ABS(JVAL))
          IF (XVAL == 0.0) XVAL = 1.0
          K = INT((5.0*REAL(DLOGTN) + 2.0*LOG(XVAL))/ALOGMB + 2.0)
          NDIG = MAX(NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              NDIG = MAX(NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = MAX(ABS(IVAL),ABS(JVAL))
          IF (XVAL == 0.0) XVAL = 1.0
          K = INT(LOG(XVAL)/ALOGMB + 1.0)
          NDIG = NDIG + K
      ENDIF

      MAS = MWK(START(MA))
      MA1 = MWK(START(MA)+2)
      MA2 = MWK(START(MA)+3)
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Use GCD-reduced positive exponents.

      IJSIGN = 1
      IVAL2 = ABS(IVAL)
      JVAL2 = ABS(JVAL)
      IF (IVAL > 0 .AND. JVAL < 0) IJSIGN = -1
      IF (IVAL < 0 .AND. JVAL > 0) IJSIGN = -1
      IF (IVAL2 > 0 .AND. JVAL2 > 0) CALL FMGCDI(IVAL2,JVAL2)

!             Check for special cases.

  120 IF (MA1 == MUNKNO .OR. JVAL2 == 0 .OR. (IJSIGN <= 0 .AND. MA2 == 0)) THEN
          CALL FMST2M('UNKNOWN',MXY(4))
          KFLAG = -4
          GO TO 130
      ENDIF

      IF (IVAL2 == 0) THEN
          CALL FMIM(1,MXY(4))
          GO TO 130
      ENDIF

      IF (JVAL2 == 1) THEN
          CALL FMIPWR(MXY(2),IJSIGN*IVAL2,MXY(4))
          GO TO 130
      ENDIF

      IF (MA2 == 0) THEN
          CALL FMEQ(MA,MXY(4))
          GO TO 130
      ENDIF

      IF (MAS < 0) THEN
          IF (MOD(JVAL2,2) == 0) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
      ENDIF

      IF (MA1 == MEXPOV) THEN
          IF (IVAL2 < JVAL2) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
          CALL FMIM(0,MXY(4))
          IF (IJSIGN == 1 .AND. MAS > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(4))
              KFLAG = -5
          ELSE IF (IJSIGN == -1 .AND. MAS > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(4))
              KFLAG = -6
          ELSE IF (IJSIGN == 1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(4))
                  KFLAG = -5
              ELSE
                  CALL FMST2M('-OVERFLOW',MXY(4))
                  KFLAG = -5
              ENDIF
          ELSE IF (IJSIGN == -1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('UNDERFLOW',MXY(4))
                  KFLAG = -6
              ELSE
                  CALL FMST2M('-UNDERFLOW',MXY(4))
                  KFLAG = -6
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      IF (MA1 == MEXPUN) THEN
          IF (IVAL2 < JVAL2) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
          CALL FMIM(0,MXY(4))
          IF (IJSIGN == 1 .AND. MAS > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(4))
              KFLAG = -6
          ELSE IF (IJSIGN == -1 .AND. MAS > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(4))
              KFLAG = -5
          ELSE IF (IJSIGN == 1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('UNDERFLOW',MXY(4))
                  KFLAG = -6
              ELSE
                  CALL FMST2M('-UNDERFLOW',MXY(4))
                  KFLAG = -6
              ENDIF
          ELSE IF (IJSIGN == -1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(4))
                  KFLAG = -5
              ELSE
                  CALL FMST2M('-OVERFLOW',MXY(4))
                  KFLAG = -5
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

!             Invert MA if MA > 1 and IVAL or JVAL is large.

      INVERT = 0
      IF (MWK(START(MA)+2) > 0) THEN
          IF (IVAL > 5 .OR. JVAL > 5) THEN
              INVERT = 1
              CALL FMI2M(1,MXY(1))
              CALL FMDIV_R2(MXY(1),MXY(2))
          ENDIF
      ENDIF

!             Generate the first approximation to ABS(MA)**(1/JVAL2).

      MA1 = MWK(START(MXY(2))+2)
      MWK(START(MXY(2))+2) = 0
      MWK(START(MXY(2))) = 1
      CALL FMM2DP(MXY(2),X)
      L = INT(MA1/JVAL2)
      F = MA1/DBLE(JVAL2) - L
      X = X**(1.0D0/JVAL2) * DBLE(MBASE)**F
      CALL FMDPM(X,MXY(4))
      MWK(START(MXY(4))+2) = MWK(START(MXY(4))+2) + L
      MWK(START(MXY(2))+2) = MA1

!             Initialize.

      CALL FMI2M(0,MXY(3))
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         IF (J < KST) NDIG = NDIG + 1
         LVAL = JVAL2 - 1
         CALL FMIPWR(MXY(4),LVAL,MXY(3))
         CALL FMDIV_R2(MXY(2),MXY(3))
         CALL FMMPYI_R1(MXY(4),LVAL)
         CALL FMADD_R1(MXY(4),MXY(3))
         CALL FMDIVI_R1(MXY(4),JVAL2)
      ENDDO

      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0 .AND. MAS < 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMIPWR(MXY(4),IJSIGN*IVAL2,MXY(3))
      CALL FMEQ(MXY(3),MXY(4))
      IF (INVERT == 1) THEN
          CALL FMI2M(1,MXY(1))
          CALL FMDIV_R2(MXY(1),MXY(4))
      ENDIF

!             Round the result and return.

  130 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(4))+3))+1))/0.69315)
      MWK(START(MXY(4))+1) = MIN(MACCA,MACMAX)
      KWRNSV = KWARN
      IF (MA1 == MUNKNO) KWARN = 0

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(4),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMRPWR

      SUBROUTINE FMRSLT(MA,MB,MC,KRESLT)

!  Handle results that are special cases, such as overflow, underflow, and unknown.

!  MA and MB are the input arguments to an FM subroutine.

!  MC is the result that is returned.

!  KRESLT is the result code from FMARGS.  Result codes handled here:

!   0 - Perform the normal operation
!   1 - The result is the first input argument
!   2 - The result is the second input argument
!   3 - The result is -OVERFLOW
!   4 - The result is +OVERFLOW
!   5 - The result is -UNDERFLOW
!   6 - The result is +UNDERFLOW
!   7 - The result is -1.0
!   8 - The result is +1.0
!  11 - The result is 0.0
!  12 - The result is UNKNOWN

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: KRESLT

      REAL (KIND(1.0D0)) :: MACCAB,MACCSV
      INTEGER :: KFSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      KFSAVE = KFLAG
      MACCAB = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
      IF (KRESLT == 1) THEN
          MACCSV = MWK(START(MA)+1)
          CALL FMEQ(MA,MC)
          MWK(START(MC)+1) = MACCAB
          IF (NAMEST(NCALL) == 'FMADD' .OR. NAMEST(NCALL) == 'FMADD_R1' .OR.  &
              NAMEST(NCALL) == 'FMADD_R2' .OR. NAMEST(NCALL) == 'FMSUB' .OR.  &
              NAMEST(NCALL) == 'FMSUB_R1' .OR. NAMEST(NCALL) == 'FMSUB_R2') THEN
              KFLAG = 1
              MWK(START(MC)+1) = MACCSV
          ELSE
              KFLAG = KFSAVE
          ENDIF
          RETURN
      ENDIF

      IF (KRESLT == 2) THEN
          MACCSV = MWK(START(MB)+1)
          CALL FMEQ(MB,MC)
          MWK(START(MC)+1) = MACCAB
          IF (NAMEST(NCALL) == 'FMADD' .OR. NAMEST(NCALL) == 'FMADD_R1' .OR.  &
              NAMEST(NCALL) == 'FMADD_R2') THEN
              KFLAG = 1
              MWK(START(MC)+1) = MACCSV
          ELSE
              KFLAG = KFSAVE
          ENDIF
          IF (NAMEST(NCALL) == 'FMSUB' .OR. NAMEST(NCALL) == 'FMSUB_R1' .OR.  &
              NAMEST(NCALL) == 'FMSUB_R2') THEN
              IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                  MWK(START(MC)) = -MWK(START(MC))
              KFLAG = KFSAVE
              MWK(START(MC)+1) = MACCSV
          ENDIF
          RETURN
      ENDIF

      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+2) = MEXPOV
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          IF (KRESLT == 3) MWK(START(MC)) = -1
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+2) = MEXPUN
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          IF (KRESLT == 5) MWK(START(MC)) = -1
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 7) THEN
          CALL FMIM(-1,MC)
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 8) THEN
          CALL FMIM(1,MC)
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 11) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 12 .OR. KRESLT < 0 .OR. KRESLT > 15) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE FMRSLT

      SUBROUTINE FMSETVAR(STRING)

!  Change the value of one of the internal FM variables.
!  STRING must have the format  ' variablename = value ', with no embedded blanks in variablename.

      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      CHARACTER(9) :: VARNAME
      INTEGER :: IVAL,J,KPTEQ,KPT1,KPT2
      DOUBLE PRECISION :: DVAL
      REAL (KIND(1.0D0)) :: MVAL

      CHARACTER(52) :: LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
      INTENT (IN) :: STRING

!             Find the equal sign.

      KPTEQ = INDEX(STRING,'=')
      IF (KPTEQ <= 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Cannot find the equal sign in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF

!             Find the variable name.

      KPT1 = 0
      KPT2 = 0
      DO J = 1, KPTEQ-1
         IF (KPT1 == 0 .AND. STRING(J:J) /= ' ') KPT1 = J
      ENDDO
      DO J = KPTEQ-1, 1, -1
         IF (KPT2 == 0 .AND. STRING(J:J) /= ' ') KPT2 = J
      ENDDO
      IF (KPT1 == 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Cannot find the variable name in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF
      VARNAME = ' '
      DO J = KPT1, KPT2
         IVAL = INDEX(LETTERS,STRING(J:J))
         IF (IVAL > 26 .AND. IVAL <= 52) THEN
             VARNAME(J-KPT1+1:J-KPT1+1) = LETTERS(IVAL-26:IVAL-26)
         ELSE
             VARNAME(J-KPT1+1:J-KPT1+1) = STRING(J:J)
         ENDIF
      ENDDO

!             CMCHAR is a special case, since the value is a character.

      IF (VARNAME == 'CMCHAR') THEN
          KPT1 = 0
          KPT2 = 0
          DO J = KPTEQ+1, LEN(STRING)
             IF (KPT1 == 0 .AND. STRING(J:J) /= ' ') KPT1 = J
          ENDDO
          DO J = LEN(STRING), KPTEQ+1, -1
             IF (KPT2 == 0 .AND. STRING(J:J) /= ' ') KPT2 = J
          ENDDO
          IF (KPT1 == KPT2 .AND. INDEX(LETTERS,STRING(KPT1:KPT2)) > 0) THEN
              CMCHAR = STRING(KPT1:KPT2)
              RETURN
          ELSE
              WRITE (KW,*) ' '
              WRITE (KW,*) ' Only a single letter is allowed after the equal sign in FMSETVAR.'
              WRITE (KW,*) ' Input string:  ',STRING
              RETURN
          ENDIF
      ENDIF

!             Convert the value after the equal sign.

      IF (KPTEQ+1 <= LEN(STRING)) THEN
          IF (INDEX(STRING(KPTEQ+1:LEN(STRING)),'=') /= 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' Only a single equal sign is allowed in FMSETVAR.'
              WRITE (KW,*) ' Input string:  ',STRING
              RETURN
          ENDIF
          CALL FMST2D(STRING(KPTEQ+1:LEN(STRING)),DVAL)
          IF (KFLAG /= 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' Invalid value after the equal sign in FMSETVAR.'
              WRITE (KW,*) ' Input string:  ',STRING
              RETURN
          ENDIF
      ELSE
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Cannot find a value after the equal sign in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF

!             Check the list of variable names.

      IF (VARNAME == 'JFORM1') THEN
          JFORM1 = NINT(DVAL)
          IF (JFORM1 < 0 .OR. JFORM1 > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JFORM1,' is an invalid value for JFORM1'
              JFORM1 = 1
              WRITE (KW,*) '            Valid values are 0,1,2.  JFORM1 was set to ',JFORM1
          ENDIF
      ELSE IF (VARNAME == 'JFORM2') THEN
          JFORM2 = NINT(DVAL)
          IF (JFORM2 < 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JFORM2,' is an invalid value for JFORM2'
              JFORM2 = 1
              WRITE (KW,*) '            It should be nonnegative.  JFORM2 was set to ',JFORM2
          ENDIF
      ELSE IF (VARNAME == 'JFORMZ') THEN
          JFORMZ = NINT(DVAL)
          IF (JFORMZ < 1 .OR. JFORMZ > 3) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JFORMZ,' is an invalid value for JFORMZ'
              JFORMZ = 1
              WRITE (KW,*) '            Valid values are 1,2,3.  JFORMZ was set to ',JFORMZ
          ENDIF
      ELSE IF (VARNAME == 'JPRNTZ') THEN
          JPRNTZ = NINT(DVAL)
          IF (JPRNTZ < 1 .OR. JPRNTZ > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JPRNTZ,' is an invalid value for JPRNTZ'
              JPRNTZ = 1
              WRITE (KW,*) '            Valid values are 1,2.  JPRNTZ was set to ',JPRNTZ
          ENDIF
      ELSE IF (VARNAME == 'KACCSW') THEN
          KACCSW = NINT(DVAL)
          IF (KACCSW < 0 .OR. KACCSW > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KACCSW,' is an invalid value for KACCSW'
              KACCSW = 0
              WRITE (KW,*) '            Valid values are 0,1.  KACCSW was set to ',KACCSW
          ENDIF
      ELSE IF (VARNAME == 'KDEBUG') THEN
          KDEBUG = NINT(DVAL)
          IF (KDEBUG < 0 .OR. KDEBUG > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KDEBUG,' is an invalid value for KDEBUG'
              KDEBUG = 1
              WRITE (KW,*) '            Valid values are 0,1.  KDEBUG was set to ',KDEBUG
          ENDIF
      ELSE IF (VARNAME == 'KESWCH') THEN
          KESWCH = NINT(DVAL)
          IF (KESWCH < 0 .OR. KESWCH > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KESWCH,' is an invalid value for KESWCH'
              KESWCH = 1
              WRITE (KW,*) '            Valid values are 0,1.  KESWCH was set to ',KESWCH
          ENDIF
      ELSE IF (VARNAME == 'KRAD') THEN
          KRAD = NINT(DVAL)
          IF (KRAD < 0 .OR. KRAD > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KRAD,' is an invalid value for KRAD'
              KRAD = 1
              WRITE (KW,*) '            Valid values are 0,1.  KRAD was set to ',KRAD
          ENDIF
      ELSE IF (VARNAME == 'KROUND') THEN
          KROUND = NINT(DVAL)
          IF (KROUND < -1 .OR. KROUND > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KROUND,' is an invalid value for KROUND'
              KROUND = 1
              WRITE (KW,*) '            Valid values are -1,0,1,2.  KROUND was set to ',KROUND
          ENDIF
      ELSE IF (VARNAME == 'KRPERF') THEN
          KRPERF = NINT(DVAL)
          IF (KRPERF < 0 .OR. KRPERF > 1) THEN
              KRPERF = 0
          ENDIF
          WRITE (KW,*) ' '
          WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
          WRITE (KW,*) '            KRPERF is no longer used.  Now perfect rounding is ',  &
                       'always done.'
          WRITE (KW,*) ' '
      ELSE IF (VARNAME == 'KSWIDE') THEN
          KSWIDE = NINT(DVAL)
          IF (KSWIDE < 10) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KSWIDE,' is an invalid value for KSWIDE'
              KSWIDE = 80
              WRITE (KW,*) '            It should be 10 or more.  KSWIDE was set to ',KSWIDE
          ENDIF
      ELSE IF (VARNAME == 'KW') THEN
          KW = NINT(DVAL)
      ELSE IF (VARNAME == 'KWARN') THEN
          KWARN = NINT(DVAL)
          IF (KWARN < 0 .OR. KWARN > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KWARN,' is an invalid value for KWARN'
              KWARN = 1
              WRITE (KW,*) '            Valid values are 0,1,2.  KWARN was set to ',KWARN
          ENDIF
      ELSE IF (VARNAME == 'LVLTRC') THEN
          LVLTRC = NINT(DVAL)
          IF (LVLTRC < 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',LVLTRC,' is an invalid value for LVLTRC'
              LVLTRC = 1
              WRITE (KW,*) '            It should be nonnegative.  LVLTRC was set to ',LVLTRC
          ENDIF
      ELSE IF (VARNAME == 'NDIG') THEN
          IVAL = NDIG
          NDIG = NINT(DVAL)
          IF (NDIG < 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',NDIG,' is an invalid value for NDIG'
              NDIG = IVAL
              WRITE (KW,*) '            It should be > 1.  NDIG was not changed from ',NDIG
          ENDIF
      ELSE IF (VARNAME == 'NTRACE') THEN
          NTRACE = NINT(DVAL)
          IF (NTRACE < -2 .OR. NTRACE > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',NTRACE,' is an invalid value for NTRACE'
              NTRACE = 0
              WRITE (KW,*) '            Valid values are -2,-1,0,1,2.  NTRACE was set to ',NTRACE
          ENDIF
      ELSE IF (VARNAME == 'MBASE') THEN
          MVAL = MBASE
          MBASE = AINT (0.5 + DVAL)
          IF (MBASE < 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',MBASE,' is an invalid value for MBASE'
              MBASE = MVAL
              WRITE (KW,*) '            It should be > 1.  MBASE was not changed from ',MBASE
          ENDIF
          IF (MBASE > MXBASE) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',MBASE,' is an invalid value for MBASE'
              MBASE = MVAL
              WRITE (KW,*) '            It should be <= ',MXBASE,  &
                           '.  MBASE was not changed from ',MBASE
          ENDIF
      ELSE IF (VARNAME == 'MXEXP') THEN
          MXEXP = AINT (DVAL)
          IF (MXEXP < 10 .OR. MXEXP > MXEXP2/2.01D0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',MXEXP,' is an invalid value for MXEXP'
              MXEXP = INT(MXEXP2/2.01D0)
              WRITE (KW,*) '            Valid values are 10 to ',  &
                           INT(MXEXP2/2.01D0),'  MXEXP was set to ',MXEXP
          ENDIF
      ELSE
          WRITE (KW,*) ' Variable name not recognized in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF

      CALL FMCONS
      RETURN
      END SUBROUTINE FMSETVAR

      SUBROUTINE FMSIGN(MA,MB,MC)

!  MC = SIGN(MA,MB)

!  MC is set to ABS(MA) if MB is positive or zero, or -ABS(MA) if MB is negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KWRNSV

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMSIGN'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (MWK(START(MB)) >= 0) THEN
          CALL FMEQ(MA,MC)
          MWK(START(MC)) = 1
      ELSE
          CALL FMEQ(MA,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
      ENDIF

      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSIGN

      SUBROUTINE FMSIN(MA,MB)

!  MB = SIN(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),-6,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE IF (MWK(START(MA)) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMSIN    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMSIN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      CALL FMEQU(MA,MXY(6),NDSAVE,NDIG)
      MWK(START(MXY(6))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(6))) = 1
      CALL FMEQ(MXY(6),MXY(5))
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(6))
          GO TO 120
      ENDIF

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1))
          CALL FMSUB(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0 .AND. JSWAP == 0) THEN
              CALL FMST2M('0.5',MXY(1))
              CALL FMMPYI(MXY(1),JSIN,MXY(6))
              GO TO 120
          ENDIF
      ENDIF
      KWARN = KWRNSV
      IF (MWK(START(MXY(6))+2) == MUNKNO) THEN
          IF (KRAD /= 1 .OR. JSWAP == 0) THEN
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
              GO TO 120
          ENDIF
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(3))
              NDIG = NDSV
          ENDIF
          CALL FMDIV(MXY(5),MPISAV,MXY(3))
          CALL FMMPYI_R1(MXY(3),2)
          CALL FMNINT(MXY(3),MXY(2))
          CALL FMMPY(MXY(2),MPISAV,MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMSUB_R2(MXY(5),MXY(1))
          IF (MWK(START(MXY(1))+3) == 0) CALL FMULP(MXY(5),MXY(1))
          CALL FMI2M(1,MXY(3))
          CALL FMSQR_R1(MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMSUB_R2(MXY(3),MXY(1))
          CALL FMSUB_R1(MXY(1),MXY(3))
          IF (MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(JSIN,MXY(6))
          ELSE
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
          ENDIF
          GO TO 120
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(4))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(6),MPISAV)
          CALL FMDIVI_R1(MXY(6),180)
      ENDIF
      IF (MWK(START(MXY(6))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MWK(START(MXY(6))+2) < 0 .OR. NDIG <= 50) THEN
                  CALL FMSIN2(MXY(6),MXY(4))
                  CALL FMEQ(MXY(4),MXY(6))
              ELSE
                  CALL FMCOS2(MXY(6),MXY(4))
                  CALL FMI2M(1,MXY(2))
                  CALL FMSQR_R1(MXY(4))
                  CALL FMSUB_R2(MXY(2),MXY(4))
                  CALL FMSQRT(MXY(4),MXY(6))
              ENDIF
          ELSE
              CALL FMCOS2(MXY(6),MXY(4))
              CALL FMEQ(MXY(4),MXY(6))
          ENDIF
      ENDIF

!             Append the sign, round, and return.

      IF (JSIN == -1 .AND. MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))
  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSIN

      SUBROUTINE FMSIN2(MA,MB)

!  Internal subroutine for MB = SIN(MA) where 0 <= MA <= 1.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K,K2,KTHREE,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG3,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series
!                  SIN(X) = X - X**3/3! + X**5/5! - ...

!             The argument will be divided by 3**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG3 = LOG(3.0)
      ALOGT = LOG(T)
      TJ = 0.55*(NDIG*ALOGMT)**0.3333
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      K2 = MAX(1,INT(0.62*(NDIG*ALOGMT)**0.3333 - 0.8))

      TJ = -(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
             REAL(MWK(START(MA)+4))/(B*B)))/ALOG3 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3)) + .33)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ENDIF

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3))
      L2 = INT((LOG(1+REAL(N2)/3.0D0**K2)+K2*LOG(3.0D0))/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Divide the argument by 3**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTHREE = 1
      MAXV = MXBASE/3
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTHREE = 3*KTHREE
             IF (KTHREE > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTHREE)
                 KTHREE = 1
             ENDIF
          ENDDO
          IF (KTHREE > 1) CALL FMCSDIVI_R1(MXY(1),KTHREE)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      CALL FMI2M(1,MJSUMS(1))
      CALL FMI2M(1,MXY(2))
      NTERM = 3
      DO J = 2, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMCSDIVI_R1(MXY(2),NBOT)
         CALL FMEQ(MXY(2),MJSUMS(J))
         NTERM = NTERM + 2
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),2*J2,MXY(3))
      IF (MWK(START(MXY(3))+2) < -NDIG) GO TO 120

  110 CALL FMCSMPY_R1(MXY(2),MXY(3))
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMSQR(MXY(1),MXY(2))
      IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
          MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      CALL FMEQ(MJSUMS(J2),MXY(3))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(2))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
      ENDDO
      CALL FMCSMPY_R1(MXY(3),MXY(1))

!             Reverse the effect of reducing the argument to compute SIN(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          CALL FMI2M(3,MXY(1))
          DO J = 1, K2
             CALL FMSQR(MXY(3),MXY(2))
             CALL FMCSMPYI_R1(MXY(2),-4)
             CALL FMADD_R2(MXY(1),MXY(2))
             CALL FMCSMPY_R1(MXY(3),MXY(2))
          ENDDO
      ENDIF

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSIN2

      SUBROUTINE FMSINH(MA,MB)

!  MB = SINH(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSINH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),6,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE IF (MWK(START(MA)) >= 0 .AND. KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSINH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMSINH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMSINH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      IF (MWK(START(MA)+3) == 0) THEN
          GO TO 120
      ENDIF
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(3))) = 1

!             Use a series for small arguments, FMEXP for large ones.

      IF (MWK(START(MXY(3))+2) == MUNKNO) GO TO 120
      IF (MBASE > 99) THEN
          IF (MWK(START(MXY(3))+2) <= 0) THEN
              NMETHD = 1
          ELSE IF (MWK(START(MXY(3))+2) >= 2) THEN
              NMETHD = 2
          ELSE IF (ABS(MWK(START(MXY(3))+3)) < 10) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(3))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          IF (MWK(START(MXY(3))+2) < 0 .OR. NDIG <= 50) THEN
              CALL FMSNH2(MXY(3),MXY(4))
              CALL FMEQ(MXY(4),MXY(3))
          ELSE
              CALL FMCSH2(MXY(3),MXY(4))
              CALL FMI2M(1,MXY(2))
              CALL FMSQR_R1(MXY(4))
              CALL FMSUB_R1(MXY(4),MXY(2))
              CALL FMSQRT(MXY(4),MXY(3))
          ENDIF
      ELSE
          CALL FMEXP(MXY(3),MXY(5))
          CALL FMEQ(MXY(5),MXY(3))
          IF (MWK(START(MXY(3))+2) == MEXPOV) THEN
              GO TO 120
          ELSE IF (MWK(START(MXY(3))+2) == MEXPUN) THEN
              MWK(START(MXY(3))+2) = MEXPOV
              GO TO 120
          ENDIF
          IF (INT(MWK(START(MXY(3))+2)) <= (NDIG+1)/2) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMDIV_R1(MXY(1),MXY(3))
              CALL FMSUB_R1(MXY(3),MXY(1))
          ENDIF
          CALL FMDIVI_R1(MXY(3),2)
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
          MWK(START(MXY(3))) = -MWK(START(MXY(3)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSINH

      SUBROUTINE FMSNH2(MA,MB)

!  Internal subroutine for MB = SINH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K,K2,KTHREE,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG3,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series
!                  SINH(X) = X + X**3/3! + X**5/5! - ...

!             The argument will be divided by 3**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG3 = LOG(3.0)
      ALOGT = LOG(T)
      TJ = 0.67*(NDIG*ALOGMT)**0.3333 - 0.3
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2,LJSUMS))
      K2 = MAX(2,INT(0.6*(NDIG*ALOGMT)**0.3333 - 0.8))

      TJ = -(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
             REAL(MWK(START(MA)+4))/(B*B)))/ALOG3 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3))
      L2 = INT(LOG(REAL(N2)+3.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Divide the argument by 3**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTHREE = 1
      MAXV = MXBASE/3
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTHREE = 3*KTHREE
             IF (KTHREE > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTHREE)
                 KTHREE = 1
             ENDIF
          ENDDO
          IF (KTHREE > 1) CALL FMCSDIVI_R1(MXY(1),KTHREE)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 1
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NBOT > 1) CALL FMCSDIVI_R1(MXY(2),NBOT)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J))
      ENDDO
      CALL FMSQR_R1(MXY(1))
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3))

  110 CALL FMCSMPY_R1(MXY(2),MXY(3))
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(3))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
      ENDDO

!             Reverse the effect of reducing the argument to compute SINH(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          CALL FMI2M(3,MXY(1))
          DO J = 1, K2
             CALL FMSQR(MXY(3),MXY(2))
             CALL FMCSMPYI_R1(MXY(2),4)
             CALL FMADD_R2(MXY(1),MXY(2))
             CALL FMCSMPY_R1(MXY(3),MXY(2))
          ENDDO
      ENDIF

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSNH2

      SUBROUTINE FMSP2M(X,MA)

!  MA = X

!  Convert a single precision number to FM format.

!  This version tries to convert the single precision machine number to FM with accuracy of nearly
!  full FM precision.
!  If conversion to FM with approximately double precision accuracy is good enough, it is faster to
!  CALL FMDPM(DBLE(X),MA)

      USE FMVALS
      IMPLICIT NONE

      REAL :: X
      INTEGER :: MA

      DOUBLE PRECISION :: XDP,Y,YT
      INTEGER :: J,K
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMSP2M'
      XDP = DBLE(X)
      IF (NTRACE /= 0) CALL FMNTRR(2,XDP,1)

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          GO TO 110
      ENDIF

!             Check to see if X is exactly a small integer.  If so, converting as an integer
!             is better.  Also see if X is exactly a small integer divided by a small power of two.

      Y = MXEXP2
      IF (ABS(XDP) < Y) THEN
          K = INT(XDP)
          Y = K
          IF (Y == XDP) THEN
              CALL FMIM(K,MA)
              GO TO 110
          ENDIF
      ENDIF
      IF (ABS(XDP) < 1.0D0) THEN
          Y = 4096.0D0 * XDP
          K = INT(Y)
          YT = K
          IF (Y == YT) THEN
              CALL FMIM(K,MA)
              CALL FMDIVI_R1(MA,4096)
              GO TO 110
          ENDIF
      ENDIF

      CALL FMDM2(XDP,MA)

  110 IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSP2M

      SUBROUTINE FMSQR(MA,MB)

!  MB = MA*MA    Faster than using FMMPY.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSQR'
          CALL FMNTR(2,MA,MA,1,1)

          CALL FMSQR2(MA,MB)

          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMSQR2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR

      SUBROUTINE FMSQR2(MA,MB)

!  MB = MA*MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MAXMAX,MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MD2B,MK,MKA,MKT,MMAX,MR,MT
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JMA,JMWA,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KR_RETRY,KSHIFT,KWA,L,N1,NGUARD,  &
                 NMETHD,NZDA
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      KSQR = 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      KR_RETRY = 0
      JRSSAV = JRSIGN
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. KDEBUG == 1 .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MA,MB)
          NCALL = NCALL - 1
          IF ((KFLAG < 0 .AND. KOVUN == 0) .OR. (KFLAG == -4 .AND. KOVUN == 1)) THEN
              NAMEST(NCALL) = 'FMSQR'
              CALL FMWARN
          ENDIF
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          GO TO 130
      ENDIF
      KFLAG = 0

!             Check for using an FFT-based method if precision is very high.

      C = 1300
      IF (NDIG >= C) THEN
          NZDA = 0
          DO J = 2, NDIG
             IF (MWK(START(MA)+J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (NDIG-NZDA < 50 .OR. REAL(NZDA)/NDIG > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPY2(MA,MA,MB)
          GO TO 130
      ENDIF

      MAXMAX = 0
      MACCA = MWK(START(MA)+1)
      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MA)+2)

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MA)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MA)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 120
                 ENDIF
              ENDDO
          ENDIF

  120     MWK(START(MWA)+3) = 0
          MWK(START(MWA)+4) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 3, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, MIN(L/2,N1)
             MBJ = MWK(START(MA)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = 2*J, JM1+KL
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1
          IF (2*MAX(MAXMAX,MAXMWA)+MBASE > MMAX) THEN
              DO KB = L, 4, -1
                 MKT = INT (MWK(JMWA+KB)/MBASE)
                 MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
                 MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
              ENDDO
          ENDIF

          DO J = 3, L-1, 2
             IF ((J+1)/2 <= N1) THEN
                 MKA = MWK(JMA+(J+1)/2)
                 MWK(JMWA+J) = 2*MWK(JMWA+J) + MKA*MKA
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ELSE
                 MWK(JMWA+J) = 2*MWK(JMWA+J)
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MWK(JMA+(L+1)/2)
                  MWK(JMWA+L) = 2*MWK(JMWA+L) + MKA*MKA
              ELSE
                  MWK(JMWA+L) = 2*MWK(JMWA+L)
              ENDIF
          ENDIF

          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MA)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplication is complete.  Round the result and move it to MB.

      JRSIGN = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMSQR'
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF
  130 MWK(START(MB)) = 1
      KSQR = 0
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR2

      SUBROUTINE FMSQR_R1(MA)

!  MA = MA*MA    Faster than using FMMPY.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSQR_R1'
          CALL FMNTR(2,MA,MA,1,1)

          CALL FMSQR2_R1(MA)

          NAMEST(NCALL) = 'FMSQR_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMSQR2_R1(MA)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR_R1

      SUBROUTINE FMSQR2_R1(MA)

!  MA = MA*MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      REAL (KIND(1.0D0)) :: MACCA,MAXMAX,MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MD2B,MK,MKA,MKT,MMAX,MR,MT
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JMA,JMWA,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KR_RETRY,KSHIFT,KWA,L,N1,NGUARD,  &
                 NMETHD,NZDA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      KSQR = 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      KR_RETRY = 0
      JRSSAV = JRSIGN
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. KDEBUG == 1 .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MA,MXY(1))
          CALL FMEQ(MXY(1),MA)
          NCALL = NCALL - 1
          IF ((KFLAG < 0 .AND. KOVUN == 0) .OR. (KFLAG == -4 .AND. KOVUN == 1)) THEN
              NAMEST(NCALL) = 'FMSQR_R1'
              CALL FMWARN
          ENDIF
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          GO TO 130
      ENDIF
      KFLAG = 0

!             Check for using an FFT-based method if precision is very high.

      C = 1300
      IF (NDIG >= C) THEN
          NZDA = 0
          DO J = 2, NDIG
             IF (MWK(START(MA)+J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (NDIG-NZDA < 50 .OR. REAL(NZDA)/NDIG > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPY2(MA,MA,MXY(1))
          CALL FMEQ(MXY(1),MA)
          GO TO 130
      ENDIF

      MAXMAX = 0
      MACCA = MWK(START(MA)+1)
      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MA)+2)

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MA)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MA)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 120
                 ENDIF
              ENDDO
          ENDIF

  120     MWK(START(MWA)+3) = 0
          MWK(START(MWA)+4) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 3, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, MIN(L/2,N1)
             MBJ = MWK(START(MA)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = 2*J, JM1+KL
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1
          IF (2*MAX(MAXMAX,MAXMWA)+MBASE > MMAX) THEN
              DO KB = L, 4, -1
                 MKT = INT (MWK(JMWA+KB)/MBASE)
                 MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
                 MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
              ENDDO
          ENDIF

          DO J = 3, L-1, 2
             IF ((J+1)/2 <= N1) THEN
                 MKA = MWK(JMA+(J+1)/2)
                 MWK(JMWA+J) = 2*MWK(JMWA+J) + MKA*MKA
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ELSE
                 MWK(JMWA+J) = 2*MWK(JMWA+J)
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MWK(JMA+(L+1)/2)
                  MWK(JMWA+L) = 2*MWK(JMWA+L) + MKA*MKA
              ELSE
                  MWK(JMWA+L) = 2*MWK(JMWA+L)
              ENDIF
          ENDIF

          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MA)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplication is complete.  Round the result and move it to MA.

      JRSIGN = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMSQR_R1'
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MA)+1) = MACCA
      ENDIF
  130 MWK(START(MA)) = 1
      KSQR = 0
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR2_R1

      SUBROUTINE FMSQRT(MA,MB)

!  MB = SQRT(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: DC,DP,ERR,X,XB
      REAL (KIND(1.0D0)) :: MA1,MACCA,MD2B,MKE,MXSAVE
      INTEGER :: NSTACK(49),J,JPT,K,KASAVE,KL,KMA1,KN,KOVUN,KRESLT,KST,KR_RETRY,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR2('FMSQRT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'FMSQRT'
              CALL FMNTR(2,MA,MA,1,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

      MA1 = MWK(START(MA)+2)

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      NMETHD = 1
      IF (MBASE >= 1000 .AND. MBASE <= MXBASE/1.5D0 .AND. NDIG*ALOGMT < 1400) THEN
          NMETHD = 4
      ELSE IF (NDIG*ALOGMT > 50000) THEN
          NMETHD = 3
      ELSE IF (NDIG*ALOGMT > 2750) THEN
          NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 130
      IF (NMETHD == 3) GO TO 140
      IF (NMETHD == 4) GO TO 150

!             Method 1.  Ordinary Newton iteration.

!             Generate the first approximation.

  120 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMCSDIV(MXY(2),MXY(3),MXY(1))
         CALL FMCSADD_R1(MXY(3),MXY(1))
         CALL FMCSDIVI_R1(MXY(3),2)
      ENDDO

      GO TO 160

!             Method 2.  Modified Newton iteration.
!                        x2 = x1 - (x1^2 - a) / (2*x1)
!                        where the square is done at full current precision,
!                        and the division is done at half current precision.

!             Generate the first approximation.

  130 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(1))
         CALL FMSUB_R1(MXY(1),MXY(2))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMADD(MXY(3),MXY(3),MXY(4))
         CALL FMDIV_R2(MXY(1),MXY(4))
         NDIG = NSTACK(J)
         CALL FMSUB_R1(MXY(3),MXY(4))
      ENDDO

      GO TO 160

!             Method 3.  Karp's method.  Newton iteration for 1/sqrt(a)
!                        x2 = x1 + (1 - a*x1**2)*x1/2
!                        where a*x1**2 is done at full current precision,
!                        and *x1/2 is done at half current precision.

!             Generate the first approximation to 1/sqrt(a).

  140 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = 1.0D0/SQRT(X)
      MKE = -MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = -(MA1+1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(1,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration for 1/sqrt(a).

      DO J = 1, KST-1
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(4))
         CALL FMMPY_R2(MXY(2),MXY(4))
         CALL FMSUB_R2(MXY(1),MXY(4))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMMPY_R2(MXY(3),MXY(4))
         CALL FMDIVI_R1(MXY(4),2)
         NDIG = NSTACK(J)
         CALL FMADD_R1(MXY(3),MXY(4))
      ENDDO

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      NDIG = NSTACK(KST)
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY(MXY(2),MXY(3),MXY(4))
      NDIG = NSTACK(KST)
      CALL FMSQR(MXY(4),MXY(1))
      CALL FMSUB_R2(MXY(2),MXY(1))
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY_R2(MXY(3),MXY(1))
      CALL FMDIVI_R1(MXY(1),2)
      NDIG = NSTACK(KST)
      CALL FMADD(MXY(4),MXY(1),MXY(3))
      GO TO 160

!             Method 4.  Direct method.

  150 CALL FMI2M(1,MXY(1))
      CALL FMI2M(1,MXY(3))
      CALL FMI2M(1,MXY(4))
      MWK(START(MXY(1))+3) = MWK(START(MXY(2))+3)
      MWK(START(MXY(1))+2) = 1
      DC = MWK(START(MXY(1))+3)
      JPT = 2
      KN = MAX(1,INT(MAXINT/(2*MBASE**2)-5))
      IF (MOD(INT(ABS(MWK(START(MXY(2))+2))),2) == 0) THEN
          MWK(START(MXY(1))+2) = 1
          MWK(START(MXY(1))+3) = MWK(START(MXY(2))+3) * MBASE + MWK(START(MXY(2))+4)
          DC = MWK(START(MXY(1))+3)
          JPT = 3
      ENDIF
      X = INT(SQRT(DC))
      MKE = 2
      IF (MOD(MWK(START(MXY(2))+2),MKE) == 0) THEN
          MWK(START(MXY(3))+2) = MWK(START(MXY(2))+2) / 2
      ELSE
          MWK(START(MXY(3))+2) = (MWK(START(MXY(2))+2)+1) / 2
      ENDIF
      MWK(START(MXY(3))+3) = X
      MWK(START(MXY(4))+2) = 1
      MKE = X
      MWK(START(MXY(4))+3) = MKE*MKE
      MWK(START(MXY(1))+3) = MWK(START(MXY(1))+3) - MWK(START(MXY(4))+3)
      DO J = 2, NDIG
         MWK(START(MXY(1))+2) = MWK(START(MXY(1))+2) + 2
         IF (JPT <= NDIG) THEN
             MWK(START(MXY(1))+J+2) = MWK(START(MXY(2))+JPT+2)
         ENDIF
         IF (JPT+1 <= NDIG) THEN
             MWK(START(MXY(1))+J+3) = MWK(START(MXY(2))+JPT+3)
         ENDIF
         JPT = JPT + 2
         DC = MWK(START(MXY(1))+3)
         IF (NDIG >= 4) THEN
             DC = ((DC*MBASE + MWK(START(MXY(1))+4))*MBASE + MWK(START(MXY(1))+5))*MBASE +  &
                   MWK(START(MXY(1))+6)
         ELSE IF (NDIG == 3) THEN
             DC = ((DC*MBASE + MWK(START(MXY(1))+4))*MBASE + MWK(START(MXY(1))+5))*MBASE
         ELSE
             DC = ((DC*MBASE + MWK(START(MXY(1))+4))*MBASE)*MBASE
         ENDIF
         IF (J <= 4) THEN
             DP = MWK(START(MXY(3))+3)
             IF (NDIG >= 3) THEN
                 DP = (DP*MBASE + MWK(START(MXY(3))+4))*MBASE + MWK(START(MXY(3))+5)
             ELSE
                 DP = (DP*MBASE + MWK(START(MXY(3))+4))*MBASE
             ENDIF
         ENDIF
         IF (J <= 2) THEN
             DC = DC*DBLE(MBASE)**INT(MWK(START(MXY(1))+2)-4)
             DP = DP*DBLE(MBASE)**(J-4)
             X = FLOOR(DP*MBASE*(SQRT(1+DC/(DP*MBASE)**2)-1))
         ELSE
             IF (INT(MWK(START(MXY(1))+2))-J-1 /= 0) THEN
                 DC = DC*DBLE(MBASE)**(INT(MWK(START(MXY(1))+2))-J-1)
             ENDIF
             X = FLOOR(DC/(2.0D0*DP))
         ENDIF
         IF (ABS(2.0D0 * X * MBASE) >= MAXINT) THEN
             GO TO 120
         ENDIF
         MWK(START(MXY(4))+2) = J
         KL = MIN(J,NDIG/2+2+NDIG/10)
         DO K = 2, KL
            MKE = X
            MWK(START(MXY(4))+K+1) = 2 * MKE * MWK(START(MXY(3))+K+1)
         ENDDO
         MKE = X
         MWK(START(MXY(4))+J+2) = MKE * MKE
         MWK(START(MXY(3))+J+2) = X
         IF (J == NDIG) EXIT
         IF (MWK(START(MXY(1))+2) - MWK(START(MXY(4))+2) /= 1) THEN
             GO TO 120
         ENDIF
         MWK(START(MXY(1))+2) = MWK(START(MXY(1))+2) - 1
         MWK(START(MXY(1))+3) = MWK(START(MXY(1))+3) * MBASE + MWK(START(MXY(1))+4) -  &
                                  MWK(START(MXY(4))+3)
         KL = MIN(J,NDIG/2+2+NDIG/10)
         DO K = 4, KL+2
            MWK(START(MXY(1))+K) = MWK(START(MXY(1))+K+1) - MWK(START(MXY(4))+K)
         ENDDO
         MWK(START(MXY(1))+J+3) = 0
         IF (MOD(J,KN) == 0) THEN
             DO K = J+2, 4, -1
                IF (MOD(MWK(START(MXY(1))+K),MBASE) == 0) THEN
                    KL = MWK(START(MXY(1))+K) / MBASE
                ELSE IF (MWK(START(MXY(1))+K) > 0) THEN
                    KL = MWK(START(MXY(1))+K) / MBASE
                ELSE
                    KL = MWK(START(MXY(1))+K) / MBASE - 1
                ENDIF
                MWK(START(MXY(1))+K-1) = MWK(START(MXY(1))+K-1) + KL
                MWK(START(MXY(1))+K) = MWK(START(MXY(1))+K) - KL*MBASE
             ENDDO
         ENDIF
      ENDDO
      DO K = NDIG+2, 4, -1
         IF (MWK(START(MXY(3))+K) >= 0 .AND. MWK(START(MXY(3))+K) < MBASE) CYCLE
         IF (MOD(MWK(START(MXY(3))+K),MBASE) == 0) THEN
             KL = MWK(START(MXY(3))+K) / MBASE
         ELSE IF (MWK(START(MXY(3))+K) > 0) THEN
             KL = MWK(START(MXY(3))+K) / MBASE
         ELSE
             KL = MWK(START(MXY(3))+K) / MBASE - 1
         ENDIF
         MWK(START(MXY(3))+K-1) = MWK(START(MXY(3))+K-1) + KL
         MWK(START(MXY(3))+K) = MWK(START(MXY(3))+K) - KL*MBASE
      ENDDO

!             Round the result and return.

  160 IF (KASAVE == 1) THEN
          MD2B = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
          MWK(START(MXY(3))+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MXY(3))+1) = MACCA
      ENDIF
      MWK(START(MXY(3))) = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,0)
      IF (KFLAG == 1) KFLAG = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQRT

      SUBROUTINE FMSQRT_R1(MA)

!  MA = SQRT(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: DC,DP,ERR,X,XB
      REAL (KIND(1.0D0)) :: MA1,MACCA,MD2B,MKE,MXSAVE
      INTEGER :: NSTACK(49),J,JPT,K,KASAVE,KL,KMA1,KN,KOVUN,KRESLT,KST,KR_RETRY,NDSAVE,NMETHD
      INTENT (INOUT) :: MA
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR2('FMSQRT_R1',MA,MA,1,1,MXY(3),KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              CALL FMEQ(MXY(3),MA)
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'FMSQRT_R1'
              CALL FMNTR(2,MA,MA,1,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

      MA1 = MWK(START(MA)+2)

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      NMETHD = 1
      IF (MBASE >= 1000 .AND. MBASE <= MXBASE/1.5D0 .AND. NDIG*ALOGMT < 1400) THEN
          NMETHD = 4
      ELSE IF (NDIG*ALOGMT > 50000) THEN
          NMETHD = 3
      ELSE IF (NDIG*ALOGMT > 2750) THEN
          NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 130
      IF (NMETHD == 3) GO TO 140
      IF (NMETHD == 4) GO TO 150

!             Method 1.  Ordinary Newton iteration.

!             Generate the first approximation.

  120 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMCSDIV(MXY(2),MXY(3),MXY(1))
         CALL FMCSADD_R1(MXY(3),MXY(1))
         CALL FMCSDIVI_R1(MXY(3),2)
      ENDDO

      GO TO 160

!             Method 2.  Modified Newton iteration.
!                        x2 = x1 - (x1^2 - a) / (2*x1)
!                        where the square is done at full current precision,
!                        and the division is done at half current precision.

!             Generate the first approximation.

  130 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(1))
         CALL FMSUB_R1(MXY(1),MXY(2))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMADD(MXY(3),MXY(3),MXY(4))
         CALL FMDIV_R2(MXY(1),MXY(4))
         NDIG = NSTACK(J)
         CALL FMSUB_R1(MXY(3),MXY(4))
      ENDDO

      GO TO 160

!             Method 3.  Karp's method.  Newton iteration for 1/sqrt(a)
!                        x2 = x1 + (1 - a*x1**2)*x1/2
!                        where a*x1**2 is done at full current precision,
!                        and *x1/2 is done at half current precision.

!             Generate the first approximation to 1/sqrt(a).

  140 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = 1.0D0/SQRT(X)
      MKE = -MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = -(MA1+1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(1,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration for 1/sqrt(a).

      DO J = 1, KST-1
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(4))
         CALL FMMPY_R2(MXY(2),MXY(4))
         CALL FMSUB_R2(MXY(1),MXY(4))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMMPY_R2(MXY(3),MXY(4))
         CALL FMDIVI_R1(MXY(4),2)
         NDIG = NSTACK(J)
         CALL FMADD_R1(MXY(3),MXY(4))
      ENDDO

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      NDIG = NSTACK(KST)
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY(MXY(2),MXY(3),MXY(4))
      NDIG = NSTACK(KST)
      CALL FMSQR(MXY(4),MXY(1))
      CALL FMSUB_R2(MXY(2),MXY(1))
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY_R2(MXY(3),MXY(1))
      CALL FMDIVI_R1(MXY(1),2)
      NDIG = NSTACK(KST)
      CALL FMADD(MXY(4),MXY(1),MXY(3))
      GO TO 160

!             Method 4.  Direct method.

  150 CALL FMI2M(1,MXY(1))
      CALL FMI2M(1,MXY(3))
      CALL FMI2M(1,MXY(4))
      MWK(START(MXY(1))+3) = MWK(START(MXY(2))+3)
      MWK(START(MXY(1))+2) = 1
      DC = MWK(START(MXY(1))+3)
      JPT = 2
      KN = MAX(1,INT(MAXINT/(2*MBASE**2)-5))
      IF (MOD(INT(ABS(MWK(START(MXY(2))+2))),2) == 0) THEN
          MWK(START(MXY(1))+2) = 1
          MWK(START(MXY(1))+3) = MWK(START(MXY(2))+3) * MBASE + MWK(START(MXY(2))+4)
          DC = MWK(START(MXY(1))+3)
          JPT = 3
      ENDIF
      X = INT(SQRT(DC))
      MKE = 2
      IF (MOD(MWK(START(MXY(2))+2),MKE) == 0) THEN
          MWK(START(MXY(3))+2) = MWK(START(MXY(2))+2) / 2
      ELSE
          MWK(START(MXY(3))+2) = (MWK(START(MXY(2))+2)+1) / 2
      ENDIF
      MWK(START(MXY(3))+3) = X
      MWK(START(MXY(4))+2) = 1
      MKE = X
      MWK(START(MXY(4))+3) = MKE*MKE
      MWK(START(MXY(1))+3) = MWK(START(MXY(1))+3) - MWK(START(MXY(4))+3)
      DO J = 2, NDIG
         MWK(START(MXY(1))+2) = MWK(START(MXY(1))+2) + 2
         IF (JPT <= NDIG) THEN
             MWK(START(MXY(1))+J+2) = MWK(START(MXY(2))+JPT+2)
         ENDIF
         IF (JPT+1 <= NDIG) THEN
             MWK(START(MXY(1))+J+3) = MWK(START(MXY(2))+JPT+3)
         ENDIF
         JPT = JPT + 2
         DC = MWK(START(MXY(1))+3)
         IF (NDIG >= 4) THEN
             DC = ((DC*MBASE + MWK(START(MXY(1))+4))*MBASE + MWK(START(MXY(1))+5))*MBASE +  &
                   MWK(START(MXY(1))+6)
         ELSE IF (NDIG == 3) THEN
             DC = ((DC*MBASE + MWK(START(MXY(1))+4))*MBASE + MWK(START(MXY(1))+5))*MBASE
         ELSE
             DC = ((DC*MBASE + MWK(START(MXY(1))+4))*MBASE)*MBASE
         ENDIF
         IF (J <= 4) THEN
             DP = MWK(START(MXY(3))+3)
             IF (NDIG >= 3) THEN
                 DP = (DP*MBASE + MWK(START(MXY(3))+4))*MBASE + MWK(START(MXY(3))+5)
             ELSE
                 DP = (DP*MBASE + MWK(START(MXY(3))+4))*MBASE
             ENDIF
         ENDIF
         IF (J <= 2) THEN
             DC = DC*DBLE(MBASE)**INT(MWK(START(MXY(1))+2)-4)
             DP = DP*DBLE(MBASE)**(J-4)
             X = FLOOR(DP*MBASE*(SQRT(1+DC/(DP*MBASE)**2)-1))
         ELSE
             IF (INT(MWK(START(MXY(1))+2))-J-1 /= 0) THEN
                 DC = DC*DBLE(MBASE)**(INT(MWK(START(MXY(1))+2))-J-1)
             ENDIF
             X = FLOOR(DC/(2.0D0*DP))
         ENDIF
         IF (ABS(2.0D0 * X * MBASE) >= MAXINT) THEN
             GO TO 120
         ENDIF
         MWK(START(MXY(4))+2) = J
         KL = MIN(J,NDIG/2+2+NDIG/10)
         DO K = 2, KL
            MKE = X
            MWK(START(MXY(4))+K+1) = 2 * MKE * MWK(START(MXY(3))+K+1)
         ENDDO
         MKE = X
         MWK(START(MXY(4))+J+2) = MKE * MKE
         MWK(START(MXY(3))+J+2) = X
         IF (J == NDIG) EXIT
         IF (MWK(START(MXY(1))+2) - MWK(START(MXY(4))+2) /= 1) THEN
             GO TO 120
         ENDIF
         MWK(START(MXY(1))+2) = MWK(START(MXY(1))+2) - 1
         MWK(START(MXY(1))+3) = MWK(START(MXY(1))+3) * MBASE + MWK(START(MXY(1))+4) -  &
                                  MWK(START(MXY(4))+3)
         KL = MIN(J,NDIG/2+2+NDIG/10)
         DO K = 4, KL+2
            MWK(START(MXY(1))+K) = MWK(START(MXY(1))+K+1) - MWK(START(MXY(4))+K)
         ENDDO
         MWK(START(MXY(1))+J+3) = 0
         IF (MOD(J,KN) == 0) THEN
             DO K = J+2, 4, -1
                IF (MOD(MWK(START(MXY(1))+K),MBASE) == 0) THEN
                    KL = MWK(START(MXY(1))+K) / MBASE
                ELSE IF (MWK(START(MXY(1))+K) > 0) THEN
                    KL = MWK(START(MXY(1))+K) / MBASE
                ELSE
                    KL = MWK(START(MXY(1))+K) / MBASE - 1
                ENDIF
                MWK(START(MXY(1))+K-1) = MWK(START(MXY(1))+K-1) + KL
                MWK(START(MXY(1))+K) = MWK(START(MXY(1))+K) - KL*MBASE
             ENDDO
         ENDIF
      ENDDO
      DO K = NDIG+2, 4, -1
         IF (MWK(START(MXY(3))+K) >= 0 .AND. MWK(START(MXY(3))+K) < MBASE) CYCLE
         IF (MOD(MWK(START(MXY(3))+K),MBASE) == 0) THEN
             KL = MWK(START(MXY(3))+K) / MBASE
         ELSE IF (MWK(START(MXY(3))+K) > 0) THEN
             KL = MWK(START(MXY(3))+K) / MBASE
         ELSE
             KL = MWK(START(MXY(3))+K) / MBASE - 1
         ENDIF
         MWK(START(MXY(3))+K-1) = MWK(START(MXY(3))+K-1) + KL
         MWK(START(MXY(3))+K) = MWK(START(MXY(3))+K) - KL*MBASE
      ENDDO

!             Round the result and return.

  160 IF (KASAVE == 1) THEN
          MD2B = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
          MWK(START(MXY(3))+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MXY(3))+1) = MACCA
      ENDIF
      MWK(START(MXY(3))) = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MA,NDSAVE,MXSAVE,KASAVE,0)
      IF (KFLAG == 1) KFLAG = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQRT_R1

      SUBROUTINE FMST2D(STRING,X)

!  STRING contains a free-format number that is converted to double precision and returned in X.

!  The input number may be in integer or any real format. The convention is made that if no digits
!  appear before 'E' then 1.0 is assumed.  For example 'E6' is converted as '1.0E+6'.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: J,JSTATE,KDIGFL,KEXP,KPT,KSIGN,KSIGNX,KSTART,KSTOP,KTYPE,KVAL,N2
      DOUBLE PRECISION :: X,F1,F2

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      CHARACTER :: KBLANK = ' '
      INTENT (IN) :: STRING
      INTENT (INOUT) :: X

      JSTATE = 1
      KSIGN = 1
      F1 = 0.0D0
      F2 = 0.0D0
      N2 = 0
      KSIGNX = 1
      KEXP = 0
      KSTART = 1
      KSTOP = LEN(STRING)
      KFLAG = 0

!             KDIGFL will be 1 if any digits are found before 'E'.

      KDIGFL = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (STRING(J:J) == KBLANK) CYCLE
         KPT = ICHAR(STRING(J:J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) STRING(J:J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF
         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDIGFL = 1
             F1 = 10.0D0*F1 + KVAL

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDIGFL = 1
             F2 = 10.0D0*F2 + KVAL
             N2 = N2 + 1

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDIGFL == 0) F1 = 1.0D0

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             KEXP = 10*KEXP + KVAL

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Form the number and return.

      KEXP = KSIGNX*KEXP
      X = KSIGN*(F1 + F2/10.0D0**N2)*10.0D0**KEXP

      RETURN

!             Error in converting the number.

  110 X = -1.0D+31
      KFLAG = -4
      RETURN
      END SUBROUTINE FMST2D

      SUBROUTINE FMST2M(STRING,MA)

!  MA = STRING

!  Convert a character string to FM format.
!  This is often more convenient than using FMINP, which converts an array of character(1) values.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: MA

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMST2M'
      LB = LEN(STRING)
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF
      KFSAVE = KFLAG

      DO J = 1, LB
         CMBUFF(J) = STRING(J:J)
      ENDDO
      NCALL = NCALL - 1
      CALL FMINP(CMBUFF,MA,1,LB)
      NCALL = NCALL + 1

      IF (KFSAVE /= 0) KFLAG = KFSAVE
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMST2M

      SUBROUTINE FMSUB(MA,MB,MC)

!  MC = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KFLG1
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSUB'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          KSUB = 1
          CALL FMADD2(MA,MB,MC)
          KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0

          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      ELSE
          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0
          KSUB = 1
          CALL FMADD2(MA,MB,MC)
          KSUB = 0
          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSUB

      SUBROUTINE FMSUB_R1(MA,MB)

!  MA = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: KFLG1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSUB_R1'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          KSUB = 1
          CALL FMADD2_R1(MA,MB)
          KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0

          IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      ELSE
          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0
          KSUB = 1
          CALL FMADD2_R1(MA,MB)
          KSUB = 0
          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSUB_R1

      SUBROUTINE FMSUB_R2(MA,MB)

!  MB = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: KFLG1

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSUB_R2'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          KSUB = 1
          CALL FMADD2_R2(MA,MB)
          KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0

          IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      ELSE
          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0
          KSUB = 1
          CALL FMADD2_R2(MA,MB)
          KSUB = 0
          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSUB_R2

      SUBROUTINE FMTAN(MA,MB)

!  MB = TAN(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NDSV,NTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTAN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),3,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE IF (MWK(START(MA)) >= 0 .AND. KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTAN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMTAN    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMTAN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      NTRY = 1
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(5))
          GO TO 130
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
  120 CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(5))) = 1

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      CALL FMRDC(MXY(5),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(45,MXY(1))
          CALL FMSUB(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMMPYI(MXY(1),JSIN/JCOS,MXY(5))
              GO TO 130
          ENDIF
      ENDIF
      IF (MWK(START(MXY(5))+2) == MUNKNO) GO TO 130
      IF (MWK(START(MXY(5))+3) == 0) THEN
          IF (JSWAP == 1) THEN
              KFLAG = -4
              CALL FMWARN
              CALL FMST2M('UNKNOWN',MXY(5))
          ENDIF
          GO TO 130
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(4))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(5),MPISAV)
          CALL FMDIVI_R1(MXY(5),180)
      ENDIF
      IF (MWK(START(MXY(5))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JSIN*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JCOS*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JCOS*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JSIN*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
              ENDIF
          ELSE
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JCOS*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JSIN*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JSIN*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JCOS*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
              ENDIF
          ENDIF
      ENDIF

!             Round and return.

  130 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTAN

      SUBROUTINE FMTANH(MA,MB)

!  MB = TANH(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      LOGICAL :: LCOMP
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X,XT
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),-3,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE IF (MWK(START(MA)) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      J = NTRACE
      NTRACE = 0
      CALL FMABS(MA,MXY(1))
      CALL FMDP2M(DLOGMB*NDIG,MXY(2))
      LCOMP = FMCOMP(MXY(1),'>',MXY(2))
      NTRACE = J
      IF (KROUND /= 1 .AND. LCOMP .AND. MWK(START(MA)+2) /= MUNKNO) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          IF (MWK(START(MA)) < 0 .AND. (KROUND == 0 .OR. KROUND == 2)) THEN
              CALL FMI2M(-1,MXY(1))
              CALL FMTINY(MXY(2))
              CALL FMADD(MXY(1),MXY(2),MXY(3))
          ELSE IF (MWK(START(MA)) > 0 .AND. (KROUND == 0 .OR. KROUND == -1)) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMTINY(MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
          ELSE IF (MWK(START(MA)) < 0) THEN
              CALL FMI2M(-1,MXY(3))
          ELSE
              CALL FMI2M(1,MXY(3))
          ENDIF
          CALL FMEQ(MXY(3),MB)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMTANH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMTANH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      MAS = MWK(START(MA))

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      IF (MWK(START(MA)+3) == 0) THEN
          GO TO 120
      ENDIF
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(5))) = 1

      IF (MWK(START(MA)+2) >= 1) THEN
          XT = REAL((NDIG+1)/2)*ALOGMB
          K = INT(LOG(XT)/ALOGMB)
          IF (MWK(START(MA)+2) > K+1) THEN
              CALL FMI2M(1,MXY(5))
              GO TO 120
          ELSE
              X = REAL(MWK(START(MXY(5))+3)*MBASE+MWK(START(MXY(5))+4))*  &
                  REAL(MBASE)**INT(MWK(START(MXY(5))+2)-2)
              IF (X > XT+5.0) THEN
                  CALL FMI2M(1,MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
      ENDIF
      IF (MWK(START(MXY(5))+2) == 0 .AND. NDIG < 50) THEN
          CALL FMEXP2(MXY(5),MXY(3))
          CALL FMSQR_R1(MXY(3))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB(MXY(3),MXY(1),MXY(2))
          CALL FMADD_R2(MXY(3),MXY(1))
          CALL FMDIV(MXY(2),MXY(1),MXY(5))
          GO TO 120
      ENDIF
      IF (MWK(START(MXY(5))+2) >= 0 .AND. MWK(START(MXY(5))+3) /= 0) THEN
          CALL FMCOSH(MXY(5),MXY(4))
          IF (MWK(START(MXY(4))+2) > NDIG) THEN
              IF (MAS > 0) THEN
                  CALL FMI2M(1,MXY(5))
                  GO TO 120
              ELSE
                  CALL FMI2M(-1,MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
          CALL FMSQR(MXY(4),MXY(2))
          CALL FMI2M(-1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT_R1(MXY(2))
          CALL FMDIV(MXY(2),MXY(4),MXY(5))
      ELSE
          CALL FMSINH(MXY(5),MXY(4))
          CALL FMSQR(MXY(4),MXY(2))
          CALL FMI2M(1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT_R1(MXY(2))
          CALL FMDIV(MXY(4),MXY(2),MXY(5))
      ENDIF

!             Round and return.

  120 KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTANH

      SUBROUTINE FMTINY(MA)

!     MA = The smallest positive representable FM number using the current base and precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,N1

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMTINY'

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1
      DO J = 3, N1
         MWK(START(MA)+J+1) = 0
      ENDDO
      MWK(START(MA)+2) = -MXEXP
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA)) = 1
      MWK(START(MA)+3) = 1

      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTINY

      SUBROUTINE FMTRAP(MA)

!  If MA has overflowed or underflowed, replace it by the appropriate symbol.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA

      IF (NCALL <= 0) RETURN
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MWK(START(MA)+2) > MXEXP+1) THEN
          IF (MWK(START(MA)) > 0) THEN
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPOV
              MWK(START(MA)+3) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ELSE
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPOV
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = -1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ENDIF
          KFLAG = -5
      ENDIF
      IF (MWK(START(MA)+2) < -MXEXP) THEN
          IF (MWK(START(MA)) > 0) THEN
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPUN
              MWK(START(MA)+3) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ELSE
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPUN
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = -1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ENDIF
          KFLAG = -6
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTRAP

      SUBROUTINE FMULP(MA,MB)

!  MB = The value of one Unit in the Last Place of MA at the current base and precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MA1
      INTEGER :: J,KWRNSV,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMULP'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)

      MA1 = MWK(START(MA)+2)
      N1 = NDIG + 1
      DO J = 3, N1
         MWK(START(MWA)+J+1) = 0
      ENDDO
      MWK(START(MWA)+3) = 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) - NDIG + 1
      IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MA)+2) >= MEXPOV) THEN
          KFLAG = -4
          IF (MA1 /= MUNKNO) CALL FMWARN
          CALL FMST2M('UNKNOWN',MB)
      ELSE
          KWRNSV = KWARN
          IF (MA1 == MEXPUN) KWARN = 0
          IF (MWK(START(MA)) < 0) THEN
              CALL FMMOVE(MWA,MB)
              MWK(START(MB)) = 1
              IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
          ELSE
              CALL FMMOVE(MWA,MB)
              MWK(START(MB)) = 1
          ENDIF
          IF (KFLAG < 0) THEN
              NAMEST(NCALL) = 'FMULP'
              CALL FMWARN
          ENDIF
          KWARN = KWRNSV
      ENDIF
      MWK(START(MB)+1) = NINT(NDIG*ALOGM2)

      IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMULP

      SUBROUTINE FMUNPK(MP,MA)

!  MP is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      KP = 2
      MWK(START(MA)) = MWK(START(MP))
      MWK(START(MA)+1) = MWK(START(MP)+1)
      MWK(START(MA)+2) = MWK(START(MP)+2)
      MWK(START(MA)+3) = AINT (ABS(MWK(START(MP)+3))/MBASE)
      MWK(START(MA)+4) = ABS(MWK(START(MP)+3)) - MWK(START(MA)+3)*MBASE
      IF (NDIG >= 4) THEN
          DO J = 4, NDIG, 2
             KP = KP + 1
             MWK(START(MA)+J+1) = AINT (MWK(START(MP)+KP+1)/MBASE)
             MWK(START(MA)+J+2) = MWK(START(MP)+KP+1) - MWK(START(MA)+J+1)*MBASE
          ENDDO
      ENDIF
      IF (MOD(NDIG,2) == 1) THEN
          MWK(START(MA)+NDIG+2) = AINT (MWK(START(MP)+KP+2)/MBASE)
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMUNPK

      SUBROUTINE FMVARS

!  Write the values of the FM global variables in module FMVALS.

      USE FMVALS
      IMPLICIT NONE

      WRITE (KW,*) ' '
      WRITE (KW,*) ' Current values of the FM global variables.'
      WRITE (KW,*) ' '
      WRITE (KW,*) ' ALOGM2 = ',ALOGM2
      WRITE (KW,*) ' ALOGMB = ',ALOGMB
      WRITE (KW,*) ' ALOGMT = ',ALOGMT
      WRITE (KW,*) ' ALOGMX = ',ALOGMX
      WRITE (KW,*) ' CMCHAR = ',CMCHAR
      WRITE (KW,*) ' DLOGEB = ',DLOGEB
      WRITE (KW,*) ' DLOGMB = ',DLOGMB
      WRITE (KW,*) ' DLOGPI = ',DLOGPI
      WRITE (KW,*) ' DLOGTN = ',DLOGTN
      WRITE (KW,*) ' DLOGTP = ',DLOGTP
      WRITE (KW,*) ' DLOGTW = ',DLOGTW
      WRITE (KW,*) ' DPEPS  = ',DPEPS
      WRITE (KW,*) ' DPMAX  = ',DPMAX
      WRITE (KW,*) ' DPPI   = ',DPPI
      WRITE (KW,*) ' INTMAX = ',INTMAX
      WRITE (KW,*) ' IUNKNO = ',IUNKNO
      WRITE (KW,*) ' JFORM1 = ',JFORM1
      WRITE (KW,*) ' JFORM2 = ',JFORM2
      WRITE (KW,*) ' JFORMZ = ',JFORMZ
      WRITE (KW,*) ' JPRNTZ = ',JPRNTZ
      WRITE (KW,*) ' KACCSW = ',KACCSW
      WRITE (KW,*) ' KDEBUG = ',KDEBUG
      WRITE (KW,*) ' KESWCH = ',KESWCH
      WRITE (KW,*) ' KFLAG  = ',KFLAG
      WRITE (KW,*) ' KRAD   = ',KRAD
      WRITE (KW,*) ' KROUND = ',KROUND
      WRITE (KW,*) ' KSUB   = ',KSUB
      WRITE (KW,*) ' KSWIDE = ',KSWIDE
      WRITE (KW,*) ' KW     = ',KW
      WRITE (KW,*) ' KWARN  = ',KWARN
      WRITE (KW,*) ' LHASH  = ',LHASH
      WRITE (KW,*) ' LHASH1 = ',LHASH1
      WRITE (KW,*) ' LHASH2 = ',LHASH2
      WRITE (KW,*) ' LJSUMS = ',LJSUMS
      WRITE (KW,*) ' LMBERN = ',LMBERN
      WRITE (KW,*) ' LMBUFF = ',LMBUFF
      WRITE (KW,*) ' LMBUFZ = ',LMBUFZ
      WRITE (KW,*) ' LVLTRC = ',LVLTRC
      WRITE (KW,*) ' MAXINT = ',MAXINT
      WRITE (KW,*) ' MBASE  = ',MBASE
      WRITE (KW,*) ' MBLOGS = ',MBLOGS
      WRITE (KW,*) ' MBS2PI = ',MBS2PI
      WRITE (KW,*) ' MBSBRN = ',MBSBRN
      WRITE (KW,*) ' MBSE   = ',MBSE
      WRITE (KW,*) ' MBSEUL = ',MBSEUL
      WRITE (KW,*) ' MBSGAM = ',MBSGAM
      WRITE (KW,*) ' MBSLB  = ',MBSLB
      WRITE (KW,*) ' MBSLI  = ',MBSLI
      WRITE (KW,*) ' MBSPI  = ',MBSPI
      WRITE (KW,*) ' MEXPAB = ',MEXPAB
      WRITE (KW,*) ' MEXPOV = ',MEXPOV
      WRITE (KW,*) ' MEXPUN = ',MEXPUN
      WRITE (KW,*) ' MUNKNO = ',MUNKNO
      WRITE (KW,*) ' MXBASE = ',MXBASE
      WRITE (KW,*) ' MXEXP  = ',MXEXP
      WRITE (KW,*) ' MXEXP2 = ',MXEXP2
      WRITE (KW,*) ' NCALL  = ',NCALL
      WRITE (KW,*) ' NDG2PI = ',NDG2PI
      WRITE (KW,*) ' NDGEUL = ',NDGEUL
      WRITE (KW,*) ' NDGGAM = ',NDGGAM
      WRITE (KW,*) ' NDIG   = ',NDIG
      WRITE (KW,*) ' NDIGE  = ',NDIGE
      WRITE (KW,*) ' NDIGLB = ',NDIGLB
      WRITE (KW,*) ' NDIGLI = ',NDIGLI
      WRITE (KW,*) ' NDIGPI = ',NDIGPI
      WRITE (KW,*) ' NGRD21 = ',NGRD21
      WRITE (KW,*) ' NGRD22 = ',NGRD22
      WRITE (KW,*) ' NGRD52 = ',NGRD52
      WRITE (KW,*) ' NTRACE = ',NTRACE
      WRITE (KW,*) ' NUMBRN = ',NUMBRN
      WRITE (KW,*) ' RUNKNO = ',RUNKNO
      WRITE (KW,*) ' SPMAX  = ',SPMAX
      WRITE (KW,*) ' '
      WRITE (KW,*) ' RADIX(1) = ',RADIX(1),'    DIGITS(1) = ',DIGITS(1)
      WRITE (KW,*) '    HUGE(1) = ',HUGE(1)
      WRITE (KW,*) ' RADIX(1.0) = ',RADIX(1.0),'    DIGITS(1.0) = ',DIGITS(1.0)
      WRITE (KW,*) '    HUGE(1.0)    = ',HUGE(1.0)
      WRITE (KW,*) '    TINY(1.0)    = ',TINY(1.0)
      WRITE (KW,*) '    EPSILON(1.0) = ',EPSILON(1.0)
      WRITE (KW,*) ' RADIX(1.0D0) = ',RADIX(1.0D0),'    DIGITS(1.0D0) = ',DIGITS(1.0D0)
      WRITE (KW,*) '    HUGE(1.0D0)    = ',HUGE(1.0D0)
      WRITE (KW,*) '    TINY(1.0D0)    = ',TINY(1.0D0)
      WRITE (KW,*) '    EPSILON(1.0D0) = ',EPSILON(1.0D0)
      WRITE (KW,*) ' '

      RETURN
      END SUBROUTINE FMVARS

      SUBROUTINE FMWARN

!  Called by one of the FM routines to print a warning message if any error condition arises
!  in that routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NAME
      INTEGER :: NCS

      IF (KFLAG >= 0 .OR. NCALL /= 1 .OR. KWARN <= 0) RETURN
      NCS = NCALL
      NAME = NAMEST(NCALL)
      WRITE (KW,                                   &
             "(/' Error of type KFLAG =',I3,"  //  &
             "' in FM package in routine ',A/)"    &
            ) KFLAG,TRIM(NAME)

  110 NCALL = NCALL - 1
      IF (NCALL > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (KFLAG == -3) THEN
          WRITE (KW,                                                     &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -4 .OR. KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (KFLAG == -8 .AND. NAME == 'FMOUT') THEN
          WRITE (KW,                                                          &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (KFLAG == -8 .AND. NAME == 'FMREAD') THEN
          WRITE (KW,                                                        &
                 "(' The CMBUFF array is not big enough to hold the',"  //  &
                 "' input character string'/"                           //  &
                 "' UNKNOWN has been returned.'/)"                          &
                )
      ELSE IF (KFLAG == -9) THEN
          WRITE (KW,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,                                        &
                 "(I23,' digits were requested (NDIG).'/)"  &
                ) NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -10) THEN
          IF (NAMEST(NCS) == 'FMM2SP') THEN
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to single precision.'/)"                      &
                    )
          ELSE
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to double precision.'/)"                      &
                    )
          ENDIF
          WRITE (KW,"(' Zero has been returned.'/)")
      ENDIF

      NCALL = NCS
      IF (KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE FMWARN

      SUBROUTINE FMWRIT(KWRITE,MA)

!  Write MA on unit KWRITE.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using FMREAD.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KWRITE
      INTEGER :: MA

      INTEGER :: J,JF1SAV,JF2SAV,K,KSAVE,L,LAST,LB,ND,NDSAVE,NEXP
      INTENT (IN) :: MA,KWRITE

      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMWRIT'
      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = ND + NEXP

      JF1SAV = JFORM1
      JF2SAV = JFORM2
      JFORM1 = 1
      JFORM2 = ND + 6
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF

      CALL FMOUT(MXY(1),CMBUFF,LB)

      KFLAG = KSAVE
      NDIG = NDSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      LAST = LB + 1
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L)
             ELSE
                 IF (L > 73) WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFF(K),K=L-72,L)
             ENDIF
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             NUMBER_USED = NUMBER_USED_SAVE
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMWRIT


!  Here are the routines that work with packed FM numbers.  All names are the same as unpacked
!  versions with 'FM' replaced by 'FP'.

!  This packed format is not available when using the FM, IM, or ZM derived types.

      SUBROUTINE FPABS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMABS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPABS

      SUBROUTINE FPACOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMACOS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPACOS

      SUBROUTINE FPACOSH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMACOSH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPACOSH

      SUBROUTINE FPADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMADD(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPADD

      SUBROUTINE FPADD_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMADD_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPADD_R1

      SUBROUTINE FPADD_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMADD_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPADD_R2

      SUBROUTINE FPADDI(MA,L)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: L
      INTEGER :: L
      CALL FMUNPK(MA,MPA)
      CALL FMADDI(MPA,L)
      CALL FMPACK(MPA,MA)
      RETURN
      END SUBROUTINE FPADDI

      SUBROUTINE FPASIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMASIN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPASIN

      SUBROUTINE FPASINH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMASINH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPASINH

      SUBROUTINE FPATAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMATAN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPATAN

      SUBROUTINE FPATANH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMATANH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPATANH

      SUBROUTINE FPATN2(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMATN2(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPATN2

      SUBROUTINE FPBIG(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMBIG(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBIG

      SUBROUTINE FPCHSH(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCHSH(MPA,MPB,MPC)
      CALL FMPACK(MPB,MB)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCHSH

      FUNCTION FPCOMP(MA,LREL,MB)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: FPCOMP
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      INTENT (IN) :: MA,MB,LREL
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      FPCOMP = FMCOMP(MPA,LREL,MPB)
      RETURN
      END FUNCTION FPCOMP

      SUBROUTINE FPCOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCOS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCOS

      SUBROUTINE FPCOSH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCOSH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCOSH

      SUBROUTINE FPCSSN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCSSN(MPA,MPB,MPC)
      CALL FMPACK(MPB,MB)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCSSN

      SUBROUTINE FPDIG(NSTACK,KST)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: NSTACK(49),KST
      CALL FMDIG(NSTACK,KST)
      RETURN
      END SUBROUTINE FPDIG

      SUBROUTINE FPDIM(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIM(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIM

      SUBROUTINE FPDIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIV(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIV

      SUBROUTINE FPDIV_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIV_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIV_R1

      SUBROUTINE FPDIV_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIV_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIV_R2

      SUBROUTINE FPDIVI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMDIVI(MPA,IVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIVI

      SUBROUTINE FPDIVI_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMDIVI_R1(MPA,IVAL)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIVI_R1

      SUBROUTINE FPDP2M(X,MA)
      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMDP2M(X,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDP2M

      SUBROUTINE FPDPM(X,MA)
      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMDPM(X,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDPM

      SUBROUTINE FPEQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEQ(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQ

      SUBROUTINE FPEQU(MA,MB,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: NDA,NDB
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU_UNPCK(MA,NDA,MPA)
      CALL FMEQU_R1(MPA,NDA,NDB)
      CALL FPEQU_PACK(MPA,NDB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU

      SUBROUTINE FPEQU_R1(MA,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: NDA,NDB
      INTENT (INOUT) :: MA
      INTENT (IN) :: NDA,NDB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU_UNPCK(MA,NDA,MPA)
      CALL FMEQU_R1(MPA,NDA,NDB)
      CALL FPEQU_PACK(MPA,NDB,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU_R1

      SUBROUTINE FPEQU_PACK(MA,ND,MP)

!  MA (with ND digits) is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,ND
      INTENT (IN) :: MA,ND
      INTENT (INOUT) :: MP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,ND+3)
      ELSE IF (SIZE_OF(MP) < ND/2+4) THEN
          CALL IMDEFINE(MP,ND+3)
      ENDIF

      KP = 2
      MWK(START(MP)) = MWK(START(MA))
      MWK(START(MP)+1) = MWK(START(MA)+1)
      MWK(START(MP)+2) = MWK(START(MA)+2)
      MWK(START(MP)+3) = ABS(MWK(START(MA)+3))*MBASE + MWK(START(MA)+4)
      IF (ND >= 4) THEN
          DO J = 4, ND, 2
             KP = KP + 1
             MWK(START(MP)+KP+1) = MWK(START(MA)+J+1)*MBASE + MWK(START(MA)+J+2)
          ENDDO
      ENDIF
      IF (MOD(ND,2) == 1) MWK(START(MP)+KP+2) = MWK(START(MA)+ND+2)*MBASE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU_PACK

      SUBROUTINE FPEQU_UNPCK(MP,ND,MA)

!  MP (with ND digits) is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,ND
      INTENT (IN) :: MP,ND
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,ND+3)
      ELSE IF (SIZE_OF(MA) < ND+3) THEN
          CALL IMDEFINE(MA,ND+3)
      ENDIF

      KP = 2
      MWK(START(MA)) = MWK(START(MP))
      MWK(START(MA)+1) = MWK(START(MP)+1)
      MWK(START(MA)+2) = MWK(START(MP)+2)
      MWK(START(MA)+3) = AINT (ABS(MWK(START(MP)+3))/MBASE)
      MWK(START(MA)+4) = ABS(MWK(START(MP)+3)) - MWK(START(MA)+3)*MBASE
      IF (ND >= 4) THEN
          DO J = 4, ND, 2
             KP = KP + 1
             MWK(START(MA)+J+1) = AINT (MWK(START(MP)+KP+1)/MBASE)
             MWK(START(MA)+J+2) = MWK(START(MP)+KP+1) - MWK(START(MA)+J+1)*MBASE
          ENDDO
      ENDIF
      IF (MOD(ND,2) == 1) THEN
          MWK(START(MA)+ND+2) = AINT (MWK(START(MP)+KP+2)/MBASE)
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU_UNPCK

      SUBROUTINE FPEXP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEXP(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEXP

      SUBROUTINE FPFLAG(K)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: K
      K = KFLAG
      RETURN
      END SUBROUTINE FPFLAG

      SUBROUTINE FPFORM(FORM,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: STRING
      CALL FMUNPK(MA,MPA)
      CALL FMFORM(FORM,MPA,STRING)
      RETURN
      END SUBROUTINE FPFORM

      SUBROUTINE FPFPRT(FORM,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMFPRT(FORM,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPFPRT

      SUBROUTINE FPHYPOT(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMHYPOT(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPHYPOT

      SUBROUTINE FPI2M(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: IVAL
      INTEGER :: MA
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMI2M(IVAL,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPI2M

      SUBROUTINE FPINP(LINE,MA,LA,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMINP(LINE,MPA,LA,LB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPINP

      SUBROUTINE FPINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMINT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPINT

      SUBROUTINE FPIPWR(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMIPWR(MPA,IVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIPWR

      SUBROUTINE FPLG10(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLG10(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLG10

      SUBROUTINE FPLN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLN

      SUBROUTINE FPLNI(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: IVAL
      INTEGER :: MA
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMLNI(IVAL,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLNI

      SUBROUTINE FPM2DP(MA,X)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      DOUBLE PRECISION :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: X
      CALL FMUNPK(MA,MPA)
      CALL FMM2DP(MPA,X)
      RETURN
      END SUBROUTINE FPM2DP

      SUBROUTINE FPM2I(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL
      INTEGER :: IVAL
      CALL FMUNPK(MA,MPA)
      CALL FMM2I(MPA,IVAL)
      RETURN
      END SUBROUTINE FPM2I

      SUBROUTINE FPM2SP(MA,X)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      INTENT (INOUT) :: X
      REAL :: X
      CALL FMUNPK(MA,MPA)
      CALL FMM2SP(MPA,X)
      RETURN
      END SUBROUTINE FPM2SP

      SUBROUTINE FPMAX(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMAX(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMAX

      SUBROUTINE FPMIN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMIN(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMIN

      SUBROUTINE FPMOD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMOD(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMOD

      SUBROUTINE FPMPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMPY(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPY

      SUBROUTINE FPMPY_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMPY_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPY_R1

      SUBROUTINE FPMPY_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMPY_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPY_R2

      SUBROUTINE FPMPYI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMMPYI(MPA,IVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPYI

      SUBROUTINE FPMPYI_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMMPYI_R1(MPA,IVAL)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPYI_R1

      SUBROUTINE FPNINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMNINT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPNINT

      SUBROUTINE FPOUT(MA,LINE,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      INTEGER :: LB
      CHARACTER :: LINE(LB)
      CALL FMUNPK(MA,MPA)
      CALL FMOUT(MPA,LINE,LB)
      RETURN
      END SUBROUTINE FPOUT

      SUBROUTINE FPPI(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMPI(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPI

      SUBROUTINE FPPRNT(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPRNT(MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPRNT

      SUBROUTINE FPPWR(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMPWR(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPWR

      SUBROUTINE FPREAD(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KREAD
      INTEGER :: MA
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMREAD(KREAD,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPREAD

      SUBROUTINE FPRPWR(MA,KVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,KVAL,JVAL
      INTENT (INOUT) :: MB
      INTEGER :: KVAL,JVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMRPWR(MPA,KVAL,JVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPRPWR

      SUBROUTINE FPSET(NPREC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      CALL FMSET(NPREC)
      RETURN
      END SUBROUTINE FPSET

      SUBROUTINE FPSETVAR(STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      CALL FMSETVAR(STRING)
      RETURN
      END SUBROUTINE FPSETVAR

      SUBROUTINE FPSIGN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSIGN(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSIGN

      SUBROUTINE FPSIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSIN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSIN

      SUBROUTINE FPSINH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSINH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSINH

      SUBROUTINE FPSP2M(X,MA)
      USE FMVALS
      IMPLICIT NONE
      REAL :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMSP2M(X,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSP2M

      SUBROUTINE FPSQR(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQR(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQR

      SUBROUTINE FPSQR_R1(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQR_R1(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQR_R1

      SUBROUTINE FPSQRT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQRT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQRT

      SUBROUTINE FPSQRT_R1(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQRT_R1(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQRT_R1

      SUBROUTINE FPST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTEGER :: MA
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMST2M(STRING,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPST2M

      SUBROUTINE FPSUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSUB(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSUB

      SUBROUTINE FPSUB_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSUB_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSUB_R1

      SUBROUTINE FPSUB_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSUB_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSUB_R2

      SUBROUTINE FPTAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMTAN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPTAN

      SUBROUTINE FPTANH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMTANH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPTANH

      SUBROUTINE FPTINY(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMTINY(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPTINY

      SUBROUTINE FPULP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMULP(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPULP

      SUBROUTINE FPVARS
      USE FMVALS
      CALL FMVARS
      RETURN
      END SUBROUTINE FPVARS

      SUBROUTINE FPWRIT(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      INTENT (IN) :: MA,KWRITE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMWRIT(KWRITE,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPWRIT


!  The random number routines use integer multiple precision arithmetic.

      SUBROUTINE FM_RANDOM_NUMBER(VALUE)

!  FM_RANDOM_NUMBER generates pseudo-random numbers uniform on (0,1).
!  VALUE is returned as the next random (double precision) number.
!  Neither zero nor one will be returned in VALUE.

!  This version uses the FM package to implement a multiplicative congruential generator.
!  Both the modulus and the multiplier are 49-digit primes, and the period is over 1.0E+49.

!  This generator passes the spectral test, with mu(2), ..., mu(6) =
!    3.40,   4.35,   3.98,   3.19,   3.20.
!  It also has passed Marsaglia's DieHard test suite for random generators.

!  The typical usage is to call FM_RANDOM_SEED_PUT once with SEED defined as an integer array of
!  length 7 containing seven seed values used to initialize the generator.  A default seed is used
!  if no call to FM_RANDOM_SEED_PUT is done.  Then each call to FM_RANDOM_NUMBER returns the next
!  random value.

!  This example seeds the generator and then fills the array R with random values between 0 and 1.

!        SEED = (/ 314159,265358,979323,846264,338327,950288,419716 /)
!        CALL FM_RANDOM_SEED_PUT(SEED)
!        DO J = 1, N
!           CALL FM_RANDOM_NUMBER(R(J))
!        ENDDO

!  In a FM_RANDOM_SEED_GET call, the seed array is returned that would later restart the generator
!  in FM_RANDOM_NUMBER at the same place in the sequence.

!      SEED = (/ 314159,265358,979323,846264,338327,950288,419716 /)
!      CALL FM_RANDOM_SEED_PUT(SEED)
!      DO J = 1, 100
!         CALL FM_RANDOM_NUMBER(R(J))
!      ENDDO

!      CALL FM_RANDOM_SEED_GET(SEED)
!      DO J = 101, 200
!         CALL FM_RANDOM_NUMBER(R(J))
!      ENDDO

!      CALL FM_RANDOM_SEED_PUT(SEED)
!      DO J = 201, 300
!         CALL FM_RANDOM_NUMBER(R(J))
!      ENDDO

!  Here the seed is saved after 100 calls.  The seed is used to re-set the generator after 200 calls
!  to the same state it had after 100 calls, and R(201), ..., R(300) is the same sequence as
!  R(101), ..., R(200).

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: VALUE,DPX
      INTEGER :: POS_OF_LAST_DIGIT,J,JBASE,LAST_DIGIT_OF_X
      INTEGER :: SEED(7) = (/314159,265358,979323,846264,338327,950288,419716/)
      SAVE JBASE,SEED
      REAL (KIND(1.0D0)) :: MSAVE
      LOGICAL, EXTERNAL :: IMCOMP
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 2) THEN
          NAMEST(NCALL) = 'FM_RANDOM'
          WRITE (KW,"(' Input to FM_RANDOM_NUMBER')")
      ENDIF

!             Variables (in module FMVALS).

!             MBRAND is the base (value of MBASE) used for computing the random numbers.  This
!                    allows the user to change MBASE without causing problems in FM_RANDOM_NUMBER.

!             The multiplicative congruence used by the generator is
!                 X = ( A*X + C ) mod M
!             where all four are integers.
!             MRNX is X  (the current random integer)
!             MRNA is A  (the multiplier, defined in FM_RANDOM_SEED_PUT)
!             MRNC is C  (C = 1 for this generator)
!             MRNM is M  (the modulus, defined in FM_RANDOM_SEED_PUT)

!             X is the current value of the random sequence.
!             VALUE is then returned as approximately X/M.

      MSAVE = MBASE
      MBASE = MBRAND
      IF (MSAVE /= MBASE) CALL FMCONS

!             START_RANDOM_SEQUENCE =  0  for normal operation. Get the next  random value.
!                                   =  1  for the first call after the user has called
!                                         FM_RANDOM_SEED. Use that value in MRNX to initialize.
!                                   = -1  for the first user call if there was no initializing call
!                                         to FM_RANDOM_SEED.  Use a default seed to initialize MRNX.

      IF (START_RANDOM_SEQUENCE /= 0) THEN
          IF (START_RANDOM_SEQUENCE == -1) THEN
              CALL FM_RANDOM_SEED_PUT(SEED)
          ENDIF
          START_RANDOM_SEQUENCE = 0
      ENDIF
      JBASE = INT(MBASE) - 1

!             Get the next number in the sequence.

  110 CALL IMMPYM(MRNA,MRNX,MRNM,MXY(2))
      POS_OF_LAST_DIGIT = INT(MWK(START(MXY(2))+2)) + 1
      DO J = -1, POS_OF_LAST_DIGIT
         MWK(START(MRNX)+J+1) = MWK(START(MXY(2))+J+1)
      ENDDO
      LAST_DIGIT_OF_X = INT(MWK(START(MRNX)+POS_OF_LAST_DIGIT+1))
      IF (LAST_DIGIT_OF_X == LAST_DIGIT_OF_M_M1) THEN
          CALL IMADD(MRNX,MRNC,MXY(1))
          CALL IMEQ(MXY(1),MRNX)
          IF (IMCOMP(MRNX,'>=',MRNM)) THEN
              CALL IMSUB(MRNX,MRNM,MXY(1))
              CALL IMEQ(MXY(1),MRNX)
          ENDIF
      ELSE IF (LAST_DIGIT_OF_X < JBASE) THEN
          MWK(START(MRNX)+POS_OF_LAST_DIGIT+1) = MWK(START(MRNX)+POS_OF_LAST_DIGIT+1) + 1
      ELSE
          CALL IMADD(MRNX,MRNC,MXY(1))
          CALL IMEQ(MXY(1),MRNX)
      ENDIF

!             Convert to double precision.

      DPX = MWK(START(MRNX)+3)
      DO J = 3, POS_OF_LAST_DIGIT
         DPX = MBASE*DPX + MWK(START(MRNX)+J+1)
      ENDDO

      DPX = DPX*DPM
      IF (DPX >= 1.0D0 .OR. DPX <= 0.0D0) GO TO 110

      VALUE = DPX

      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 1) THEN
          WRITE (KW,                                              &
                 "(' ',A,5X,'Call level =',I2,5X,'MBASE =',I10)"  &
                ) 'FM_RANDOM_NUMBER',NCALL,INT(MBASE)
          WRITE (KW,"(1X,D30.20)") VALUE
      ENDIF
      NCALL = NCALL - 1

      IF (MSAVE /= MBASE) THEN
          MBASE = MSAVE
          CALL FMCONS
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FM_RANDOM_NUMBER

      SUBROUTINE FM_RANDOM_SEED_GET(SEED)

!  Return SEED(1) through SEED(7) as the current state of the generator.
!  See the comments in routine FM_RANDOM_NUMBER.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: SEED(7)
      REAL (KIND(1.0D0)) :: MSAVE
      INTEGER :: SCR(7) = (/462643,383279,502884,197163,141592,653589,793238/)
      INTEGER :: J,K
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      MSAVE = MBASE
      MBASE = MBRAND
      IF (MBLOGS /= MBASE) CALL FMCONS
      K = 10**7
      CALL IMI2M(K,MXY(2))
      CALL IMEQ(MRNX,MXY(1))
      DO J = 7, 1, -1
         CALL IMMOD(MXY(1),MXY(2),MXY(3))
         CALL IMM2I(MXY(3),SEED(J))
         SEED(J) = SEED(J) - SCR(J)
         IF (SEED(J) < 0) THEN
             SEED(J) = SEED(J) + K
         ENDIF
         CALL IMDIVI(MXY(1),K,MXY(3))
         CALL IMEQ(MXY(3),MXY(1))
      ENDDO
      MBASE = MSAVE
      IF (MBLOGS /= MBASE) CALL FMCONS
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FM_RANDOM_SEED_GET

      SUBROUTINE FM_RANDOM_SEED_PUT(SEED)

!  Use SEED(1) through SEED(7) to initialize the FM_RANDOM_NUMBER generator.
!  See the comments in routine FM_RANDOM_NUMBER.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: SEED(7)
      REAL (KIND(1.0D0)) :: MSAVE
      INTEGER :: SCR(7) = (/462643,383279,502884,197163,141592,653589,793238/)
      INTEGER :: J,K,L
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      MSAVE = MBASE
      MBASE = MBRAND
      IF (MBLOGS /= MBASE) CALL FMCONS
      CALL IMST2M('1424133622579837639401183671018194926834820238197',MRNA)
      CALL IMST2M('2070613773952029032014000773560846464373793273739',MRNM)
      K = 10**7
      L = ABS(SEED(1)) + SCR(1)
      IF (L <= K) THEN
          CALL IMI2M(L,MRNX)
      ELSE
          CALL IMI2M(L-K,MRNX)
      ENDIF
      DO J = 2, 7
         CALL IMMPYI(MRNX,K,MXY(2))
         L = ABS(SEED(J)) + SCR(J)
         IF (L <= K) THEN
             CALL IMI2M(L,MXY(1))
         ELSE
             CALL IMI2M(L-K,MXY(1))
         ENDIF
         CALL IMADD(MXY(2),MXY(1),MRNX)
      ENDDO
      CALL IMMOD(MRNX,MRNM,MXY(2))
      CALL IMEQ(MXY(2),MRNX)
      START_RANDOM_SEQUENCE = 1
      J = MWK(START(MRNM)+2)
      LAST_DIGIT_OF_M_M1 = INT(MWK(START(MRNM)+J+2)) - 1
      CALL IMI2M(1,MRNC)
      CALL IMM2DP(MRNM,DPM)
      DPM = 1.0D0/DPM

      MBASE = MSAVE
      IF (MBLOGS /= MBASE) CALL FMCONS
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FM_RANDOM_SEED_PUT

      SUBROUTINE FM_RANDOM_SEED_SIZE(SIZE)

!  Return the size of the SEED array used by the FM_RANDOM_NUMBER generator.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: SIZE

      SIZE = 7
      RETURN
      END SUBROUTINE FM_RANDOM_SEED_SIZE


!  The IM routines perform integer multiple-precision arithmetic.

      SUBROUTINE IMABS(MA,MB)

!  MB = ABS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+3))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMABS    ',1,MA,MA)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMABS'
          CALL IMNTR(2,MA,MA,1)
      ENDIF

      KFLAG = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL IMEQ(MA,MB)
      MWK(START(MB)) = 1
      KWARN = KWRNSV

      IF (NTRACE /= 0) CALL IMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMABS

      FUNCTION IMABS_GREATER_THAN(U, V)

!  Return true if abs(U) > abs(V) for IM numbers U, V.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J
      INTEGER :: U, V
      INTENT (IN) :: U, V
      LOGICAL :: IMABS_GREATER_THAN

      IF (MWK(START(U)+2) > MWK(START(V)+2)) THEN
          IMABS_GREATER_THAN = .TRUE.
          RETURN
      ELSE IF (MWK(START(U)+2) < MWK(START(V)+2)) THEN
          IMABS_GREATER_THAN = .FALSE.
          RETURN
      ENDIF

      IMABS_GREATER_THAN = .FALSE.
      DO J = 1, INT(MWK(START(U)+2))
         IF (MWK(START(U)+J+2) > MWK(START(V)+J+2)) THEN
             IMABS_GREATER_THAN = .TRUE.
             RETURN
         ELSE IF(MWK(START(U)+J+2) < MWK(START(V)+J+2)) THEN
             IMABS_GREATER_THAN = .FALSE.
             RETURN
         ENDIF
      ENDDO

      END FUNCTION IMABS_GREATER_THAN

      SUBROUTINE IMADD(MA,MB,MC)

!  MC = MA + MB

!  This routine performs the trace printing.  IMADD2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMADD'
          CALL IMNTR(2,MA,MB,2)

          CALL IMADD2(MA,MB,MC)

          CALL IMNTR(1,MC,MC,1)
      ELSE
          CALL IMADD2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADD

      SUBROUTINE IMADD2(MA,MB,MC)

!  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      IF (KDEBUG == 1) CALL IMARGS('IMADD    ',2,MA,MB)
      NDSAVE = NDIG
      KFLAG = 0

      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MB)+2) > 2 .OR. MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) GO TO 110
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          IF (MWK(START(MB)+2) <= 1) THEN
              MDB = MWK(START(MB)) * MWK(START(MB)+3)
          ELSE
              MDB = MWK(START(MB)) * (MWK(START(MB)+3)*MBASE + MWK(START(MB)+4))
          ENDIF
          MDAB = MDA + MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              IF (MDAB < 0) THEN
                  MWK(START(MC)+3) = -MDAB
                  MWK(START(MC)) = -1
              ELSE
                  MWK(START(MC)+3) = MDAB
                  MWK(START(MC)) = 1
              ENDIF
              MWK(START(MC)+4) = 0
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 2
              IF (MDAB < 0) THEN
                  MWK(START(MC)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(-MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = -1
              ELSE
                  MWK(START(MC)+3) = AINT (MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = 1
              ENDIF
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
              CALL IMI2M2(0,MC)
              MWK(START(MC)+2) = MUNKNO
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
              KFLAG = -4
              GO TO 120
          ENDIF
          IF (MWK(START(MA)+2) == MEXPOV) THEN
              IF (MWK(START(MA)) == MWK(START(MB)) .OR. MWK(START(MB)+3) == 0) THEN
                  MWK(START(MC)) = MWK(START(MA))
                  MWK(START(MC)+1) = MWK(START(MA)+1)
                  MWK(START(MC)+2) = MWK(START(MA)+2)
                  MWK(START(MC)+3) = MWK(START(MA)+3)
                  MWK(START(MC)+4) = MWK(START(MA)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMADD'
                  CALL FMWARN
                  CALL IMI2M2(0,MC)
                  MWK(START(MC)+2) = MUNKNO
                  MWK(START(MC)+3) = 1
                  MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MWK(START(MB)+2) == MEXPOV) THEN
              IF (MWK(START(MB)) == MWK(START(MA)) .OR. MWK(START(MA)+3) == 0) THEN
                  MWK(START(MC)) = MWK(START(MB))
                  MWK(START(MC)+1) = MWK(START(MB)+1)
                  MWK(START(MC)+2) = MWK(START(MB)+2)
                  MWK(START(MC)+3) = MWK(START(MB)+3)
                  MWK(START(MC)+4) = MWK(START(MB)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMADD'
                  CALL FMWARN
                  CALL IMI2M2(0,MC)
                  MWK(START(MC)+2) = MUNKNO
                  MWK(START(MC)+3) = 1
                  MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
                  GO TO 120
              ENDIF
          ENDIF
          KFLAG = -4
          NAMEST(NCALL) = 'IMADD'
          CALL FMWARN
          CALL IMI2M2(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF

      CALL IMADD3(MA,MB,MC)

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADD2

      SUBROUTINE IMADD3(MA,MB,MC)

!  Internal addition routine.  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MAS,MBS
      INTEGER :: J,JCOMP,JSIGN,N1
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL IMEQ(MB,MC)
          KFLAG = 1
          IF (KSUB == 1) THEN
              IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                  MWK(START(MC)) = -MWK(START(MC))
              KFLAG = 0
          ENDIF
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          CALL IMEQ(MA,MC)
          KFLAG = 1
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KFLAG = 0
      N1 = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 1

!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          IF (MAS*MBS > 0) THEN
              CALL IMADDP(MA,MB)
          ELSE
              CALL IMADDN(MA,MB)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          IF (MAS*MBS > 0) THEN
              CALL IMADDP(MB,MA)
          ELSE
              CALL IMADDN(MB,MA)
          ENDIF
      ENDIF

!             Transfer to MC and fix the sign of the result.

      NDIG = MWK(START(MWA)+2)
      IF (NDIG < 2) NDIG = 2
      CALL FMMOVE(MWA,MC)
      MWK(START(MC)+1) = NINT(10**7*ALOGM2)
      MWK(START(MC)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'IMSUB'
          ELSE
              NAMEST(NCALL) = 'IMADD'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADD3

      SUBROUTINE IMADDN(MA,MB)

!  Internal addition routine.  MWA = MA - MB
!  The arguments are such that MA >= MB >= 0.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MK
      INTEGER :: J,JMA,JMB,JMWA,K,KL,KP1,KP2,KPT,KSH,N1
      INTENT (IN) :: MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          KFLAG = -4
          MWK(START(MWA)+2) = MUNKNO
          MWK(START(MWA)+3) = 1
          MWK(START(MWA)+4) = 0
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      N1 = MWK(START(MA)+2) + 1
      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      K = INT(MK)

!             Subtract MB from MA.

      KP1 = MIN(N1,K+1)
      DO J = 1, KP1
         MWK(START(MWA)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 1
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) - MWK(JMB+J)
      ENDDO
      MWK(JMWA+N1+1) = 0

!             Normalize.  Fix the sign of any negative digit.

      IF (K > 0) THEN
          DO J = N1, KP2, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
             ENDIF
          ENDDO
          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) < 0 .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) + MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) - 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
      ELSE
          DO J = N1, 3, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
             ENDIF
          ENDDO
      ENDIF

!             Shift left if there are any leading zeros in the mantissa.

      DO J = 2, N1
         IF (MWK(START(MWA)+J+1) > 0) THEN
             KSH = J - 2
             GO TO 120
         ENDIF
      ENDDO
      MWK(START(MWA)+2) = 0
      MWK(START(MWA)+4) = 0
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

  120 IF (KSH > 0) THEN
          KL = N1 - KSH
          DO J = 2, KL
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+KSH+1)
          ENDDO
          DO J = KL+1, N1
             MWK(START(MWA)+J+1) = 0
          ENDDO
          MWK(START(MWA)+2) = MWK(START(MWA)+2) - KSH
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADDN

      SUBROUTINE IMADDP(MA,MB)

!  Internal addition routine.  MWA = MA + MB
!  The arguments are such that MA >= MB >= 0.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MK
      INTEGER :: J,JMA,JMB,JMWA,K,KP2,KPT,N1
      INTENT (IN) :: MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = 2*(MWK(START(MA)+2)+1) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      N1 = MWK(START(MA)+2) + 1
      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      K = INT(MK)

!             Add MA and MB.

      MWK(START(MWA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MWA)+3) = 0
      DO J = 2, K+1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 2
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) + MWK(JMB+J)
      ENDDO
      MWK(JMWA+N1+1) = 0

!             Normalize.  Fix any digit not less than MBASE.

      IF (K > 0) THEN
          DO J = N1+1, KP2, -1
             IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
             ENDIF
          ENDDO
          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) >= MBASE .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) - MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) + 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
      ELSE
          DO J = N1+1, 3, -1
             IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
             ENDIF
          ENDDO
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADDP

      SUBROUTINE IMARGS(KROUTN,NARGS,MA,MB)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: KROUTN
      INTEGER :: MA,MB
      INTEGER :: NARGS

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,LAST
      INTENT (IN) :: KROUTN,NARGS,MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = -4
      IF (MWK(START(MA)+2) == MUNKNO) THEN
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MUNKNO) THEN
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0

!             Check the validity of parameters.

      IF (NCALL > 1 .AND. KDEBUG == 0) THEN
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NAMEST(NCALL) = KROUTN

!             Check MBASE.

      IF (MBASE < 2 .OR. MBASE > MXBASE) THEN
          KFLAG = -2
          CALL FMWARN
          MBS = MBASE
          IF (MBASE < 2) MBASE = 2
          IF (MBASE > MXBASE) MBASE = MXBASE
          WRITE (KW,                                                       &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(MBASE)
          CALL FMCONS
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Check exponent range.

      IF (MWK(START(MA)+2) < 0) THEN
          IF (ABS(MWK(START(MA)+2)) /= MEXPOV .OR. ABS(MWK(START(MA)+3)) /= 1) THEN
              KFLAG = -3
              CALL FMWARN
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) < 0) THEN
              IF (ABS(MWK(START(MB)+2)) /= MEXPOV .OR. ABS(MWK(START(MB)+3)) /= 1) THEN
                  KFLAG = -3
                  CALL FMWARN
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MB) == -1) TEMPV(MB) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MWK(START(MA)+2)-INT(MWK(START(MA)+2))) /= 0) KFLAG = 1
      IF (MWK(START(MA)+3) <= (-1) .OR. MWK(START(MA)+3) >= MBASE .OR.  &
          ABS(MWK(START(MA)+3)-INT(MWK(START(MA)+3))) /= 0) KFLAG = 2
      IF (KDEBUG == 0) GO TO 110
      LAST = INT(MWK(START(MA)+2)) + 1
      IF (MWK(START(MA)+2) > SIZE_OF(MA)-2) LAST = 3
      DO J = 3, LAST
         IF (MWK(START(MA)+J+1) < 0 .OR. MWK(START(MA)+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA)+J+1)-INT(MWK(START(MA)+J+1))) /= 0) THEN
             KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
  110 IF (KFLAG /= 0) THEN
          J = KFLAG
          KFLAG = -4
          KWRNSV = KWARN
          IF (KWARN >= 2) KWARN = 1
          CALL FMWARN
          KWARN = KWRNSV
          IF (KWARN >= 1) THEN
              WRITE (KW,*) ' First invalid array element:  MA(',J,') = ',MWK(START(MA)+J+1)
          ENDIF
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MWK(START(MB)+2)-INT(MWK(START(MB)+2))) /= 0) KFLAG = 1
          IF (MWK(START(MB)+3) <= (-1) .OR. MWK(START(MB)+3) >= MBASE .OR.  &
              ABS(MWK(START(MB)+3)-INT(MWK(START(MB)+3))) /= 0) KFLAG = 2
          IF (KDEBUG == 0) GO TO 120
          LAST = INT(MWK(START(MB)+2)) + 1
          IF (MWK(START(MB)+2) > SIZE_OF(MB)-2) LAST = 3
          DO J = 3, LAST
             IF (MWK(START(MB)+J+1) < 0 .OR. MWK(START(MB)+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB)+J+1)-INT(MWK(START(MB)+J+1))) /= 0) THEN
                 KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (KFLAG /= 0) THEN
              J = KFLAG
              KFLAG = -4
              KWRNSV = KWARN
              IF (KWARN >= 2) KWARN = 1
              CALL FMWARN
              KWARN = KWRNSV
              IF (KWARN >= 1) THEN
                  WRITE (KW,*) ' First invalid array element:  MB(',J,') = ',MWK(START(MB)+J+1)
              ENDIF
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMARGS

      SUBROUTINE IMBIG(MA)

!  MA = A very large IM integer.

!  Before version 1.3 of FM, this routine returned the largest representable IM integer.
!  Starting with version 1.3 the size of IM integers is limited only by the space available
!  in the working array MWK in FMSAVE.f95.
!  But if this routine set MA as large as possible, it would leave no room for other
!  FM/IM/ZM numbers.  So a result of 10**(10**6) is returned here.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: L
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      L = 1.05D+6*LOG(10.0D0)/LOG(DBLE(MBASE)) + 3
      RESULT_SIZE = L + 3
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'IMBIG'

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      CALL IMI2M(10,MXY(1))
      CALL IMI2M(10**6,MXY(2))
      CALL IMPWR(MXY(1),MXY(2),MA)

      IF (NTRACE /= 0 .AND. NCALL <= LVLTRC) THEN
          WRITE (KW,                                               &
                 "(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)"  &
                ) 'IMBIG',NCALL,INT(MBASE)
          WRITE (KW,*) '       1.0M+1000000'
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMBIG

      SUBROUTINE IMCOMB(MA,MB,MC)

!  Binomial coefficients for integers.  MA, MB, MC, are all multiprecision integers.

!  MC = MA choose MB = MA! / ( MB! * (MA-MB)! )

!  This routine extends this definition to allow negative integer values for MA and/or MB.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: MXY(3),K,KMOD2,L,N,NUMBER_USED_SAVE
      INTEGER, SAVE :: MT = -3
      INTEGER :: J
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMCOMB'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      CALL IMM2I(MA,N)
      IF (KFLAG == 0) THEN
          CALL IMM2I(MB,K)
          IF (KFLAG == 0) THEN
              CALL IMCOMBI(N,K,MT)
              CALL IMEQ(MT,MC)
              IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
              NCALL = NCALL - 1
              RETURN
          ENDIF
      ENDIF

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS

      IF (MWK(START(MA)) < 0) THEN
          CALL IMSUB(MB,MA,MXY(1))
          CALL IMI2M(1,MXY(2))
          CALL IMSUB(MXY(1),MXY(2),MXY(3))
      ELSE
          CALL IMEQ(MA,MXY(3))
      ENDIF
      CALL IMSUB(MXY(3),MB,MXY(1))
      CALL IMMIN(MB,MXY(1),MXY(2))
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL IMI2M(0,MT)
          GO TO 110
      ELSE IF (MWK(START(MXY(2))+3) == 0) THEN
          CALL IMI2M(1,MT)
          GO TO 110
      ENDIF
      CALL IMM2I(MXY(2),L)

!             If L = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      IF (KFLAG /= 0) THEN
          CALL IMST2M('UNKNOWN',MT)
          GO TO 110
      ENDIF
      IF (L == 1) THEN
          CALL IMEQ(MXY(3),MT)
          GO TO 110
      ENDIF
      IF (L > 10) THEN
          CALL IMCOMB2(MXY(3),MXY(2),MT)
          GO TO 110
      ENDIF

!             Compute the binomial coefficient.

      CALL IMEQ(MXY(3),MT)
      CALL IMI2M(1,MXY(1))
      DO J = 2, L
         CALL IMSUB(MXY(3),MXY(1),MXY(2))
         CALL IMEQ(MXY(2),MXY(3))
         CALL IMMPY(MXY(3),MT,MXY(2))
         CALL IMDIVI(MXY(2),J,MT)
      ENDDO

  110 CALL IMMODI(MB,2,KMOD2)
      IF (MWK(START(MA)) < 0 .AND. KMOD2 == 1 .AND.  &
          MWK(START(MT)+2) /= MUNKNO .AND. MWK(START(MT)+3) /= 0) THEN
          MWK(START(MT)) = -MWK(START(MT))
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      CALL IMEQ(MT,MC)
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMCOMB

      SUBROUTINE IMCOMB2(MA,MB,MC)

!  Binomial coefficients for integers.  MA, MB, MC, are all multiprecision integers.

!  MC = MA choose MB = MA! / ( MB! * (MA-MB)! )

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: MXY(3),J,J1,J1FAC,KMOD2,KPT,KPT2,L,NUMBER_USED_SAVE,R
      INTEGER, ALLOCATABLE :: TOP(:)
      INTEGER, SAVE :: MT = -3
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMCOMB2'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS

      IF (MWK(START(MA)) < 0) THEN
          CALL IMSUB(MB,MA,MXY(1))
          CALL IMI2M(1,MXY(2))
          CALL IMSUB(MXY(1),MXY(2),MXY(3))
      ELSE
          CALL IMEQ(MA,MXY(3))
      ENDIF
      CALL IMSUB(MXY(3),MB,MXY(1))
      CALL IMMIN(MB,MXY(1),MXY(2))
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL IMI2M(0,MT)
          GO TO 110
      ELSE IF (MWK(START(MXY(2))+3) == 0) THEN
          CALL IMI2M(1,MT)
          GO TO 110
      ENDIF
      CALL IMM2I(MXY(2),L)

!             If L = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      IF (KFLAG /= 0) THEN
          CALL IMST2M('UNKNOWN',MT)
          GO TO 110
      ENDIF
      IF (L == 1) THEN
          CALL IMEQ(MXY(3),MT)
          GO TO 110
      ENDIF

!             Compute the binomial coefficient by making a list of the numerator terms
!             N, N-1, ..., N-L+1.  Then divide out each of the denominator terms 2, 3, ..., L.


      ALLOCATE(TOP(L),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      TOP = -2
      CALL IMI2M(1,MXY(1))
      CALL IMEQ(MXY(3),TOP(1))
      DO J = 2, L
         CALL IMSUB(TOP(J-1),MXY(1),TOP(J))
      ENDDO

      DO J = L, 2, -1
         CALL IMMODI(MXY(3),J,R)
         KPT = R + 1
         DO WHILE (KPT <= L)
            CALL IMMODI(TOP(KPT),J,R)
            IF (R == 0) THEN
                CALL IMDIVI(TOP(KPT),J,MXY(2))
                CALL IMEQ(MXY(2),TOP(KPT))
                EXIT
            ENDIF
            KPT = KPT + J
            IF (KPT > L) THEN
                J1 = J
                DO WHILE (J1 > 1)
                   CALL IMCOMB2_FACTOR(J1,J1FAC)
                   CALL IMMODI(MXY(3),J1FAC,R)
                   KPT2 = R + 1
                   DO WHILE (KPT2 <= L)
                      CALL IMMODI(TOP(KPT2),J1FAC,R)
                      IF (R == 0) THEN
                          CALL IMDIVI(TOP(KPT2),J1FAC,MXY(2))
                          CALL IMEQ(MXY(2),TOP(KPT2))
                          EXIT
                      ENDIF
                      KPT2 = KPT2 + J1FAC
                   ENDDO
                ENDDO
            ENDIF
         ENDDO
      ENDDO

!             Form the product of the remaining TOP terms.

      CALL IMEQ(TOP(1),MT)
      DO J = 2, L
         IF (MWK(START(TOP(J))+2) > 1 .OR.  &
            (MWK(START(TOP(J))+2) == 1 .AND. MWK(START(TOP(J))+3) > 1)) THEN
             CALL IMMPY(TOP(J),MT,MXY(2))
             CALL IMEQ(MXY(2),MT)
         ENDIF
      ENDDO

      DEALLOCATE(TOP)

  110 CALL IMI2M(2,MXY(1))
      CALL IMMOD(MB,MXY(1),MXY(2))
      CALL IMM2I(MXY(2),KMOD2)
      IF (MWK(START(MA)) < 0 .AND. KMOD2 == 1 .AND.  &
          MWK(START(MT)+2) /= MUNKNO .AND. MWK(START(MT)+3) /= 0) THEN
          MWK(START(MT)) = -MWK(START(MT))
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      CALL IMEQ(MT,MC)
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMCOMB2

      SUBROUTINE IMCOMB2_FACTOR(J1,J1FAC)

!  Return J1FAC as one prime factor of J1, and return J1 with the value J1 / J1FAC

      IMPLICIT NONE
      INTEGER :: J,J1,J1FAC

      IF (MOD(J1,2) == 0) THEN
          J1FAC = 2
          J1 = J1 / J1FAC
          RETURN
      ENDIF

      IF (MOD(J1,3) == 0) THEN
          J1FAC = 3
          J1 = J1 / J1FAC
          RETURN
      ENDIF

      DO J = 5, INT(SQRT(DBLE(J1)))+1, 6
         J1FAC = J
         IF (MOD(J1,J1FAC) == 0) THEN
             J1 = J1 / J1FAC
             RETURN
         ENDIF
         J1FAC = J + 2
         IF (MOD(J1,J1FAC) == 0) THEN
             J1 = J1 / J1FAC
             RETURN
         ENDIF
      ENDDO

      J1FAC = J1
      J1 = 1

      END SUBROUTINE IMCOMB2_FACTOR

      SUBROUTINE IMCOMBI(N,K,MA)

!  Binomial coefficients for integers.
!  N, K, are machine precision integers, MC is a multiprecision integer.

!  MA = N choose K = N! / ( K! * (N-K)! )

!  See the comments in IMCOMB about results for negative N, etc.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N,K
      INTEGER :: MA
      INTEGER :: MXY(2),L,N1,NMETHD,NUMBER_USED_SAVE
      INTEGER :: J,KSTART,KT,LARGE,LARGED,NDIV,NEXTD,NEXTN,NMPY,NTD,NTN
      DOUBLE PRECISION :: CN,CK,CNK,E,LOGN,LOGK,LOGNK,PI
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MBLOGS /= MBASE) CALL FMCONS

      N1 = N
      IF (N < 0) N1 = -N + K - 1
      CN = MAX(1,N1)
      CK = MAX(1,K)
      CK = MIN(CK,CN)
      CNK = MAX(1,N1-K)
      CNK = MIN(CNK,CN)
      E = EXP(1.0D0)
      PI = ACOS(-1.0D0)
      LOGN = (LOG( 2*PI*CN )/2) + CN*LOG( CN/E ) + LOG( 1 + 1/(12.0D0*CN) )
      LOGK = (LOG( 2*PI*CK )/2) + CK*LOG( CK/E ) + LOG( 1 + 1/(12.0D0*CK) )
      LOGNK = (LOG( 2*PI*CNK )/2) + CNK*LOG( CNK/E ) + LOG( 1 + 1/(12.0D0*CNK) )
      L = MIN(K,N1-K)
      IF (LOGN < 1.0D+10) THEN
          RESULT_SIZE = (LOGN - LOGK - LOGNK) / DLOGMB + 7
      ELSE
          RESULT_SIZE = (L*LOG(CN) - MIN(LOGK,LOGNK)) / DLOGMB + 7
      ENDIF
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (L < 0) THEN
          CALL IMI2M(0,MA)
          GO TO 110
      ELSE IF (L == 0) THEN
          CALL IMI2M(1,MA)
          GO TO 110
      ELSE IF (L == 1) THEN
          CALL IMI2M(N1,MA)
          GO TO 110
      ENDIF

!             Determine which method to use.

      NMETHD = 2
      IF (N1 >= 2100) THEN
          IF (N1 >= 10**7) THEN
              IF (L >= 8) NMETHD = 1
          ELSE
              IF (L > EXP(10.7D0 - 0.53D0*LOG(CN))) NMETHD = 1
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          CALL IMFACT_P(N1-L+1,N1,MXY(1))
          CALL IMFACT_P(2,L,MXY(2))
          CALL IMDIV(MXY(1),MXY(2),MA)
          GO TO 110
      ENDIF

!             Find the largest value for N1 choose J using integers.

      NTN = N1
      NTD = 1
      LARGE = INT(INTMAX/N1)
      DO J = 2, L
         IF (NTN <= LARGE) THEN
             NTN = (NTN*((N1+1)-J))/J
         ELSE
             CALL IMI2M(NTN,MA)
             NTN = (N1+1) - J
             NTD = J
             EXIT
         ENDIF
      ENDDO

      IF (NTD == 1) THEN
          CALL IMI2M(NTN,MA)
          GO TO 110
      ENDIF

      NEXTN = NTN
      NEXTD = NTD
      KSTART = NTD + 1

!             Compute the rest of N1 choose K.

      LARGED = MIN(LARGE,INT(MXBASE))
      DO KT = KSTART, L
         NEXTN = NEXTN - 1
         NEXTD = NEXTD + 1
         IF (NTN >= LARGE .OR. NTD >= LARGED) THEN
             CALL IMMPYI(MA,NTN,MXY(1))
             CALL IMDIVI(MXY(1),NTD,MA)
             NTN = NEXTN
             NTD = NEXTD
             CYCLE
         ENDIF
         NMPY = NTN*NEXTN
         NDIV = NTD*NEXTD
         IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
             NTN = NMPY
             NTD = NDIV
         ELSE
             CALL FMGCDI(NMPY,NDIV)
             IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                 NTN = NMPY
                 NTD = NDIV
             ELSE
                 CALL IMMPYI(MA,NTN,MXY(1))
                 CALL IMDIVI(MXY(1),NTD,MA)
                 NTN = NEXTN
                 NTD = NEXTD
             ENDIF
         ENDIF
      ENDDO
      CALL FMGCDI(NTN,NTD)
      CALL IMMPYI(MA,NTN,MXY(1))
      CALL IMDIVI(MXY(1),NTD,MA)

  110 IF (N < 0 .AND. MOD(K,2) == 1 .AND.  &
          MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) THEN
          MWK(START(MA)) = -MWK(START(MA))
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMCOMBI

      FUNCTION IMCOMP(MA,LREL,MB)

!  Logical comparison of FM numbers MA and MB.

!  LREL is a CHARACTER description of the comparison to be done:
!  LREL = 'EQ' returns IMCOMP = .TRUE. if MA == MB
!       = 'NE', 'GE', 'GT', 'LE', 'LT' also work like a logical IF.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

      USE FMVALS
      IMPLICIT NONE

      LOGICAL :: IMCOMP
      CHARACTER(*) :: LREL
      CHARACTER(2) :: JREL
      INTEGER :: MA,MB

      INTEGER :: J,JCOMP,NDSAVE,NLAST,NTRSAV
      INTENT (IN) :: MA,LREL,MB

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMCOMP   ',2,MA,MB)
      NAMEST(NCALL) = 'IMCOMP'

      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 2) THEN
          WRITE (KW,"(' Input to IMCOMP')")
          NDSAVE = NDIG
          IF (NTRACE > 0) THEN
              CALL IMPRNT(MA)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL IMPRNT(MB)
          ELSE
              NDIG = MAX(2,INT(MWK(START(MA)+2)))
              NTRSAV = NTRACE
              CALL IMNTRJ(MA,NDIG)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              NDIG = MAX(2,INT(MWK(START(MB)+2)))
              CALL IMNTRJ(MB,NDIG)
              NTRACE = NTRSAV
          ENDIF
          NDIG = NDSAVE
      ENDIF

!             JCOMP will be 1 if MA > MB
!                           2 if MA == MB
!                           3 if MA < MB

!             Check for special cases.

      JREL = LREL
      IF (LREL /= 'EQ' .AND. LREL /= 'NE' .AND. LREL /= 'LT' .AND.  &
          LREL /= 'GT' .AND. LREL /= 'LE' .AND. LREL /= 'GE') THEN
          IF (LREL == 'eq' .OR. LREL == '==') THEN
              JREL = 'EQ'
          ELSE IF (LREL == 'ne' .OR. LREL == '/=') THEN
              JREL = 'NE'
          ELSE IF (LREL == 'lt' .OR. LREL == '<') THEN
              JREL = 'LT'
          ELSE IF (LREL == 'gt' .OR. LREL == '>') THEN
              JREL = 'GT'
          ELSE IF (LREL == 'le' .OR. LREL == '<=') THEN
              JREL = 'LE'
          ELSE IF (LREL == 'ge' .OR. LREL == '>=') THEN
              JREL = 'GE'
          ELSE
              IMCOMP = .FALSE.
              KFLAG = -4
              IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
              IF (KWARN <= 0) GO TO 120
              WRITE (KW,                                                     &
                     "(/' Error of type KFLAG = -4 in FM package in',"   //  &
                     "' routine IMCOMP'//1X,A,' is not one of the six'," //  &
                     "' recognized comparisons.'//' .FALSE. has been',"  //  &
                     "' returned.'/)"                                        &
                    ) LREL
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          IMCOMP = .FALSE.
          KFLAG = -4
          GO TO 120
      ENDIF

      IF (ABS(MWK(START(MA)+2)) == MEXPOV .AND. MWK(START(MA)+2) == MWK(START(MB)+2) .AND.  &
          MWK(START(MA)+3) == MWK(START(MB)+3) .AND. MWK(START(MA)) == MWK(START(MB))) THEN
          IMCOMP = .FALSE.
          KFLAG = -4
          IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
          IF (KWARN <= 0) GO TO 120
          WRITE (KW,                                                     &
                 "(/' Error of type KFLAG = -4 in FM package in ',"  //  &
                 "'routine IMCOMP'//' Two numbers in the same ',"    //  &
                 "'overflow category cannot be compared.'//"         //  &
                 "' .FALSE. has been returned.'/)"                       &
                )
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          GO TO 120
      ENDIF

!             Check for zero.

      KFLAG = 0
      IF (MWK(START(MA)+3) == 0) THEN
          JCOMP = 2
          IF (MWK(START(MB)+3) == 0) GO TO 110
          IF (MWK(START(MB)) < 0) JCOMP = 1
          IF (MWK(START(MB)) > 0) JCOMP = 3
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          JCOMP = 1
          IF (MWK(START(MA)) < 0) JCOMP = 3
          GO TO 110
      ENDIF

!             Check for opposite signs.

      IF (MWK(START(MA)) > 0 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)) > 0 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
          GO TO 110
      ENDIF

!             See which one is larger in absolute value.

      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
          GO TO 110
      ENDIF
      NLAST = INT(MWK(START(MA)+2)) + 1

      DO J = 2, NLAST
         IF (ABS(MWK(START(MA)+J+1)) > ABS(MWK(START(MB)+J+1))) THEN
             JCOMP = 1
             GO TO 110
         ENDIF
         IF (ABS(MWK(START(MB)+J+1)) > ABS(MWK(START(MA)+J+1))) THEN
             JCOMP = 3
             GO TO 110
         ENDIF
      ENDDO

      JCOMP = 2

!             Now match the JCOMP value to the requested comparison.

  110 IF (JCOMP == 1 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
      ELSE IF (JCOMP == 3 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
      ENDIF

      IMCOMP = .FALSE.
      IF (JCOMP == 1 .AND. (JREL == 'GT' .OR. JREL == 'GE' .OR. JREL == 'NE')) IMCOMP = .TRUE.
      IF (JCOMP == 2 .AND. (JREL == 'EQ' .OR. JREL == 'GE' .OR. JREL == 'LE')) IMCOMP = .TRUE.
      IF (JCOMP == 3 .AND. (JREL == 'NE' .OR. JREL == 'LT' .OR. JREL == 'LE')) IMCOMP = .TRUE.

  120 CONTINUE
      IF (NTRACE /= 0) THEN
          IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 1) THEN
              IF (KFLAG == 0) THEN
                  WRITE (KW,                                         &
                         "(' IMCOMP',15X,'Call level =',I2,5X,"  //  &
                         "'MBASE =',I10)"                            &
                        ) NCALL,INT(MBASE)
              ELSE
                  WRITE (KW,                                        &
                         "(' IMCOMP',6X,'Call level =',I2,4X,"  //  &
                         "'MBASE =',I10,4X,'KFLAG =',I3)"           &
                        ) NCALL,INT(MBASE),KFLAG
              ENDIF
              IF (IMCOMP) THEN
                  WRITE (KW,"(7X,'.TRUE.')")
              ELSE
                  WRITE (KW,"(7X,'.FALSE.')")
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      RETURN
      END FUNCTION IMCOMP

      SUBROUTINE IMDEFINE(MA,SIZE_MA)

!  Assign space in the FM work area, MWK, for a new multiple precision number.
!  Before being defined the first time, MA must have one of these values, to indicate what
!  type of multiple precision number MA will represent, and how much space it will need:

!      -1 for derived type FM, IM, ZM temporary numbers
!      -2 for internal FM temporary multiple precision numbers
!      -3 for user saved derived type variables or FM saved constants (MPI, ...)
!      -4 for bigger saved FM work areas (MWA, ...)
!      -5 for multiple precision temporary numbers in packed format
!      -6 and -7 for internal bookkeeping of assigned space.

!  After calling FMDEFINE with MA from -5 to -1, the returned value of MA is positive, giving an
!  "index" value.  Then START(MA) gives the starting location in array MWK for the multiple
!  precision number, and SIZE_OF(MA) gives the number of array elements in MWK that are assigned
!  to multiple precision number MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,SIZE_MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: SIZE_MA
      INTEGER :: I,J,K,L,L1,L2,NEW_SIZE,NFREE,N_RESIZE

      NEW_SIZE = SIZE_MA
      N_RESIZE = 0
      IF (MA > SIZE_OF_START) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In IMDEFINE the index value of MA is too large.'
          WRITE (KW,*) '               Index =',MA,' cannot be greater than ',SIZE_OF_START,'.'
          WRITE (KW,*) '               Usually this means a low-level FM, IM, or ZM routine has'
          WRITE (KW,*) '               been called directly with an undefined argument.'
          WRITE (KW,*) ' '
          STOP
      ENDIF

!             If MA has already been defined at a lower precision, MA will be positive here.
!             Re-define it with a new index and more space in MWK.

!             TEMPV(L) is set to the -1, ..., -5 input value of MA when MA is defined (= L) the
!             first time, so that a record is preserved of which type of multiple precision number
!             MA represents.
!             TEMPV(L) is set to -6 if MA gets re-defined at higher precision.  MA then has a new
!             index value and more space in MWK, and the -6 TEMPV value marks the old index as
!             unused.
!             If MWK runs out of space for new multiple precision numbers, it is re-allocated at a
!             bigger size.  When that is done, the unused space in MWK corresponding to any
!             TEMPV = -6 index values is deleted, and then those TEMPV elements are set to -7 to
!             mark those indexes as deleted.

      IF (MA > 0) THEN
          N_RESIZE = RESIZE(MA)
          RESIZE(MA) = 0
          L = MA
          MA = TEMPV(L)
          TEMPV(L) = -6
          IF (L >= LOWEST_SAVED_AREA_INDEX) THEN
              TOTAL_IMTEMP6 = TOTAL_IMTEMP6 + 1
              IF (NMAX_IMTEMP6 >= SIZE_OF_TEMP6) THEN
                  N_IMTEMP6 = MOD( TOTAL_IMTEMP6, SIZE_OF_TEMP6 ) + 1
                  IMTEMP6(N_IMTEMP6) = L
              ELSE
                  NMAX_IMTEMP6 = NMAX_IMTEMP6 + 1
                  IMTEMP6(NMAX_IMTEMP6) = L
              ENDIF
          ENDIF
          N_RESIZE = N_RESIZE + 1
          IF (N_RESIZE > 10) NEW_SIZE = 2*SIZE_MA
      ELSE IF (MA == 0 .OR. MA < -5) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In IMDEFINE the index value of MA must be positive or in'
          WRITE (KW,*) '               the range -5, ..., -1.  MA is ',MA
          WRITE (KW,*) '               Usually this means a low-level FM, IM, or ZM routine has'
          WRITE (KW,*) '               been called directly with an undefined argument.'
          WRITE (KW,*) ' '
          STOP
      ENDIF

!             L1    is the last word used on the left of MWK.
!             L2    is the first word used on the right of MWK.
!             NFREE is the number of free words in the middle.

      L1 = 1
      IF (NUMBER_USED > 0) L1 = START(NUMBER_USED)+SIZE_OF(NUMBER_USED)
      L2 = SIZE_OF_MWK
      IF (LOWEST_SAVED_AREA_INDEX <= SIZE_OF_START) L2 = START_OF_MWK_SAVED_AREA
      NFREE = L2 - L1 - 1

!             If MWK runs out of space, try to re-allocate it with a bigger size.

      IF (NEW_SIZE > NFREE) CALL FMDEFINE_RESIZE(NEW_SIZE)

      IF (MA == -3 .OR. MA == -4) GO TO 110

!             Store temporary variables from the beginning of MWK.

      IF (NUMBER_USED <= 0) THEN
          NUMBER_USED = 1
          START(1) = 1
          SIZE_OF(1) = NEW_SIZE
      ELSE
          IF (LOWEST_SAVED_AREA_INDEX <= SIZE_OF_START) THEN
              L1 = START_OF_MWK_SAVED_AREA
          ELSE
              L1 = SIZE_OF_MWK
          ENDIF
          IF (NUMBER_USED+1 >= LOWEST_SAVED_AREA_INDEX) THEN
              CALL FMDEFINE_ERROR(2)
          ENDIF
          NUMBER_USED = NUMBER_USED + 1
          START(NUMBER_USED) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
          SIZE_OF(NUMBER_USED) = NEW_SIZE
      ENDIF
      MAXIMUM_NUMBER_USED = MAX(MAXIMUM_NUMBER_USED,NUMBER_USED)
      MAXIMUM_MWK_USED = MAX(MAXIMUM_MWK_USED,START(NUMBER_USED)+NEW_SIZE)
      TEMPV(NUMBER_USED) = MA

      MA = NUMBER_USED
      RESIZE(MA) = N_RESIZE
      RETURN

!             Store saved variables from the end of MWK.

  110 IF (LOWEST_SAVED_AREA_INDEX > SIZE_OF_START) THEN
          LOWEST_SAVED_AREA_INDEX = SIZE_OF_START
          START(LOWEST_SAVED_AREA_INDEX) = SIZE_OF_MWK - NEW_SIZE + 1
          START_OF_MWK_SAVED_AREA = SIZE_OF_MWK - NEW_SIZE + 1
          SIZE_OF(LOWEST_SAVED_AREA_INDEX) = NEW_SIZE
          TEMPV(LOWEST_SAVED_AREA_INDEX) = MA
          MA = LOWEST_SAVED_AREA_INDEX
      ELSE
          L1 = START_OF_MWK_SAVED_AREA
          IF (NUMBER_USED > 0) THEN
              L2 = START(NUMBER_USED) + SIZE_OF(NUMBER_USED)
          ELSE
              L2 = 1
          ENDIF
          L = -1
          IF (NMAX_IMTEMP6 == 0) THEN
              IF (NMAX_FMTEMP6 > 0) THEN
                  DO J = 1, NMAX_FMTEMP6
                     IF (SIZE_OF(FMTEMP6(J)) >= NEW_SIZE) THEN
                         TOTAL_IMTEMP6 = TOTAL_IMTEMP6 + 1
                         IF (NMAX_IMTEMP6 >= SIZE_OF_TEMP6) THEN
                             N_IMTEMP6 = MOD( TOTAL_IMTEMP6, SIZE_OF_TEMP6 ) + 1
                             IMTEMP6(N_IMTEMP6) = FMTEMP6(J)
                         ELSE
                             NMAX_IMTEMP6 = NMAX_IMTEMP6 + 1
                             IMTEMP6(NMAX_IMTEMP6) = FMTEMP6(J)
                         ENDIF
                         DO I = J, NMAX_FMTEMP6 - 1
                            FMTEMP6(I) = FMTEMP6(I+1)
                         ENDDO
                         TOTAL_FMTEMP6 = TOTAL_FMTEMP6 - 1
                         NMAX_FMTEMP6 = NMAX_FMTEMP6 - 1
                         N_FMTEMP6 = MAX(N_FMTEMP6 - 1, 0)
                         EXIT
                     ENDIF
                  ENDDO
              ELSE IF (TOTAL_FMTEMP6 + TOTAL_IMTEMP6 > 0) THEN
                  DO J = LOWEST_SAVED_AREA_INDEX, SIZE_OF_START
                     IF (TEMPV(J) == -6) THEN
                         IF (NMAX_IMTEMP6 >= SIZE_OF_TEMP6) THEN
                             N_IMTEMP6 = MOD( TOTAL_IMTEMP6, SIZE_OF_TEMP6 ) + 1
                             IMTEMP6(N_IMTEMP6) = J
                         ELSE
                             NMAX_IMTEMP6 = NMAX_IMTEMP6 + 1
                             IMTEMP6(NMAX_IMTEMP6) = J
                         ENDIF
                         IF (NMAX_IMTEMP6 > TOTAL_IMTEMP6) THEN
                             TOTAL_IMTEMP6 = TOTAL_IMTEMP6 + 1
                             TOTAL_FMTEMP6 = TOTAL_FMTEMP6 - 1
                         ENDIF
                         IF (NMAX_IMTEMP6 >= SIZE_OF_TEMP6 .OR.  &
                             NMAX_IMTEMP6 >= TOTAL_FMTEMP6 + TOTAL_IMTEMP6) EXIT
                     ENDIF
                  ENDDO
              ENDIF
          ENDIF
          DO J = 1, NMAX_IMTEMP6
             IF (TEMPV(IMTEMP6(J)) /= -6) THEN
                 CYCLE
             ENDIF
             IF (SIZE_OF(IMTEMP6(J)) == NEW_SIZE) THEN
                 L = IMTEMP6(J)
                 EXIT
             ELSE IF (SIZE_OF(IMTEMP6(J)) >= NEW_SIZE) THEN
                 IF (L < 0) THEN
                     L = IMTEMP6(J)
                 ELSE
                     IF (SIZE_OF(IMTEMP6(J)) < SIZE_OF(L)) THEN
                         L = IMTEMP6(J)
                     ENDIF
                 ENDIF
             ENDIF
          ENDDO
          IF (L > 0) THEN
              K = 0
              DO J = 1, NMAX_IMTEMP6 - 1
                 IF (IMTEMP6(J) == L) K = 1
                 IF (K == 1) IMTEMP6(J) = IMTEMP6(J+1)
              ENDDO
              TOTAL_IMTEMP6 = TOTAL_IMTEMP6 - 1
              NMAX_IMTEMP6 = NMAX_IMTEMP6 - 1
              N_IMTEMP6 = MAX(N_IMTEMP6 - 1, 0)
          ENDIF
          IF (L < 0) THEN
              IF (NUMBER_USED+1 >= LOWEST_SAVED_AREA_INDEX .OR. L2+NEW_SIZE >= L1) THEN
                  CALL FMDEFINE_ERROR(2)
              ENDIF
              IF (TOTAL_TEMP7 <= 0 .AND. LOWEST_SAVED_AREA_INDEX-1 < START_RESIZE) THEN
                  CALL FMDEFINE_START
              ENDIF
              IF (TOTAL_TEMP7 > 0) THEN
                  L = TEMP7(TOTAL_TEMP7)
                  TOTAL_TEMP7 = TOTAL_TEMP7 - 1
                  START_OF_MWK_SAVED_AREA = START_OF_MWK_SAVED_AREA - NEW_SIZE
                  START(L) = START_OF_MWK_SAVED_AREA
                  SIZE_OF(L) = NEW_SIZE
                  TEMPV(L) = MA
                  MA = L
              ELSE
                  LOWEST_SAVED_AREA_INDEX = LOWEST_SAVED_AREA_INDEX - 1
                  START(LOWEST_SAVED_AREA_INDEX) = START_OF_MWK_SAVED_AREA - NEW_SIZE
                  START_OF_MWK_SAVED_AREA = START_OF_MWK_SAVED_AREA - NEW_SIZE
                  SIZE_OF(LOWEST_SAVED_AREA_INDEX) = NEW_SIZE
                  TEMPV(LOWEST_SAVED_AREA_INDEX) = MA
                  MA = LOWEST_SAVED_AREA_INDEX
              ENDIF
          ELSE
              TEMPV(L) = MA
              MA = L
          ENDIF
      ENDIF
      MINIMUM_SAVED_CONSTANTS_USED = MIN(MINIMUM_SAVED_CONSTANTS_USED,LOWEST_SAVED_AREA_INDEX)
      RESIZE(MA) = N_RESIZE
      RETURN
      END SUBROUTINE IMDEFINE

      SUBROUTINE IMDIM(MA,MB,MC)

!  MC = DIM(MA,MB)

!  Positive difference.  MC = MA - MB  if MA >= MB,
!                           = 0        otherwise.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KOVFL
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIM    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIM'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ENDIF
      IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMDIM'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 110
      ENDIF
      KOVFL = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          KOVFL = 1
          IF (MWK(START(MA)+2) == MEXPOV .AND. MWK(START(MB)+2) == MEXPOV .AND.  &
              MWK(START(MA)+3) == MWK(START(MB)+3) .AND. MWK(START(MA)) == MWK(START(MB))) THEN
              KFLAG = -4
              NAMEST(NCALL) = 'IMDIM'
              CALL FMWARN
              CALL IMST2M('UNKNOWN',MC)
              GO TO 110
          ENDIF
      ENDIF

      IF (IMCOMP(MA,'>=',MB)) THEN
          CALL IMSUB(MA,MB,MC)
          IF (KFLAG == 1) KFLAG = 0
      ELSE
          MWK(START(MC)+2) = 0
          MWK(START(MC)+3) = 0
          MWK(START(MC)+4) = 0
          MWK(START(MC)) = 1
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
      ENDIF

      IF (MWK(START(MC)+2) >= MEXPOV) THEN
          IF (MWK(START(MC)+2) == MUNKNO) THEN
              KFLAG = -4
              NAMEST(NCALL) = 'IMDIM'
              CALL FMWARN
          ELSE IF (NCALL == 1 .OR. MWK(START(MC)+2) >= MEXPOV) THEN
              IF (MWK(START(MC)) > 0) THEN
                  CALL IMST2M('OVERFLOW',MC)
              ELSE
                  CALL IMST2M('-OVERFLOW',MC)
              ENDIF
              KFLAG = -5
              NAMEST(NCALL) = 'IMDIM'
              IF (KOVFL /= 1) CALL FMWARN
          ENDIF
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIM

      SUBROUTINE IMDIV(MA,MB,MC)

!  MC = INT(MA/MB)

!  Use IMDIVR if both INT(MA/MB) and MOD(MA,MB) are needed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MWK(START(MA)+2) - MWK(START(MB)+2) + 6
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIV    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIV'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ENDIF

      KREM = 0
      CALL IMDIVR(MA,MB,MC,MXY(1))
      KREM = 1

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMDIV'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIV

      SUBROUTINE IMDIVI(MA,IDIV,MB)

!  MB = INT(MA/IDIV)

!  Use IMDVIR if both INT(MA/IDIV) and MOD(MA,IDIV) are needed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IDIV,IREM,NDSAVE
      INTENT (IN) :: MA,IDIV
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+3))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIVI   ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIVI'
          CALL IMNTR(2,MA,MA,1)
          CALL IMNTRI(2,IDIV,0)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MB)
          KFLAG = -4
          GO TO 110
      ENDIF

      CALL IMDVIR(MA,IDIV,MB,IREM)

      IF (MWK(START(MB)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMDIVI'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIVI

      SUBROUTINE IMDIVR(MA,MB,MC,MD)

!  MC = INT(MA / MB),    MD = Remainder from the division.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB,MDR
      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MAXMWA,MB1,MBP1,MBS,MCARRY,MKT,MLMAX,MQD
      INTEGER :: J,JB,JL,JMB,JMWA,K,KA,KB,KL,KLTFLG,KPTMWA,LCRRCT,NA1,NB1,ND,NDSAVE,NGUARD,NL,  &
                 NMBWDS,NMETHD,NTRSAV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC,MD
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MWK(START(MA)+2) - MWK(START(MB)+2) + 6
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = MAX(5,INT(MWK(START(MB)+2)+3)) + 2
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = MWK(START(MA)+2) + 5
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIVR   ',2,MA,MB)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIVR'
          CALL IMNTR(2,MA,MB,2)
      ENDIF
      KFLAG = 0
      NTRSAV = NTRACE
      NTRACE = 0
      IF (MBLOGS /= MBASE) CALL FMCONS

!             Check for special cases.

      IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MA)+2) /= MUNKNO) THEN
          IF (MWK(START(MB))*MWK(START(MB)+3) == 1) THEN
              CALL IMEQ(MA,MC)
              MWK(START(MD)+2) = 0
              MWK(START(MD)+3) = 0
              MWK(START(MD)+4) = 0
              MWK(START(MD)) = 1
              MWK(START(MD)+1) = NINT(10**7*ALOGM2)
              GO TO 170
          ELSE IF (MWK(START(MB))*MWK(START(MB)+3) == -1) THEN
              CALL IMEQ(MA,MC)
              IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                  MWK(START(MC)) = -MWK(START(MC))
              MWK(START(MD)+2) = 0
              MWK(START(MD)+3) = 0
              MWK(START(MD)+4) = 0
              MWK(START(MD)) = 1
              MWK(START(MD)+1) = NINT(10**7*ALOGM2)
              GO TO 170
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) < MWK(START(MB)+2) .AND. MWK(START(MB)+2) /= MUNKNO) GO TO 110
      IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR. MWK(START(MB)+3) == 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
              NAMEST(NCALL) = 'IMDIVR'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MC)
          CALL IMST2M('UNKNOWN',MD)
          GO TO 170
      ENDIF
      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MB)+2) > 2) GO TO 110
          IF (MWK(START(MB)+3) == 0) GO TO 110
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          IF (MWK(START(MB)+2) <= 1) THEN
              MDB = MWK(START(MB)) * MWK(START(MB)+3)
          ELSE
              MDB = MWK(START(MB)) * (MWK(START(MB)+3)*MBASE + MWK(START(MB)+4))
          ENDIF
          MDAB = AINT (MDA / MDB)
          MDR = MDA - MDAB*MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = NINT(10**7*ALOGM2)
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = MDAB
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = -MDAB
                  MWK(START(MC)) = -1
              ENDIF
              MWK(START(MC)+4) = 0
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = NINT(10**7*ALOGM2)
              MWK(START(MC)+2) = 2
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = AINT (MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(-MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = -1
              ENDIF
          ELSE
              GO TO 110
          ENDIF
          IF (ABS(MDR) < MBASE) THEN
              MWK(START(MD)+1) = MWK(START(MC)+1)
              MWK(START(MD)+2) = 1
              IF (MDR == 0) MWK(START(MD)+2) = 0
              IF (MDR >= 0) THEN
                  MWK(START(MD)+3) = MDR
                  MWK(START(MD)) = 1
              ELSE
                  MWK(START(MD)+3) = -MDR
                  MWK(START(MD)) = -1
              ENDIF
              MWK(START(MD)+4) = 0
              GO TO 170
          ELSE IF (ABS(MDR) < MBASE*MBASE) THEN
              MWK(START(MD)+1) = MWK(START(MC)+1)
              MWK(START(MD)+2) = 2
              IF (MDR >= 0) THEN
                  MWK(START(MD)+3) = AINT (MDR/MBASE)
                  MWK(START(MD)+4) = ABS(MDR - MBASE*MWK(START(MD)+3))
                  MWK(START(MD)) = 1
              ELSE
                  MWK(START(MD)+3) = AINT (-MDR/MBASE)
                  MWK(START(MD)+4) = ABS(-MDR - MBASE*MWK(START(MD)+3))
                  MWK(START(MD)) = -1
              ENDIF
              GO TO 170
          ENDIF
      ENDIF

  110 KLTFLG = 0
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      KL = INT(MWK(START(MB)+2))
      IF (ABS(KL) >= MEXPOV) KL = 2
      RESULT_SIZE = ABS(MWK(START(MB)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      DO J = 0, KL+1
         MWK(START(MXY(1))+J+1) = MWK(START(MB)+J+1)
      ENDDO
      MWK(START(MXY(1))) = 1
      IF (KL == 1) MWK(START(MXY(1))+4) = 0
      IF (MWK(START(MA)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MA)+3)) <= MWK(START(MXY(1))+3)) THEN
          DO J = 2, KL+1
             IF (MWK(START(MA)+J+1) /= MWK(START(MXY(1))+J+1)) GO TO 120
          ENDDO
          KLTFLG = 2
  120     IF (KLTFLG == 0) THEN
              DO J = 2, KL+1
                 IF (MWK(START(MA)+J+1) < MWK(START(MXY(1))+J+1)) THEN
                     KLTFLG = 1
                     EXIT
                 ELSE IF (MWK(START(MA)+J+1) > MWK(START(MXY(1))+J+1)) THEN
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) < MWK(START(MB)+2) .OR. KLTFLG >= 1) THEN
          IF (KLTFLG /= 2) THEN
              CALL IMEQ(MA,MD)
              MWK(START(MD)) = ABS(MWK(START(MD)))
              CALL IMI2M(0,MC)
          ELSE
              CALL IMI2M(1,MC)
              CALL IMI2M(0,MD)
          ENDIF
          GO TO 160
      ENDIF

      NDIG = INT(MWK(START(MA)+2)) + 2
      IF (NDIG < 2) NDIG = 2

!             Check for using an FFT-based method if precision is very high.

      ND = 1000
      IF (INT(MWK(START(MA)+2))-INT(MWK(START(MB)+2)) >= ND) THEN
          NMETHD = 2
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL IMI2FM(MA,MXY(1))
          MWK(START(MXY(1))) = 1
          CALL IMI2FM(MB,MXY(2))
          MWK(START(MXY(2))) = 1
          CALL FMDIV(MXY(1),MXY(2),MXY(3))
          CALL IMFM2I(MXY(3),MC)
          IF (KREM /= 1) THEN
              CALL IMI2M(0,MD)
          ELSE
              CALL IMABS(MA,MXY(1))
              CALL IMABS(MB,MXY(2))
              CALL IMMPY(MC,MXY(2),MXY(3))
              CALL IMSUB(MXY(1),MXY(3),MXY(4))
              CALL IMEQ(MXY(4),MD)
              IF (MWK(START(MD)) == -1) THEN
                  CALL IMI2M(1,MXY(3))
                  CALL IMSUB(MC,MXY(3),MXY(4))
                  CALL IMEQ(MXY(4),MC)
                  CALL IMADD(MD,MXY(2),MXY(4))
                  CALL IMEQ(MXY(4),MD)
              ELSE IF (IMCOMP(MD,'>=',MXY(2))) THEN
                  CALL IMI2M(1,MXY(3))
                  CALL IMADD(MC,MXY(3),MXY(4))
                  CALL IMEQ(MXY(4),MC)
                  CALL IMSUB(MD,MXY(2),MXY(4))
                  CALL IMEQ(MXY(4),MD)
              ENDIF
          ENDIF
          GO TO 160
      ENDIF

      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)

!             NGUARD is the number of guard digits used.

      NGUARD = 1
      NA1 = INT(MWK(START(MA)+2)) + 1
      NB1 = INT(MWK(START(MB)+2)) + 1

!             Copy MA into the working array.

      DO J = 3, NA1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1
      MWK(START(MWA)+3) = 0
      NL = NA1 + NGUARD + 3
      DO J = NA1+2, NL
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MB1 = MWK(START(MB)+2)
      MBS = MWK(START(MB))
      MWK(START(MWA)+4) = MWK(START(MA)+3)

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= NB1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= NB1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= NB1) THEN
          XB = XB + DBLE(MWK(START(MB)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.
!             It is used to determine whether normalization can be postponed.

      MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  130 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = KA + INT(MB1) - 1
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMB = START(MB) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMB+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA-2 < MWK(START(MWA)+2)) GO TO 130

!             Final normalization.

      KPTMWA = KPTMWA - 1
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

      LCRRCT = 0
  140 DO J = KPTMWA+INT(MB1), KPTMWA+2, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

!             Due to rounding, the remainder may not be between 0 and ABS(MB) here.
!             Correct if necessary.

      IF (MWK(START(MWA)+KA+1) < 0) THEN
          LCRRCT = LCRRCT - 1
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MWK(START(MB)+J-JB+1)
          ENDDO
          GO TO 140
      ELSE IF (MWK(START(MWA)+KA+1) >= MBASE) THEN
          LCRRCT = LCRRCT + 1
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MWK(START(MB)+J-JB+1)
          ENDDO
          GO TO 140
      ENDIF
      IF (MWK(START(MWA)+3) /= 0 .OR. KPTMWA == 2) THEN
          DO J = 1, INT(MWK(START(MWA)+2))+1
             MWK(START(MC)+J+1) = MWK(START(MWA)+J+1)
          ENDDO
      ELSE
          DO J = 3, INT(MWK(START(MWA)+2))+1
             MWK(START(MC)+J) = MWK(START(MWA)+J+1)
          ENDDO
          IF (MWK(START(MC)+3) /= 0) THEN
              MWK(START(MC)+2) = MWK(START(MWA)+2) - 1
          ELSE
              MWK(START(MC)+2) = 0
          ENDIF
      ENDIF
      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      MWK(START(MC)+1) = MIN(MACCA,MACCB)
      MWK(START(MC)) = 1

      IF (MWK(START(MWA)+KPTMWA+2) /= 0) THEN
          DO J = 1, INT(MB1)
             MWK(START(MD)+J+2) = MWK(START(MWA)+J+KPTMWA+1)
          ENDDO
          MWK(START(MD)+2) = MB1
      ELSE
          DO J = 1, INT(MB1)
             IF (MWK(START(MWA)+J+KPTMWA+1) /= 0) THEN
                 DO K = J, INT(MB1)
                    MWK(START(MD)+K-J+3) = MWK(START(MWA)+K+KPTMWA+1)
                 ENDDO
                 MWK(START(MD)+2) = MB1 + 1 - J
                 GO TO 150
             ENDIF
          ENDDO
          MWK(START(MD)+2) = 0
          MWK(START(MD)+3) = 0
      ENDIF
  150 IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      MWK(START(MD)+1) = MIN(MACCA,MACCB)
      MWK(START(MD)) = 1

!             If the remainder had to be corrected, make the corresponding adjustment in
!             the quotient.

      IF (MWK(START(MD)+2) > MWK(START(MXY(1))+2) .OR.    &
         (MWK(START(MD)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MD)+3)) >= MWK(START(MXY(1))+3))) THEN
          IF (IMCOMP(MD,'>=',MXY(1))) THEN
              CALL IMSUB(MD,MXY(1),MXY(3))
              CALL IMEQ(MXY(3),MD)
              LCRRCT = LCRRCT + 1
          ENDIF
      ENDIF
      IF (LCRRCT /= 0) THEN
          CALL IMI2M(LCRRCT,MXY(2))
          CALL IMADD(MXY(2),MC,MXY(3))
          CALL IMEQ(MXY(3),MC)
      ENDIF

  160 MWK(START(MC)) = 1
      MWK(START(MD)) = 1
      IF (MAS < 0 .AND. MBS > 0) THEN
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0) MWK(START(MD)) = -1
      ELSE IF (MAS > 0 .AND. MBS < 0)  THEN
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
      ELSE IF (MAS < 0 .AND. MBS < 0)  THEN
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0) MWK(START(MD)) = -1
      ENDIF

  170 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      NTRACE = NTRSAV
      IF (NTRACE /= 0) THEN
          CALL IMNTR(1,MC,MC,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  NDIG = MAX(2,INT(MWK(START(MD)+2)))
                  NTRSAV = NTRACE
                  CALL IMNTRJ(MD,NDIG)
                  NTRACE = NTRSAV
              ELSE
                  CALL IMPRNT(MD)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIVR

      SUBROUTINE IMDVIR(MA,IDIV,MB,IREM)

!  MB = INT(MA / IDIV),    IREM = Remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MDA,MDAB,MDB,MDR,MKT,MODINT,MVALP
      INTEGER :: IDIV,IREM,J,JDIV,JMA,JMWA,KA,KL,KLTFLG,KPT,N1,NDSAVE,NMVAL,NTRSAV,NV2
      INTENT (IN) :: MA,IDIV
      INTENT (INOUT) :: MB,IREM
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+5))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDVIR   ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      KLTFLG = 0
      NTRSAV = NTRACE
      NTRACE = 0
      MKT = ABS(IDIV)
      IF (MKT < MBASE) THEN
          CALL IMDEFINE(MXY(1),5)
          MWK(START(MXY(1))+1) = MWK(START(MA)+1)
          MWK(START(MXY(1))+2) = 1
          MWK(START(MXY(1))+3) = ABS(IDIV)
          MWK(START(MXY(1))+4) = 0
          MWK(START(MXY(1))) = 1
          IF (IDIV < 0) MWK(START(MXY(1))) = -1
      ELSE IF (MKT < MBASE*MBASE) THEN
          CALL IMDEFINE(MXY(1),6)
          MWK(START(MXY(1))+1) = MWK(START(MA)+1)
          MWK(START(MXY(1))+2) = 2
          MWK(START(MXY(1))+3) = INT(MKT/MBASE)
          MWK(START(MXY(1))+4) = MKT - MWK(START(MXY(1))+3)*MBASE
          MWK(START(MXY(1))+5) = 0
          MWK(START(MXY(1))) = 1
          IF (IDIV < 0) MWK(START(MXY(1))) = -1
      ELSE
          CALL IMI2M(IDIV,MXY(1))
      ENDIF
      NTRACE = NTRSAV
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDVIR'
          CALL IMNTR(2,MA,MA,1)
          CALL IMNTRI(2,IDIV,0)
      ENDIF
      JDIV = ABS(IDIV)

!             Check for special cases.

      IF (MWK(START(MA)+2) < 0) THEN
          IREM = IUNKNO
          KFLAG = -4
          NAMEST(NCALL) = 'IMDVIR'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MB)
          GO TO 150
      ENDIF
      IF (JDIV == 1 .AND. MWK(START(MA)+2) /= MUNKNO) THEN
          IF (IDIV == 1) THEN
              CALL IMEQ(MA,MB)
              IREM = 0
              GO TO 150
          ELSE
              CALL IMEQ(MA,MB)
              IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
                  MWK(START(MB)) = -MWK(START(MB))
              IREM = 0
              GO TO 150
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) >= MEXPOV .OR. IDIV == 0) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) THEN
              NAMEST(NCALL) = 'IMDVIR'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MB)
          IREM = IUNKNO
          GO TO 150
      ENDIF
      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          MDB = IDIV
          MDAB = AINT (MDA/MDB)
          MDR = MDA - MDAB*MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 1
              IF (MDAB == 0) MWK(START(MB)+2) = 0
              IF (MDAB < 0) THEN
                  MWK(START(MB)+3) = -MDAB
                  MWK(START(MB)) = -1
              ELSE
                  MWK(START(MB)+3) = MDAB
                  MWK(START(MB)) = 1
              ENDIF
              MWK(START(MB)+4) = 0
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 2
              IF (MDAB < 0) THEN
                  MWK(START(MB)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MB)+4) = ABS(-MDAB - MBASE*MWK(START(MB)+3))
                  MWK(START(MB)) = -1
              ELSE
                  MWK(START(MB)+3) = AINT (MDAB/MBASE)
                  MWK(START(MB)+4) = ABS(MDAB - MBASE*MWK(START(MB)+3))
                  MWK(START(MB)) = 1
              ENDIF
          ELSE
              GO TO 110
          ENDIF
          IREM = INT(MDR)
          GO TO 150
      ENDIF

  110 MAS = MWK(START(MA))
      MWK(START(MXY(1))) = 1
      KL = MWK(START(MXY(1))+2)
      IF (MWK(START(MA)+2) <= MWK(START(MXY(1))+2)) THEN
          IF (MWK(START(MA)+2) == MWK(START(MXY(1))+2) .AND.  &
              ABS(MWK(START(MA)+3)) <= MWK(START(MXY(1))+3)) THEN
              DO J = 2, KL+1
                 IF (MWK(START(MA)+J+1) /= MWK(START(MXY(1))+J+1)) THEN
                     IF (MWK(START(MA)+J+1) < MWK(START(MXY(1))+J+1)) KLTFLG = 1
                     GO TO 120
                 ENDIF
              ENDDO
              KLTFLG = 2
          ENDIF
  120     IF (MWK(START(MA)+2) < MWK(START(MXY(1))+2) .OR. KLTFLG >= 1) THEN
              IF (KLTFLG /= 2) THEN
                  CALL IMM2I(MA,IREM)
                  IREM = ABS(IREM)
                  CALL IMI2M(0,MB)
              ELSE
                  CALL IMI2M(1,MB)
                  IREM = 0
              ENDIF
              GO TO 140
          ENDIF
      ENDIF
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      N1 = INT(MWK(START(MA)+2)) + 1

!             If ABS(IDIV) >= MXBASE use IMDIVR.

      MVALP = ABS(IDIV)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IDIV) > MXBASE .OR. NMVAL /= ABS(IDIV) .OR. NV2 /= ABS(IDIV)-1) THEN
          CALL IMI2M(IDIV,MXY(2))
          CALL IMDIVR(MA,MXY(2),MXY(1),MXY(3))
          CALL IMEQ(MXY(1),MB)
          CALL IMEQ(MXY(3),MXY(2))
          CALL IMM2I(MXY(2),IREM)
          GO TO 150
      ENDIF

!             Find the first significant digit of the quotient.

      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO

      CALL IMM2I(MA,IREM)
      CALL IMI2M(0,MB)
      GO TO 150

!             Do the rest of the division.

  130 KA = KPT + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MWA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MWA)+3)*MVALP
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
      ENDIF

      MWK(START(MB)+1) = MWK(START(MA)+1)
      DO J = 1, INT(MWK(START(MWA)+2))+1
         MWK(START(MB)+J+1) = MWK(START(MWA)+J+1)
      ENDDO
      IREM = INT(MODINT)

  140 MWK(START(MB)) = 1
      IF (MAS < 0 .AND. IDIV > 0) THEN
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
          IREM = -IREM
      ELSE IF (MAS > 0 .AND. IDIV < 0)  THEN
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
      ELSE IF (MAS < 0 .AND. IDIV < 0)  THEN
          IREM = -IREM
      ENDIF

  150 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      IF (NTRACE /= 0 .AND. NCALL <= LVLTRC) THEN
          CALL IMNTR(1,MB,MB,1)
          CALL IMNTRI(1,IREM,0)
      ENDIF

      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDVIR

      SUBROUTINE IMEQ(MA,MB)

!  MB = MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: J,KDG
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MA)+2)+3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      KDG = MAX(2,INT(MWK(START(MA)+2))) + 1
      IF (KDG > SIZE_OF(MA)-2) KDG = 3
      DO J = -1, KDG
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMEQ

      SUBROUTINE IMFACT(N,MA)

!  MA = N!   (N factorial)  N is a machine precision integer and MA is an IM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N,MA
      INTENT (IN) :: N
      INTENT (INOUT) :: MA
      INTEGER :: J,K,NDSAVE,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      K = MAX(N,2)
      RESULT_SIZE = 10 + (LOG(2.0D0*DPPI*K)/2 + K*LOG(DBLE(K)) - K) / DLOGMB
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMFACT'
          CALL  IMNTRI(2,N,1)
      ENDIF

!             Check for special cases.

      IF (N < 0) THEN
          CALL IMST2M('UNKNOWN',MA)
          KFLAG = -4
          GO TO 110
      ELSE IF (N <= 12) THEN
          K = 1
          DO J = 2, N
             K = K*J
          ENDDO
          CALL IMI2M(K,MA)
          GO TO 110
      ENDIF

      CALL IMFACT_P(2,N,MA)

  110 IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFACT

      RECURSIVE SUBROUTINE IMFACT_P(A,B,MP)

!  This routine does the binary splitting for computing N!
!  MP = A * (A+1) * ... * B.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP
      INTEGER :: MXY(2),NUMBER_USED_SAVE,J,M
      REAL (KIND(0.0D0)) :: DA,DB,DLA,DLB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      IF ((DB+0.5D0)*LOG(DB+1) > 1.0D+10) THEN
          RESULT_SIZE = (B-A+1)*LOG(DB) / DLOGMB + 7 + NGRD52
      ELSE
          IF (A >= 2) THEN
              DLA = (DA+0.5D0)*LOG(DA) - DA + 1/(12*(DA))
          ELSE
              DLA = 0
          ENDIF
          IF (B >= 2) THEN
              DLB = (DB+0.5D0)*LOG(DB) - DB + 1/(12*(DB))
          ELSE
              DLB = 0
          ENDIF
          RESULT_SIZE = ( DLB - DLA ) / DLOGMB + 7 + NGRD52
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 25) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMI2M(A,MP)
          DO J = A+1, B-1, 2
             CALL IMMPYI(MP,J,MXY(1))
             CALL IMMPYI(MXY(1),J+1,MP)
          ENDDO
          IF (MOD(B-A,2) == 1) THEN
              CALL IMMPYI(MP,B,MXY(1))
              CALL IMEQ(MXY(1),MP)
          ENDIF
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL IMFACT_P(A,M,MXY(1))
      CALL IMFACT_P(M+1,B,MXY(2))
      CALL IMMPY(MXY(1),MXY(2),MP)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFACT_P

      SUBROUTINE IMFM2I(MA,MB)

!  MB = INT(MA)

!  Convert from real (FM) format to integer (IM) format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: J,NTRSAV,NDGSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+4))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      KFLAG = 0
      NTRSAV = NTRACE
      NTRACE = 0
      NDGSAV = NDIG
      IF (ABS(MWK(START(MA)+2)+3) >= MEXPOV) THEN
          NDIG = 2
          CALL FMEQ(MA,MB)
          NDIG = NDGSAV
      ELSE
          NDIG = MIN(NDIG,RESULT_SIZE-3)
          CALL FMINT(MA,MXY(1))
          CALL FMEQ(MXY(1),MB)
          NDIG = NDGSAV
          DO J = NDIG+2, INT(MWK(START(MA)+2))+1
             MWK(START(MB)+J+1) = 0
          ENDDO
          IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      ENDIF
      NTRACE = NTRSAV
      NCALL = NCALL - 1

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFM2I

      SUBROUTINE IMFORM(FORM,MA,STRING)

!  Convert an IM number (MA) to a character string base 10 (STRING) using character string
!  FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTEGER :: NDSAVE
      INTENT (IN) :: FORM,MA
      INTENT (INOUT) :: STRING

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMFORM   ',1,MA,MA)
      KFLAG = 0
      NAMEST(NCALL) = 'IMFORM'
      NDSAVE = NDIG
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2

      CALL FMFORM(FORM,MA,STRING)

      NCALL = NCALL - 1
      NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMFORM

      SUBROUTINE IMFPRT(FORM,MA)

!  Print an IM number (MA) on unit KW using character string FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTEGER :: NDSAVE
      INTENT (IN) :: FORM,MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMFPRT   ',1,MA,MA)
      KFLAG = 0
      NAMEST(NCALL) = 'IMFPRT'
      NDSAVE = NDIG
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2

      CALL FMFPRT(FORM,MA)

      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFPRT

      SUBROUTINE IMGCD(MA,MB,MC)

!  Lehmer's GCD algorithm for MC = GCD(MA,MB).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA, MB, MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: J, K
      DOUBLE PRECISION :: ABCD_MAX, DPBASE, A1, B1, C1, D1, Q1A, Q1B, T1, T2, T3, U1, V1
      CHARACTER(25) :: ST
      LOGICAL, EXTERNAL :: IMABS_GREATER_THAN
      INTEGER :: MXY(4),NDSAVE,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMGCD    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMGCD'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ELSE IF (MWK(START(MB)+3) == 0) THEN
          CALL IMABS(MA,MC)
          GO TO 110
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL IMABS(MB,MC)
          GO TO 110
      ELSE IF (MWK(START(MB)+2) == 1 .AND. ABS(MWK(START(MB)+3)) == 1) THEN
          CALL IMI2M(1,MC)
          GO TO 110
      ELSE IF (MWK(START(MA)+2) == 1 .AND. ABS(MWK(START(MA)+3)) == 1) THEN
          CALL IMI2M(1,MC)
          GO TO 110
      ELSE IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMGCD'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 110
      ENDIF

      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      CALL IMDEFINE(MXY(2),RESULT_SIZE)
      CALL IMDEFINE(MXY(3),RESULT_SIZE)
      CALL IMDEFINE(MXY(4),RESULT_SIZE)
      CALL IMABS(MA,MXY(3))
      CALL IMABS(MB,MXY(4))
      IF (IMABS_GREATER_THAN(MXY(3),MXY(4))) THEN
          CALL IMEQ(MXY(3),MXY(1))
          CALL IMEQ(MXY(4),MXY(2))
      ELSE
          CALL IMEQ(MXY(4),MXY(1))
          CALL IMEQ(MXY(3),MXY(2))
      ENDIF

      IF (MBASE < 1000) THEN
          CALL IMGCD2(MA,MB,MC)
          GO TO 110
      ENDIF

      ABCD_MAX = (MAXINT / MBASE) / 2
      DPBASE = MBASE
      T1 = 1.0D-3 / EPSILON(1.0D0)
      CALL IMI2M(1,MXY(3))
      T2 = DPBASE
      K = 1
      DO WHILE (T2 < T1)
         MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + 1
         K = K + 1
         MWK(START(MXY(3))+K+2) = 0
         T2 = T2 * DPBASE
      ENDDO
      MWK(START(MXY(3))+3) = AINT( DPBASE * T1 / T2 )

!             MXY(1) >= MXY(2) > 0 during the algorithm.

      DO WHILE (IMABS_GREATER_THAN(MXY(1),MXY(3)))

         IF (MWK(START(MXY(1))+2) == MWK(START(MXY(2))+2)) THEN
             U1 = MWK(START(MXY(1))+3)
             V1 = MWK(START(MXY(2))+3)
             DO J = 2, INT(MWK(START(MXY(1))+2))
                IF (U1 < MAXINT / (10 * DPBASE)) THEN
                    U1 = U1 * DPBASE + MWK(START(MXY(1))+J+2)
                    V1 = V1 * DPBASE + MWK(START(MXY(2))+J+2)
                ELSE
                    T1 = (MWK(START(MXY(1))+J+2) + 1.0D-2) / DPBASE
                    T2 = (MWK(START(MXY(2))+J+2) + 1.0D-2) / DPBASE
                    DO WHILE (U1 < MAXINT / 100)
                       T1 = T1 * 10
                       K = T1
                       T1 = T1 - K
                       U1 = U1 * 10 + K

                       T2 = T2 * 10
                       K = T2
                       T2 = T2 - K
                       V1 = V1 * 10 + K
                    ENDDO
                    EXIT
                ENDIF
             ENDDO
         ELSE IF (MWK(START(MXY(1))+2) == MWK(START(MXY(2))+2) + 1) THEN
             U1 = MWK(START(MXY(1))+3)
             V1 = 0
             DO J = 2, INT(MWK(START(MXY(1))+2))
                IF (U1 < MAXINT / (10 * DPBASE)) THEN
                    U1 = U1 * DPBASE + MWK(START(MXY(1))+J+2)
                    V1 = V1 * DPBASE + MWK(START(MXY(2))+J+1)
                ELSE
                    T1 = (MWK(START(MXY(1))+J+2)   + 1.0D-2) / DPBASE
                    T2 = (MWK(START(MXY(2))+J+1) + 1.0D-2) / DPBASE
                    DO WHILE (U1 < MAXINT / 100)
                       T1 = T1 * 10
                       K = T1
                       T1 = T1 - K
                       U1 = U1 * 10 + K

                       T2 = T2 * 10
                       K = T2
                       T2 = T2 - K
                       V1 = V1 * 10 + K
                    ENDDO
                    EXIT
                ENDIF
             ENDDO
         ELSE
             U1 = 1
             V1 = 0
         ENDIF

         A1 = 1
         B1 = 0
         C1 = 0
         D1 = 1
         Q1A = 0
         Q1B = 0

         DO WHILE (Q1A == Q1B)
            IF (V1 + C1 /= 0.0D0 .AND. V1 + D1 /= 0.0D0) THEN
                Q1A = AINT( (U1 + A1) / (V1 + C1) )
                Q1B = AINT( (U1 + B1) / (V1 + D1) )
                IF (Q1A == Q1B) THEN
                    T1 = A1 - Q1A*C1
                    T2 = B1 - Q1A*D1
                    T3 = U1 - Q1A*V1
                    IF (ABS(T1) > ABCD_MAX .OR. ABS(T2) > ABCD_MAX) THEN
                        EXIT
                    ELSE
                        A1 = C1
                        C1 = T1
                        B1 = D1
                        D1 = T2
                        U1 = V1
                        V1 = T3
                    ENDIF
                ENDIF
            ELSE
                EXIT
            ENDIF
         ENDDO

         IF (B1 == 0) THEN
             CALL IMMOD(MXY(1),MXY(2),MXY(4))
             CALL IMEQ(MXY(2),MXY(1))
             CALL IMEQ(MXY(4),MXY(2))
             IF (MWK(START(MXY(2))+3) == 0) THEN
                 CALL IMEQ(MXY(1),MC)
                 GO TO 110
             ENDIF
         ELSE
             CALL IMGCD_REDUCE_UV(MXY(1), MXY(2), MXY(4), A1, B1, C1, D1)
         ENDIF
      ENDDO

!             Finish the gcd using double precision.

      IF (MWK(START(MXY(2))+3) == 0) THEN
          CALL IMEQ(MXY(1),MC)
          GO TO 110
      ENDIF
      U1 = 0
      DO J = 1, INT(MWK(START(MXY(1))+2))
         U1 = U1 * DPBASE + MWK(START(MXY(1))+J+2)
      ENDDO
      V1 = 0
      DO J = 1, INT(MWK(START(MXY(2))+2))
         V1 = V1 * DPBASE + MWK(START(MXY(2))+J+2)
      ENDDO
      DO WHILE (V1 > 0)
         T1 = MOD(U1,V1)
         U1 = V1
         V1 = T1
      ENDDO
      IF (U1 < DPBASE) THEN
          MWK(START(MXY(1))+2) = 1
          MWK(START(MXY(1))+3) = U1
          MWK(START(MXY(1))+4) = 0
      ELSE IF (U1 < DPBASE*DPBASE) THEN
          MWK(START(MXY(1))+2) = 2
          MWK(START(MXY(1))+3) = AINT(U1/DPBASE)
          MWK(START(MXY(1))+4) = MOD(U1,DPBASE)
      ELSE
          IF (ABS(U1) < HUGE(1)) THEN
              K = U1
              CALL IMI2M(K,MXY(1))
          ELSE
              WRITE (ST,'(E25.16)') U1
              CALL IMST2M(ST,MXY(1))
          ENDIF
      ENDIF

      CALL IMEQ(MXY(1),MC)

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMGCD'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMGCD

      SUBROUTINE IMGCD_REDUCE_UV(U, V, V_SHIFT, A1, B1, C1, D1)

!  Return  U = A1 * U + B1 * V,
!  and     V = C1 * U + D1 * V.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: U, V, V_SHIFT
      DOUBLE PRECISION :: A1, B1, C1, D1, U1, V1
      INTENT (INOUT) :: U, V
      INTENT (IN) :: A1, B1, C1, D1
      INTEGER :: J, K, KPT_U, KPT_V, N_U, N_V

!             Do the operations.

      N_U = MWK(START(U)+2)
      N_V = MWK(START(V)+2)
      K = N_U - N_V
      IF (K == 0) THEN
          KPT_U = START(U)+2
          KPT_V = START(V)+2
          DO J = 1, N_U
             U1 = MWK(KPT_U+J)
             V1 = MWK(KPT_V+J)
             MWK(KPT_U+J-1) = A1 * U1 + B1 * V1
             MWK(KPT_V+J-1) = C1 * U1 + D1 * V1
          ENDDO
      ELSE
          DO J = 1, K
             MWK(START(V_SHIFT)+J+2) = 0
          ENDDO
          DO J = 1, N_V
             MWK(START(V_SHIFT)+J+K+2) = MWK(START(V)+J+2)
          ENDDO
          N_V = N_U
          KPT_U = START(U)+2
          KPT_V = START(V)+2
          DO J = 1, N_U
             U1 = MWK(KPT_U+J)
             V1 = MWK(START(V_SHIFT)+J+2)
             MWK(KPT_U+J-1) = A1 * U1 + B1 * V1
             MWK(KPT_V+J-1) = C1 * U1 + D1 * V1
          ENDDO
      ENDIF

!             Normalize the digits in U and V.

      KPT_U = START(U)+2+N_U
      DO J = N_U, 1, -1
         KPT_U = KPT_U - 1
         IF (MWK(KPT_U) < 0) THEN
             K = (-MWK(KPT_U)-1) / MBASE + 1
             MWK(KPT_U) = MWK(KPT_U) + K * MBASE
             MWK(KPT_U-1) = MWK(KPT_U-1) - K
         ELSE
             K = MWK(KPT_U) / MBASE
             MWK(KPT_U) = MWK(KPT_U) - K * MBASE
             MWK(KPT_U-1) = MWK(KPT_U-1) + K
         ENDIF
      ENDDO

      KPT_V = START(V)+2+N_V
      DO J = N_V, 1, -1
         KPT_V = KPT_V - 1
         IF (MWK(KPT_V) < 0) THEN
             K = (-MWK(KPT_V)-1) / MBASE + 1
             MWK(KPT_V) = MWK(KPT_V) + K * MBASE
             MWK(KPT_V-1) = MWK(KPT_V-1) - K
         ELSE
             K = MWK(KPT_V) / MBASE
             MWK(KPT_V) = MWK(KPT_V) - K * MBASE
             MWK(KPT_V-1) = MWK(KPT_V-1) + K
         ENDIF
      ENDDO

!             Normalize the numbers if there are leading zeros.

      IF (MWK(START(U)+2) == 0) THEN
          MWK(START(U)+2) = N_U - 1
      ELSE
          DO J = N_U, 1, -1
             MWK(START(U)+J+2) = MWK(START(U)+J+1)
          ENDDO
          MWK(START(U)+2) = N_U
      ENDIF
      K = 0
      DO J = 1, N_U
         IF (MWK(START(U)+J+2) == 0) THEN
             K = K + 1
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (K > 0) THEN
          MWK(START(U)+2) = MWK(START(U)+2) - K
          DO J = 1, INT(MWK(START(U)+2))
             MWK(START(U)+J+2) = MWK(START(U)+J+K+2)
          ENDDO
          DO J = 0, K-1
             MWK(START(U)+N_U-J+2) = 0
          ENDDO
      ENDIF

      IF (MWK(START(V)+2) == 0) THEN
          MWK(START(V)+2) = N_V - 1
      ELSE
          DO J = N_V, 1, -1
             MWK(START(V)+J+2) = MWK(START(V)+J+1)
          ENDDO
          MWK(START(V)+2) = N_V
      ENDIF
      K = 0
      DO J = 1, N_V
         IF (MWK(START(V)+J+2) == 0) THEN
             K = K + 1
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (K > 0) THEN
          MWK(START(V)+2) = MWK(START(V)+2) - K
          DO J = 1, INT(MWK(START(V)+2))
             MWK(START(V)+J+2) = MWK(START(V)+J+K+2)
          ENDDO
          DO J = 0, K-1
             MWK(START(V)+N_V-J+2) = 0
          ENDDO
      ENDIF

      END SUBROUTINE IMGCD_REDUCE_UV

      SUBROUTINE IMGCD2(MA,MB,MC)

!  MC is returned as the greatest common divisor of MA and MB.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMGCD2   ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMGCD2'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 120
      ELSE IF (MWK(START(MB)+3) == 0) THEN
          CALL IMABS(MA,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL IMABS(MB,MC)
          GO TO 120
      ELSE IF (MWK(START(MB)+2) == 1 .AND. ABS(MWK(START(MB)+3)) == 1) THEN
          CALL IMI2M(1,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. ABS(MWK(START(MA)+3)) == 1) THEN
          CALL IMI2M(1,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMGCD2'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 120
      ENDIF

      CALL IMABS(MA,MXY(3))
      CALL IMABS(MB,MXY(2))
      CALL IMMAX(MXY(3),MXY(2),MXY(1))
      CALL IMMIN(MXY(3),MXY(2),MXY(4))
      CALL IMEQ(MXY(4),MXY(2))
  110 CALL IMDIVR(MXY(1),MXY(2),MXY(4),MXY(3))
      IF (MWK(START(MXY(3))+3) /= 0) THEN
          CALL IMEQ(MXY(2),MXY(1))
          CALL IMEQ(MXY(3),MXY(2))
          GO TO 110
      ENDIF
      CALL IMEQ(MXY(2),MC)

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMGCD2'
          CALL FMWARN
      ENDIF

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMGCD2

      SUBROUTINE IMI2FM(MA,MB)

!  MB = MA

!  Convert from integer (IM) format to real (FM) format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KDG
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMI2FM   ',1,MA,MA)
      KFLAG = 0
      KDG = MAX(2,INT(MWK(START(MA)+2)))
      IF (MWK(START(MA)+2) >= MEXPOV) KDG = 2
      CALL FMEQU(MA,MB,KDG,NDIG)
      MWK(START(MB)+1) = NINT(10**7*ALOGM2)
      NCALL = NCALL - 1

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMI2FM

      SUBROUTINE IMI2M(IVAL,MA)

!  MA = IVAL

!  This routine performs the trace printing.  IMI2M2 is used to do the conversion.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMI2M'
          CALL IMNTRI(2,IVAL,1)

          CALL IMI2M2(IVAL,MA)

          CALL IMNTR(1,MA,MA,1)
      ELSE
          CALL IMI2M2(IVAL,MA)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMI2M

      SUBROUTINE IMI2M2(IVAL,MA)

!  MA = IVAL

!  Convert a one word integer to IM format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      INTEGER :: NDSAVE
      DOUBLE PRECISION :: DT
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NDSAVE = NDIG
      IF (IVAL == 0) THEN
          NDIG = 2
      ELSE
          DT = LOG(DBLE(ABS(IVAL)))/DLOGMB + 2
          NDIG = MAX(2,INT(DT))
      ENDIF
      RESULT_SIZE = NDIG + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      CALL FMIM(IVAL,MA)
      IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMI2M2

      SUBROUTINE IMINP(LINE,MA,LA,LB)

!  Convert an array of characters to multiple precision integer format.

!  LINE is an A1 character array of length LB to be converted to IM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.
!  LB is a pointer to the last character of the field for that number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KFSAVE,NDSAVE,LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      KFLAG = 0
      NDSAVE = NDIG
      NAMEST(NCALL) = 'IMINP'

      NDIG = 50
      NCALL = NCALL - 1
      CALL FMINP(LINE,MWI,LA,LB)
      NCALL = NCALL + 1
      IF (MWK(START(MWI)+2) > 50 .AND. ABS(MWK(START(MWI)+2)) < MEXPOV) THEN
          NDIG = MWK(START(MWI)+2) + 1
          NCALL = NCALL - 1
          CALL FMINP(LINE,MWI,LA,LB)
          NCALL = NCALL + 1
      ENDIF
      KFSAVE = KFLAG
      NUMBER_USED = NUMBER_USED_SAVE
      CALL IMFM2I(MWI,MA)
      KFLAG = KFSAVE

      IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      NDIG = NDSAVE
      IF (NTRACE /= 0) CALL IMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMINP

      SUBROUTINE IMM2DP(MA,X)

!  X = MA

!  Convert an IM number to double precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's double
!  precision number system, change the definition of DPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: X

      INTEGER :: KRESLT,ND2,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      KFLAG = 0
      NAMEST(NCALL) = 'IMM2DP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('IMM2DP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL IMNTR(2,MA,MA,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.  Set X to some value that the user is likely
!             to recognize as wrong.

          X = DBLE(RUNKNO)
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          IF (NTRACE /= 0) CALL IMNTRR(1,X,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      NDSAVE = NDIG
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      ND2 = 2 - LOG(EPSILON(1.0D0))/DLOGMB
      IF (NDIG >= ND2) NDIG = ND2
      CALL FMMD(MA,X)

      IF (NTRACE /= 0) CALL IMNTRR(1,X,1)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE IMM2DP

      SUBROUTINE IMM2I(MA,IVAL)

!  IVAL = MA

!  Convert an IM number to a one word integer.

!  KFLAG =  0 is returned if the conversion is exact.
!        = -4 is returned if MA is larger than INTMAX in magnitude.  IVAL = IUNKNO is returned as
!             an indication that IVAL could not be computed without integer overflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      INTEGER :: IVAL,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMM2I    ',1,MA,MA)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMM2I'
          CALL IMNTR(2,MA,MA,1)
      ENDIF

      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
      KFLAG = 0
      CALL FMM2I(MA,IVAL)

      IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
          CALL IMNTRI(1,IVAL,1)
      ENDIF
      NCALL = NCALL - 1
      NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMM2I

      SUBROUTINE IMM2SP(MA,X)

!  X = MA

!  Convert an IM number to single precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's single
!  precision number system, change the definition of SPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      REAL :: X

      DOUBLE PRECISION :: Y
      INTEGER :: KRESLT,ND2,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      KFLAG = 0
      NAMEST(NCALL) = 'IMM2SP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('IMM2SP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL IMNTR(2,MA,MA,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.  Set X to some value that the user is likely
!             to recognize as wrong.

          X = RUNKNO
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          Y = X
          IF (NTRACE /= 0) CALL IMNTRR(1,Y,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      NDSAVE = NDIG
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      ND2 = 2 - LOG(EPSILON(1.0D0))/DLOGMB
      IF (NDIG >= ND2) NDIG = ND2
      CALL FMMD(MA,Y)
      X = Y

      IF (NTRACE /= 0) CALL IMNTRR(1,Y,1)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE IMM2SP

      SUBROUTINE IMMAX(MA,MB,MC)

!  MC = MAX(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMAX    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMAX'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (IMCOMP(MA,'<',MB)) THEN
          CALL IMEQ(MB,MC)
      ELSE
          CALL IMEQ(MA,MC)
      ENDIF

      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMAX

      SUBROUTINE IMMIN(MA,MB,MC)

!  MC = MIN(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMIN    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMIN'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (IMCOMP(MA,'>',MB)) THEN
          CALL IMEQ(MB,MC)
      ELSE
          CALL IMEQ(MA,MC)
      ENDIF

      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMIN

      SUBROUTINE IMMOD(MA,MB,MC)

!  MC = MOD(MA,MB)

!  Use IMDIVR if both INT(MA/MB) and MOD(MA,MB) are needed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MIN(MWK(START(MA)+2),MWK(START(MB)+2)) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMOD    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMOD'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ENDIF

      CALL IMDIVR(MA,MB,MXY(1),MXY(2))
      CALL IMEQ(MXY(2),MC)

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMOD'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMOD

      SUBROUTINE IMMODI(MA,IMOD,IREM)

!  Internal routine to return integer IREM = mod( MA , IMOD ).
!  ABS(IMOD) should be less than MAXINT/MBASE for faster mod calculation.

!  MA is a multiple precision IM integer.
!  IMOD and IREM are one-word integers.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IMOD,IREM,J,KPT,N
      INTEGER, SAVE :: T1 = -3, T2 = -3
      REAL (KIND(1.0D0)) :: MMOD, MREM

      MMOD = ABS(IMOD)
      KPT = START(MA) + 3
      N = MWK(KPT-1)

!             If abs(imod) is more than than MAXINT/MBASE, do it the hard way, since the
!             MBASE*MREM in the fast method could be too big to represent exactly in d.p.

      IF (MMOD >= MAXINT/MBASE) THEN
          CALL IMI2M(ABS(IMOD),T1)
          CALL IMMOD(MA,T1,T2)
          CALL IMM2I(T2,IREM)
      ELSE
          MREM = 0
          DO J = 1, N
             MREM = MOD( MBASE*MREM + MWK(KPT) , MMOD )
             KPT = KPT + 1
          ENDDO
      ENDIF

      IREM = MREM
      IF (MWK(START(MA)) < 0) IREM = -IREM

      END SUBROUTINE IMMODI

      SUBROUTINE IMMPY(MA,MB,MC)

!  MC = MA * MB

!  This routine performs the trace printing.  IMMPY2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMPY'
          CALL IMNTR(2,MA,MB,2)

          CALL IMMPY2(MA,MB,MC)

          CALL IMNTR(1,MC,MC,1)
      ELSE
          CALL IMMPY2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPY

      SUBROUTINE IMMPY2(MA,MB,MC)

!  MC = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MDAB
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MWK(START(MA)+2) + MWK(START(MB)+2) + 4
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      IF (KDEBUG == 1) CALL IMARGS('IMMPY    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG

      IF (MWK(START(MA)+2) <= 1) THEN
          IF (MWK(START(MB)+2) > 1) GO TO 110
          MDAB = MWK(START(MA)) * MWK(START(MA)+3) * MWK(START(MB)) * MWK(START(MB)+3)
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = MDAB
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = -MDAB
                  MWK(START(MC)) = -1
              ENDIF
              MWK(START(MC)+4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 2
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = AINT (MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(-MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = -1
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMI2M2(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          MWK(START(MC)) = 1
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
          MWK(START(MC)+2) = 0
          MWK(START(MC)+3) = 0
          MWK(START(MC)+4) = 0
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          KFLAG = -5
          IF (MWK(START(MA))*MWK(START(MB)) < 0) THEN
              CALL IMI2M2(-1,MC)
              MWK(START(MC)+2) = MEXPOV
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          ELSE
              CALL IMI2M2(1,MC)
              MWK(START(MC)+2) = MEXPOV
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          ENDIF
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPY'
          CALL FMWARN
          CALL IMI2M2(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF
      IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == 1) THEN
          CALL IMEQ(MA,MC)
          GO TO 120
      ELSE IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == -1) THEN
          CALL IMEQ(MA,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
              MWK(START(MC)) = -MWK(START(MC))
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == 1) THEN
          CALL IMEQ(MB,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == -1) THEN
          CALL IMEQ(MB,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
              MWK(START(MC)) = -MWK(START(MC))
          GO TO 120
      ENDIF
      NDIG = INT(MWK(START(MA)+2) + MWK(START(MB)+2))

      IF (NDIG < 2) NDIG = 2
      CALL IMMPY3(MA,MB)

!             Transfer to MC and fix the sign of the result.

      NDIG = MWK(START(MWA)+2)
      IF (NDIG < 2) NDIG = 2
      IF (MWK(START(MA))*MWK(START(MB)) < 0) THEN
          CALL FMMOVE(MWA,MC)
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
          MWK(START(MC)) = -1
      ELSE
          CALL FMMOVE(MWA,MC)
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
          MWK(START(MC)) = 1
      ENDIF

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPY2

      SUBROUTINE IMMPY3(MA,MB)

!  Internal multiplication of MA*MB.  The result is returned in MWA.  Both MA and MB are positive.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBP1,MKT,MMAX
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KL,KLMA,KLMB,N1,ND,NMETHD,NZDA,NZDB
      INTEGER :: MXY(2),NUMBER_USED_SAVE
      INTENT (IN) :: MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = 2*(MWK(START(MA)+2)+MWK(START(MB)+2)) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      MWK(START(MWA)+N1+2) = 0

!             Check for using an FFT-based method if precision is very high.

      ND = MAX(MWK(START(MA)+2),MWK(START(MB)+2))
      IF (LOG(7.0D0*ND/3.0D0) < LOG(7.0D3/3.0D0)*MIN(MWK(START(MA)+2),MWK(START(MB)+2))/1.0D3) THEN
          NZDA = INT(MWK(START(MA)+2))
          NZDB = INT(MWK(START(MB)+2))
          DO J = 2, INT(MWK(START(MB)+2))
             IF (MWK(START(MB)+J+2) == 0) NZDB = NZDB - 1
          ENDDO
          IF (REAL(NZDA)*NZDB < 65.0*ND*LOG(REAL(ND))) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          ND = NDIG
          NDIG = MAX(MWK(START(MA)+2),MWK(START(MB)+2))
          CALL IMI2FM(MA,MXY(1))
          CALL IMI2FM(MB,MXY(2))
          CALL FMMPYFFT(MXY(1),MXY(2))
          NDIG = ND
          NUMBER_USED = NUMBER_USED_SAVE
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             The multiplication loop begins here.

!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      MBJ = MWK(START(MB)+3)
      MWK(START(MWA)+3) = 0
      KLMA = INT(MWK(START(MA)+2))
      DO K = KLMA+3, N1
         MWK(START(MWA)+K+1) = 0
      ENDDO

!             (Inner Loop)

      JMA = START(MA) + 1
      JMWA = START(MWA) + 2
      DO K = 2, KLMA+1
         MWK(JMWA+K) = MWK(JMA+K)*MBJ
      ENDDO
      MAXMWA = MBJ
      IF (MAXMWA > MMAX) THEN
          MAXMWA = 0
          KL = KLMA + 1
          DO KB = KL+1, 3, -1
             MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
             MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
             MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
          ENDDO
      ENDIF
      KLMB = INT(MWK(START(MB)+2))
      DO J = 3, KLMB+1
         MBJ = MWK(START(MB)+J+1)
         IF (MBJ /= 0) THEN
             MAXMWA = MAXMWA + MBJ
             JM1 = J - 1
             KL = KLMA + 1

!                       Major (Inner Loop)

             JMA = START(MA) + 1 - JM1
             JMWA = START(MWA) + 1
             DO K = J+1, J+KLMA
                MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
             ENDDO
         ENDIF

         IF (MAXMWA > MMAX) THEN
             MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

             DO KB = JM1+KL, JM1+2, -1
                MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
             ENDDO
         ENDIF
      ENDDO

!             Perform the final normalization.  (Inner Loop)

      JMWA = START(MWA) + 1
      DO KB = N1, 3, -1
         MKT = INT (MWK(JMWA+KB)/MBASE)
         MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
         MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
      ENDDO

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPY3

      SUBROUTINE IMMPYI(MA,IVAL,MB)

!  MB = MA * IVAL

!  This routine performs the trace printing.  IMMPYI2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMPYI'
          CALL IMNTR(2,MA,MA,1)
          CALL IMNTRI(2,IVAL,0)

          CALL IMMPYI2(MA,IVAL,MB)

          CALL IMNTR(1,MB,MB,1)
      ELSE
          CALL IMMPYI2(MA,IVAL,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPYI

      SUBROUTINE IMMPYI2(MA,IVAL,MB)

!  MB = MA * IVAL

!  Multiplication by a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MDAB,MKT,MVAL
      DOUBLE PRECISION :: DT
      INTEGER :: IVAL,J,KA,KB,KC,KSHIFT,N1,NDSAVE,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DT = LOG(DBLE(ABS(IVAL)+1))/DLOGMB + 1
      RESULT_SIZE = MWK(START(MA)+2) + DT + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = 2*RESULT_SIZE + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (KDEBUG == 1) CALL IMARGS('IMMPYI   ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      MAS = MWK(START(MA))

      IF (MWK(START(MA)+2) <= 1) THEN
          MDAB = MWK(START(MA)) * MWK(START(MA)+3) * IVAL
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 1
              IF (MDAB == 0) MWK(START(MB)+2) = 0
              MWK(START(MB)) = 1
              IF (MDAB < 0) MWK(START(MB)) = -1
              MWK(START(MB)+3) = ABS(MDAB)
              MWK(START(MB)+4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 2
              MWK(START(MB)) = 1
              IF (MDAB < 0) MWK(START(MB)) = -1
              MDAB = ABS(MDAB)
              MWK(START(MB)+3) = AINT (MDAB/MBASE)
              MWK(START(MB)+4) = MDAB - MBASE*MWK(START(MB)+3)
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPYI'
          CALL FMWARN
          CALL IMI2M2(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMI2M2(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ELSE IF (IVAL == 0) THEN
          CALL IMI2M2(0,MB)
          GO TO 120
      ELSE IF (IVAL == 1) THEN
          CALL IMEQ(MA,MB)
          GO TO 120
      ELSE IF (IVAL == -1) THEN
          CALL IMEQ(MA,MB)
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
              MWK(START(MB)) = -MWK(START(MB))
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3)*MWK(START(MA)) == 1) THEN
          CALL IMI2M2(IVAL,MB)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3)*MWK(START(MA)) == -1) THEN
          CALL IMI2M2(IVAL,MB)
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
              MWK(START(MB)) = -MWK(START(MB))
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == MEXPOV) THEN
          KFLAG = -5
          CALL IMI2M2(1,MB)
          MWK(START(MB)+2) = MEXPOV
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          GO TO 110
      ENDIF

!             Work with positive numbers.

      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      N1 = NDIG + 1

!             To leave room for normalization, shift the product to the right KSHIFT places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)

!             If IVAL is too big, use IMMPY2.

      IF (KSHIFT > NDIG .OR. MVAL > MAXINT/MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL IMI2M2(IVAL,MXY(1))
          CALL IMMPY2(MA,MXY(1),MB)
          GO TO 120
      ENDIF

      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).

      MWK(START(MB)+1) = MWK(START(MA)+1)
      IF (MWK(START(MWA)+3) == 0) THEN
          MWK(START(MB)+2) = MWK(START(MWA)+2) - 1
          DO J = 3, KB
             MWK(START(MB)+J) = MWK(START(MWA)+J+1)
          ENDDO
      ELSE
          MWK(START(MB)+2) = MWK(START(MWA)+2)
          DO J = 2, KB
             MWK(START(MB)+J+1) = MWK(START(MWA)+J+1)
          ENDDO
      ENDIF

!             Put the sign on the result.

  110 MWK(START(MB)) = 1
      IF ((IVAL > 0 .AND. MAS < 0) .OR. (IVAL < 0 .AND.MAS > 0)) MWK(START(MB)) = -1

  120 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPYI2

      SUBROUTINE IMMPYM(MA,MB,MC,MD)

!  MD = MA * MB mod MC

!  This routine is slightly faster than calling IMMPY and IMMOD separately.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MAS,MAXMWA,MBP1,MBS,MC1,MCARRY,MDC,MDAB,MKT,MLMAX,MQD
      DOUBLE PRECISION  XB,XBASE,XBR,XMWA
      INTEGER :: J,JB,JL,JMC,JMWA,K,KA,KB,KL,KLTFLG,KPTMWA,N1,NA1,NC1,NDSAVE,NGUARD,NL,NMCWDS,NTRSAV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MWK(START(MC)+2) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = 2*(MWK(START(MA)+2)+MWK(START(MB)+2)) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMPYM   ',2,MA,MB)
      NDSAVE = NDIG
      KFLAG = 0
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMPYM'
          CALL IMNTR(2,MA,MB,2)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  NDIG = MAX(2,INT(MWK(START(MC)+2)))
                  IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
                  NTRSAV = NTRACE
                  CALL IMNTRJ(MC,NDIG)
                  NTRACE = NTRSAV
                  NDIG = NDSAVE
              ELSE
                  CALL IMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF

      IF (MWK(START(MA)+2) <= 1) THEN
          IF (MWK(START(MB)+2) > 1) GO TO 110
          IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) GO TO 110
          MDAB = MWK(START(MA)) * MWK(START(MA)+3) * MWK(START(MB)) * MWK(START(MB)+3)
          IF (MWK(START(MC)+2) <= 2) THEN
              IF (MWK(START(MC)+3) == 0) GO TO 110
              IF (MWK(START(MC)+2) <= 1) THEN
                  MDC = MWK(START(MC)) * MWK(START(MC)+3)
              ELSE
                  MDC = MWK(START(MC)) * (MWK(START(MC)+3)*MBASE + MWK(START(MC)+4))
              ENDIF
              MDAB = MOD(MDAB,MDC)
          ENDIF
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))
              MWK(START(MD)+2) = 1
              IF (MDAB == 0) MWK(START(MD)+2) = 0
              MWK(START(MD)) = 1
              IF (MDAB < 0) MWK(START(MD)) = -1
              MWK(START(MD)+3) = ABS(MDAB)
              MWK(START(MD)+4) = 0
              GO TO 160
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))
              MWK(START(MD)+2) = 2
              MWK(START(MD)) = 1
              IF (MDAB < 0) MWK(START(MD)) = -1
              MDAB = ABS(MDAB)
              MWK(START(MD)+3) = AINT (MDAB/MBASE)
              MWK(START(MD)+4) = MDAB - MBASE*MWK(START(MD)+3)
              GO TO 160
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
          MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMST2M('UNKNOWN',MD)
          GO TO 170
      ELSE IF (MWK(START(MC)+3) == 0 .OR. MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
               MWK(START(MC)+2) < 0 .OR. MWK(START(MA)+2) >= MEXPOV .OR.                       &
               MWK(START(MB)+2) >= MEXPOV .OR. MWK(START(MC)+2) >= MEXPOV) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPYM'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MD)
          GO TO 170
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL IMI2M(0,MD)
          GO TO 170
      ELSE IF (MWK(START(MC)+2) == 1 .AND. MWK(START(MC)+3) == 1) THEN
          CALL IMI2M(0,MD)
          GO TO 170
      ELSE IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == 1) THEN
          CALL IMMOD(MA,MC,MD)
          GO TO 160
      ELSE IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == -1) THEN
          CALL IMMOD(MA,MC,MD)
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
              MWK(START(MD)) = -MWK(START(MD))
          GO TO 160
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == 1) THEN
          CALL IMMOD(MB,MC,MD)
          GO TO 160
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == -1) THEN
          CALL IMMOD(MB,MC,MD)
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
              MWK(START(MD)) = -MWK(START(MD))
          GO TO 160
      ENDIF

      NDIG = INT(MWK(START(MA)+2) + MWK(START(MB)+2))
      IF (NDIG < 2) NDIG = 2

!             Check for using an FFT-based method if precision is very high.

      IF (NDIG >= 1000) THEN
          CALL IMMPY(MA,MB,MXY(1))
          CALL IMMOD(MXY(1),MC,MXY(2))
          CALL IMEQ(MXY(2),MD)
          GO TO 160
      ENDIF

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

      N1 = NDIG + 1

!             It is faster if the second argument is the one with fewer digits.

      IF (MWK(START(MA)+2) < MWK(START(MB)+2)) THEN
          CALL IMMPY3(MB,MA)
      ELSE
          CALL IMMPY3(MA,MB)
      ENDIF

!             Now do the division to find MWA mod MC.

      KLTFLG = 0
      IF (MWK(START(MWA)+3) == 0) THEN
          MWK(START(MWA)+2) = MWK(START(MWA)+2) - 1
      ELSE
          DO J = N1, 2, -1
             MWK(START(MWA)+J+2) = MWK(START(MWA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
      ENDIF
      KL = INT(MWK(START(MC)+2))
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2),MWK(START(MC)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      CALL IMDEFINE(MXY(2),RESULT_SIZE)
      DO J = -1, KL+1
         MWK(START(MXY(1))+J+1) = MWK(START(MC)+J+1)
      ENDDO
      MWK(START(MXY(1))) = 1
      IF (MWK(START(MWA)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MWA)+4)) <= MWK(START(MXY(1))+3)) THEN
          DO J = 4, N1+1
             MWK(START(MXY(2))+J) = MWK(START(MWA)+J+1)
          ENDDO
          MWK(START(MXY(2))+3) = ABS(MWK(START(MWA)+4))
          MWK(START(MXY(2))+2) = MWK(START(MWA)+2)
          MWK(START(MXY(2))+1) = MWK(START(MC)+1)
          MWK(START(MXY(2))) = 1
          IF (IMCOMP(MXY(2),'==',MXY(1))) THEN
              KLTFLG = 2
          ELSE IF (IMCOMP(MXY(2),'<',MXY(1))) THEN
              KLTFLG = 1
          ENDIF
      ENDIF
      IF (MWK(START(MWA)+2) < MWK(START(MC)+2) .OR. KLTFLG >= 1) THEN
          IF (KLTFLG /= 2) THEN
              DO J = 3, N1+1
                 MWK(START(MD)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MD)+2) = MWK(START(MWA)+2)
              MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))
          ELSE
              CALL IMI2M(0,MD)
          ENDIF
          GO TO 150
      ENDIF

      NDIG = INT(MWK(START(MWA)+2))
      IF (NDIG < 2) NDIG = 2

!             NGUARD is the number of guard digits used.

      NGUARD = 1
      NA1 = INT(MWK(START(MWA)+2)) + 1
      NC1 = INT(MWK(START(MC)+2)) + 1
      MWK(START(MWA)+2) = MWK(START(MWA)+2) - MWK(START(MC)+2) + 1
      NL = NA1 + NGUARD + 3
      DO J = NA1+2, NL
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             Work only with positive numbers.

      MC1 = MWK(START(MC)+2)

!             NMCWDS is the number of words of MC used to compute the estimated quotient digit MQD.

      NMCWDS = 4
      IF (MBASE < 100) NMCWDS = 7

!             XB is an approximation of MC used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMCWDS
      IF (JL <= NC1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= NC1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= NC1) THEN
          XB = XB + DBLE(MWK(START(MC)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.
!             It is used to determine whether normalization can be postponed.

      MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMCWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = KA + INT(MC1) - 1
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MC from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMC = START(MC) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMC+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA-2 < MWK(START(MWA)+2)) GO TO 120

!             Final normalization.

      KPTMWA = KPTMWA - 1
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

  130 DO J = KPTMWA+INT(MC1), KPTMWA+2, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

!             Due to rounding, the remainder may not be between 0 and ABS(MC) here.
!             Correct if necessary.

      IF (MWK(START(MWA)+KA+1) < 0) THEN
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MWK(START(MC)+J-JB+1)
          ENDDO
          GO TO 130
      ELSE IF (MWK(START(MWA)+KA+1) >= MBASE) THEN
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MWK(START(MC)+J-JB+1)
          ENDDO
          GO TO 130
      ENDIF

      IF (MWK(START(MWA)+KPTMWA+2) /= 0) THEN
          DO J = 1, INT(MC1)
             MWK(START(MD)+J+2) = MWK(START(MWA)+J+KPTMWA+1)
          ENDDO
          MWK(START(MD)+2) = MC1
      ELSE
          DO J = 1, INT(MC1)
             IF (MWK(START(MWA)+J+KPTMWA+1) /= 0) THEN
                 DO K = J, INT(MC1)
                    MWK(START(MD)+K-J+3) = MWK(START(MWA)+K+KPTMWA+1)
                 ENDDO
                 MWK(START(MD)+2) = MC1 + 1 - J
                 GO TO 140
             ENDIF
          ENDDO
          MWK(START(MD)+2) = 0
          MWK(START(MD)+3) = 0
      ENDIF
  140 IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))

      IF (MWK(START(MD)+2) > MWK(START(MXY(1))+2) .OR.    &
         (MWK(START(MD)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MD)+3)) >= MWK(START(MXY(1))+3))) THEN
          MWK(START(MD)) = 1
          IF (IMCOMP(MD,'>=',MXY(1))) THEN
              CALL IMSUB(MD,MXY(1),MXY(3))
              CALL IMEQ(MXY(3),MD)
          ENDIF
      ENDIF

  150 MWK(START(MD)) = 1
      IF (MAS*MBS < 0) THEN
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
              MWK(START(MD)) = -MWK(START(MD))
      ENDIF

  160 IF (MWK(START(MD)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPYM'
          CALL FMWARN
      ENDIF

  170 IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPYM

      SUBROUTINE IMNTR(NTR,MA,MB,NARG)

!  Print IM numbers in base 10 format.  This is used for trace output from the IM routines.

!  NTR =  1 if a result of an IM call is to be printed.
!      =  2 to print input argument(s) to an IM call.

!  MA  -  the IM number to be printed.

!  MB  -  an optional second IM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be printed, and NARG = 2 if both
!         MA and MB are to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NARG,NDSAVE,NTR,NTRSAV
      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MA,MB,NARG

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10)"                                            &
                    ) NAME,NCALL,INT(MBASE)
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,NCALL,INT(MBASE),KFLAG
          ENDIF
      ENDIF

      NDSAVE = NDIG
      IF (NTRACE < 0) THEN
          NDIG = MAX(2,INT(MWK(START(MA)+2)))
          IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
          NTRSAV = NTRACE
          CALL IMNTRJ(MA,NDIG)
          IF (NARG == 2) THEN
              NDIG = MAX(2,INT(MWK(START(MB)+2)))
              IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
              CALL IMNTRJ(MB,NDIG)
          ENDIF
          NTRACE = NTRSAV
      ENDIF

      IF (NTRACE > 0) THEN
          CALL IMPRNT(MA)
          IF (NARG == 2) CALL IMPRNT(MB)
      ENDIF

      NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMNTR

      SUBROUTINE IMNTRI(NTR,N,KNAM)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,"(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)")  &
                     NAME,NCALL,INT(MBASE)
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,NCALL,INT(MBASE),KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I20)") N

      RETURN
      END SUBROUTINE IMNTRI

      SUBROUTINE IMNTRJ(MA,ND)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: ND

      CHARACTER(99) :: FORM
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(MBASE-1))) + 2
      N = (KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,                                                       &
                 "(' (1X,I19,I',I2,',',I3,'I',I2,'/(22X,',I3,'I',I2,')) ')"  &
                ) L+2, N-1, L, N, L
      ENDIF
      IF (INT(MWK(START(MA)+2)) >= 2) THEN
          WRITE (KW,*) '            Sign = ',INT(MWK(START(MA))),'  Accuracy = ',  &
                       INT(MWK(START(MA)+1)),'  Exponent = ',INT(MWK(START(MA)+2)),'  Digits:'
          WRITE (FORM,*) '(13X,', N, 'I', L, ')'
          WRITE (KW,FORM) (INT(MWK(START(MA)+J)),J=3,ND+2)
      ELSE
          WRITE (KW,*) '            Sign = ',INT(MWK(START(MA))),'  Accuracy = ',  &
                       INT(MWK(START(MA)+1)),'  Exponent = ',INT(MWK(START(MA)+2)),'  Digits:'
          WRITE (FORM,*) '(13X,', N, 'I', L, ')'
          WRITE (KW,FORM) INT(MWK(START(MA)+3)),(0,J=4,ND+2)
      ENDIF

      RETURN
      END SUBROUTINE IMNTRJ

      SUBROUTINE IMNTRR(NTR,X,KNAM)

!  Internal routine for trace output of real variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Double precision value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      DOUBLE PRECISION :: X

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,X,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,"(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)") NAME,NCALL,INT(MBASE)
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,NCALL,INT(MBASE),KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,D30.20)") X

      RETURN
      END SUBROUTINE IMNTRR

      SUBROUTINE IMOUT(MA,LINE,LB)

!  Convert an integer multiple precision number to a character array for output.

!  MA   is an IM number to be converted to an A1 character array in base 10 format.
!  LINE is the character(1) array in which the result is returned.
!  LB   is the length of LINE.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: JF1SAV,JF2SAV,LB,NDSAVE
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMOUT    ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      NAMEST(NCALL) = 'IMOUT'

      NDSAVE = NDIG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      JFORM1 = 2
      JFORM2 = 0
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
      CALL FMOUT(MA,LINE,LB)

      NDIG = NDSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE IMOUT

      SUBROUTINE IMPACK(MA,MP)

!  MA is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,KMA1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MA)+2)/2 + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV/2) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF

      KMA1 = INT(MWK(START(MA)+2))
      IF (KMA1 <= 2) KMA1 = 2
      IF (ABS(KMA1) >= MEXPOV) KMA1 = 2
      KP = 2
      MWK(START(MP)+1) = MWK(START(MA)+1)
      MWK(START(MP)+2) = MWK(START(MA)+2)
      MWK(START(MP)+3) = ABS(MWK(START(MA)+3))*MBASE + MWK(START(MA)+4)
      MWK(START(MP)) = 1
      IF (MWK(START(MA)) < 0) MWK(START(MP)) = -1
      IF (KMA1 >= 4) THEN
          DO J = 4, KMA1, 2
             KP = KP + 1
             MWK(START(MP)+KP+1) = MWK(START(MA)+J+1)*MBASE + MWK(START(MA)+J+2)
          ENDDO
      ENDIF
      IF (MOD(KMA1,2) == 1) MWK(START(MP)+KP+2) = MWK(START(MA)+KMA1+2)*MBASE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPACK

      SUBROUTINE IMPMOD(MA,MB,MC,MD)

!  MD = MOD(MA**MB,MC)

!  The binary multiplication method used requires an average of 1.5 * LOG2(MB) operations.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MBS
      INTEGER :: IREM,KWRNSV,NDSAVE,NTRSAV
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MWK(START(MC)+2) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMPMOD   ',2,MA,MB)
      IF (KDEBUG == 1) CALL IMARGS('IMPMOD   ',1,MC,MC)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMPMOD'
          CALL IMNTR(2,MA,MB,2)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  NDIG = MAX(2,INT(MWK(START(MC)+2)))
                  IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
                  NTRSAV = NTRACE
                  CALL IMNTRJ(MC,NDIG)
                  NTRACE = NTRSAV
                  NDIG = NDSAVE
              ELSE
                  CALL IMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      MBS = MWK(START(MB))
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.                &
          MWK(START(MC)+2) == MUNKNO .OR. MWK(START(MA)+2) == MEXPOV .OR.                &
          MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPOV .OR.                &
          MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR. MWK(START(MC)+2) < 0 .OR.  &
          (MWK(START(MB))*MWK(START(MB)+3) <= 0 .AND. MWK(START(MA)+3) == 0) .OR.        &
          MWK(START(MC)+3) == 0) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO .AND.  &
              MWK(START(MC)+2) /=MUNKNO) THEN
              NAMEST(NCALL) = 'IMPMOD'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MB)+3) == 0) THEN
          CALL IMI2M(1,MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MB)+2) == 1 .AND. ABS(MWK(START(MB)+3)) == 1) THEN
          KWRNSV = KWARN
          KWARN = 0
          IF (MWK(START(MB)) == 1) THEN
              CALL IMMOD(MA,MC,MXY(6))
          ELSE
              CALL IMI2M(1,MXY(2))
              CALL IMDIVR(MXY(2),MA,MXY(1),MXY(3))
              CALL IMMOD(MXY(1),MC,MXY(6))
          ENDIF
          CALL IMEQ(MXY(6),MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          KWARN = KWRNSV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL IMI2M(0,MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Initialize.

      KWRNSV = KWARN
      KWARN = 0
      CALL IMABS(MB,MXY(3))
      CALL IMDIVR(MA,MC,MXY(1),MXY(2))
      CALL IMEQ(MC,MXY(1))
      CALL IMDVIR(MXY(3),2,MXY(6),IREM)
      IF (IREM == 0) THEN
          CALL IMI2M(1,MXY(6))
      ELSE
          CALL IMEQ(MXY(2),MXY(6))
      ENDIF
      CALL IMDVIR(MXY(3),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(3))

!             This is the multiplication loop.

  110 CALL IMDVIR(MXY(3),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(3))
      CALL IMMPYM(MXY(2),MXY(2),MXY(1),MXY(5))
      CALL IMEQ(MXY(5),MXY(2))
      IF (IREM == 1) THEN
          CALL IMMPYM(MXY(2),MXY(6),MXY(1),MXY(5))
          CALL IMEQ(MXY(5),MXY(6))
      ENDIF
      IF (MWK(START(MXY(3))+3) > 0 .AND. MWK(START(MXY(6))+3) /= 0) GO TO 110

      IF (MBS < 0) THEN
          CALL IMI2M(1,MXY(2))
          KREM = 0
          CALL IMDIVR(MXY(2),MXY(6),MXY(4),MXY(3))
          KREM = 1
          CALL IMEQ(MXY(4),MXY(6))
      ENDIF
      KWARN = KWRNSV
      CALL IMEQ(MXY(6),MD)
      MWK(START(MD)+1) = MIN(MACCA,MACCB)
      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'IMPMOD'
          CALL FMWARN
      ENDIF
      IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPMOD

      SUBROUTINE IMPRNT(MA)

!  Print MA in base 10 format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      INTEGER :: JF1SAV,JF2SAV,NDSAVE
      INTENT (IN) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NDSAVE = NDIG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      JFORM1 = 2
      JFORM2 = 0
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
      CALL FMPRNT(MA)
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPRNT

      SUBROUTINE IMPWR(MA,MB,MC)

!  MC = MA ** MB

!  The binary multiplication method used requires an average of 1.5 * LOG2(MB) multiplications.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS
      DOUBLE PRECISION :: DA,DB
      INTEGER :: IREM,IREMB,JSIGN,KOVFL,KWRNSV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF ((MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1) .OR.  &
          MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = 5
          KOVFL = 1
          KWRNSV = KWARN
          KWARN = 0
          CALL IMM2DP(MA,DA)
          IF (KFLAG == 0) THEN
              CALL IMM2DP(MB,DB)
              IF (KFLAG == 0) THEN
                  RESULT_SIZE = ABS(DB)*LOG(ABS(DA)+1)/DLOGMB + 5
                  KOVFL = 0
                  IF (ABS(RESULT_SIZE) >= MEXPOV) THEN
                      RESULT_SIZE = 5
                      KOVFL = 1
                  ENDIF
              ENDIF
          ELSE
              CALL IMM2DP(MB,DB)
              IF (KFLAG == 0) THEN
                  RESULT_SIZE = MIN(HUGE(1)/10.0D0,ABS(DB)*(ABS(MWK(START(MA)+2))+1) + 5)
                  KOVFL = 0
                  IF (ABS(RESULT_SIZE) >= MEXPOV .OR. ABS(MWK(START(MA)+2)) >= MEXPOV) THEN
                      RESULT_SIZE = 5
                      KOVFL = 1
                  ENDIF
              ENDIF
          ENDIF
          KWARN = KWRNSV
          NUMBER_USED = NUMBER_USED_SAVE
      ENDIF
      IF (MWK(START(MB)) < 0 .AND. MWK(START(MA)+3) /= 0) THEN
          RESULT_SIZE = 5
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMPWR    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMPWR'
          CALL IMNTR(2,MA,MB,2)
      ENDIF
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KWRNSV = KWARN

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.                &
          MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR. ((MWK(START(MB)) < 0 .OR.  &
          MWK(START(MB)+3) == 0) .AND. MWK(START(MA)+3) == 0)) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MB)+3) == 0) THEN
          CALL IMI2M(1,MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1) THEN
          KWARN = 0
          IF (MAS == 1) THEN
              CALL IMI2M(1,MC)
          ELSE
              CALL IMI2M(2,MXY(1))
              CALL IMDIVR(MB,MXY(1),MXY(4),MXY(2))
              CALL IMEQ(MXY(4),MXY(1))
              IF (MWK(START(MXY(2))+2) == MUNKNO) THEN
                  KFLAG = -4
                  KWARN = KWRNSV
                  NAMEST(NCALL) = 'IMPWR'
                  CALL FMWARN
                  CALL IMST2M('UNKNOWN',MC)
              ELSE IF (MWK(START(MXY(2))+3) == 0) THEN
                  CALL IMI2M(1,MC)
              ELSE
                  CALL IMI2M(-1,MC)
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1) THEN
          KWARN = 0
          IF (MBS == 1) THEN
              CALL IMEQ(MA,MC)
          ELSE
              CALL IMI2M(1,MXY(1))
              KREM = 0
              CALL IMDIVR(MXY(1),MA,MXY(3),MXY(2))
              CALL IMEQ(MXY(3),MC)
              KREM = 1
          ENDIF
          GO TO 130
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL IMI2M(0,MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MB)) < 0) THEN
          CALL IMI2M(0,MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MB)+2) == MEXPOV) THEN
          IF (MBS < 0) THEN
              CALL IMI2M(0,MC)
          ELSE IF (MAS > 0) THEN
              CALL IMST2M('OVERFLOW',MC)
              KFLAG = -5
          ELSE
              KFLAG = -4
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
              CALL IMST2M('UNKNOWN',MC)
          ENDIF
          GO TO 130
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          JSIGN = 1
          IF (MWK(START(MA)) < 0) JSIGN = -1
          IF (MBS > 0) THEN
              CALL IMDVIR(MB,2,MXY(1),IREM)
              CALL IMST2M('OVERFLOW',MC)
              MWK(START(MC)) = JSIGN**IREM
              KFLAG = -5
          ELSE
              CALL IMI2M(0,MC)
          ENDIF
          GO TO 130
      ENDIF

      IF (KOVFL == 1) THEN
          IF (MBS <= 0) THEN
              CALL IMI2M(0,MC)
          ELSE IF (MWK(START(MA)) >= 0) THEN
              CALL IMST2M('OVERFLOW',MC)
              KFLAG = -5
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ELSE
              CALL IMDVIR(MB,2,MXY(1),IREM)
              CALL IMST2M('OVERFLOW',MC)
              MWK(START(MC)) = (-1)**IREM
              KFLAG = -5
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ENDIF
          GO TO 130
      ENDIF

!             Initialize.

      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      CALL IMDEFINE(MXY(3),RESULT_SIZE)
      CALL IMDEFINE(MXY(5),RESULT_SIZE)
      KWARN = 0
      CALL IMABS(MB,MXY(2))

      CALL IMEQ(MA,MXY(1))

      CALL IMDVIR(MB,2,MXY(4),IREMB)
      CALL IMEQ(MXY(4),MC)
      IF (IREMB == 0) THEN
          CALL IMI2M(1,MC)
      ELSE
          CALL IMEQ(MXY(1),MC)
      ENDIF
      CALL IMDVIR(MXY(2),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(2))

!             This is the multiplication loop.

  110 CALL IMDVIR(MXY(2),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(2))
      CALL IMSQR(MXY(1),MXY(5))
      CALL IMEQ(MXY(5),MXY(1))
      IF (IREM == 1) THEN
          CALL IMMPY(MXY(1),MC,MXY(3))
          CALL IMEQ(MXY(3),MC)
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL IMEQ(MXY(1),MC)
          IF (MAS < 0 .AND. IREMB == 1) MWK(START(MC)) = -1
          GO TO 120
      ENDIF
      IF (MWK(START(MXY(2))+3) > 0) GO TO 110

  120 IF (MBS < 0) THEN
          CALL IMI2M(1,MXY(1))
          KREM = 0
          CALL IMDIVR(MXY(1),MC,MXY(4),MXY(2))
          KREM = 1
          CALL IMEQ(MXY(4),MC)
      ENDIF

      MWK(START(MC)+1) = MIN(MACCA,MACCB)
      IF (MWK(START(MC)+2) >= MEXPOV) THEN
          IF (NCALL == 1 .OR. MWK(START(MC)+2) >= MEXPOV) THEN
              IF (MWK(START(MC)) > 0) THEN
                  CALL IMST2M('OVERFLOW',MC)
              ELSE
                  CALL IMST2M('-OVERFLOW',MC)
              ENDIF
              KFLAG = -5
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ENDIF
      ENDIF

  130 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMPWR'
          CALL IMNTR(1,MC,MC,1)
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPWR

      SUBROUTINE IMREAD(KREAD,MA)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: KREAD

      CHARACTER :: LINE(132)
      INTEGER :: J,K,L2,LB
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'IMREAD'
      LB = 0

  110 READ (KREAD,"(132A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 132
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFF) THEN

!                If CMBUFF runs out of space, try to re-allocate it with a bigger size.

                 IF (LMBUFF > 0) THEN
                     ALLOCATE(MOVE_CMBUFF(LMBUFF),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, LMBUFF
                        MOVE_CMBUFF(K) = CMBUFF(K)
                     ENDDO
                     DEALLOCATE(CMBUFF)
                     L2 = MAX(10000,2*LMBUFF)
                     ALLOCATE(CMBUFF(L2),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, L2
                        CMBUFF(K) = ' '
                     ENDDO
                     DO K = 1, LMBUFF
                        CMBUFF(K) = MOVE_CMBUFF(K)
                     ENDDO
                     DEALLOCATE(MOVE_CMBUFF)
                     LMBUFF = L2
                 ELSE
                     ALLOCATE(CMBUFF(10000),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     LMBUFF = 10000
                 ENDIF
             ENDIF
             CMBUFF(LB) = LINE(J)
         ENDIF
      ENDDO

      CALL IMINP(CMBUFF,MA,1,LB)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 KFLAG = -4
      CALL FMWARN
      CALL FMST2M('UNKNOWN',MA)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMREAD

      SUBROUTINE IMSIGN(MA,MB,MC)

!  MC = SIGN(MA,MB)

!  MC is set to ABS(MA) if MB is positive or zero, or -ABS(MA) if MB is negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MA)+2) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMSIGN   ',2,MA,MB)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMSIGN'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMSIGN'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
      ELSE IF (MWK(START(MB)) >= 0) THEN
          CALL IMEQ(MA,MC)
          MWK(START(MC)) = 1
      ELSE
          CALL IMEQ(MA,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
      ENDIF

      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSIGN

      SUBROUTINE IMSQR(MA,MB)

!  MB = MA * MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MDAB
      INTEGER :: NDSAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = 2*MWK(START(MA)+2) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMSQR    ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMSQR'
          CALL IMNTR(2,MA,MA,1)
      ENDIF

      IF (MWK(START(MA)+2) <= 1) THEN
          IF (MWK(START(MA)+2) < 0) GO TO 110
          MDAB = MWK(START(MA)+3) * MWK(START(MA)+3)
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 1
              IF (MDAB == 0) MWK(START(MB)+2) = 0
              MWK(START(MB)+3) = MDAB
              MWK(START(MB)+4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 2
              MWK(START(MB)+3) = AINT (MDAB/MBASE)
              MWK(START(MB)+4) = MDAB - MBASE*MWK(START(MB)+3)
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMST2M('UNKNOWN',MB)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          MWK(START(MB)) = 1
          MWK(START(MB)+1) = NINT(10**7*ALOGM2)
          MWK(START(MB)+2) = 0
          MWK(START(MB)+3) = 0
          MWK(START(MB)+4) = 0
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV) THEN
          KFLAG = -5
          CALL IMST2M('OVERFLOW',MB)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == 1 .AND. ABS(MWK(START(MA)+3)) == 1) THEN
          CALL IMI2M(1,MB)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMSQR'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MB)
          GO TO 120
      ENDIF

      NDIG = INT(MWK(START(MA)+2) + MWK(START(MA)+2))

      IF (NDIG < 2) NDIG = 2

      CALL IMSQR2(MA,MB)

  120 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      MWK(START(MB)) = 1
      IF (NTRACE /= 0) CALL IMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSQR

      SUBROUTINE IMSQR2(MA,MB)

!  MB = MA*MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MAXMAX,MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKA,MKT,MMAX,MT
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KI,KJ,KL,KNZ,KOVUN,KWA,L,N1,ND,NMETHD,NZDA
      INTEGER :: MXY(2),NUMBER_USED_SAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             KSQR is used to tell FMMPYFFT that only one input fft is needed.

      KSQR = 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (KDEBUG == 1 .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL IMMPY(MA,MA,MB)
          NCALL = NCALL - 1
          IF ((KFLAG < 0 .AND. KOVUN == 0) .OR. (KFLAG == -4 .AND. KOVUN == 1)) THEN
              NAMEST(NCALL) = 'IMSQR'
              CALL FMWARN
          ENDIF
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL IMEQ(MA,MB)
          GO TO 130
      ENDIF
      KFLAG = 0
      MAXMAX = 0
      N1 = INT(MWK(START(MA)+2)) + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MA)+2)

!             Check for using an FFT-based method if precision is very high.

      ND = 1000
      IF (NDIG >= ND) THEN
          NZDA = 0
          DO J = 2, INT(MWK(START(MA)+2))
             IF (MWK(START(MA)+J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (MWK(START(MA)+2)-NZDA < 50 .OR. REAL(NZDA)/MWK(START(MA)+2) > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          ND = NDIG
          NDIG = MWK(START(MA)+2)
          CALL IMI2FM(MA,MXY(1))
          CALL IMI2FM(MA,MXY(2))
          CALL FMMPYFFT(MXY(1),MXY(2))
          NDIG = ND
          GO TO 120
      ENDIF

      L = N1 + INT(MWK(START(MA)+2))
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MA)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = INT(MWK(START(MA)+2)), 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          MWK(START(MWA)+4) = 0
          DO K = N1+1, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 3, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MWK(START(MA)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = 2*J, JM1+KL
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1
          IF (2*MAX(MAXMAX,MAXMWA)+MBASE > MMAX) THEN
              DO KB = L, 4, -1
                 MKT = INT (MWK(JMWA+KB)/MBASE)
                 MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
                 MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
              ENDDO
          ENDIF

          DO J = 3, L-1, 2
             IF ((J+1)/2 <= N1) THEN
                 MKA = MWK(JMA+(J+1)/2)
                 MWK(JMWA+J) = 2*MWK(JMWA+J) + MKA*MKA
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ELSE
                 MWK(JMWA+J) = 2*MWK(JMWA+J)
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MWK(JMA+(L+1)/2)
                  MWK(JMWA+L) = 2*MWK(JMWA+L) + MKA*MKA
              ELSE
                  MWK(JMWA+L) = 2*MWK(JMWA+L)
              ENDIF
          ENDIF

          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = MWK(START(MA)+2) + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MA)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             The multiplication is complete.

  120 NDIG = MWK(START(MWA)+2)
      IF (NDIG < 2) NDIG = 2
      CALL FMMOVE(MWA,MB)
      MWK(START(MB)+1) = NINT(10**7*ALOGM2)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'IMSQR'
          CALL FMWARN
      ENDIF

  130 MWK(START(MB)) = 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      KSQR = 0
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSQR2

      SUBROUTINE IMST2M(STRING,MA)

!  MA = STRING

!  Convert a character string to IM format.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: MA

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'IMST2M'
      LB = LEN(STRING)
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF
      KFSAVE = KFLAG

      DO J = 1, LB
         CMBUFF(J) = STRING(J:J)
      ENDDO

      CALL IMINP(CMBUFF,MA,1,LB)

      IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      IF (KFSAVE /= 0) KFLAG = KFSAVE
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMST2M

      SUBROUTINE IMSUB(MA,MB,MC)

!  MC = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMSUB    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMSUB'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MB)+2) > 2 .OR. MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) GO TO 110
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          IF (MWK(START(MB)+2) <= 1) THEN
              MDB = MWK(START(MB)) * MWK(START(MB)+3)
          ELSE
              MDB = MWK(START(MB)) * (MWK(START(MB)+3)*MBASE + MWK(START(MB)+4))
          ENDIF
          MDAB = MDA - MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              MWK(START(MC)) = 1
              IF (MDAB < 0) MWK(START(MC)) = -1
              MWK(START(MC)+3) = ABS(MDAB)
              MWK(START(MC)+4) = 0
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 2
              MWK(START(MC)) = 1
              IF (MDAB < 0) MWK(START(MC)) = -1
              MDAB = ABS(MDAB)
              MWK(START(MC)+3) = AINT (MDAB/MBASE)
              MWK(START(MC)+4) = MDAB - MBASE*MWK(START(MC)+3)
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
              CALL IMST2M('UNKNOWN',MC)
              KFLAG = -4
              GO TO 120
          ENDIF
          IF (MWK(START(MA)+2) == MEXPOV) THEN
              IF (MWK(START(MA)) == -MWK(START(MB)) .OR. MWK(START(MB)+3) == 0) THEN
                  MWK(START(MC)) = MWK(START(MA))
                  MWK(START(MC)+1) = MWK(START(MA)+1)
                  MWK(START(MC)+2) = MWK(START(MA)+2)
                  MWK(START(MC)+3) = MWK(START(MA)+3)
                  MWK(START(MC)+4) = MWK(START(MA)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMSUB'
                  CALL FMWARN
                  CALL IMST2M('UNKNOWN',MC)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MWK(START(MB)+2) == MEXPOV) THEN
              IF (-MWK(START(MB)) == MWK(START(MA)) .OR. MWK(START(MA)+3) == 0) THEN
                  MWK(START(MC)) = -MWK(START(MB))
                  MWK(START(MC)+1) = MWK(START(MB)+1)
                  MWK(START(MC)+2) = MWK(START(MB)+2)
                  MWK(START(MC)+3) = MWK(START(MB)+3)
                  MWK(START(MC)+4) = MWK(START(MB)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMSUB'
                  CALL FMWARN
                  CALL IMST2M('UNKNOWN',MC)
                  GO TO 120
              ENDIF
          ENDIF
          KFLAG = -4
          NAMEST(NCALL) = 'IMSUB'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 120
      ENDIF

!             IMADD3 will negate MB and add.

      KSUB = 1
      CALL IMADD3(MA,MB,MC)
      KSUB = 0

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSUB

      SUBROUTINE IMUNPK(MP,MA)

!  MP is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,KMA1
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MP)+2) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF

      KMA1 = INT(MWK(START(MP)+2))
      IF (KMA1 <= 2) KMA1 = 2
      IF (ABS(KMA1) >= MEXPOV) KMA1 = 2
      KP = 2
      MWK(START(MA)+1) = MWK(START(MP)+1)
      MWK(START(MA)+2) = MWK(START(MP)+2)
      MWK(START(MA)+3) = AINT (ABS(MWK(START(MP)+3))/MBASE)
      MWK(START(MA)+4) = ABS(MWK(START(MP)+3)) - MWK(START(MA)+3)*MBASE
      MWK(START(MA)) = 1
      IF (MWK(START(MP)) < 0) MWK(START(MA)) = -1
      IF (KMA1 >= 4) THEN
          DO J = 4, KMA1, 2
             KP = KP + 1
             MWK(START(MA)+J+1) = AINT (MWK(START(MP)+KP+1)/MBASE)
             MWK(START(MA)+J+2) = MWK(START(MP)+KP+1) - MWK(START(MA)+J+1)*MBASE
          ENDDO
      ENDIF
      IF (MOD(KMA1,2) == 1) MWK(START(MA)+KMA1+2) = AINT (MWK(START(MP)+KP+2)/MBASE)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMUNPK

      SUBROUTINE IMWRIT(KWRITE,MA)

!  Write MA on unit KWRITE.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using IMREAD.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KWRITE
      INTEGER :: MA

      INTEGER :: J,K,KSAVE,L,LAST,LB,ND,NDSAVE,NEXP
      INTENT (IN) :: KWRITE,MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMWRIT   ',1,MA,MA)
      NAMEST(NCALL) = 'IMWRIT'
      NDSAVE = NDIG
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      IF (MWK(START(MA)+2) >= MEXPOV) NDIG = 2

      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = ND + NEXP
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF

      CALL IMOUT(MA,CMBUFF,LB)

      KFLAG = KSAVE
      NDIG = NDSAVE
      LAST = LB + 1
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L)
             ELSE
                 IF (L > 73) WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFF(K),K=L-72,L)
             ENDIF
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMWRIT

      SUBROUTINE IM_OR_FM_ADD(MA,MB,MC)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: M1,M2,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      M1 = -2
      M2 = -2
      IF (MAX(MWK(START(MA)+2),MWK(START(MB)+2)) > NDIG) THEN
          IF (MC <= 0) THEN
              CALL FMDEFINE(MC)
          ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
              CALL FMDEFINE(MC)
          ENDIF
      ELSE
          RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 4
          IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MC <= 0) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ENDIF
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MAX(MWK(START(MA)+2),MWK(START(MB)+2)) > NDIG) THEN
          IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL FMADD(MA,MB,MC)
          ELSE IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MB,M2)
              CALL FMADD(MA,M2,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL FMADD(M1,MB,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL IMI2FM(MB,M2)
              CALL FMADD(M1,M2,MC)
          ENDIF
      ELSE
          CALL IMADD(MA,MB,MC)
      ENDIF

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IM_OR_FM_ADD

      SUBROUTINE IM_OR_FM_EQ(MA,MB)

!  Internal routine used by binary splitting algorithms.
!  MA is an integer, but if it gets bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      IF (MWK(START(MA)+2) >= NDIG) THEN
          CALL FMEQ(MA,MB)
      ELSE
          CALL IMEQ(MA,MB)
      ENDIF
      RETURN
      END SUBROUTINE IM_OR_FM_EQ

      SUBROUTINE IM_OR_FM_MPY(MA,MB,MC)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: M1,M2,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      M1 = -2
      M2 = -2
      IF (MWK(START(MA)+2)+MWK(START(MB)+2) > NDIG) THEN
          IF (MC <= 0) THEN
              CALL FMDEFINE(MC)
          ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
              CALL FMDEFINE(MC)
          ENDIF
      ELSE
          IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
              RESULT_SIZE = 5
          ELSE
              RESULT_SIZE = MWK(START(MA)+2) + MWK(START(MB)+2) + 4
          ENDIF
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MC <= 0) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ENDIF
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MWK(START(MA)+2)+MWK(START(MB)+2) > NDIG) THEN
          IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL FMMPY(MA,MB,MC)
          ELSE IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MB,M2)
              CALL FMMPY(MA,M2,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL FMMPY(M1,MB,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL IMI2FM(MB,M2)
              CALL FMMPY(M1,M2,MC)
          ENDIF
      ELSE
          CALL IMMPY(MA,MB,MC)
      ENDIF

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IM_OR_FM_MPY

      SUBROUTINE IM_OR_FM_SQR(MA,MB)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: M1,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      M1 = -2
      IF (2*MWK(START(MA)+2) > NDIG) THEN
          IF (MB <= 0) THEN
              CALL FMDEFINE(MB)
          ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
              CALL FMDEFINE(MB)
          ENDIF
      ELSE
          RESULT_SIZE = 2*MWK(START(MA)+2) + 4
          IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MB <= 0) THEN
              CALL IMDEFINE(MB,RESULT_SIZE)
          ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
              CALL IMDEFINE(MB,RESULT_SIZE)
          ENDIF
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (2*MWK(START(MA)+2) > NDIG) THEN
          IF (MWK(START(MA)+2) >= NDIG) THEN
              CALL FMSQR(MA,MB)
          ELSE
              CALL IMI2FM(MA,M1)
              CALL FMSQR(M1,MB)
          ENDIF
      ELSE
          CALL IMSQR(MA,MB)
      ENDIF

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IM_OR_FM_SQR


!  These versions of the IM routines use packed IM numbers.

      SUBROUTINE IPABS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMABS(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPABS

      SUBROUTINE IPADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMADD(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPADD

      SUBROUTINE IPBIG(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMBIG(MPB)
      CALL IMPACK(MPB,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPBIG

      FUNCTION IPCOMP(MA,LREL,MB)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: IPCOMP
      LOGICAL, EXTERNAL ::IMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      INTENT (IN) :: MA,MB,LREL
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      IPCOMP = IMCOMP(MPA,LREL,MPB)
      RETURN
      END FUNCTION IPCOMP

      SUBROUTINE IPDIM(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMDIM(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIM

      SUBROUTINE IPDIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMDIV(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIV

      SUBROUTINE IPDIVI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMDIVI(MPA,IVAL,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIVI

      SUBROUTINE IPDIVR(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC,MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMDIVR(MPA,MPB,MPC,MPD)
      CALL IMPACK(MPC,MC)
      CALL IMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIVR

      SUBROUTINE IPDVIR(MA,IVAL,MB,IREM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL,IREM
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB,IREM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMDVIR(MPA,IVAL,MPB,IREM)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDVIR

      SUBROUTINE IPEQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMEQ(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPEQ

      SUBROUTINE IPFACT(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: IVAL,MA
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMFACT(IVAL,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPFACT

      SUBROUTINE IPFM2I(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL IMFM2I(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPFM2I

      SUBROUTINE IPFORM(FORM,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: STRING
      CALL IMUNPK(MA,MPA)
      CALL IMFORM(FORM,MPA,STRING)
      RETURN
      END SUBROUTINE IPFORM

      SUBROUTINE IPFPRT(FORM,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMFPRT(FORM,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPFPRT

      SUBROUTINE IPGCD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMGCD(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPGCD

      SUBROUTINE IPI2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMI2FM(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPI2FM

      SUBROUTINE IPI2M(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMI2M(IVAL,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPI2M

      SUBROUTINE IPINP(LINE,MA,LA,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMINP(LINE,MPA,LA,LB)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPINP

      SUBROUTINE IPM2DP(MA,DVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      DOUBLE PRECISION :: DVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: DVAL
      CALL IMUNPK(MA,MPA)
      CALL IMM2DP(MPA,DVAL)
      RETURN
      END SUBROUTINE IPM2DP

      SUBROUTINE IPM2I(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL
      CALL IMUNPK(MA,MPA)
      CALL IMM2I(MPA,IVAL)
      RETURN
      END SUBROUTINE IPM2I

      SUBROUTINE IPMAX(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMAX(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMAX

      SUBROUTINE IPMIN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMIN(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMIN

      SUBROUTINE IPMOD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMOD(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMOD

      SUBROUTINE IPMPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMPY(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMPY

      SUBROUTINE IPMPYI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMMPYI(MPA,IVAL,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMPYI

      SUBROUTINE IPMPYM(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMUNPK(MC,MPC)
      CALL IMMPYM(MPA,MPB,MPC,MPD)
      CALL IMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMPYM

      SUBROUTINE IPOUT(MA,LINE,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: LB
      CHARACTER :: LINE(LB)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      CALL IMUNPK(MA,MPA)
      CALL IMOUT(MPA,LINE,LB)
      RETURN
      END SUBROUTINE IPOUT

      SUBROUTINE IPPMOD(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMUNPK(MC,MPC)
      CALL IMPMOD(MPA,MPB,MPC,MPD)
      CALL IMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPPMOD

      SUBROUTINE IPPRNT(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMPRNT(MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPPRNT

      SUBROUTINE IPPWR(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMPWR(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPPWR

      SUBROUTINE IPREAD(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: KREAD
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMREAD(KREAD,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPREAD

      SUBROUTINE IPSIGN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMSIGN(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPSIGN

      SUBROUTINE IPSQR(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMSQR(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPSQR

      SUBROUTINE IPST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTEGER :: MA
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMST2M(STRING,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPST2M

      SUBROUTINE IPSUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMSUB(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPSUB

      SUBROUTINE IPWRIT(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      INTENT (IN) :: MA,KWRITE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMWRIT(KWRITE,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPWRIT


!  The ZM routines perform complex multiple-precision arithmetic.

      SUBROUTINE ZMSET(NPREC)

!  Set precision to at least NPREC significant digits for using ZM arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NPREC
      INTENT (IN) :: NPREC

!             Set JFORMZ to ' 1.23 + 4.56 i ' format.

      JFORMZ = 1

!             Set JPRNTZ to print real and imaginary parts on one line whenever possible.

      JPRNTZ = 1

!             Use FMSET to initialize the other variables.

      CALL FMSET(NPREC)

      RETURN
      END SUBROUTINE ZMSET

      SUBROUTINE ZMABS(MA,MBFM)

!  MBFM = ABS(MA)

!  Complex absolute value.  The result is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      INTEGER :: MXY(3),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MBFM <= 0) THEN
          CALL FMDEFINE(MBFM)
      ELSE IF (SIZE_OF(MBFM) < NDIG+3) THEN
          CALL FMDEFINE(MBFM)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTRSAV = NTRACE
      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'ZMABS'
          CALL ZMNTR(2,MA,MA,1)
          NCALL = NCALL - 1
      ENDIF
      NTRACE = 0
      CALL ZMENTR('ZMABS    ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NTRACE = NTRSAV
      IF (KRESLT /= 0) THEN
          CALL FMEQ(MZ01(1),MBFM)
          NCALL = NCALL + 1
          IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      MXEXP1 = INT(MXEXP2/2.01D0)
      IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMABS(MZ02(2),MXY(3))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMABS(MZ02(1),MXY(3))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPOV) THEN
          CALL FMI2M(1,MXY(3))
          MWK(START(MXY(3))+2) = MAX(MWK(START(MZ02(1))+2),MWK(START(MZ02(2))+2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) == MEXPUN) THEN
          IF (MWK(START(MA(2))+2) > -MXEXP1+NDIG+1) THEN
              CALL FMABS(MZ02(2),MXY(3))
          ELSE
              CALL FMST2M('UNKNOWN',MXY(3))
              KFLAG = -4
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(2))+2) == MEXPUN) THEN
          IF (MWK(START(MA(1))+2) > -MXEXP1+NDIG+1) THEN
              CALL FMABS(MZ02(1),MXY(3))
          ELSE
              CALL FMST2M('UNKNOWN',MXY(3))
              KFLAG = -4
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) /= MUNKNO .AND. MWK(START(MA(2))+2) /= MUNKNO) THEN
          IF (MWK(START(MA(1))+2) > MWK(START(MA(2))+2)+NDIG+1) THEN
              CALL FMABS(MZ02(1),MXY(3))
              GO TO 120
          ELSE IF (MWK(START(MA(2))+2) > MWK(START(MA(1))+2)+NDIG+1) THEN
              CALL FMABS(MZ02(2),MXY(3))
              GO TO 120
          ENDIF
      ENDIF

      CALL FMSQR(MZ02(1),MXY(1))
      CALL FMSQR(MZ02(2),MXY(2))
      CALL FMADD(MXY(1),MXY(2),MXY(3))
      CALL FMSQRT_R1(MXY(3))

  120 MACCMB = MWK(START(MXY(3))+1)
      MWK(START(MXY(3))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXI2(MXY(3),MBFM,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMABS

      SUBROUTINE ZMACOS(MA,MB)

!  MB = ACOS(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMACOS   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL FMPI(MZ01(1))
          CALL FMDIVI_R1(MZ01(1),2)
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          KRSAVE = KRAD
          KRAD = 1
          CALL FMACOS(MZ04(1),MZ01(1))
          KRAD = KRSAVE
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2))
              GO TO 120
          ENDIF
      ENDIF
      IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
          (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL FMPI(MZ02(1))
          CALL FMDIVI_R1(MZ02(1),2)
          CALL FMI2M(0,MZ02(2))
          CALL ZMSUB(MZ02,MZ04,MZ01)
          GO TO 120
      ENDIF

      CALL ZMI2M(0,MZ01)
      CALL ZMI2M(1,MZ03)
      CALL ZMSUB(MZ03,MZ04,MZ02)
      CALL ZMADD(MZ03,MZ04,MZ05)
      CALL ZMMPY(MZ02,MZ05,MZ03)
      CALL ZMSQRT(MZ03,MZ02)
      DO J = -1, NDIG+1
         MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
         MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
      ENDDO
      IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
          MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))

      IF ((MWK(START(MA(1))+3) /= 0 .AND. MWK(START(MZ03(1))+2) == MWK(START(MA(1))+2) .AND.   &
          MWK(START(MZ03(1)))*MWK(START(MZ03(1))+3) == MWK(START(MA(1)))*MWK(START(MA(1))+3))  &
          .OR. (MWK(START(MA(2))+3) /= 0 .AND. MWK(START(MZ03(2))+2) == MWK(START(MA(2))+2)    &
          .AND. MWK(START(MZ03(2)))*MWK(START(MZ03(2))+3) ==                                   &
          MWK(START(MA(2)))*MWK(START(MA(2))+3)) ) THEN
          CALL ZMADD(MZ04,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMADD(MZ04,MZ03,MZ05)
          ENDIF

          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ELSE
          CALL ZMSUB(MZ04,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMSUB(MZ04,MZ03,MZ05)
          ENDIF

          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMACOS

      SUBROUTINE ZMACOSH(MA,MB)

!  MB = ACOSH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMACOSH  ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

      IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*4 <= -NDIG) .AND.  &
          (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*4 <= -NDIG)) THEN
          CALL FMPI(MZ02(1))
          CALL FMDIVI_R1(MZ02(1),2)
          CALL FMI2M(0,MZ02(2))
          CALL ZMSUB(MZ02,MZ04,MZ03)
          IF (MWK(START(MZ04(2))+2) /= MEXPUN) THEN
              CALL ZMIPWR(MZ04,3,MZ02)
              CALL ZMDIVI(MZ02,6,MZ01)
              CALL ZMSUB(MZ03,MZ01,MZ02)
              CALL FMEQ(MZ02(1),MZ01(2))
              CALL FMMPYI(MZ02(2),-1,MZ01(1))
          ELSE
              CALL FMIPWR(MZ04(1),3,MZ02(1))
              CALL FMDIVI(MZ02(1),6,MZ01(1))
              CALL FMSUB(MZ03(1),MZ01(1),MZ01(2))
              CALL FMMPYI(MZ03(2),-1,MZ01(1))
          ENDIF
          IF (MWK(START(MZ04(2))) < 0) THEN
              MWK(START(MZ01(2))) = -1
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
          ENDIF
          GO TO 120
      ENDIF

      CALL ZMI2M(1,MZ03)
      CALL ZMADD(MZ04,MZ03,MZ05)
      CALL ZMSQRT(MZ05,MZ02)
      CALL ZMSUB(MZ04,MZ03,MZ05)
      CALL ZMSQRT(MZ05,MZ01)
      CALL ZMMPY(MZ01,MZ02,MZ05)
      CALL ZMADD(MZ04,MZ05,MZ02)
      CALL ZMLN(MZ02,MZ01)

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      IF (MWK(START(MA(2))+3) == 0 .AND. MWK(START(MA(1))+2) <= 0) THEN
          CALL FMI2M(0,MZ01(1))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMACOSH

      SUBROUTINE ZMADD(MA,MB,MC)

!  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      INTEGER :: KASAVE,KF1,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MAR,MAI,MBR,MBI,MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMADD    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NTRSAV = NTRACE
          NTRACE = 0
      ELSE
          NCALL = NCALL + 1
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMADD'
              CALL ZMNTR(2,MA,MB,2)
              NTRACE = 0
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMADD to use more guard digits for user calls.

      NCALL = NCALL - 1

      KWRNSV = KWARN
      KWARN = 0
      MAR = MWK(START(MA(1))+2)
      IF (MWK(START(MA(1))+3) == 0) MAR = MEXPUN - 1
      MAI = MWK(START(MA(2))+2)
      IF (MWK(START(MA(2))+3) == 0) MAI = MEXPUN - 1
      MBR = MWK(START(MB(1))+2)
      IF (MWK(START(MB(1))+3) == 0) MBR = MEXPUN - 1
      MBI = MWK(START(MB(2))+2)
      IF (MWK(START(MB(2))+3) == 0) MBI = MEXPUN - 1

      CALL FMADD(MA(1),MB(1),MC(1))
      KF1 = KFLAG
      CALL FMADD(MA(2),MB(2),MC(2))

      NCALL = NCALL + 1
      IF (NTRSAV /= 0) THEN
          NTRACE = NTRSAV
          NAMEST(NCALL) = 'ZMADD'
      ENDIF
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = KF1
      IF (KFLAG == 1) THEN
          KFLAG = 0
          IF (MAR <= MBR .AND. MAI <= MBI) KFLAG = 1
          IF (MAR >= MBR .AND. MAI >= MBI) KFLAG = 1
      ENDIF

      IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMADD'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) THEN
          CALL ZMNTR(1,MC,MC,1)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMADD

      SUBROUTINE ZMADDI(MA,INTEG)

!  MA = MA + INTEG        Increment by one-word (real) integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: INTEG

      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (INOUT) :: MA
      INTENT (IN) :: INTEG
      INTEGER :: MZ01(2),NUMBER_USED_SAVE

      MZ01 = -2
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'ZMADDI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
              NCALL = NCALL - 1
          ENDIF
          NTRACE = 0
          CALL ZMENTR('ZMADDI   ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              CALL FMEQ(MZ01(1),MA(1))
              NCALL = NCALL + 1
              IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NTRSAV = NTRACE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMADDI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMADDI to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMADDI(MA(1),INTEG)

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMADDI'
      IF (MWK(START(MA(1))+2) == MUNKNO .OR. MWK(START(MA(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MA(1))+2) == MEXPUN .OR. MWK(START(MA(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MA(1))+2) == MUNKNO) .OR. (MWK(START(MA(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MA(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MA(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MA(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MA(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMADDI'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMADDI

      SUBROUTINE ZMARG(MA,MBFM)

!  MBFM = ARG(MA)

!  Complex argument.  The result is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      INTEGER :: MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      IF (MBFM <= 0) THEN
          CALL FMDEFINE(MBFM)
      ELSE IF (SIZE_OF(MBFM) < NDIG+3) THEN
          CALL FMDEFINE(MBFM)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTRSAV = NTRACE
      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'ZMARG'
          CALL ZMNTR(2,MA,MA,1)
          NCALL = NCALL - 1
      ENDIF
      NTRACE = 0
      CALL ZMENTR('ZMARG    ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NTRACE = NTRSAV
      IF (KRESLT /= 0) THEN
          CALL FMEQ(MZ01(1),MBFM)
          NCALL = NCALL + 1
          IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

      CALL FMATN2(MZ02(2),MZ02(1),MZ01(1))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXI2(MZ01(1),MBFM,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMARG

      SUBROUTINE ZMASIN(MA,MB)

!  MB = ASIN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMASIN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
               (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL ZMEQ(MZ04,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          KRSAVE = KRAD
          KRAD = 1
          CALL FMASIN(MZ04(1),MZ01(1))
          KRAD = KRSAVE
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2))
              GO TO 120
          ENDIF
      ENDIF

      CALL ZMI2M(0,MZ01)
      CALL ZMI2M(1,MZ03)
      CALL ZMSUB(MZ03,MZ04,MZ02)
      CALL ZMADD(MZ03,MZ04,MZ05)
      CALL ZMMPY(MZ02,MZ05,MZ03)
      CALL ZMSQRT(MZ03,MZ02)
      DO J = -1, NDIG+1
         MWK(START(MZ03(1))+J+1) = MWK(START(MZ04(2))+J+1)
         MWK(START(MZ03(2))+J+1) = MWK(START(MZ04(1))+J+1)
      ENDDO
      IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
          MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))

      IF ((MWK(START(MZ02(1))+3) /= 0 .AND. MWK(START(MZ03(1))+2) == MWK(START(MZ02(1))+2)  &
          .AND. MWK(START(MZ03(1)))*MWK(START(MZ03(1))+3) ==                                &
                MWK(START(MZ02(1)))*MWK(START(MZ02(1))+3)) .OR.                             &
          (MWK(START(MZ02(2))+3) /= 0 .AND. MWK(START(MZ03(2))+2) == MWK(START(MZ02(2))+2)  &
          .AND.  MWK(START(MZ03(2)))*MWK(START(MZ03(2))+3) ==                               &
                 MWK(START(MZ02(2)))*MWK(START(MZ02(2))+3)) ) THEN
          CALL ZMADD(MZ02,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ04(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ04(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMADD(MZ02,MZ03,MZ05)
          ENDIF

          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ELSE
          CALL ZMSUB(MZ02,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ04(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ04(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMSUB(MZ02,MZ03,MZ05)
          ENDIF
          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMASIN

      SUBROUTINE ZMASINH(MA,MB)

!  MB = ASINH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMASINH  ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
               (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          IF (KROUND == 1) THEN
              CALL ZMEQ(MZ04,MZ01)
          ELSE
              CALL ZMIPWR(MZ04,3,MZ03)
              CALL ZMDIVI(MZ03,6,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ01)
              KR_RETRY = 2
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMASINH(MZ04(1),MZ01(1))
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2))
              GO TO 120
          ENDIF
      ENDIF

      CALL ZMI2M(1,MZ03)
      CALL ZMSQR(MZ04,MZ02)
      CALL ZMADD(MZ03,MZ02,MZ05)
      CALL ZMSQRT(MZ05,MZ02)

      IF (MWK(START(MZ04(1))) > 0) THEN
          CALL ZMADD(MZ02,MZ04,MZ05)
          CALL ZMLN(MZ05,MZ01)
      ELSE
          CALL ZMSUB(MZ02,MZ04,MZ05)
          CALL ZMLN(MZ05,MZ01)
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+2) <= 0) THEN
          CALL FMI2M(0,MZ01(1))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMASINH

      SUBROUTINE ZMATAN(MA,MB)

!  MB = ATAN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JTERM,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMATAN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ03)
          GO TO 130
      ELSE IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
               (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL ZMEQ(MZ04,MZ03)
          GO TO 130
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          KRSAVE = KRAD
          KRAD = 1
          CALL FMATAN(MZ04(1),MZ03(1))
          KRAD = KRSAVE
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ03(2))
              GO TO 130
          ENDIF
      ENDIF

      X = 1.0E+5
      CALL FMDPM(DBLE(X),MXY(1))
      CALL FMABS(MZ04(1),MXY(2))
      CALL FMABS(MZ04(2),MXY(3))
      CALL FMADD_R2(MXY(2),MXY(3))

      IF (FMCOMP(MXY(3),'>=',MXY(1))) THEN
          CALL ZMI2M(0,MZ03)
          CALL FMPI(MZ03(1))
          CALL FMDIVI_R1(MZ03(1),2)
          IF (MWK(START(MA(1))) < 0 .AND. MWK(START(MZ03(1))+2) /= MUNKNO .AND.  &
              MWK(START(MZ03(1))+3) /= 0) MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
          CALL ZMI2M(1,MZ01)
          CALL ZMDIV(MZ01,MZ04,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMSUB(MZ03,MZ05,MZ01)
          CALL ZMEQ(MZ01,MZ03)
          IF (MWK(START(MA(1))+2) > NDIG .OR. MWK(START(MA(2))+2) > NDIG) GO TO 130
          CALL ZMSQR(MZ05,MZ01)
          JTERM = 1
  120     CALL ZMMPY(MZ02,MZ01,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          JTERM = JTERM + 2
          CALL FMEQ(MZ02(1),MXY(4))
          CALL FMEQ(MZ02(2),MXY(5))
          CALL ZMDIVI(MZ02,JTERM,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMADD(MZ03,MZ02,MZ05)
          CALL ZMEQ(MZ05,MZ03)
          IF (KFLAG /= 0) GO TO 130
          CALL FMEQ(MXY(4),MZ02(1))
          CALL FMEQ(MXY(5),MZ02(2))
          CALL ZMMPY(MZ02,MZ01,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          JTERM = JTERM + 2
          CALL FMEQ(MZ02(1),MXY(4))
          CALL FMEQ(MZ02(2),MXY(5))
          CALL ZMDIVI(MZ02,JTERM,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMSUB(MZ03,MZ02,MZ05)
          CALL ZMEQ(MZ05,MZ03)
          IF (KFLAG /= 0) GO TO 130
          CALL FMEQ(MXY(4),MZ02(1))
          CALL FMEQ(MXY(5),MZ02(2))
          GO TO 120
      ELSE
          CALL ZM2I2M(0,1,MZ01)
          CALL ZMSUB(MZ01,MZ04,MZ03)
          CALL ZMADD(MZ01,MZ04,MZ05)
          CALL ZMDIV(MZ05,MZ03,MZ02)
          CALL FMSQR(MZ02(1),MXY(3))
          CALL FMSQR(MZ02(2),MXY(4))
          CALL FMADD(MXY(3),MXY(4),MXY(5))
          CALL FMI2M(1,MXY(2))
          CALL FMSUB_R2(MXY(5),MXY(2))
          IF (MWK(START(MXY(2))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(2))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZM2I2M(0,1,MZ01)
              CALL ZMSUB(MZ01,MZ04,MZ03)
              CALL ZMADD(MZ01,MZ04,MZ05)
              CALL ZMDIV(MZ05,MZ03,MZ02)
          ENDIF
          CALL ZMLN(MZ02,MZ05)
          CALL ZMDIVI(MZ05,2,MZ02)
          DO J = -1, NDIG+1
             MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
             MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
          ENDDO
          IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
              MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
      ENDIF

  130 MACCMB = MWK(START(MZ03(1))+1)
      MWK(START(MZ03(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ03(2))+1)
      MWK(START(MZ03(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ03(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ03(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ03,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMATAN

      SUBROUTINE ZMATANH(MA,MB)

!  MB = ATANH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JTERM,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),MZ06(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      MZ06 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMATANH  ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ03)
          GO TO 130
      ELSE IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
               (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL ZMEQ(MZ04,MZ03)
          GO TO 130
      ELSE IF (MWK(START(MA(2))+3) == 0 .AND. MWK(START(MA(2))+2) <= 0) THEN
          CALL FMATANH(MZ04(1),MZ03(1))
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ03(2))
              GO TO 130
          ENDIF
      ENDIF

      CALL FMDPM(1.0D+5,MXY(1))
      CALL FMABS(MZ04(1),MXY(2))
      CALL FMABS(MZ04(2),MXY(3))
      CALL FMADD_R2(MXY(2),MXY(3))

      IF (FMCOMP(MXY(3),'>=',MXY(1))) THEN
          CALL ZMI2M(0,MZ03)
          CALL FMPI(MZ03(2))
          IF (MWK(START(MA(2))) > 0) THEN
              CALL FMDIVI_R1(MZ03(2),2)
          ELSE
              CALL FMDIVI_R1(MZ03(2),-2)
          ENDIF
          IF (MWK(START(MA(1))) < 0 .AND. MWK(START(MZ03(1))+2) /= MUNKNO .AND.  &
              MWK(START(MZ03(1))+3) /= 0) MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
          CALL ZMI2M(1,MZ01)
          CALL ZMDIV(MZ01,MZ04,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMADD(MZ03,MZ05,MZ01)
          CALL ZMEQ(MZ01,MZ03)
          IF (MWK(START(MA(1))+2) > NDIG .OR. MWK(START(MA(2))+2) > NDIG) GO TO 130
          CALL ZMSQR(MZ05,MZ01)
          JTERM = 1
  120     CALL ZMMPY(MZ02,MZ01,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          JTERM = JTERM + 2
          CALL ZMDIVI(MZ02,JTERM,MZ06)
          CALL ZMADD(MZ03,MZ06,MZ05)
          CALL ZMEQ(MZ05,MZ03)
          IF (KFLAG /= 0) GO TO 130
          GO TO 120
      ELSE
          CALL ZMI2M(0,MZ03)
          CALL ZMI2M(1,MZ01)
          CALL ZMSUB(MZ01,MZ04,MZ02)
          CALL ZMADD(MZ01,MZ04,MZ05)
          CALL ZMDIV(MZ05,MZ02,MZ03)
          CALL FMSQR(MZ03(1),MXY(3))
          CALL FMSQR(MZ03(2),MXY(4))
          CALL FMADD(MXY(3),MXY(4),MXY(5))
          CALL FMI2M(1,MXY(2))
          CALL FMSUB_R2(MXY(5),MXY(2))
          IF (MWK(START(MXY(2))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(2))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(1,MZ01)
              CALL ZMSUB(MZ01,MZ04,MZ02)
              CALL ZMADD(MZ01,MZ04,MZ05)
              CALL ZMDIV(MZ05,MZ02,MZ03)
          ENDIF
          CALL ZMLN(MZ03,MZ05)
          CALL ZMDIVI(MZ05,2,MZ03)
      ENDIF

  130 MACCMB = MWK(START(MZ03(1))+1)
      MWK(START(MZ03(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ03(2))+1)
      MWK(START(MZ03(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      IF (MWK(START(MA(2))+3) == 0 .AND. MWK(START(MA(1))+2) >= 1) THEN
          MWK(START(MZ03(2))) = -MWK(START(MA(1)))
      ENDIF
      IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMI2M(0,MZ03(1))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ03(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ03(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ03,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMATANH

      SUBROUTINE ZMCHSH(MA,MB,MC)

!  MB = COSH(MA),    MC = SINH(MA).

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  ZMCOSH and ZMSINH.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCSAVE = NCALL
      CALL ZMENTR('ZMCHSH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NCALL = NCSAVE + 1
      IF (KRESLT /= 0) THEN
          CALL ZMEQ(MB,MC)
          IF (NTRACE /= 0) THEN
              CALL ZMNTR(1,MB,MB,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL ZMNTRJ(MC,NDIG)
                  ELSE
                      CALL ZMPRNT(MC)
                  ENDIF
              ENDIF
          ENDIF
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
              IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          CALL ZMI2M(0,MZ05)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCHSH(MZ04(1),MZ01(1),MZ05(1))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCSSN(MZ04(2),MZ01(1),MZ05(2))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(1))
          GO TO 120
      ENDIF

!             Find SINH(REAL(MA)) and COSH(REAL(MA)).

      CALL FMCHSH(MZ04(1),MZ02(1),MZ02(2))

!             Find SIN(IMAG(MA)) and COS(IMAG(MA)).

      CALL FMCSSN(MZ04(2),MZ03(1),MZ03(2))

!             COSH(MA) =  COSH(REAL(MA))*COS(IMAG(MA)) + SINH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY(MZ02(1),MZ03(1),MZ01(1))
      CALL FMMPY(MZ02(2),MZ03(2),MZ01(2))

!             SINH(MA) =  SINH(REAL(MA))*COS(IMAG(MA)) + COSH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY(MZ02(2),MZ03(1),MZ05(1))
      CALL FMMPY(MZ02(1),MZ03(2),MZ05(2))

      IF (MWK(START(MZ05(1))+2) == MUNKNO .OR. MWK(START(MZ05(2))+2) == MUNKNO) THEN
          CALL ZMCOSH(MZ04,MZ01)
          CALL ZMSINH(MZ04,MZ05)
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      MWK(START(MZ05(1))+1) = MWK(START(MZ01(1))+1)
      MWK(START(MZ05(2))+1) = MWK(START(MZ01(2))+1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      KACCSW = KASAVE
      CALL ZMEQU(MZ05,MC,NDIG,NDSAVE)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL ZMNTRJ(MC,NDIG)
              ELSE
                  CALL ZMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCHSH

      SUBROUTINE ZMCMPX(MAFM,MBFM,MC)

!  MC = COMPLEX( MAFM , MBFM )

!  MAFM and MBFM are real FM numbers, MC is a complex ZM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MAFM,MBFM,MC(2)
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMCMPX'
      IF (NTRACE /= 0) CALL FMNTR(2,MAFM,MBFM,2,1)

      CALL FMEQ(MAFM,MC(1))
      CALL FMEQ(MBFM,MC(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCMPX

      SUBROUTINE ZMCONJ(MA,MB)

!  MB = CONJG(MA)

!  Complex conjugate.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMCONJ'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMEQ(MA(1),MB(1))
      CALL FMEQ(MA(2),MB(2))
      IF (MWK(START(MB(2))+2) /= MUNKNO .AND. MWK(START(MB(2))+3) /= 0)  &
          MWK(START(MB(2))) = -MWK(START(MB(2)))

      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCONJ

      SUBROUTINE ZMCOS(MA,MB)

!  MB = COS(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMCOS    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCOS(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCOSH(MZ02(2),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find COS(REAL(MA)) and SIN(REAL(MA)).

      CALL FMCSSN(MZ02(1),MZ01(1),MZ01(2))

!             Find COSH(IMAG(MA)) and SINH(IMAG(MA)).

      CALL FMCHSH(MZ02(2),MXY(1),MXY(2))

!             COS(MA) =  COS(REAL(MA))*COSH(IMAG(MA)) - SIN(REAL(MA))*SINH(IMAG(MA)) i

      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMABS(MZ02(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(5))
          CALL FMEXP(MXY(5),MXY(4))
          IF (MWK(START(MZ01(1))) < 0) CALL FMMPYI_R1(MXY(4),-1)

          CALL FMABS(MZ01(2),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMADD(MXY(2),MXY(3),MXY(1))
          CALL FMEXP(MXY(1),MXY(5))
          IF (MWK(START(MZ02(2))) > 0) CALL FMMPYI_R1(MXY(5),-1)
          IF (MWK(START(MZ01(2))) < 0) CALL FMMPYI_R1(MXY(5),-1)

          CALL FMEQ(MXY(4),MZ01(1))
          CALL FMEQ(MXY(5),MZ01(2))
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(1))
          IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
              MWK(START(MXY(2))) = -MWK(START(MXY(2)))
          CALL FMMPY_R1(MZ01(2),MXY(2))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCOS

      SUBROUTINE ZMCOSH(MA,MB)

!  MB = COSH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMCOSH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCOS(MZ02(2),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCOSH(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find COS(IMAG(MA)) and SIN(IMAG(MA)).

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2))

!             Find COSH(REAL(MA)) and SINH(REAL(MA)).

      CALL FMCHSH(MZ02(1),MXY(1),MXY(2))

!             COSH(MA) =  COSH(REAL(MA))*COS(IMAG(MA)) + SINH(REAL(MA))*SIN(IMAG(MA)) i

      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMABS(MZ02(1),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(5))
          CALL FMEXP(MXY(5),MXY(4))
          IF (MWK(START(MZ01(1))) < 0) CALL FMMPYI_R1(MXY(4),-1)

          CALL FMABS(MZ01(2),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMADD(MXY(2),MXY(3),MXY(1))
          CALL FMEXP(MXY(1),MXY(5))
          IF (MWK(START(MZ02(1))) < 0) CALL FMMPYI_R1(MXY(5),-1)
          IF (MWK(START(MZ01(2))) < 0) CALL FMMPYI_R1(MXY(5),-1)

          CALL FMEQ(MXY(4),MZ01(1))
          CALL FMEQ(MXY(5),MZ01(2))
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(1))
          CALL FMMPY_R1(MZ01(2),MXY(2))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCOSH

      SUBROUTINE ZMCSSN(MA,MB,MC)

!  MB = COS(MA),    MC = SIN(MA).

!  If both the sine and cosine are needed, this routine is faster than calling both ZMCOS and ZMSIN.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCSAVE = NCALL
      CALL ZMENTR('ZMCSSN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NCALL = NCSAVE + 1
      IF (KRESLT /= 0) THEN
          CALL ZMEQ(MB,MC)
          IF (NTRACE /= 0) THEN
              CALL ZMNTR(1,MB,MB,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL ZMNTRJ(MC,NDIG)
                  ELSE
                      CALL ZMPRNT(MC)
                  ENDIF
              ENDIF
          ENDIF
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
              IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          CALL ZMI2M(0,MZ05)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCSSN(MZ04(1),MZ01(1),MZ05(1))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCHSH(MZ04(2),MZ01(1),MZ05(2))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(1))
          GO TO 120
      ENDIF

!             Find SIN(REAL(MA)) and COS(REAL(MA)).

      CALL FMCSSN(MZ04(1),MZ02(1),MZ02(2))

!             Find SINH(IMAG(MA)) and COSH(IMAG(MA)).

      CALL FMCHSH(MZ04(2),MZ03(1),MZ03(2))

!             COS(MA) =  COS(REAL(MA))*COSH(IMAG(MA)) - SIN(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY(MZ02(1),MZ03(1),MZ01(1))
      CALL FMMPY(MZ02(2),MZ03(2),MZ01(2))
      IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
          MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))

!             SIN(MA) =  SIN(REAL(MA))*COSH(IMAG(MA)) + COS(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY(MZ02(2),MZ03(1),MZ05(1))
      CALL FMMPY(MZ02(1),MZ03(2),MZ05(2))

      IF (MWK(START(MZ05(1))+2) == MUNKNO .OR. MWK(START(MZ05(2))+2) == MUNKNO) THEN
          CALL ZMCOS(MZ04,MZ01)
          CALL ZMSIN(MZ04,MZ05)
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      MWK(START(MZ05(1))+1) = MWK(START(MZ01(1))+1)
      MWK(START(MZ05(2))+1) = MWK(START(MZ01(2))+1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      KACCSW = KASAVE
      CALL ZMEQU(MZ05,MC,NDIG,NDSAVE)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL ZMNTRJ(MC,NDIG)
              ELSE
                  CALL ZMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCSSN

      SUBROUTINE ZMDIV(MA,MB,MC)

!  MC = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MBIZ,MBRZ,MXSAVE,MZ11SV,MZ1KSV
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NGOAL,NTRSAV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(8),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMDIV    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMDIV'
              CALL ZMNTR(2,MA,MB,2)
          ENDIF
          NDSAVE = NDIG
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR. MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
              NDIG = NDIG + 1
          ELSE IF (MBASE >= 100*ABS(MWK(START(MB(1))+3)) .OR.  &
              MBASE >= 100*ABS(MWK(START(MB(2))+3))) THEN
              NDIG = NDIG + 1
          ENDIF
          KASAVE = KACCSW
          KACCSW = 1
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      NTRSAV = NTRACE
      NTRACE = 0
      MARZ = MWK(START(MA(1))+1)
      MBRZ = MWK(START(MB(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      MBIZ = MWK(START(MB(2))+1)
      KR_RETRY = 0
      KWRNSV = KWARN
      KWARN = 0
      IEXTRA = 0
      MZ11SV = -MUNKNO
      MZ1KSV = -MUNKNO

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA(1),MXY(5),NDSAVE,NDIG)
      CALL FMEQU(MA(2),MXY(6),NDSAVE,NDIG)
      CALL FMEQU(MB(1),MXY(7),NDSAVE,NDIG)
      CALL FMEQU(MB(2),MXY(8),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(7))+1) = MWK(START(MXY(5))+1)
      MWK(START(MXY(6))+1) = MWK(START(MXY(5))+1)
      MWK(START(MXY(8))+1) = MWK(START(MXY(5))+1)

!             Check for special cases.

      IF (MWK(START(MB(2))+3) == 0) THEN
          CALL FMDIVD(MXY(5),MXY(6),MXY(7),MZ01(1),MZ01(2))
          GO TO 130
      ELSE IF (MWK(START(MB(1))+3) == 0) THEN
          CALL FMDIVD(MXY(6),MXY(5),MXY(8),MZ01(1),MZ01(2))
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
          GO TO 130
      ENDIF
      IF (MWK(START(MA(1))+2) == MWK(START(MB(1))+2) .AND.  &
          MWK(START(MA(1))+3) == MWK(START(MB(1))+3) .AND.  &
          MWK(START(MA(1))) == MWK(START(MB(1)))) THEN
          IF (MWK(START(MA(2))+2) == MWK(START(MB(2))+2) .AND.  &
              MWK(START(MA(2))+3) == MWK(START(MB(2))+3) .AND.  &
              MWK(START(MA(2))) == MWK(START(MB(2)))) THEN
              DO J = 3, NDSAVE+1
                 IF (MWK(START(MA(1))+J+1) /= MWK(START(MB(1))+J+1)) GO TO 120
                 IF (MWK(START(MA(2))+J+1) /= MWK(START(MB(2))+J+1)) GO TO 120
              ENDDO
              IF (ABS(MWK(START(MA(1))+2)) < MEXPOV .AND. ABS(MWK(START(MA(2))+2)) < MEXPOV  &
                  .AND. ABS(MWK(START(MB(1))+2)) < MEXPOV .AND.                              &
                  ABS(MWK(START(MB(2))+2)) < MEXPOV) THEN
                  CALL ZMI2M(1,MZ01)
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF
      IF (MWK(START(MA(1))+2) == MWK(START(MB(1))+2) .AND.  &
          MWK(START(MA(1))+3) == MWK(START(MB(1))+3) .AND.  &
          (-MWK(START(MA(1)))) == MWK(START(MB(1)))) THEN
          IF (MWK(START(MA(2))+2) == MWK(START(MB(2))+2) .AND.  &
              MWK(START(MA(2))+3) == MWK(START(MB(2))+3) .AND.  &
              (-MWK(START(MA(2)))) == MWK(START(MB(2)))) THEN
              DO J = 3, NDSAVE+1
                 IF (MWK(START(MA(1))+J+1) /= MWK(START(MB(1))+J+1)) GO TO 120
                 IF (MWK(START(MA(2))+J+1) /= MWK(START(MB(2))+J+1)) GO TO 120
              ENDDO
              IF (ABS(MWK(START(MA(1))+2)) < MEXPOV .AND. ABS(MWK(START(MA(2))+2)) < MEXPOV  &
                  .AND. ABS(MWK(START(MB(1))+2)) < MEXPOV .AND.                              &
                  ABS(MWK(START(MB(2))+2)) < MEXPOV) THEN
                  CALL ZMI2M(-1,MZ01)
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF
  120 IF (MZ11SV /= -MUNKNO) THEN

!             If a retry is being done due to cancellation, try a slower but more stable form of
!             the division formula.

!                ( a + b i ) / ( c + d i ) =
!
!                ( a*c + b*d) / ( c*c + d*d ) + ( b*c - a*d) / ( c*c + d*d ) i

          CALL FMMPYE(MXY(7),MXY(5),MXY(6),MXY(7), MZ01(1),MZ01(2),MXY(3))
          CALL FMMPYE(MXY(8),MXY(6),MXY(5),MXY(8), MXY(1),MXY(2),MXY(4))
          CALL FMADD_R2(MXY(3),MXY(4))
          CALL FMADD_R1(MZ01(1),MXY(1))
          CALL FMSUB_R1(MZ01(2),MXY(2))
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(4),MZ02(1),MZ02(2))
          CALL ZMEQ(MZ02,MZ01)
          IF (ABS(MWK(START(MZ01(1))+2)) < MEXPOV .AND.  &
              ABS(MWK(START(MZ01(2))+2)) < MEXPOV) GO TO 130
      ENDIF

!             Normal method for  ( a + b i ) / ( c + d i ):

!             If  abs(c) << abs(d)  Then

!                 P = c / d
!                 result = ( a*P + b )/( c*P + d ) + ( b*P - a )/( c*P + d ) i

!             Else

!                 P = d / c
!                 result = ( b*P + a )/( d*P + c ) + ( b - a*P )/( d*P + c ) i

      KACCSW = 0
      IF (MWK(START(MB(1))+2) <= MWK(START(MB(2))+2)) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4))
          CALL FMMPYE(MXY(4),MXY(5),MXY(6),MXY(7),MZ01(1),MZ01(2),MXY(3))
          IF (MWK(START(MA(2)))*MWK(START(MZ01(1))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R2(MXY(6),MZ01(1))
          IF (MWK(START(MXY(3)))*MWK(START(MB(2))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R1(MXY(3),MXY(8))
          IF (MWK(START(MZ01(2)))*MWK(START(MA(1))) < 0) THEN
              KACCSW = 0
          ELSE
              KACCSW = 1
          ENDIF
          CALL FMSUB_R1(MZ01(2),MXY(5))
          KACCSW = 0
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(3),MZ02(1),MZ02(2))
          CALL ZMEQ(MZ02,MZ01)
      ELSE
          CALL FMDIV(MXY(8),MXY(7),MXY(4))
          CALL FMMPYE(MXY(4),MXY(6),MXY(5),MXY(8), MZ01(1),MZ01(2),MXY(3))
          IF (MWK(START(MA(1)))*MWK(START(MZ01(1))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R2(MXY(5),MZ01(1))
          IF (MWK(START(MXY(3)))*MWK(START(MB(1))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R1(MXY(3),MXY(7))
          IF (MWK(START(MZ01(2)))*MWK(START(MA(2))) < 0) THEN
              KACCSW = 0
          ELSE
              KACCSW = 1
          ENDIF
          CALL FMSUB_R2(MXY(6),MZ01(2))
          KACCSW = 0
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(3),MZ02(1),MZ02(2))
          CALL ZMEQ(MZ02,MZ01)
      ENDIF
      KACCSW = 1

!             If one of the two parts of the result is unknown, re-try using the more
!             stable formula.

      IF (MZ11SV == -MUNKNO) THEN
          IF (MWK(START(MZ01(1))+2) == MUNKNO .OR. MWK(START(MZ01(2))+2) == MUNKNO) THEN
              MZ11SV = MWK(START(MZ01(1))+2)
              MZ1KSV = MWK(START(MZ01(2))+2)
              GO TO 110
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IF (MZ11SV-MWK(START(MZ01(1))+2) >= IEXTRA-1 .AND. MWK(START(MZ01(2))+1) > NGOAL)  &
              GO TO 140
          IF (MZ1KSV-MWK(START(MZ01(2))+2) >= IEXTRA-1 .AND. MWK(START(MZ01(1))+1) > NGOAL)  &
              GO TO 140
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(1))+1) > NGOAL .AND.  &
              MWK(START(MZ01(2))+3) == 0) GO TO 140
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(2))+1) > NGOAL .AND.  &
              MWK(START(MZ01(1))+3) == 0) GO TO 140
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          MZ11SV = MWK(START(MZ01(1))+2)
          MZ1KSV = MWK(START(MZ01(2))+2)
          NDIG = NDIG + IEXTRA
          GO TO 110
      ENDIF

  140 MXEXP = MXSAVE
      NTRACE = NTRSAV
      NDGSV2 = NDIG
      NDIG = NDSAVE
      KWARN = KWRNSV
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      CALL ZMEQU(MZ01,MC,NDGSV2,NDSAVE)
      IF (MWK(START(MC(1))+2) >= MEXPOV .OR. MWK(START(MC(1))+2) <= -MEXPOV .OR.  &
          MWK(START(MC(2))+2) >= MEXPOV .OR. MWK(START(MC(2))+2) <= -MEXPOV) THEN
          IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
              KFLAG = -4
          ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
              KFLAG = -5
          ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
              KFLAG = -6
          ENDIF
          IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
             .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
                  NAMEST(NCALL) = 'ZMDIV'
                  CALL ZMWARN
          ENDIF
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMDIV

      SUBROUTINE ZMDIVI(MA,INTEG,MB)

!  MB = MA / INTEG        Divide by one-word (real) integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG

      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'ZMDIVI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
              NCALL = NCALL - 1
          ENDIF
          NTRACE = 0
          CALL ZMENTR('ZMDIVI   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
              NCALL = NCALL - 1
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMDIVI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMDIVI to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMDIVI(MA(1),INTEG,MB(1))
      CALL FMDIVI(MA(2),INTEG,MB(2))

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMDIVI'
      IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMDIVI'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMDIVI

      SUBROUTINE ZMENTR(NROUTN,MA,MB,NARGS,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision, overflow threshold, etc., upon entry to
!  a ZM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result immediately
!           (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NARGS,KRESLT,NDSAVE,KASAVE,KOVUN

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,NDS
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      KRESLT = 0
      NCALL = NCALL + 1
      KFLAG = 0
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MB,NARGS)

      IF (MBLOGS /= MBASE) CALL FMCONS
      KOVUN = 0
      IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(1))+2) == MEXPUN .OR.  &
          MWK(START(MA(2))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(1))+2) == MEXPUN .OR.  &
          MWK(START(MB(2))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPUN) KOVUN = 1
      ENDIF
      KASAVE = KACCSW
      MXSAVE = MXEXP

!             Check the validity of parameters if this is a user call.

      IF (NCALL > 1 .AND. KDEBUG == 0) GO TO 130

!             Check NDIG.

      IF (NDIG < 2) THEN
          KFLAG = -1
          CALL ZMWARN
          NDS = NDIG
          IF (NDIG < 2) NDIG = 2
          WRITE (KW,                                                      &
                 "(' NDIG was',I10,'.  It has been changed to',I10,'.')"  &
                ) NDS,NDIG
          KRESLT = 12
          GO TO 130
      ENDIF

!             Check MBASE.

      IF (MBASE < 2 .OR. MBASE > MXBASE) THEN
          KFLAG = -2
          CALL ZMWARN
          MBS = MBASE
          IF (MBASE < 2) MBASE = 2
          IF (MBASE > MXBASE) MBASE = MXBASE
          WRITE (KW,                                                       &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(MBASE)
          CALL FMCONS
          KRESLT = 12
          GO TO 130
      ENDIF

!             Check exponent range.

      IF (MWK(START(MA(1))+2) > MXEXP+1 .OR. MWK(START(MA(1))+2) < -MXEXP) THEN
          IF ((ABS(MWK(START(MA(1))+2)) /= MEXPOV .AND. ABS(MWK(START(MA(1))+2)) /= MUNKNO) .OR.  &
              ABS(MWK(START(MA(1))+3)) /= 1) THEN
              KFLAG = -3
              CALL ZMWARN
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF
      IF (MWK(START(MA(2))+2) > MXEXP+1 .OR. MWK(START(MA(2))+2) < -MXEXP) THEN
          IF ((ABS(MWK(START(MA(2))+2)) /= MEXPOV .AND. ABS(MWK(START(MA(2))+2)) /= MUNKNO) .OR.  &
              ABS(MWK(START(MA(2))+3)) /= 1) THEN
              KFLAG = -3
              CALL ZMWARN
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB(1))+2) > MXEXP+1 .OR. MWK(START(MB(1))+2) < -MXEXP) THEN
              IF ((ABS(MWK(START(MB(1))+2)) /= MEXPOV .AND.  &
                   ABS(MWK(START(MB(1))+2)) /= MUNKNO) .OR. ABS(MWK(START(MB(1))+3)) /= 1) THEN
                  KFLAG = -3
                  CALL ZMWARN
                  KRESLT = 12
                  GO TO 130
              ENDIF
          ENDIF
          IF (MWK(START(MB(2))+2) > MXEXP+1 .OR. MWK(START(MB(2))+2) < -MXEXP) THEN
              IF ((ABS(MWK(START(MB(2))+2)) /= MEXPOV .AND.  &
                   ABS(MWK(START(MB(2))+2)) /= MUNKNO) .OR. ABS(MWK(START(MB(2))+3)) /= 1) THEN
                  KFLAG = -3
                  CALL ZMWARN
                  KRESLT = 12
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MWK(START(MA(1))+2)-INT(MWK(START(MA(1))+2))) /= 0) KFLAG = 1
      IF (ABS(MWK(START(MA(2))+2)-INT(MWK(START(MA(2))+2))) /= 0) KFLAG = 1 + NDIG + 1
      IF (MWK(START(MA(1))+3) <= (-1) .OR. MWK(START(MA(1))+3) >= MBASE .OR.  &
          ABS(MWK(START(MA(1))+3)-INT(MWK(START(MA(1))+3))) /= 0) KFLAG = 2
      IF (MWK(START(MA(2))+3) <= (-1) .OR. MWK(START(MA(2))+3) >= MBASE .OR.  &
          ABS(MWK(START(MA(2))+3)-INT(MWK(START(MA(2))+3))) /= 0) KFLAG = 2 + NDIG + 1
      IF (KDEBUG == 0) GO TO 110
      DO J = 3, NDIG+1
         IF (MWK(START(MA(1))+J+1) < 0 .OR. MWK(START(MA(1))+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA(1))+J+1)-INT(MWK(START(MA(1))+J+1))) /= 0) THEN
             KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
      DO J = 3, NDIG+1
         IF (MWK(START(MA(2))+J+1) < 0 .OR. MWK(START(MA(2))+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA(2))+J+1)-INT(MWK(START(MA(2))+J+1))) /= 0) THEN
             KFLAG = J + NDIG + 1
             GO TO 110
         ENDIF
      ENDDO
  110 IF (KFLAG /= 0) THEN
          J = KFLAG
          KFLAG = -4
          KWRNSV = KWARN
          IF (KWARN >= 2) KWARN = 1
          CALL ZMWARN
          KWARN = KWRNSV
          IF (KWARN >= 1) THEN
              IF (J < NDIG+1) THEN
                  WRITE (KW,*) ' First invalid array element:  MA(',  &
                               J,',1) = ',MWK(START(MA(1))+J+1)
              ELSE
                  WRITE (KW,*) ' First invalid array element:  MA(',  &
                               J-NDIG-1,',2) = ',MWK(START(MA(2))+J+1)
              ENDIF
          ENDIF
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          KRESLT = 12
          GO TO 130
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MWK(START(MB(1))+2)-INT(MWK(START(MB(1))+2))) /= 0) KFLAG = 1
          IF (ABS(MWK(START(MB(2))+2)-INT(MWK(START(MB(2))+2))) /= 0) KFLAG = 1 + NDIG + 1
          IF (MWK(START(MB(1))+3) <= (-1) .OR. MWK(START(MB(1))+3) >= MBASE .OR.  &
              ABS(MWK(START(MB(1))+3)-INT(MWK(START(MB(1))+3))) /= 0) KFLAG = 2
          IF (MWK(START(MB(2))+3) <= (-1) .OR. MWK(START(MB(2))+3) >= MBASE .OR.  &
              ABS(MWK(START(MB(2))+3)-INT(MWK(START(MB(2))+3))) /= 0) KFLAG = 2 + NDIG + 1
          IF (KDEBUG == 0) GO TO 120
          DO J = 3, NDIG+1
             IF (MWK(START(MB(1))+J+1) < 0 .OR. MWK(START(MB(1))+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB(1))+J+1)-INT(MWK(START(MB(1))+J+1))) /= 0) THEN
                 KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
          DO J = 3, NDIG+1
             IF (MWK(START(MB(2))+J+1) < 0 .OR. MWK(START(MB(2))+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB(2))+J+1)-INT(MWK(START(MB(2))+J+1))) /= 0) THEN
                 KFLAG = J + NDIG + 1
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (KFLAG /= 0) THEN
              J = KFLAG
              KFLAG = -4
              KWRNSV = KWARN
              IF (KWARN >= 2) KWARN = 1
              CALL ZMWARN
              KWARN = KWRNSV
              IF (KWARN >= 1) THEN
                  IF (J < NDIG+1) THEN
                      WRITE (KW,*) ' First invalid array element:  MB(',  &
                                   J,',1) = ',MWK(START(MB(1))+J+1)
                  ELSE
                      WRITE (KW,*) ' First invalid array element:  MB(',  &
                                   J-NDIG-1,',2) = ',MWK(START(MB(2))+J+1)
                  ENDIF
              ENDIF
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF

!             Increase the working precision.

  130 NDSAVE = NDIG
      IF (NCALL == 1) THEN
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR. MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
              NDIG = NDIG + 1
          ELSE IF (NARGS == 2 .AND. (MBASE >= 100*ABS(MWK(START(MB(1))+3)) .OR.  &
              MBASE >= 100*ABS(MWK(START(MB(2))+3)))) THEN
              NDIG = NDIG + 1
          ENDIF
      ENDIF
      IF ((MWK(START(MA(1))+2) == MUNKNO .AND. MWK(START(MA(2))+2) == MUNKNO) .OR.  &
          (MWK(START(MB(1))+2) == MUNKNO .AND. MWK(START(MB(2))+2) == MUNKNO)) THEN
          KFLAG = -4
          KRESLT = 12
      ENDIF
      IF (KRESLT /= 0) THEN
          NDIG = NDSAVE
          CALL ZMRSLT(MC,KRESLT)
          IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      KACCSW = 1

!             Extend the overflow/underflow threshold.

      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE ZMENTR

      SUBROUTINE ZMEQ(MA,MB)

!  MB = MA

!  This is the standard form of equality, where MA and MB both have precision NDIG.
!  Use ZMEQU for assignments that also change precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEQ(MA(1),MB(1))
      CALL FMEQ(MA(2),MB(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEQ

      SUBROUTINE ZMEQU(MA,MB,NDA,NDB)

!  Set MB (having NDB digits) equal to MA (having NDA digits).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEQU(MA(1),MB(1),NDA,NDB)
      CALL FMEQU(MA(2),MB(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEQU

      SUBROUTINE ZMEQU_R1(MA,NDA,NDB)

!  Change precision of MA from NDA digits on input to NDB digits on output.

!  If NDB is less than NDA the result is rounded to NDB digits.

!  If NDB is greater than NDA the result has zero digits padded on the right.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEQU_R1(MA(1),NDA,NDB)
      CALL FMEQU_R1(MA(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEQU_R1

      SUBROUTINE ZMEXIT(MT,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Upon exit from an ZM routine the result MT (having precision NDIG) is rounded and returned in
!  MC (having precision NDSAVE).
!  The values of NDIG, MXEXP, and KACCSW are restored to the values NDSAVE,MXSAVE,KASAVE.
!  KOVUN is nonzero if one of the routine's input arguments was overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT
      INTENT (INOUT) :: MC,NDSAVE,MXSAVE,KASAVE,KOVUN

      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      KACCSW = KASAVE
      CALL ZMEQU(MT,MC,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) KFLAG = -6
      IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) KFLAG = -5
      IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
          IF (KFLAG /= -9) KFLAG = -4
      ENDIF
      IF ((MWK(START(MC(1))+2) == MUNKNO .AND. KFLAG /= -9) .OR.  &
          (MWK(START(MC(2))+2) == MUNKNO .AND. KFLAG /= -9) .OR.  &
          (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)  .OR.  &
          (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)  .OR.  &
          (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)  .OR.  &
          (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) CALL ZMWARN
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMEXIT

      SUBROUTINE ZMEXI2(MXFM,MYFM,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  This routine is used upon exit for complex functions that return real FM results.
!  Round MXFM and return the result in MYFM.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MXFM,MYFM
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN
      INTENT (IN) :: MXFM
      INTENT (INOUT) :: MYFM,NDSAVE,MXSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV

      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      KACCSW = KASAVE
      CALL FMEQU(MXFM,MYFM,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF (MWK(START(MYFM)+2) == MUNKNO) THEN
          IF (KFLAG >= 0) KFLAG = -4
      ELSE IF (MWK(START(MYFM)+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MYFM)+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MYFM)+2) == MUNKNO .AND. KFLAG /= -9)     &
         .OR. (MWK(START(MYFM)+2) == MEXPUN .AND. KOVUN == 0)  &
         .OR. (MWK(START(MYFM)+2) == MEXPOV .AND. KOVUN == 0)) CALL ZMWARN
      IF (NTRACE /= 0) CALL ZMNTR2(1,MYFM,MYFM,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMEXI2

      SUBROUTINE ZMEXP(MA,MB)

!  MB = EXP(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMEXP    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMI2M(1,MXY(1))
      ELSE
          CALL FMEXP(MZ02(1),MXY(1))
          IF (MWK(START(MA(2))+3) == 0) THEN
              CALL FMEQ(MXY(1),MZ01(1))
              CALL FMI2M(0,MZ01(2))
              GO TO 120
          ENDIF
      ENDIF

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2))

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMEQ(MZ02(1),MZ02(2))
          CALL FMABS(MZ01(1),MXY(1))
          CALL FMLN(MXY(1),MXY(2))
          CALL FMADD_R2(MZ02(2),MXY(2))
          CALL FMEXP(MXY(2),MZ02(1))
          IF (MWK(START(MZ01(1))) < 0) CALL FMMPYI_R1(MZ02(1),-1)

          CALL FMABS(MZ01(2),MXY(1))
          CALL FMLN(MXY(1),MXY(2))
          CALL FMADD_R2(MZ02(2),MXY(2))
          CALL FMEXP(MXY(2),MZ02(2))
          IF (MWK(START(MZ01(2))) < 0) CALL FMMPYI_R1(MZ02(2),-1)
      ELSE
          CALL FMMPYD(MXY(1),MZ01(1),MZ01(2),MZ02(1),MZ02(2))
      ENDIF
      CALL ZMEQ(MZ02,MZ01)
      KWARN = KWRNSV

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEXP

      SUBROUTINE ZMFORM(FORM1,FORM2,MA,STRING)

!  Convert MA to STRING using FORM1 format for the real part and FORM2 format for the
!  imaginary part.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM1,FORM2,STRING
      INTEGER :: MA(2)

      INTEGER :: J,KWIDIM,KWIDRE,LAST,LSIGN
      INTENT (IN) :: MA,FORM1,FORM2
      INTENT (INOUT) :: STRING
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMFORM'
      STRING = ' '
      CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      CALL FMEQ(MA(2),MXY(1))
      IF (MWK(START(MXY(1))) > 0) THEN
          LSIGN = 1
      ELSE
          LSIGN = -1
          IF (MWK(START(MXY(1))+2) /= MUNKNO .AND. MWK(START(MXY(1))+3) /= 0)  &
              MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      ENDIF
      CALL ZMFPCM(FORM2,MXY(1),KWIDIM)

      IF (KWIDRE+KWIDIM+50 > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(KWIDRE+KWIDIM+50),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = KWIDRE + KWIDIM + 50
          CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      ENDIF

      CMBUFZ(KWIDRE+1) = ' '
      IF (LSIGN == 1) THEN
          CMBUFZ(KWIDRE+2) = '+'
      ELSE
          CMBUFZ(KWIDRE+2) = '-'
      ENDIF
      CMBUFZ(KWIDRE+3) = ' '
      DO J = 1, KWIDIM
         CMBUFZ(KWIDRE+3+J) = CMBUFF(J)
      ENDDO
      CMBUFZ(KWIDRE+4+KWIDIM) = ' '
      CMBUFZ(KWIDRE+5+KWIDIM) = 'i'
      IF (JFORMZ == 2) CMBUFZ(KWIDRE+5+KWIDIM) = 'I'
      LAST = KWIDRE + KWIDIM + 5

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          DO J = KWIDRE+3, LAST
             IF (CMBUFZ(J) == 'O' .OR. CMBUFZ(J) == 'U') THEN
                 CMBUFZ(J-2) = ' '
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (LAST <= LEN(STRING)) THEN
          DO J = 1, LAST
             STRING(J:J) = CMBUFZ(J)
          ENDDO
      ELSE
          DO J = 1, LAST
             STRING(J:J) = '*'
          ENDDO
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMFORM

      SUBROUTINE ZMFPCM(FORM,MA,KWI)

!  Internal routine to convert MA to base 10 using FORM format. The result is returned in CMBUFF and
!  the field width is KWI.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTEGER :: KWI
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KWD,KSAVE,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: KWI
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40
      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          KWI = MAX(1,KWI)
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 11
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid
!             showing no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(MWK(START(MA)+2))+1)*LOG10(DBLE(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
                      ALLOCATE(CMBUFF(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFF = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE
          GO TO 110
      ENDIF

      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN

!             Error condition.

  110 KFLAG = -8
      DO J = 1, KWI
         CMBUFF(J) = '*'
      ENDDO
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMFPCM

      SUBROUTINE ZMFPCZ(FORM,MA,KWI)

!  Internal routine to convert MA to base 10 using FORM format. The result is returned in CMBUFZ and
!  the field width is KWI.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTEGER :: KWI
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KWD,KSAVE,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: KWI
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40
      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          KWI = MAX(1,KWI)
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 11
          IF (KWD+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFZ,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFZ(J) = ' '
              ENDDO
              CMBUFZ(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFZ(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFZ(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFZ(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFZ(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFZ(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid
!             showing no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(MWK(START(MA)+2))+1)*LOG10(DBLE(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFZ) THEN
                      IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
                      ALLOCATE(CMBUFZ(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFZ = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFZ,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFZ(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFZ(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFZ(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWI)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWI)
      ELSE
          GO TO 110
      ENDIF

      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN

!             Error condition.

  110 KFLAG = -8
      DO J = 1, KWI
         CMBUFZ(J) = '*'
      ENDDO
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMFPCZ

      SUBROUTINE ZMFPRT(FORM1,FORM2,MA)

!  Print MA in base 10 using FORM1 format for the real part and FORM2 format for the imaginary part.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM1,FORM2
      INTEGER :: MA(2)

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KWIDIM,KWIDRE,LAST,LSIGN
      INTENT (IN) :: MA,FORM1,FORM2
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMFPRT'

      CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      CALL FMEQ(MA(2),MXY(1))
      IF (MWK(START(MXY(1))) >= 0) THEN
          LSIGN = 1
      ELSE
          LSIGN = -1
          IF (MWK(START(MXY(1))+2) /= MUNKNO .AND. MWK(START(MXY(1))+3) /= 0)  &
              MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      ENDIF
      CALL ZMFPCM(FORM2,MXY(1),KWIDIM)

      IF (KWIDRE+KWIDIM+50 > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(KWIDRE+KWIDIM+50),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = KWIDRE + KWIDIM + 50
          CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      ENDIF

      CMBUFZ(KWIDRE+1) = ' '
      IF (LSIGN == 1) THEN
          CMBUFZ(KWIDRE+2) = '+'
      ELSE
          CMBUFZ(KWIDRE+2) = '-'
      ENDIF
      CMBUFZ(KWIDRE+3) = ' '
      DO J = 1, KWIDIM
         CMBUFZ(KWIDRE+3+J) = CMBUFF(J)
      ENDDO
      CMBUFZ(KWIDRE+4+KWIDIM) = ' '
      CMBUFZ(KWIDRE+5+KWIDIM) = 'i'
      IF (JFORMZ == 2) CMBUFZ(KWIDRE+5+KWIDIM) = 'I'
      LAST = KWIDRE + KWIDIM + 5

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          DO J = KWIDRE+3, LAST
             IF (CMBUFZ(J) == 'O' .OR. CMBUFZ(J) == 'U') THEN
                 CMBUFZ(J-2) = ' '
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      WRITE (FORM,"(' (6X,',I3,'A1) ')") KSWIDE-7
      WRITE (KW,FORM) (CMBUFZ(K),K=1,LAST)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMFPRT

      SUBROUTINE ZMI2M(INTEG,MA)

!  MA = INTEG

!  The real part of MA is set to the one word integer value INTEG.
!  The imaginary part is set to zero.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: INTEG
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMI2M'
      IF (NTRACE /= 0) CALL ZMNTRI(2,INTEG,1)

      CALL FMI2M(INTEG,MA(1))
      CALL FMI2M(0,MA(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMI2M

      SUBROUTINE ZM2I2M(INTEG1,INTEG2,MA)

!  MA = INTEG1 + INTEG2 i

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: INTEG1,INTEG2
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG1,INTEG2
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZM2I2M'
      IF (NTRACE /= 0) THEN
          CALL ZMNTRI(2,INTEG1,1)
          CALL ZMNTRI(2,INTEG2,0)
      ENDIF

      CALL FMI2M(INTEG1,MA(1))
      CALL FMI2M(INTEG2,MA(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZM2I2M

      SUBROUTINE ZMIMAG(MA,MBFM)

!  MBFM = IMAG(MA)        imaginary part of MA

!  MA is a complex ZM number, MBFM is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMIMAG'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMEQ(MA(2),MBFM)

      IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMIMAG

      SUBROUTINE ZMINP(LINE,MA,LA,LB)

!  Convert an A1 character string to floating point multiple precision complex format.

!  LINE is an A1 character array of length LB to be converted to ZM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.  This allows more
!     than one number to be stored in an array and converted in place.
!  LB is a pointer to the last character of the field for that number.

!  The input numbers may be in integer or any real format.
!  In exponential format the 'E' may also be 'D', 'Q', or 'M'.

!  The following are all valid input strings:

!  1.23 + 4.56 I
!  1.23 + 4.56*I
!  2 + i
!  -i
!  1.23
!  4.56i
!  ( 1.23 , 4.56 )

!  So that ZMINP will convert any output from ZMOUT, LINE is tested to see if the input contains any
!  of the special symbols +OVERFLOW, -OVERFLOW, +UNDERFLOW, -UNDERFLOW, or UNKNOWN.
!  For user input the abbreviations OVFL, UNFL, UNKN may be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA(2)
      INTEGER :: J,JSTATE,K,KASAVE,KDIGFL,KFLAG1,KIFLAG,KPT,KRSAVE,KSIGN,KSTART,KSTOP,KSTOPI,  &
                 KSTOPR,KSTRTI,KSTRTR,KTYPE,KVAL,NDSAVE,NTRSAV

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States 2-8 refer to the real part, states 10-16 refer to the imaginary part.
!  States of the machine:

!   1.  Initial entry to the subroutine
!   2.  Sign of the number
!   3.  Scanning digits before a decimal point
!   4.  Decimal point
!   5.  Scanning digits after a decimal point
!   6.  E, D, Q, or M - precision indicator before the exponent
!   7.  Sign of the exponent
!   8.  Scanning exponent
!   9.  Comma between the real and imaginary part
!  10.  Sign of the number
!  11.  Scanning digits before a decimal point
!  12.  Decimal point
!  13.  Scanning digits after a decimal point
!  14.  E, D, Q, or M - precision indicator before the exponent
!  15.  Sign of the exponent
!  16.  Scanning exponent
!  17.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (E,D,Q,M)
!  5.  Illegal character for number
!  6.  Comma (,)
!  7.  Character to be ignored   ' '    '('    ')'    '*'

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state JSTATE and a character of type JTYPE is encountered the new state of the
!  machine is given by JTRANS(JSTATE,JTYPE).

!  State  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16

      INTEGER :: JTRANS(16,4) = RESHAPE(  (/                                  &
          2, 17, 10, 10, 10,  7, 17, 10, 10, 17, 17, 17, 17, 15, 17, 17,      &
          3,  3,  3,  5,  5,  8,  8,  8, 11, 11, 11, 13, 13, 16, 16, 16,      &
          4,  4,  4, 17, 17, 17, 17, 17, 12, 12, 12, 17, 17, 17, 17, 17,      &
          6,  6,  6,  6,  6,  8, 17, 17, 14, 14, 14, 14, 14, 16, 17, 17   /)  &
        , (/ 16,4 /) )
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA(1) <= 0) THEN
          CALL FMDEFINE(MA(1))
      ELSE IF (SIZE_OF(MA(1)) < NDIG+3) THEN
          CALL FMDEFINE(MA(1))
      ENDIF
      IF (MA(2) <= 0) THEN
          CALL FMDEFINE(MA(2))
      ELSE IF (SIZE_OF(MA(2)) < NDIG+3) THEN
          CALL FMDEFINE(MA(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMINP'
      NDSAVE = NDIG
      KASAVE = KACCSW
      KRSAVE = KROUND
      KROUND = 1
      KFLAG = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Since arithmetic tracing is not usually desired during I/O conversion, disable
!             tracing during this routine.

      NTRSAV = NTRACE
      NTRACE = 0

!             Increase the working precision.

      IF (NCALL <= 2) THEN
          K = NGRD52
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KSTART = LA
      KSTOP = LB
      JSTATE = 1
      KSTRTR = 0
      KSTOPR = 0
      KSTRTI = 0
      KSTOPI = 0
      KDIGFL = 0
      KIFLAG = 0
      KSIGN = 1

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == ' ' .OR. LINE(J) == '(' .OR. LINE(J) == ')'  &
             .OR. LINE(J) == '*') CYCLE
         IF (LINE(J) == 'I' .OR. LINE(J) == 'i') THEN
             KIFLAG = 1
             IF (KSTRTI == 0) THEN
                 KSTRTI = KSTRTR
                 KSTOPI = KSTOPR
                 KSTRTR = 0
                 KSTOPR = 0
             ENDIF
             CYCLE
         ENDIF

         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF
         IF (KTYPE == 2 .OR. KTYPE == 5) KDIGFL = 1
         IF (LINE(J) == ',') THEN
             IF (JSTATE < 9) THEN
                 JSTATE = 9
             ELSE
                 GO TO 110
             ENDIF
         ELSE
             IF (KTYPE >= 5) KTYPE = 2
             IF (JSTATE < 17) JSTATE = JTRANS(JSTATE,KTYPE)
         ENDIF
         IF (JSTATE == 9 .OR. JSTATE == 10) KDIGFL = 0
         IF (JSTATE == 2 .OR. JSTATE == 10) KSIGN = KVAL

         IF (JSTATE >= 2 .AND. JSTATE <= 8) THEN
             IF (KSTRTR == 0) KSTRTR = J
             KSTOPR = J
         ENDIF
         IF (JSTATE >= 10 .AND. JSTATE <= 16) THEN
             IF (KSTRTI == 0) KSTRTI = J
             KSTOPI = J
         ENDIF

      ENDDO

!             Form the number and return.

      IF (KSTRTR > 0) THEN
          NCALL = NCALL - 1
          CALL FMINP(LINE,MXY(1),KSTRTR,KSTOPR)
          NCALL = NCALL + 1
      ELSE
          CALL FMIM(0,MXY(1))
      ENDIF
      KFLAG1 = KFLAG

      IF (KSTRTI > 0) THEN
          IF (KIFLAG == 1 .AND. KDIGFL == 0) THEN
              CALL FMIM(KSIGN,MXY(2))
          ELSE
              NCALL = NCALL - 1
              CALL FMINP(LINE,MXY(2),KSTRTI,KSTOPI)
              NCALL = NCALL + 1
          ENDIF
      ELSE IF (KIFLAG == 1) THEN
          CALL FMIM(1,MXY(2))
      ELSE
          CALL FMIM(0,MXY(2))
      ENDIF

      IF (KFLAG1 /= 0 .OR. KFLAG /= 0 .OR. JSTATE == 17) GO TO 110
      CALL FMEQU(MXY(1),MA(1),NDIG,NDSAVE)
      CALL FMEQU(MXY(2),MA(2),NDIG,NDSAVE)
      GO TO 120

!             Error in converting the number.

  110 KFLAG = -7
      CALL ZMWARN
      MWK(START(MA(1))) = 1
      MWK(START(MA(1))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA(1))+2) = MUNKNO
      MWK(START(MA(1))+3) = 1
      MWK(START(MA(2))) = 1
      MWK(START(MA(2))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA(2))+2) = MUNKNO
      MWK(START(MA(2))+3) = 1
      DO J = 2, NDSAVE
         MWK(START(MA(1))+J+2) = 0
         MWK(START(MA(2))+J+2) = 0
      ENDDO

  120 NDIG = NDSAVE
      KACCSW = KASAVE
      NTRACE = NTRSAV
      KROUND = KRSAVE
      IF (KFLAG /= -7) KFLAG = 0
      MWK(START(MA(1))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA(2))+1) = MWK(START(MA(1))+1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMINP

      SUBROUTINE ZMINT(MA,MB)

!  MB = INT(MA)

!  The integer parts of both real and imaginary values are returned.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMINT'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMINT(MA(1),MB(1))
      CALL FMINT(MA(2),MB(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMINT

      SUBROUTINE ZMIPWR(MA,IVAL,MB)

!  MB = MA ** IVAL

!  Raise a ZM number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * LOG2(IVAL) multiplications.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: IVAL
      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MA2,MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: I2N,J,K,KASAVE,KL,KOVUN,KR_RETRY,KWRNSV,LVLSAV,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMIPWR'
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          CALL ZMNTR(2,MA,MA,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KOVUN = 0
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(1))+2) == MEXPUN .OR.  &
          MWK(START(MA(2))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPUN) KOVUN = 1

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      KASAVE = KACCSW
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Check for special cases.

      IF (MWK(START(MA(1))+2) == MUNKNO .OR. MWK(START(MA(2))+2) == MUNKNO .OR.  &
          (IVAL <= 0 .AND. MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0)) THEN
          MA2 = MWK(START(MA(1))+3)
          KFLAG = -4
          IF (IVAL <= 0 .AND. MA2 == 0) CALL ZMWARN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL ZMI2M(1,MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA(2))+3) == 0) THEN
          NCALL = NCALL - 1
          LVLSAV = LVLTRC
          LVLTRC = LVLTRC - 1
          CALL FMIPWR(MA(1),IVAL,MB(1))
          CALL FMIM(0,MB(2))
          NCALL = NCALL + 1
          LVLTRC = LVLSAV
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMIPWR'
              CALL ZMNTR(1,MB,MB,1)
          ENDIF
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA(1))+3) == 0) THEN
          NCALL = NCALL - 1
          LVLSAV = LVLTRC
          LVLTRC = LVLTRC - 1
          IF (IVAL >= 0) THEN
              I2N = MOD(IVAL,4)
          ELSE
              I2N = MOD(4 - MOD(ABS(IVAL),4),4)
          ENDIF
          IF (I2N == 0) THEN
              CALL FMIPWR(MA(2),IVAL,MB(1))
              CALL FMIM(0,MB(2))
          ELSE IF (I2N == 1) THEN
              CALL FMIPWR(MA(2),IVAL,MB(2))
              CALL FMIM(0,MB(1))
          ELSE IF (I2N == 2) THEN
              CALL FMIPWR(MA(2),IVAL,MB(1))
              CALL FMIM(0,MB(2))
              IF (MWK(START(MB(1))+2) /= MUNKNO .AND. MWK(START(MB(1))+3) /= 0)  &
                  MWK(START(MB(1))) = -MWK(START(MB(1)))
          ELSE IF (I2N == 3) THEN
              CALL FMIPWR(MA(2),IVAL,MB(2))
              CALL FMIM(0,MB(1))
              IF (MWK(START(MB(2))+2) /= MUNKNO .AND. MWK(START(MB(2))+3) /= 0)  &
                  MWK(START(MB(2))) = -MWK(START(MB(2)))
          ENDIF
          NCALL = NCALL + 1
          LVLTRC = LVLSAV
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMIPWR'
              CALL ZMNTR(1,MB,MB,1)
          ENDIF
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(2*NDIG,2*NDSAVE+10)
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          KWRNSV = KWARN
          KWARN = 0
          IF (IVAL == 1) THEN
              CALL ZMEQ(MA,MZ05)
          ELSE
              K = INT((5.0D0*DLOGTN)/DLOGMB + 2.0D0)
              NDIG = MAX(NDIG+K,2)
              CALL ZMI2M(1,MZ02)
              CALL ZMEQU(MA,MZ03,NDSAVE,NDIG)
              CALL ZMDIV(MZ02,MZ03,MZ05)
          ENDIF
          KWARN = KWRNSV
          GO TO 130
      ENDIF

!             Increase the working precision.

      IF (NCALL == 1) THEN
          XVAL = ABS(IVAL) + 1
          K = INT((5.0*REAL(DLOGTN) + 2.5*LOG(XVAL))/ALOGMB + 3.0)
          IF (MBASE <= 1000) K = 2*K
          NDIG = MAX(NDIG+K,2)
      ELSE
          XVAL = ABS(IVAL) + 1
          K = INT(LOG(XVAL)/ALOGMB + 1.0)
          NDIG = NDIG + K
      ENDIF

!             Initialize.

      KWRNSV = KWARN
      KWARN = 0
      K = ABS(IVAL)

      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

      IF (MOD(K,2) == 0) THEN
          CALL ZMI2M(1,MZ05)
      ELSE
          CALL ZMEQ(MZ02,MZ05)
      ENDIF

!             This is the multiplication loop.

  120 K = K/2
      CALL ZMSQR(MZ02,MZ04)
      CALL ZMEQ(MZ04,MZ02)
      IF (MOD(K,2) == 1) THEN
          CALL ZMMPY(MZ02,MZ05,MZ04)
          CALL ZMEQ(MZ04,MZ05)
      ENDIF
      IF (K > 1) GO TO 120

!             Invert if the exponent is negative.

      IF (IVAL < 0) THEN
          CALL ZMI2M(1,MZ02)
          CALL ZMDIV(MZ02,MZ05,MZ04)
          CALL ZMEQ(MZ04,MZ05)
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

  130 MACCMB = MWK(START(MZ05(1))+1)
      MWK(START(MZ05(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ05(2))+1)
      MWK(START(MZ05(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ05,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMIPWR

      SUBROUTINE ZMLG10(MA,MB)

!  MB = LOG10(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),MZ03(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMLG10   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ03,NDSAVE,NDIG)
      CALL ZMLN(MZ03,MZ02)
      CALL FMLNI(10,MXY(1))
      CALL FMDIVD(MZ02(1),MZ02(2),MXY(1),MZ01(1),MZ01(2))

      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMLG10

      SUBROUTINE ZMLN(MA,MB)

!  MB = LN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KF1,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMLN     ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          KFLAG = -4
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          IF (MWK(START(MA(1))) < 0) THEN
              CALL FMEQ(MZ02(1),MZ01(1))
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
              CALL FMLN(MZ01(1),MXY(4))
              CALL FMEQ(MXY(4),MZ01(1))
              CALL FMPI(MZ01(2))
          ELSE
              CALL FMLN(MZ02(1),MZ01(1))
              CALL FMI2M(0,MZ01(2))
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          IF (MWK(START(MA(2))) < 0) THEN
              CALL FMEQ(MZ02(2),MZ01(1))
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
              CALL FMLN(MZ01(1),MXY(4))
              CALL FMEQ(MXY(4),MZ01(1))
              CALL FMPI(MZ01(2))
              CALL FMDIVI_R1(MZ01(2),-2)
          ELSE
              CALL FMLN(MZ02(2),MZ01(1))
              CALL FMPI(MZ01(2))
              CALL FMDIVI_R1(MZ01(2),2)
          ENDIF
          GO TO 120
      ENDIF

!             Ln(a + b i) = Ln(Abs(a + b i)) + Arg(a + b i) i.

      CALL FMABS(MZ02(1),MXY(1))
      CALL FMABS(MZ02(2),MXY(2))

!             Check for cancellation in Ln(x).

      CALL FMI2M(1,MXY(3))
      KF1 = 0
      IF (FMCOMP(MXY(1),'==',MXY(3)) .AND. MWK(START(MXY(2))+2) <= (-NDIG)) KF1 = 1
      IF (FMCOMP(MXY(2),'==',MXY(3)) .AND. MWK(START(MXY(1))+2) <= (-NDIG)) KF1 = 1

      IF (FMCOMP(MXY(1),'>=',MXY(2))) THEN
          CALL FMSUB(MZ02(1),MXY(3),MXY(1))
          CALL FMADD(MZ02(1),MXY(3),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))
          CALL FMSQR(MZ02(2),MXY(2))
          CALL FMADD_R2(MXY(1),MXY(2))
      ELSE
          CALL FMSUB(MZ02(2),MXY(3),MXY(1))
          CALL FMADD(MZ02(2),MXY(3),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))
          CALL FMSQR(MZ02(1),MXY(2))
          CALL FMADD_R2(MXY(1),MXY(2))
      ENDIF
      CALL ZMABS(MZ02,MZ01(1))
      CALL FMADD(MZ01(1),MXY(3),MXY(1))
      CALL FMDIV_R2(MXY(2),MXY(1))
      IF (KF1 == 1) THEN
          CALL FMEQ(MXY(1),MZ01(1))
          CALL FMATN2(MZ02(2),MZ02(1),MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
          NDIG = NDIG - INT(MWK(START(MXY(1))+2))
          CALL ZMEQU_R1(MZ02,NDSAVE,NDIG)
          CALL ZMABS(MZ02,MZ01(1))
      ENDIF

      CALL FMLN(MZ01(1),MXY(4))
      CALL FMEQ(MXY(4),MZ01(1))
      CALL FMATN2(MZ02(2),MZ02(1),MZ01(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMLN

      SUBROUTINE ZMM2I(MA,INTEG)

!  INTEG = MA

!  INTEG is set to the integer value of the real part of MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA
      INTENT (INOUT) :: INTEG

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMM2I'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMM2I(MA(1),INTEG)

      IF (NTRACE /= 0) CALL ZMNTRI(1,INTEG,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMM2I

      SUBROUTINE ZMM2Z(MA,ZVAL)

!  ZVAL = MA

!  Complex variable ZVAL is set to MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      COMPLEX :: ZVAL

      REAL :: DI,DR
      INTENT (IN) :: MA
      INTENT (INOUT) :: ZVAL

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMM2Z'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMM2SP(MA(1),DR)
      CALL FMM2SP(MA(2),DI)
      ZVAL = CMPLX(DR,DI)

      IF (NTRACE /= 0) CALL ZMNTRZ(1,ZVAL,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMM2Z

      SUBROUTINE ZMMPY(MA,MB,MC)

!  MC = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MBIZ,MBRZ,MXSAVE,MZ11SV
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KMETHD,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NGOAL,NTRSAV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(7),MZ01(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMMPY    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMMPY'
              CALL ZMNTR(2,MA,MB,2)
          ENDIF
          NDSAVE = NDIG
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR. MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
              NDIG = NDIG + 1
          ELSE IF (MBASE >= 100*ABS(MWK(START(MB(1))+3)) .OR.  &
              MBASE >= 100*ABS(MWK(START(MB(2))+3))) THEN
              NDIG = NDIG + 1
          ENDIF
          KASAVE = KACCSW
          KACCSW = 1
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      MARZ = MWK(START(MA(1))+1)
      MBRZ = MWK(START(MB(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      MBIZ = MWK(START(MB(2))+1)
      KR_RETRY = 0
      MZ11SV = -MUNKNO
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA(1),MXY(4),NDSAVE,NDIG)
      CALL FMEQU(MA(2),MXY(5),NDSAVE,NDIG)
      CALL FMEQU(MB(1),MXY(6),NDSAVE,NDIG)
      CALL FMEQU(MB(2),MXY(7),NDSAVE,NDIG)
      MWK(START(MXY(4))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(6))+1) = MWK(START(MXY(4))+1)
      MWK(START(MXY(5))+1) = MWK(START(MXY(4))+1)
      MWK(START(MXY(7))+1) = MWK(START(MXY(4))+1)

!             Check for special cases.

      KMETHD = 1

!             If precision is low or a retry is being done due to cancellation,
!             use a slower but more stable form of the multiplication formula.

      IF (NDIG >= 35 .AND. MZ11SV == -MUNKNO) KMETHD = 2

      IF (MWK(START(MB(2))+3) == 0) THEN
          CALL FMMPYD(MXY(6),MXY(4),MXY(5),MZ01(1),MZ01(2))
      ELSE IF (MWK(START(MB(1))+3) == 0) THEN
          CALL FMMPYD(MXY(7),MXY(5),MXY(4),MZ01(1),MZ01(2))
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMMPYD(MXY(4),MXY(6),MXY(7),MZ01(1),MZ01(2))
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMMPYD(MXY(5),MXY(7),MXY(6),MZ01(1),MZ01(2))
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ELSE IF (KMETHD == 1) THEN

!             Method 1 for  ( a + b i ) * ( c + d i )

!             result = a*c - b*d + ( a*d + b*c ) i

          KACCSW = 0
          CALL FMMPYD(MXY(4),MXY(6),MXY(7),MZ01(1),MZ01(2))
          CALL FMMPYD(MXY(5),MXY(7),MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MZ01(1)))*MWK(START(MXY(1))) < 0) THEN
              KACCSW = 0
          ELSE
              KACCSW = 1
          ENDIF
          CALL FMSUB_R1(MZ01(1),MXY(1))
          IF (MWK(START(MZ01(2)))*MWK(START(MXY(2))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R1(MZ01(2),MXY(2))
          KACCSW = 1
      ELSE

!             Method 2 for  ( a + b i ) * ( c + d i )

!             P = ( a + b )*( c + d )
!             result = a*c - b*d + ( P - a*c - b*d ) i

          CALL FMADD(MXY(4),MXY(5),MXY(1))
          CALL FMADD(MXY(6),MXY(7),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))

          CALL FMMPY(MXY(4),MXY(6),MXY(2))
          CALL FMMPY(MXY(5),MXY(7),MXY(3))

          CALL FMSUB(MXY(2),MXY(3),MZ01(1))
          CALL FMSUB(MXY(1),MXY(2),MZ01(2))
          CALL FMSUB_R1(MZ01(2),MXY(3))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(1))+1) > NGOAL .AND.  &
              MWK(START(MZ01(2))+3) == 0) GO TO 120
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(2))+1) > NGOAL .AND.  &
              MWK(START(MZ01(1))+3) == 0) GO TO 120
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          MZ11SV = MWK(START(MZ01(1))+2)
          GO TO 110
      ENDIF

  120 MXEXP = MXSAVE
      NTRACE = NTRSAV
      NDGSV2 = NDIG
      NDIG = NDSAVE
      KWARN = KWRNSV
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      CALL ZMEQU(MZ01,MC,NDGSV2,NDSAVE)
      IF (MWK(START(MC(1))+2) >= MEXPOV .OR. MWK(START(MC(1))+2) <= -MEXPOV .OR.  &
          MWK(START(MC(2))+2) >= MEXPOV .OR. MWK(START(MC(2))+2) <= -MEXPOV) THEN
          IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
              KFLAG = -4
          ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
              KFLAG = -5
          ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
              KFLAG = -6
          ENDIF
          IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
             .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
              NAMEST(NCALL) = 'ZMMPY'
              CALL ZMWARN
          ENDIF
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMMPY

      SUBROUTINE ZMMPYI(MA,INTEG,MB)

!  MB = MA * INTEG        Multiply by one-word (real) integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'ZMMPYI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
              NCALL = NCALL - 1
          ENDIF
          NTRACE = 0
          CALL ZMENTR('ZMMPYI   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
              NCALL = NCALL - 1
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NTRSAV = NTRACE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMMPYI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMMPYI to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMMPYI(MA(1),INTEG,MB(1))
      CALL FMMPYI(MA(2),INTEG,MB(2))

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMMPYI'
      IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMMPYI'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMMPYI

      SUBROUTINE ZMNINT(MA,MB)

!  MB = NINT(MA)

!  The nearest integers to both real and imaginary parts are returned.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMNINT'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMNINT(MA(1),MB(1))
      CALL FMNINT(MA(2),MB(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMNINT

      SUBROUTINE ZMNTR(NTR,MA,MB,NARG)

!  Print ZM numbers in base 10 format using ZMOUT for conversion.
!  This is used for trace output from the ZM routines.

!  NTR =  1 if a result of an ZM call is to be printed.
!      =  2 to print input argument(s) to an ZM call.

!  MA  -  the ZM number to be printed.

!  MB  -  an optional second ZM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be
!         printed, and NARG = 2 if both MA and MB are to be printed.


!  NTRACE and LVLTRC (in module FMVALS) control trace printout.

!  NTRACE = 0        No printout except warnings and errors.

!  NTRACE = 1        The result of each call to one of the routines
!                    is printed in base 10, using ZMOUT.

!  NTRACE = -1       The result of each call to one of the routines
!                    is printed in internal base MBASE format.

!  NTRACE = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using ZMOUT.

!  NTRACE = -2       The input arguments and result of each call to one
!                    of the routines is printed in base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = K prints traces for ZM or FM routines
!         with call levels up to and including level K.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: NTR,NARG
      CHARACTER(9) :: NAME
      INTENT (IN) :: MA,MB

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (NTRACE < 0) THEN
          CALL ZMNTRJ(MA,NDIG)
          IF (NARG == 2) CALL ZMNTRJ(MB,NDIG)
      ENDIF

!             Check for base 10 trace using ZMOUT.

      IF (NTRACE > 0) THEN
          CALL ZMPRNT(MA)

          IF (NARG == 2) THEN
              CALL ZMPRNT(MB)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE ZMNTR

      SUBROUTINE ZMNTR2(NTR,MAFM,MBFM,NARG)

!  Print real FM numbers in base 10 format using FMOUT for conversion.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MAFM,MBFM
      INTEGER :: NTR,NARG

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MAFM,MBFM,NARG

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (NTRACE < 0) THEN
          CALL FMNTRJ(MAFM,NDIG)
          IF (NARG == 2) CALL FMNTRJ(MBFM,NDIG)
      ENDIF

!             Check for base 10 trace using FMOUT.

      IF (NTRACE > 0) THEN
          CALL FMPRNT(MAFM)

          IF (NARG == 2) THEN
              CALL FMPRNT(MBFM)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE ZMNTR2

      SUBROUTINE ZMNTRI(NTR,N,KNAM)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I20)") N

      RETURN
      END SUBROUTINE ZMNTRI

      SUBROUTINE ZMNTRJ(MA,ND)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: ND

      CHARACTER(99) :: FORM
      CHARACTER(40), EXTERNAL :: FMFI
      CHARACTER(40) :: ST1,ST2,ST3
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(MBASE-1))) + 2
      N = (KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,                                  &
                 "(' (1X,I19,I',I2,',',I3,'I',I2,"  //  &
                 "'/(22X,',I3,'I',I2,')) ')"            &
                ) L+2, N-1, L, N, L
      ENDIF
      ST1 = FMFI(INT(MWK(START(MA(1)))))
      ST2 = FMFI(INT(MWK(START(MA(1))+1)))
      ST3 = FMFI(INT(MWK(START(MA(1))+2)))
      WRITE (KW,"(A,A,A,A,A,A,A)") '            Sign = ',TRIM(ST1),'   Accuracy = ',  &
                 TRIM(ST2),'   Exponent = ',TRIM(ST3),'   Digits of real part:'
      WRITE (FORM,*) '(13X,', N, 'I', L, ')'
      WRITE (KW,FORM) (INT(MWK(START(MA(1))+J)),J=3,ND+2)

      ST1 = FMFI(INT(MWK(START(MA(2)))))
      ST2 = FMFI(INT(MWK(START(MA(2))+1)))
      ST3 = FMFI(INT(MWK(START(MA(2))+2)))
      WRITE (KW,"(A,A,A,A,A,A,A)") '            Sign = ',TRIM(ST1),'   Accuracy = ',  &
                 TRIM(ST2),'   Exponent = ',TRIM(ST3),'   Digits of imaginary part:'
      WRITE (KW,FORM) (INT(MWK(START(MA(2))+J)),J=3,ND+2)

      RETURN
      END SUBROUTINE ZMNTRJ

      SUBROUTINE ZMNTRZ(NTR,X,KNAM)

!  Internal routine for trace output of complex variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Complex value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      COMPLEX :: X

      CHARACTER(9) :: NAME
      DOUBLE PRECISION :: XREAL,XIMAG
      INTENT (IN) :: NTR,X,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      XREAL = DBLE(X)
      XIMAG = DBLE(AIMAG(X))
      IF (XIMAG >= 0.0D0) THEN
          WRITE (KW,"(1X,D30.20,' +',D30.20,' i')") XREAL,XIMAG
      ELSE
          WRITE (KW,"(1X,D30.20,' -',D30.20,' i')") XREAL,ABS(XIMAG)
      ENDIF

      RETURN
      END SUBROUTINE ZMNTRZ

      SUBROUTINE ZMOUT(MA,LINE,LB,LAST1,LAST2)

!  Convert a floating multiple precision number to a character array for output.

!  MA    is an ZM number to be converted to an A1 character array in base 10 format
!  LINE  is the character(1) array in which the result is returned.
!  LB    is the length of LINE.
!  LAST1 is returned as the position of the last nonblank character of the real part of the
!        number in LINE.
!  LAST2 is returned as the position of the last nonblank character of the imaginary part of
!        the number in LINE.

!  JFORM1 and JFORM2 determine the format of the two FM numbers making up the complex value MA.
!  See FMOUT for details.

!  JFORMZ determines the format of the real and imaginary parts.

!  JFORMZ = 1  normal setting :       1.23 - 4.56 i
!         = 2  use capital I  :       1.23 - 4.56 I
!         = 3  parenthesis format   ( 1.23 , -4.56 )

!  LINE should be dimensioned at least 4*(LOG10(MBASE)*NDIG + 15) on a 32-bit machine to allow
!  for up to 10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit
!  integers, etc.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: LB,LAST1,LAST2
      CHARACTER :: LINE(LB)

      REAL (KIND(1.0D0)) :: MAIMS
      INTEGER :: J,KPT,LB2,ND,NEXP
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE,LAST1,LAST2
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMOUT'
      DO J = 1, LB
         LINE(J) = ' '
      ENDDO
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      KPT = 1
      IF (JFORMZ == 3) KPT = 3
      LB2 = MAX(JFORM2+NEXP,ND+NEXP)
      LB2 = MIN(LB+1-KPT,LB2)
      CALL FMOUT(MA(1),LINE(KPT),LB2)

      IF (JFORMZ == 3) LINE(1) = '('
      LAST1 = 1
      DO J = LB2, 1, -1
         IF (LINE(J) /= ' ') THEN
             LAST1 = J
             GO TO 110
         ENDIF
      ENDDO

  110 MAIMS = MWK(START(MA(2)))
      CALL FMDEFINE(MXY(1))
      DO J = -1, NDIG+1
         MWK(START(MXY(1))+J+1) = MWK(START(MA(2))+J+1)
      ENDDO
      LINE(LAST1+1) = ' '
      IF (JFORMZ == 3) THEN
          LINE(LAST1+2) = ','
      ELSE
          IF (MAIMS < 0) THEN
              MWK(START(MXY(1))) = 1
              LINE(LAST1+2) = '-'
          ELSE
              LINE(LAST1+2) = '+'
          ENDIF
      ENDIF

      KPT = LAST1 + 3
      LB2 = MAX(JFORM2+NEXP,ND+NEXP)
      LB2 = MIN(LB+1-KPT,LB2+2)
      CALL FMOUT(MXY(1),LINE(KPT),LB2)
      LAST1 = KPT
      DO J = LB2+KPT-1, KPT, -1
         IF (LINE(J) /= ' ') THEN
             LAST2 = J
             GO TO 120
         ENDIF
      ENDDO

  120 LAST2 = LAST2 + 2
      LINE(LAST2) = 'i'
      IF (JFORMZ == 2) LINE(LAST2) = 'I'
      IF (JFORMZ == 3) LINE(LAST2) = ')'

      IF (LINE(KPT) == ' ' .AND. LINE(KPT+1) == '+') THEN
          DO J = KPT+2, LAST2
             LINE(J-2) = LINE(J)
          ENDDO
          LINE(LAST2-1) = ' '
          LINE(LAST2) = ' '
          LAST2 = LAST2 - 2
      ENDIF

      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMOUT

      SUBROUTINE ZMPACK(MA,MP)

!  MA is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MP(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MP
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMPACK(MA(1),MP(1))
      CALL FMPACK(MA(2),MP(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP(1)) == -1) TEMPV(MP(1)) = -2
          IF (TEMPV(MP(2)) == -1) TEMPV(MP(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMPACK

      SUBROUTINE ZMPRNT(MA)

!  Print MA in base 10 format.

!  ZMPRNT can be called directly by the user for easy output in M format.
!  MA is converted using ZMOUT and printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KSAVE,LAST1,LAST2,LB,LBZ,ND,NEXP
      INTENT (IN) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = MAX(JFORM2+NEXP,ND+NEXP)

      IF (JPRNTZ == 1) THEN
          LBZ = 2*LB + 7
          IF (LBZ > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(LBZ),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = LBZ
          ENDIF
          CALL ZMOUT(MA,CMBUFZ,LBZ,LAST1,LAST2)
          WRITE (FORM,"(' (6X,',I3,'A1) ')") KSWIDE-7
          WRITE (KW,FORM) (CMBUFZ(K),K=1,LAST2)
      ELSE
          CALL FMPRNT(MA(1))
          CALL FMPRNT(MA(2))
      ENDIF
      KFLAG = KSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMPRNT

      SUBROUTINE ZMPWR(MA,MB,MC)

!  MC = MA ** MB.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)

      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MBIZ,MBRZ,MXSAVE,MTEMP
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTMB,J,JSIN,JCOS,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRADSV,  &
                 KRESLT,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: XVAL
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),MZ06(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      MZ06 = -2
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMPWR    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
              IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MBRZ = MWK(START(MB(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      MBIZ = MWK(START(MB(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      K = MAX(MWK(START(MB(1))+2),MWK(START(MB(2))+2))
      IF (K < 25000) THEN
          NDIG = NDIG + MAX(K,0) + 1
      ELSE
          NDIG = NDIG + 1
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)
      CALL ZMEQU(MB,MZ05,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          IF (MWK(START(MB(1))) > 0 .AND. MWK(START(MB(2))+3) == 0) THEN
              CALL ZMI2M(0,MZ02)
              GO TO 130
          ELSE
              KFLAG = -4
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ02)
              GO TO 130
          ENDIF
      ENDIF
      IF (MWK(START(MB(2))+3) == 0) THEN
          KWRNSV = KWARN
          KWARN = 0
          CALL FMMI(MZ05(1),INTMB)
          KWARN = KWRNSV
          IF (KFLAG == 0) THEN
              IF (NCALL == 1) THEN
                  XVAL = ABS(INTMB) + 1
                  K = INT((1.5*LOG(XVAL))/ALOGMB + 2.0)
                  NDIG = MAX(NDIG+K,2)
                  IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
                      MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
                      NDIG = NDIG + 1
                  ENDIF
              ENDIF
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMIPWR(MZ04,INTMB,MZ03)
              CALL ZMEQ(MZ03,MZ02)
              GO TO 120
          ENDIF
      ENDIF

!             Check for cases where ABS(MA) is very close to 1, and avoid cancellation.

      CALL FMABS(MZ04(1),MXY(1))
      CALL FMABS(MZ04(2),MXY(2))
      CALL FMI2M(1,MXY(3))
      IF (FMCOMP(MXY(1),'==',MXY(3)) .AND.  &
          (MWK(START(MXY(2))+2) <= (-NDIG).OR.MWK(START(MXY(2))+3) == 0)) THEN
          IF (MWK(START(MA(1))) > 0) THEN

!                 (1+c)**b = 1 + b*c + ...

              CALL ZMI2M(1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ06)
              CALL ZMMPY(MZ05,MZ06,MZ02)
              CALL FMADD_R1(MZ02(1),MXY(3))
          ELSE

!                 (-1+c)**b = (-1)**b * (1 - b*c + ... )

              CALL ZMI2M(-1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ01)
              CALL ZMMPY(MZ05,MZ01,MZ06)
              CALL ZMMPYI(MZ06,-1,MZ02)
              CALL FMADD_R1(MZ02(1),MXY(3))
              KRADSV = KRAD
              KRAD = 0
              IF (MWK(START(MA(2))) >= 0) THEN
                  CALL FMMPYI(MZ05(1),180,MXY(4))
              ELSE
                  CALL FMMPYI(MZ05(1),-180,MXY(4))
              ENDIF
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2))
              KRAD = KRADSV
              CALL FMPI(MXY(3))
              CALL FMMPY_R1(MXY(3),MZ05(2))
              IF (MWK(START(MA(2))) >= 0) CALL FMMPYI_R1(MXY(3),-1)
              CALL FMEXP(MXY(3),MXY(5))
              CALL FMEQ(MXY(5),MXY(3))
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2))
              CALL ZMMPY(MZ02,MZ06,MZ01)
              CALL ZMEQ(MZ01,MZ02)
          ENDIF
          GO TO 120
      ENDIF
      IF (FMCOMP(MXY(2),'==',MXY(3)) .AND.  &
          (MWK(START(MXY(1))+2) <= (-NDIG).OR.MWK(START(MXY(1))+3) == 0)) THEN
          IF (MWK(START(MA(2))) > 0) THEN

!                 (i+c)**b = i**b * (1 - b*c*i - ... )

              CALL ZM2I2M(0,1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ06)
              CALL ZMMPY(MZ05,MZ06,MZ02)
              DO J = -1, NDIG+1
                 MTEMP = MWK(START(MZ02(1))+J+1)
                 MWK(START(MZ02(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ02(2))+J+1) = MTEMP
              ENDDO
              IF (MWK(START(MZ02(2))+2) /= MUNKNO .AND. MWK(START(MZ02(2))+3) /= 0)  &
                  MWK(START(MZ02(2))) = -MWK(START(MZ02(2)))
              CALL FMADD_R1(MZ02(1),MXY(3))
              KRADSV = KRAD
              KRAD = 0
              CALL FMMPYI(MZ05(1),90,MXY(4))
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2))
              KRAD = KRADSV
              CALL FMPI(MXY(3))
              CALL FMMPY_R1(MXY(3),MZ05(2))
              CALL FMDIVI_R1(MXY(3),-2)
              CALL FMEXP(MXY(3),MXY(5))
              CALL FMEQ(MXY(5),MXY(3))
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2))
              CALL ZMMPY(MZ02,MZ06,MZ01)
              CALL ZMEQ(MZ01,MZ02)
          ELSE

!                 (-i+c)**b = (-i)**b * (1 + b*c*i - ... )

              CALL ZM2I2M(0,-1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ06)
              CALL ZMMPY(MZ05,MZ06,MZ02)
              DO J = -1, NDIG+1
                 MTEMP = MWK(START(MZ02(1))+J+1)
                 MWK(START(MZ02(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ02(2))+J+1) = MTEMP
              ENDDO
              IF (MWK(START(MZ02(1))+2) /= MUNKNO .AND. MWK(START(MZ02(1))+3) /= 0)  &
                  MWK(START(MZ02(1))) = -MWK(START(MZ02(1)))
              CALL FMADD_R1(MZ02(1),MXY(3))
              KRADSV = KRAD
              KRAD = 0
              CALL FMMPYI(MZ05(1),-90,MXY(4))
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2))
              KRAD = KRADSV
              CALL FMPI(MXY(3))
              CALL FMMPY_R1(MXY(3),MZ05(2))
              CALL FMDIVI_R1(MXY(3),2)
              CALL FMEXP(MXY(3),MXY(5))
              CALL FMEQ(MXY(5),MXY(3))
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2))
              CALL ZMMPY(MZ02,MZ06,MZ01)
              CALL ZMEQ(MZ01,MZ02)
          ENDIF
          GO TO 120
      ENDIF

      CALL ZMLN(MZ04,MZ06)
      CALL ZMMPY(MZ05,MZ06,MZ02)
      CALL FMEQ(MZ02(2),MZ01(1))
      IF (MWK(START(MZ01(1))+2) > 25000) THEN
          KFLAG = -4
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ02)
          GO TO 130
      ENDIF
      KWRNSV = KWARN
      KWARN = 0
      CALL FMRDC(MZ01(1),JSIN,JCOS,JSWAP)
      KWARN = KWRNSV
      IEXTRA = INT(MWK(START(MZ02(2))+2) - MWK(START(MZ01(1))+2))
      IF (NDIG >= NDSAVE+NGRD52+MAX(0,IEXTRA)) IEXTRA = 0
      IF (IEXTRA > 1) THEN
          NDIG = NDIG + IEXTRA
          CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
          CALL ZMEQU_R1(MZ05,NDSAVE,NDIG)
          CALL ZMLN(MZ04,MZ06)
          CALL ZMMPY(MZ05,MZ06,MZ02)
      ENDIF

      CALL ZMEXP(MZ02,MZ04)
      CALL ZMEQ(MZ04,MZ02)

  120 MACCMB = MWK(START(MZ02(1))+1)
      MWK(START(MZ02(1))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      MACCMB = MWK(START(MZ02(2))+1)
      MWK(START(MZ02(2))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ02(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ02(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
  130 CALL ZMEXIT(MZ02,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMPWR

      SUBROUTINE ZMREAD(KREAD,MA)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KREAD
      INTEGER :: MA(2)

      CHARACTER :: LINE(80)
      INTEGER :: J,K,L2,LB
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMREAD'
      LB = 0

  110 READ (KREAD,"(80A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 80
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFZ) THEN

!                If CMBUFZ runs out of space, try to re-allocate it with a bigger size.

                 IF (LMBUFZ > 0) THEN
                     ALLOCATE(MOVE_CMBUFF(LMBUFZ),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, LMBUFZ
                        MOVE_CMBUFF(K) = CMBUFZ(K)
                     ENDDO
                     DEALLOCATE(CMBUFZ)
                     L2 = MAX(10000,2*LMBUFZ)
                     ALLOCATE(CMBUFZ(L2),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, L2
                        CMBUFZ(K) = ' '
                     ENDDO
                     DO K = 1, LMBUFZ
                        CMBUFZ(K) = MOVE_CMBUFF(K)
                     ENDDO
                     DEALLOCATE(MOVE_CMBUFF)
                     LMBUFZ = L2
                 ELSE
                     ALLOCATE(CMBUFZ(10000),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     LMBUFZ = 10000
                 ENDIF
             ENDIF
             CMBUFZ(LB) = LINE(J)
          ENDIF
      ENDDO

      NCALL = NCALL - 1
      CALL ZMINP(CMBUFZ,MA,1,LB)

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 KFLAG = -4
      CALL ZMWARN
      CALL ZMST2M('UNKNOWN+UNKNOWN*i',MA)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMREAD

      SUBROUTINE ZMREAL(MA,MBFM)

!  MBFM = REAL(MA)

!  MA is a complex ZM number, MBFM is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMREAL'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMEQ(MA(1),MBFM)

      IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMREAL

      SUBROUTINE ZMRPWR(MA,IVAL,JVAL,MB)

!  MB = MA ** (IVAL/JVAL)

!  Raise a ZM number to a rational power.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      REAL (KIND(1.0D0)) :: MA2,MACCMB,MAIZ,MARZ,MR1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IJSIGN,INVERT,IVAL2,J,JVAL2,K,KASAVE,KL,KOVUN,KR_RETRY,KST,L,LVAL,NDSAVE
      REAL :: XVAL

      DOUBLE PRECISION :: AR,BR,F,THETA,X
      INTEGER :: NSTACK(49)
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),MZ03(2),MZ04(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMRPWR'
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          CALL ZMNTR(2,MA,MA,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMNTRI(2,JVAL,0)
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KOVUN = 0
      IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(1))+2) == MEXPUN .OR.  &
          MWK(START(MA(2))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPUN) KOVUN = 1

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      IJSIGN = 1
      IVAL2 = ABS(IVAL)
      JVAL2 = ABS(JVAL)
      IF (IVAL > 0 .AND. JVAL < 0) IJSIGN = -1
      IF (IVAL < 0 .AND. JVAL > 0) IJSIGN = -1
      IF (IVAL2 > 0 .AND. JVAL2 > 0) CALL FMGCDI(IVAL2,JVAL2)

!             Check for special cases.

      IF (MWK(START(MA(1))+2) == MUNKNO .OR. MWK(START(MA(2))+2) == MUNKNO .OR.             &
          (IJSIGN <= 0 .AND. MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) .OR.  &
          JVAL == 0) THEN
          MA2 = MWK(START(MA(1))+3)
          KFLAG = -4
          IF (IVAL <= 0 .AND. MA2 == 0) CALL ZMWARN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL ZMI2M(1,MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KASAVE = KACCSW
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Increase the working precision.

  110 IF (NCALL == 1) THEN
          XVAL = MAX(ABS(IVAL),ABS(JVAL)) + 1
          K = INT((5.0*REAL(DLOGTN) + LOG(XVAL))/ALOGMB + 2.0)
          NDIG = MAX(NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              NDIG = MAX(NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = MAX(ABS(IVAL),ABS(JVAL)) + 1
          K = INT(LOG(XVAL)/ALOGMB + 1.0)
          NDIG = NDIG + K
      ENDIF
      IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
          MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
          NDIG = NDIG + 1
      ENDIF

      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)
      IF (IVAL2 == 1 .AND. JVAL2 == 2) THEN
          CALL ZMSQRT(MZ02,MZ04)
          IF (IJSIGN < 0) THEN
              CALL ZMI2M(1,MZ01)
              CALL ZMDIV(MZ01,MZ04,MZ02)
              CALL ZMEQ(MZ02,MZ04)
          ENDIF
          GO TO 120
      ENDIF

!             Generate the first approximation to MA**(1/JVAL2).

      CALL ZMI2M(0,MZ04)
      CALL FMDIG(NSTACK,KST)
      NDIG = NSTACK(1)
      CALL FMSQR(MZ02(1),MZ01(1))
      CALL FMSQR(MZ02(2),MXY(1))
      CALL FMADD_R1(MZ01(1),MXY(1))
      CALL FMSQRT_R1(MZ01(1))
      IF (MWK(START(MZ01(1))+2) >= MEXPOV) THEN
          KFLAG = -4
          CALL ZMWARN
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Invert MA if ABS(MA) >= 1 and IVAL or JVAL is large.

      INVERT = 0
      IF (IVAL > 5 .OR. JVAL > 5) THEN
          IF (MWK(START(MZ01(1))+2) > 0 .AND. (MWK(START(MZ02(2))+3) /= 0 .OR.  &
              MWK(START(MZ02(1))) > 0)) THEN
              INVERT = 1
              NDIG = NSTACK(KST)
              CALL ZMI2M(1,MZ04)
              CALL ZMDIV(MZ04,MZ02,MZ03)
              CALL ZMEQ(MZ03,MZ02)
              NDIG = NSTACK(1)
              CALL FMDIV_R2(MZ04(1),MZ01(1))
          ENDIF
      ENDIF

      CALL FMDIV(MZ02(1),MZ01(1),MXY(1))
      IF (MWK(START(MXY(1))+2) == MUNKNO) THEN
          KFLAG = -4
          CALL ZMWARN
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      CALL FMM2DP(MXY(1),AR)
      CALL FMDIV(MZ02(2),MZ01(1),MXY(1))
      IF (MWK(START(MXY(1))+2) == MUNKNO) THEN
          KFLAG = -4
          CALL ZMWARN
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      CALL FMM2DP(MXY(1),BR)
      MR1 = MWK(START(MZ01(1))+2)
      MWK(START(MZ01(1))+2) = 0
      CALL FMM2DP(MZ01(1),X)
      L = INT(MR1/JVAL2)
      F = MR1/DBLE(JVAL2) - L
      X = X**(1.0D0/JVAL2) * DBLE(MBASE)**F
      CALL FMDPM(X,MXY(1))
      MWK(START(MXY(1))+2) = MWK(START(MXY(1))+2) + L

      THETA = ATAN2(BR,AR)
      X = COS(THETA/JVAL2)
      CALL FMDPM(X,MZ04(1))
      X = SIN(THETA/JVAL2)
      CALL FMDPM(X,MZ04(2))
      CALL FMMPY_R2(MXY(1),MZ04(1))
      CALL FMMPY_R2(MXY(1),MZ04(2))

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         IF (J < KST) NDIG = NDIG + 1
         LVAL = JVAL2 - 1
         CALL ZMIPWR(MZ04,LVAL,MZ01)
         CALL ZMDIV(MZ02,MZ01,MZ03)
         CALL ZMMPYI(MZ04,LVAL,MZ01)
         CALL ZMADD(MZ01,MZ03,MZ04)
         CALL ZMDIVI(MZ04,JVAL2,MZ03)
         CALL ZMEQ(MZ03,MZ04)
      ENDDO

      CALL ZMIPWR(MZ03,IJSIGN*IVAL2,MZ04)
      IF (INVERT == 1) THEN
          CALL ZMI2M(1,MZ01)
          CALL ZMDIV(MZ01,MZ04,MZ03)
          CALL ZMEQ(MZ03,MZ04)
      ENDIF

!             Round the result and return.

  120 MACCMB = MWK(START(MZ04(1))+1)
      MWK(START(MZ04(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ04(2))+1)
      MWK(START(MZ04(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ04(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ04(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ04,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KFLAG == 1) KFLAG = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMRPWR

      SUBROUTINE ZMRSLT(MC,KRESLT)

!  Handle results that are special cases, such as overflow, underflow, and unknown.

!  MC is the result that is returned

!  KRESLT is the result code.  Result codes handled here:

!   0 - Perform the normal operation
!  12 - The result is 'UNKNOWN'

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MC(2)
      INTEGER :: KRESLT

      INTEGER :: KFSAVE
      INTENT (IN) :: KRESLT
      INTENT (INOUT) :: MC

      KFSAVE = KFLAG

      IF (KRESLT == 12 .OR. KRESLT < 0 .OR. KRESLT > 15) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MC)
          KFLAG = KFSAVE
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE ZMRSLT

      SUBROUTINE ZMSIN(MA,MB)

!  MB = SIN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMSIN    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMSIN(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMSINH(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ENDIF

!             Find COS(REAL(MA)) and SIN(REAL(MA)).

      CALL FMCSSN(MZ02(1),MZ01(2),MZ01(1))

!             Find COSH(IMAG(MA)) and SINH(IMAG(MA)).

      CALL FMCHSH(MZ02(2),MXY(1),MXY(2))

!             SIN(MA) =  SIN(REAL(MA))*COSH(IMAG(MA)) + COS(REAL(MA))*SINH(IMAG(MA)) i

      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMABS(MZ02(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(5))
          CALL FMEXP(MXY(5),MXY(4))
          IF (MWK(START(MZ01(1))) < 0) CALL FMMPYI_R1(MXY(4),-1)

          CALL FMABS(MZ01(2),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMADD(MXY(2),MXY(3),MXY(1))
          CALL FMEXP(MXY(1),MXY(5))
          IF (MWK(START(MZ02(2))) < 0) CALL FMMPYI_R1(MXY(5),-1)
          IF (MWK(START(MZ01(2))) < 0) CALL FMMPYI_R1(MXY(5),-1)

          CALL FMEQ(MXY(4),MZ01(1))
          CALL FMEQ(MXY(5),MZ01(2))
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(1))
          CALL FMMPY_R1(MZ01(2),MXY(2))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSIN

      SUBROUTINE ZMSINH(MA,MB)

!  MB = SINH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMSINH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMSIN(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMSINH(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find SIN(IMAG(MA)) and COS(IMAG(MA)).

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2))

!             Find SINH(REAL(MA)) and COSH(REAL(MA)).

      CALL FMCHSH(MZ02(1),MXY(1),MXY(2))

!             SINH(MA) =  SINH(REAL(MA))*COS(IMAG(MA)) + COSH(REAL(MA))*SIN(IMAG(MA)) i

      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMABS(MZ02(1),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(5))
          CALL FMEXP(MXY(5),MXY(4))
          IF (MWK(START(MZ01(1))) < 0) CALL FMMPYI_R1(MXY(4),-1)
          IF (MWK(START(MZ02(1))) < 0) CALL FMMPYI_R1(MXY(4),-1)

          CALL FMABS(MZ01(2),MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMLN(MXY(1),MXY(2))
          CALL FMADD(MXY(2),MXY(3),MXY(1))
          CALL FMEXP(MXY(1),MXY(5))
          IF (MWK(START(MZ01(2))) < 0) CALL FMMPYI_R1(MXY(5),-1)

          CALL FMEQ(MXY(4),MZ01(1))
          CALL FMEQ(MXY(5),MZ01(2))
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(2))
          CALL FMMPY_R1(MZ01(2),MXY(1))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSINH

      SUBROUTINE ZMSQR(MA,MB)

!  MB = MA * MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSQR    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMSQR'
              CALL ZMNTR(2,MA,MA,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              NDIG = MAX(NDIG+NGRD52,2)
              IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
                  MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
                  NDIG = NDIG + 1
              ENDIF
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)
      IF (NCALL == 1) THEN
          MWK(START(MZ02(1))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MZ02(2))+1) = MWK(START(MZ02(1))+1)
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMSQR(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMSQR(MZ02(2),MZ01(1))
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
          CALL FMI2M(0,MZ01(2))
      ELSE
          CALL FMADD(MZ02(1),MZ02(2),MXY(1))
          CALL FMSUB(MZ02(1),MZ02(2),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MZ01(1))
          CALL FMMPY(MZ02(1),MZ02(2),MXY(2))
          CALL FMADD(MXY(2),MXY(2),MZ01(2))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      MXEXP = MXSAVE
      NTRACE = NTRSAV
      NDGSV2 = NDIG
      NDIG = NDSAVE
      KWARN = KWRNSV
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      KACCSW = KASAVE
      CALL ZMEQU(MZ01,MB,NDGSV2,NDSAVE)
      IF (MWK(START(MB(1))+2) >= MEXPOV .OR. MWK(START(MB(1))+2) <= -MEXPOV .OR.  &
          MWK(START(MB(2))+2) >= MEXPOV .OR. MWK(START(MB(2))+2) <= -MEXPOV) THEN
          IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
              KFLAG = -4
          ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
              KFLAG = -5
          ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
              KFLAG = -6
          ENDIF
          IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
             .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
             .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
              NAMEST(NCALL) = 'ZMSQR'
              CALL ZMWARN
          ENDIF
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSQR

      SUBROUTINE ZMSQRT(MA,MB)

!  MB = SQRT(MA).  Principal Square Root.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NTRSAV

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSQRT   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMSQRT'
              CALL ZMNTR(2,MA,MA,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              NDIG = MAX(NDIG+NGRD52,2)
              IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
                  MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
                  NDIG = NDIG + 1
              ENDIF
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      MXEXP1 = INT(MXEXP2/2.01D0)
      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMABS(MZ02(2),MXY(1))
          CALL FMDIVI(MXY(1),2,MXY(3))
          CALL FMSQRT_R1(MXY(3))
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMABS(MZ02(1),MXY(3))
          CALL FMSQRT_R1(MXY(3))
      ELSE IF (MWK(START(MA(1))+2) == MEXPUN) THEN
          IF (MWK(START(MA(2))+2) <= -MXEXP1+NDIG+1) THEN
              CALL ZMST2M('UNKNOWN + UNKNOWN i',MZ01)
              GO TO 120
          ENDIF
      ELSE IF (MWK(START(MA(2))+2) == MEXPUN) THEN
          IF (MWK(START(MA(1))+2) <= -MXEXP1+NDIG+1) THEN
              CALL ZMST2M('UNKNOWN + UNKNOWN i',MZ01)
              GO TO 120
          ENDIF
          CALL FMSQR(MZ02(1),MXY(1))
          CALL FMSQR(MZ02(2),MXY(2))
          CALL FMADD(MXY(1),MXY(2),MXY(3))
          CALL FMSQRT_R1(MXY(3))
          IF (MWK(START(MXY(3))+2) == MUNKNO) THEN
              CALL FMABS(MZ02(1),MXY(1))
              CALL FMABS(MZ02(2),MXY(2))
              CALL FMMAX(MXY(1),MXY(2),MZ01(1))
              CALL FMMIN(MXY(1),MXY(2),MZ01(2))
              CALL FMDIV(MZ01(2),MZ01(1),MXY(3))
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(3),MXY(2))
              CALL FMSQRT_R1(MXY(2))
              CALL FMMPY(MZ01(1),MXY(2),MXY(3))
          ENDIF
          CALL FMABS(MZ02(1),MXY(2))
          CALL FMADD_R2(MXY(2),MXY(3))
          CALL FMDIVI_R1(MXY(3),2)
          CALL FMSQRT_R1(MXY(3))
      ELSE
          CALL FMSQR(MZ02(1),MXY(1))
          CALL FMSQR(MZ02(2),MXY(2))
          CALL FMADD(MXY(1),MXY(2),MXY(3))
          CALL FMSQRT_R1(MXY(3))
          IF (MWK(START(MXY(3))+2) == MUNKNO) THEN
              CALL FMABS(MZ02(1),MXY(1))
              CALL FMABS(MZ02(2),MXY(2))
              CALL FMMAX(MXY(1),MXY(2),MZ01(1))
              CALL FMMIN(MXY(1),MXY(2),MZ01(2))
              CALL FMDIV(MZ01(2),MZ01(1),MXY(3))
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(3),MXY(2))
              CALL FMSQRT_R1(MXY(2))
              CALL FMMPY(MZ01(1),MXY(2),MXY(3))
          ENDIF
          CALL FMABS(MZ02(1),MXY(2))
          CALL FMADD_R2(MXY(2),MXY(3))
          CALL FMDIVI_R1(MXY(3),2)
          CALL FMSQRT_R1(MXY(3))
      ENDIF

      CALL FMADD(MXY(3),MXY(3),MXY(2))
      IF (MWK(START(MA(1))) >= 0) THEN
          CALL FMDIV(MZ02(2),MXY(2),MZ01(2))
          CALL FMEQ(MXY(3),MZ01(1))
      ELSE
          IF (MWK(START(MA(2))) >= 0) THEN
              CALL FMDIV(MZ02(2),MXY(2),MZ01(1))
              CALL FMEQ(MXY(3),MZ01(2))
          ELSE
              CALL FMDIV(MZ02(2),MXY(2),MZ01(1))
              CALL FMEQ(MXY(3),MZ01(2))
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
              IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
                  MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MXEXP = MXSAVE
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      KACCSW = KASAVE
      CALL ZMEQU(MZ01,MB,NDIG,NDSAVE)

      IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      NTRACE = NTRSAV
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMSQRT'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSQRT

      SUBROUTINE ZMST2M(STRING,MA)

!  MA = STRING

!  Convert a character string to FM format.
!  This is often more convenient than using ZMINP, which converts an array of character(1) values.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: MA(2)

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMST2M'
      LB = LEN(STRING)
      KFSAVE = KFLAG

      IF (LB > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = LB
      ENDIF
      DO J = 1, LB
         CMBUFZ(J) = STRING(J:J)
      ENDDO

      NCALL = NCALL - 1
      CALL ZMINP(CMBUFZ,MA,1,LB)

      IF (KFSAVE /= 0) KFLAG = KFSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMST2M

      SUBROUTINE ZMSUB(MA,MB,MC)

!  MC = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      INTEGER :: KASAVE,KF1,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSUB    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMSUB'
              CALL ZMNTR(2,MA,MB,2)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMSUB to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMSUB(MA(1),MB(1),MC(1))
      KF1 = KFLAG
      CALL FMSUB(MA(2),MB(2),MC(2))

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMSUB'
      IF (KFLAG == 1) KFLAG = KF1

      IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)                  &
         .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMSUB'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSUB

      SUBROUTINE ZMTAN(MA,MB)

!  MB = TAN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NGOAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MZ01(2),MZ02(2),MZ03(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMTAN    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMTAN(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMTANH(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ENDIF

!             Find SIN(2*REAL(MA)) and COS(2*REAL(MA)).

      CALL FMADD(MZ02(1),MZ02(1),MZ01(1))
      CALL FMCSSN(MZ01(1),MZ01(2),MXY(2))
      CALL FMEQ(MXY(2),MZ01(1))

!             Find SINH(2*IMAG(MA)) and COSH(2*IMAG(MA)).

      CALL FMADD(MZ02(2),MZ02(2),MXY(2))
      CALL FMCHSH(MXY(2),MXY(1),MXY(3))
      CALL FMEQ(MXY(3),MXY(2))

!             TAN(MA) =  SIN(2*REAL(MA))  / (COS(2*REAL(MA))+COSH(2*IMAG(MA)) +
!                        SINH(2*IMAG(MA)) / (COS(2*REAL(MA))+COSH(2*IMAG(MA)) i

      CALL FMADD_R2(MZ01(2),MXY(1))
      IF (MWK(START(MXY(1))+3) == 0) THEN
          MWK(START(MZ01(1))+1) = 0
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
          GO TO 130
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMDIV_R1(MZ01(1),MXY(1))
          CALL FMIM(1,MZ01(2))
          IF (MWK(START(MXY(2))) < 0 .AND. MWK(START(MZ01(2))+2) /= MUNKNO .AND.  &
              MWK(START(MZ01(2))+3) /= 0) MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ELSE
          CALL FMDIVD(MZ01(1),MXY(2),MXY(1),MZ03(1),MZ03(2))
          CALL ZMEQ(MZ03,MZ01)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
  130 IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          GO TO 110
      ENDIF

      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMTAN

      SUBROUTINE ZMTANH(MA,MB)

!  MB = TANH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NGOAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MZ01(2),MZ02(2),MZ03(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMTANH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMTAN(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMTANH(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find SIN(2*IMAG(MA)) and COS(2*IMAG(MA)).

      CALL FMADD(MZ02(2),MZ02(2),MZ01(1))
      CALL FMCSSN(MZ01(1),MZ01(2),MXY(2))
      CALL FMEQ(MXY(2),MZ01(1))

!             Find SINH(2*REAL(MA)) and COSH(2*REAL(MA)).

      CALL FMADD(MZ02(1),MZ02(1),MXY(2))
      CALL FMCHSH(MXY(2),MXY(1),MXY(3))
      CALL FMEQ(MXY(3),MXY(2))

!             TANH(MA) =  SINH(2*REAL(MA)) / (COS(2*IMAG(MA))+COSH(2*REAL(MA)) +
!                         SIN(2*IMAG(MA))  / (COS(2*IMAG(MA))+COSH(2*REAL(MA)) i

      CALL FMADD_R2(MZ01(2),MXY(1))
      IF (MWK(START(MXY(1))+3) == 0) THEN
          MWK(START(MZ01(1))+1) = 0
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
          GO TO 130
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMDIV(MZ01(1),MXY(1),MZ01(2))
          CALL FMIM(1,MZ01(1))
          IF (MWK(START(MXY(2))) < 0) MWK(START(MZ01(1))) = -1
      ELSE
          CALL FMDIVD(MZ01(1),MXY(2),MXY(1),MZ03(2),MZ03(1))
          CALL ZMEQ(MZ03,MZ01)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
  130 IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          GO TO 110
      ENDIF

      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMTANH

      SUBROUTINE ZMUNPK(MP,MA)

!  MP is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MP(2)
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MP(1),MA(1))
      CALL FMUNPK(MP(2),MA(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMUNPK

      SUBROUTINE ZMWARN

!  Called by one of the ZM routines to print a warning message if any error condition arises in
!  that routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NAME

      INTEGER :: NCS

      IF (KFLAG >= 0 .OR. NCALL /= 1 .OR. KWARN <= 0) RETURN
      NCS = NCALL
      NAME = NAMEST(NCALL)
      WRITE (KW,"(/' Error of type KFLAG =',I3,"   //  &
                "' in FM package in routine ',A/)"     &
            ) KFLAG,TRIM(NAME)

  110 NCALL = NCALL - 1
      IF (NCALL > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (KFLAG == -3) THEN
          WRITE (KW,                                                     &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -4 .OR. KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (KFLAG == -8 .AND. NAME == 'ZMOUT') THEN
          WRITE (KW,                                                          &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (KFLAG == -8 .AND. NAME == 'ZMREAD') THEN
          WRITE (KW,                                                        &
                 "(' The CMBUFF array is not big enough to hold the',"  //  &
                 "' input character string'/"                           //  &
                 "' UNKNOWN has been returned.'/)"                          &
                )
      ELSE IF (KFLAG == -9) THEN
          WRITE (KW,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,                                        &
                 "(I23,' digits were requested (NDIG).'/)"  &
                ) NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ENDIF

      NCALL = NCS
      IF (KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE ZMWARN

      SUBROUTINE ZMWRIT(KWRITE,MA)

!  Write MA on unit KWRITE under the current format.  Multi-line numbers will have '&' as the last
!  nonblank character on all but the last line of the real part and the imaginary part.
!  These numbers can then be read easily using ZMREAD.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KWRITE
      INTEGER :: MA(2)

      INTEGER :: J,K,KSAVE,L,LAST,LAST1,LAST2,LB,ND,NEXP
      INTENT (IN) :: MA,KWRITE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMWRIT'
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = 2*MAX(JFORM2+NEXP,ND+NEXP) + 3
      IF (LB > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = LB
      ENDIF
      CALL ZMOUT(MA,CMBUFZ,LB,LAST1,LAST2)
      KFLAG = KSAVE
      LAST = LAST2 + 1
      DO J = 1, LAST2
         IF (CMBUFZ(LAST-J) /= ' ' .OR. J == LAST2) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFZ(K),K=1,L)
             ELSE
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFZ(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFZ(K),K=L-72,L)
             ENDIF
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
                 IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMWRIT

      SUBROUTINE ZMZ2M(ZVAL,MA)

!  MA = ZVAL

!  ZVAL is complex and is converted to ZM form.

      USE FMVALS
      IMPLICIT NONE

      COMPLEX :: ZVAL
      INTEGER :: MA(2)
      INTENT (IN) :: ZVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMZ2M'
      IF (NTRACE /= 0) CALL ZMNTRZ(2,ZVAL,1)

      CALL FMSP2M(REAL(ZVAL),MA(1))
      CALL FMSP2M(AIMAG(ZVAL),MA(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMZ2M


!  Here are the routines which work with packed ZM numbers.
!  All names are the same as unpacked versions with 'ZM' replaced by 'ZP'.

!  This packed format is not available when using the FM, IM, or ZM derived types.

      SUBROUTINE ZPABS(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMABS(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPABS

      SUBROUTINE ZPACOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMACOS(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPACOS

      SUBROUTINE ZPACOSH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMACOSH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPACOSH

      SUBROUTINE ZPADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMADD(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPADD

      SUBROUTINE ZPADDI(MA,INTEG)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA
      CALL ZMUNPK(MA,MPX)
      CALL ZMADDI(MPX,INTEG)
      CALL ZMPACK(MPX,MA)
      RETURN
      END SUBROUTINE ZPADDI

      SUBROUTINE ZPARG(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMARG(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPARG

      SUBROUTINE ZPASIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMASIN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPASIN

      SUBROUTINE ZPASINH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMASINH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPASINH

      SUBROUTINE ZPATAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMATAN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPATAN

      SUBROUTINE ZPATANH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMATANH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPATANH

      SUBROUTINE ZPCHSH(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCHSH(MPX,MPY,MPZ)
      CALL ZMPACK(MPY,MB)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCHSH

      SUBROUTINE ZPCMPX(MAFM,MBFM,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MAFM,MBFM,MC(2)
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MAFM,MPA)
      CALL FMUNPK(MBFM,MPB)
      CALL ZMCMPX(MPA,MPB,MPX)
      CALL ZMPACK(MPX,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCMPX

      SUBROUTINE ZPCONJ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCONJ(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCONJ

      SUBROUTINE ZPCOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCOS(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCOS

      SUBROUTINE ZPCOSH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCOSH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCOSH

      SUBROUTINE ZPCSSN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCSSN(MPX,MPY,MPZ)
      CALL ZMPACK(MPY,MB)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCSSN

      SUBROUTINE ZPDIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMDIV(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPDIV

      SUBROUTINE ZPDIVI(MA,INTEG,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMDIVI(MPX,INTEG,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPDIVI

      SUBROUTINE ZPEQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQ(MA(1),MB(1))
      CALL FPEQ(MA(2),MB(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEQ

      SUBROUTINE ZPEQU(MA,MB,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU(MA(1),MB(1),NDA,NDB)
      CALL FPEQU(MA(2),MB(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEQU

      SUBROUTINE ZPEQU_R1(MA,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU_R1(MA(1),NDA,NDB)
      CALL FPEQU_R1(MA(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEQU_R1

      SUBROUTINE ZPEXP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMEXP(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEXP

      SUBROUTINE ZPFORM(FORM1,FORM2,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      CHARACTER(*) :: FORM1,FORM2,STRING
      INTENT (IN) :: MA,FORM1,FORM2
      INTENT (INOUT) :: STRING
      CALL ZMUNPK(MA,MPX)
      CALL ZMFORM(FORM1,FORM2,MPX,STRING)
      RETURN
      END SUBROUTINE ZPFORM

      SUBROUTINE ZPFPRT(FORM1,FORM2,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      CHARACTER(*) :: FORM1,FORM2
      INTENT (IN) :: MA,FORM1,FORM2
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMFPRT(FORM1,FORM2,MPX)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPFPRT

      SUBROUTINE ZP2I2M(INTEG1,INTEG2,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: INTEG1,INTEG2
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG1,INTEG2
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZM2I2M(INTEG1,INTEG2,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZP2I2M

      SUBROUTINE ZPI2M(INTEG,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: INTEG
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMI2M(INTEG,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPI2M

      SUBROUTINE ZPIMAG(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMIMAG(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPIMAG

      SUBROUTINE ZPINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMINT(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPINT

      SUBROUTINE ZPINP(LINE,MA,LA,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA(2)
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMINP(LINE,MPX,LA,LB)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPINP

      SUBROUTINE ZPIPWR(MA,INTEG,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMIPWR(MPX,INTEG,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPIPWR

      SUBROUTINE ZPLG10(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMLG10(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPLG10

      SUBROUTINE ZPLN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMLN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPLN

      SUBROUTINE ZPM2I(MA,INTEG)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA
      INTENT (INOUT) :: INTEG
      CALL ZMUNPK(MA,MPX)
      CALL ZMM2I(MPX,INTEG)
      RETURN
      END SUBROUTINE ZPM2I

      SUBROUTINE ZPM2Z(MA,ZVAL)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX :: ZVAL
      INTEGER :: MA(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: ZVAL
      CALL ZMUNPK(MA,MPX)
      CALL ZMM2Z(MPX,ZVAL)
      RETURN
      END SUBROUTINE ZPM2Z

      SUBROUTINE ZPMPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMMPY(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPMPY

      SUBROUTINE ZPMPYI(MA,INTEG,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMMPYI(MPX,INTEG,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPMPYI

      SUBROUTINE ZPNINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMNINT(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPNINT

      SUBROUTINE ZPOUT(MA,LINE,LB,LAST1,LAST2)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: LB,LAST1,LAST2
      CHARACTER :: LINE(LB)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE,LAST1,LAST2
      CALL ZMUNPK(MA,MPX)
      CALL ZMOUT(MPX,LINE,LB,LAST1,LAST2)
      RETURN
      END SUBROUTINE ZPOUT

      SUBROUTINE ZPPRNT(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTENT (IN) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMPRNT(MPX)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPPRNT

      SUBROUTINE ZPPWR(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMPWR(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPPWR

      SUBROUTINE ZPREAD(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KREAD
      INTEGER :: MA(2)
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMREAD(KREAD,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPREAD

      SUBROUTINE ZPREAL(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMREAL(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPREAL

      SUBROUTINE ZPRPWR(MA,IVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMRPWR(MPX,IVAL,JVAL,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPRPWR

      SUBROUTINE ZPSET(NPREC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      CALL ZMSET(NPREC)
      RETURN
      END SUBROUTINE ZPSET

      SUBROUTINE ZPSIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSIN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSIN

      SUBROUTINE ZPSINH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSINH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSINH

      SUBROUTINE ZPSQR(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSQR(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSQR

      SUBROUTINE ZPSQRT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSQRT(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSQRT

      SUBROUTINE ZPST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTEGER :: MA(2)
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMST2M(STRING,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPST2M

      SUBROUTINE ZPSUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMSUB(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSUB

      SUBROUTINE ZPTAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMTAN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPTAN

      SUBROUTINE ZPTANH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMTANH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPTANH

      SUBROUTINE ZPWRIT(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA(2)
      INTENT (IN) :: MA,KWRITE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMWRIT(KWRITE,MPX)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPWRIT

      SUBROUTINE ZPZ2M(ZVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX :: ZVAL
      INTEGER :: MA(2)
      INTENT (IN) :: ZVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMZ2M(ZVAL,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPZ2M


!  These FM routines perform gamma and related functions.

!  FMBERNOULLI(N,MA)    MA = B(N)  Nth Bernoulli number

!  FMBETA(MA,MB,MC)     MC = Beta(MA,MB)

!  FMCOMB(MA,MB,MC)     MC = Combination MA choose MB  (Binomial coeff.)

!  FMEULER(MA)          MA = Euler's constant ( 0.5772156649... )     < old name: FMEULR >

!  FMFACT(MA,MB)        MB = MA Factorial  (Gamma(MA+1))

!  FMGAM(MA,MB)         MB = Gamma(MA)

!  FMIBTA(MX,MA,MB,MC)  MC = Incomplete Beta(MX,MA,MB)

!  FMIGM1(MA,MB,MC)     MC = Incomplete Gamma(MA,MB).  Lower case Gamma(a,x)

!  FMIGM2(MA,MB,MC)     MC = Incomplete Gamma(MA,MB).  Upper case Gamma(a,x)

!  FMLNGM(MA,MB)        MB = Ln(Gamma(MA))

!  FMPGAM(N,MA,MB)      MB = Polygamma(N,MA)  (Nth derivative of Psi)

!  FMPOCH(MA,N,MB)      MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)  (Pochhammer)

!  FMPSI(MA,MB)         MB = Psi(MA)      (Derivative of Ln(Gamma(MA))

!  For each of these routines there is also a version available for which the argument list is the
!  same but all FM numbers are in packed format.  The packed versions have the same names except
!  'FM' is replaced by 'FP' at the start of each name.

! --------------------------------------------------------------------------------------------------

      SUBROUTINE FMARG2(KROUTN,NARGS,MA,MB,KRESLT)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)
!  KRESLT - Result code returned to the calling routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: KROUTN
      INTEGER :: MA,MB
      INTEGER :: NARGS,KRESLT

      INTEGER :: NCATMA,NCATMB

      INTEGER, PARAMETER ::                                                     &
               KFACT(15) = (/ 12,12, 0,12, 0, 0, 8, 8, 8, 0, 0, 8, 0, 4, 4 /),  &
               KGAM(15)  = (/ 12,12, 0,12, 0, 0, 3,12, 4, 0, 0, 8, 0, 4, 4 /),  &
               KLNGM(15) = (/ 12,12, 0,12,12,12,12,12,12, 0, 0,11, 0, 0, 4 /),  &
               KPSI(15)  = (/ 12,12, 0,12, 0, 0, 4,12, 3, 0, 0, 0, 0, 0,12 /)
      INTENT (IN) :: MA,MB

      CALL FMARGS(KROUTN,NARGS,MA,MB,KRESLT)
      IF (KFLAG /= 0) RETURN

!             Check for special cases.

      CALL FMCAT(MA,NCATMA)
      NCATMB = 0
      IF (NARGS == 2) CALL FMCAT(MB,NCATMB)

      IF (KROUTN == 'FMFACT') THEN
          KRESLT = KFACT(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMGAM') THEN
          KRESLT = KGAM(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMLNGM') THEN
          KRESLT = KLNGM(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMPSI') THEN
          KRESLT = KPSI(NCATMA)
          GO TO 110
      ENDIF

      KRESLT = 0
      RETURN

  110 IF (KRESLT == 12) THEN
          KFLAG = -4
          CALL FMWRN2
      ENDIF
      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -5
          ELSE
              KFLAG = -5
              CALL FMWRN2
          ENDIF
      ENDIF
      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -6
          ELSE
              KFLAG = -6
              CALL FMWRN2
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMARG2

      SUBROUTINE FMBERNOULLI(N,MA)

!  MA = B(N)  where B(N) is the Nth Bernoulli number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA

      DOUBLE PRECISION :: B
      REAL (KIND(1.0D0)) :: MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KASAVE,KL,KOVUN,KR_RETRY,NDGOAL,NDSAVE,NGOAL,NUMTRY
      INTENT (IN) :: N
      INTENT (INOUT) :: MA
      INTEGER :: MXY(5),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'BERNOULLI'
      IF (NTRACE /= 0) THEN
          CALL FMNTRI(2,N,1)
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = INT(5.0/ALOGMT + 2.0 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KOVUN = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2
      KACCSW = 1
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NUMTRY = 0

!             For functions that sum series using Bernoulli numbers, N will normally be NUMBRN+2
!             here, or possibly 28 when NUMBRN is zero.  Check to see if this N is much larger than
!             NUMBRN and can be computed directly from the zeta(N) series without computing
!             and saving the intermediate Bernoulli numbers, otherwise call FMBERN.

  120 B = NDIG*LOG(DBLE(MBASE))/6.91
      IF (N > NUMBRN+100 .AND. N > B) THEN
          CALL FMI2M(1,MXY(1))
          DO J = 2, 10000
             CALL FMI2M(J,MXY(2))
             CALL FMIPWR(MXY(2),-N,MXY(3))
             CALL FMCSADD_R1(MXY(1),MXY(3))
             IF (KFLAG == 1) EXIT
          ENDDO
          CALL FMI2M(N,MXY(3))
          CALL FMFACT(MXY(3),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))
          CALL FMMPYI_R1(MXY(1),2*(-1)**(N/2+1))
          CALL FMPI(MXY(2))
          CALL FMMPYI_R1(MXY(2),2)
          CALL FMIPWR(MXY(2),N,MXY(3))
          CALL FMDIV(MXY(1),MXY(3),MXY(4))
      ELSE
          CALL FMI2M(1,MXY(1))
          CALL FMBERN(N,MXY(1),MXY(4))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(4))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(4))+J+1)) GO TO 130
              ENDDO
              GO TO 140
          ENDIF
  130     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(4))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          NUMTRY = NUMTRY + 1
          GO TO 120
      ENDIF

  140 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACMAX)
      CALL FMEXT2(MXY(4),MA,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBERNOULLI

      SUBROUTINE FMBERN(N,MA,MB)

!  MB = MA*B(N)      B(N) is the Nth Bernoulli number.  (Internal routine used by special functions)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB

!             MBERN is the array used to save Bernoulli numbers so they do not have to be
!                   re-computed on subsequent calls.

!             Only the even-numbered Bernoulli numbers are stored.
!             B(2N) starts in MBERN(N) for 2N >= 28.
!             The first few numbers have small numerators and denominators, and they are done using
!             FMMPYI and FMDIVI, and are not stored in MBERN.

      DOUBLE PRECISION :: U,UJ,X,B
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MNEXP,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTNDG,J,J2,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,L,LARGE,LARGED,N2,NBOT,   &
                 NDGOAL,NDIV,NDOLD,NDP,NDSAV1,NDSAV2,NDSAVE,NEXTD,NEXTN,NGOAL,NMPY,NSTART,NTD,  &
                 NTN,NTOP,NUMTRY,NX
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBERN'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENT2('FMBERN   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBERN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,0)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = INT(5.0/ALOGMT + 2.0 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

  120 IF (N >= 2 .AND. N <= 26) THEN
          CALL FMBER2(N,MXY(5),MXY(4))
          GO TO 130
      ELSE IF (N == 0) THEN
          CALL FMEQ(MXY(5),MXY(4))
          GO TO 130
      ELSE IF (N == 1) THEN
          CALL FMDIVI(MXY(5),-2,MXY(4))
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(0,MXY(4))
          GO TO 130
      ENDIF

      IF (MOD(N,2) == 1 .OR. N < 0) THEN
          CALL FMI2M(0,MXY(4))
          GO TO 130
      ELSE IF (N/2 > LMBERN) THEN
          KFLAG = -11
          CALL FMWRN2
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Too many Bernoulli numbers were needed in FMBERN.'
          WRITE (KW,*) ' B(',N,') was requested, and the current maximum is B(',LMBERN*2,').'
          WRITE (KW,*) ' '
          MXEXP = MXSAVE
          NDIG = NDSAVE
          CALL FMST2M('UNKNOWN',MB)
          IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
          NCALL = NCALL - 1
          KACCSW = KASAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             See if B(N) has already been computed with sufficient precision.

      N2 = N/2
      IF (MBASE == MBSBRN) THEN
          IF (N <= NUMBRN) THEN
              IF (MBERN(N2) > 0) THEN
                  IF (SIZE_OF(MBERN(N2)) >= NDIG+3) THEN
                      IF (NDBERN(N2) >= NDIG) THEN
                          CALL FMMPY(MBERN(N2),MXY(5),MXY(4))
                          GO TO 130
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          DO J = 28, NUMBRN, 2
             NDBERN(J/2) = 0
          ENDDO
          NUMBRN = 0
      ENDIF

!             Compute more Bernoulli numbers.

      X = 1.0D0
      B = DBLE(MBASE)
      NDP = 0
      DO J = 1, 80
         X = X/B
         IF ((1.0D0+X) <= 1.0D0) THEN
             NDP = J-1
             IF (NDIG <= NDP) X = 4.0D0*DPPI*DPPI
             EXIT
         ENDIF
      ENDDO
      INTNDG = INT(ALOGMX/ALOGMB + 1.0)
      NX = INT(DBLE(NDIG)*DLOGMB/DLOGTW + 2.0D0)
      NSTART = 28
      IF (MBSBRN == MBASE .AND. NUMBRN >= 28) THEN
          NSTART = NUMBRN + 2
          DO J = 28, NUMBRN, 2
             IF (SIZE_OF(MBERN(J/2)) < NDIG+3 .OR. NDBERN(J/2) < NDIG) THEN
                 NSTART = J
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      DO J = NSTART, N, 2

!             Check to see if J is large enough so that the formula
!             B(J) = -B(J-2)*(J-1)*J/(2*pi)**2 can be used.

         IF (J >= NX .AND. NDIG <= NDP .AND. J > 28) THEN
             J2 = J/2
             MNEXP = MWK(START(MBERN(J2-1))+2)
             MWK(START(MBERN(J2-1))+2) = 0
             CALL FMM2DP(MBERN(J2-1),U)
             MWK(START(MBERN(J2-1))+2) = MNEXP
             UJ = J
             U = -U*(UJ*UJ-UJ)/X
             NUMBRN = J
             MBSBRN = MBASE
             CALL FMDPM(U,MBERN(J2))
             MWK(START(MBERN(J2))+2) = MWK(START(MBERN(J2))+2) + MNEXP
             NDBERN(J2) = NDIG
             CYCLE
         ENDIF

         IF (J >= NX .AND. J > 28) THEN
             LARGE = INT(INTMAX/J)
             J2 = J/2
             NUMBRN = J
             MBSBRN = MBASE
             CALL FMPI(MXY(2))
             CALL FMSQR_R1(MXY(2))
             IF (MOD(J,4) == 0 .OR. MOD(J,4) == 1) THEN
                 IF (J < LARGE) THEN
                     L = -(J*J-J)/4
                     CALL FMCSMPYI(MBERN(J2-1),L,MXY(3))
                 ELSE
                     CALL FMCSMPYI(MBERN(J2-1),-J,MXY(3))
                     CALL FMCSMPYI_R1(MXY(3),J-1)
                     CALL FMCSDIVI_R1(MXY(3),4)
                 ENDIF
             ELSE
                 IF (J < LARGE) THEN
                     L = -(J*J-J)
                     CALL FMCSMPYI(MBERN(J2-1),L,MXY(3))
                     CALL FMCSDIVI_R1(MXY(3),4)
                 ELSE
                     CALL FMCSMPYI(MBERN(J2-1),-J,MXY(3))
                     CALL FMCSMPYI_R1(MXY(3),J-1)
                     CALL FMCSDIVI_R1(MXY(3),4)
                 ENDIF
             ENDIF
             CALL FMCSDIV(MXY(3),MXY(2),MBERN(J2))
             NDBERN(J2) = NDIG
             CYCLE
         ENDIF

!             Use the recurrence involving a sum of binomial coefficients times previous B's.

         NTOP = J + 3
         NBOT = J - 6
         LARGE = INT(INTMAX/NTOP)
         LARGED = MIN(LARGE,INT(MXBASE))
         CALL FMCMBI(NTOP,NBOT,MXY(2))
         IF (NBOT <= 26) THEN
             CALL FMBER2(NBOT,MXY(2),MXY(3))
         ELSE
             CALL FMMPY(MBERN(NBOT/2),MXY(2),MXY(3))
         ENDIF
         NDSAV1 = NDIG
         DO NBOT = J-12, 0, -6
            NTN = NBOT + 6
            NTD = NTOP - NBOT - 5
            NEXTN = NTN
            NEXTD = NTD
            IF (NBOT >= 6) THEN
                NDSAV2 = NDIG
                DO K = 1, 5
                   NEXTN = NEXTN - 1
                   NEXTD = NEXTD + 1
                   NMPY = NTN*NEXTN
                   NDIV = NTD*NEXTD
                   IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                       NTN = NMPY
                       NTD = NDIV
                   ELSE
                       CALL FMGCDI(NMPY,NDIV)
                       IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                           NTN = NMPY
                           NTD = NDIV
                       ELSE
                           NDIG = MAX(NGRD22,MIN(NDSAV2,INT(MWK(START(MXY(2))+2))+INTNDG))
                           CALL FMCSMPYI_R1(MXY(2),NTN)
                           CALL FMCSDIVI_R1(MXY(2),NTD)
                           NTN = NEXTN
                           NTD = NEXTD
                       ENDIF
                   ENDIF
                ENDDO
                NDIG = MAX(NGRD22,MIN(NDSAV2,INT(MWK(START(MXY(2))+2))+INTNDG))
                CALL FMCSMPYI_R1(MXY(2),NTN)
                CALL FMCSDIVI_R1(MXY(2),NTD)
                NDIG = NDSAV2
            ELSE
                CALL FMCMBI(NTOP,NBOT,MXY(2))
            ENDIF
            MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Now MXY(2) is the combination NTOP choose NBOT.

            IF (NBOT <= 26) THEN
                CALL FMBER2(NBOT,MXY(2),MXY(4))
            ELSE
                CALL FMMPY(MBERN(NBOT/2),MXY(2),MXY(4))
            ENDIF
            NDIG = NDSAV1
            CALL FMCSADD_R1(MXY(3),MXY(4))
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(3))+2)-MWK(START(MXY(4))+2)))
         ENDDO

         NDIG = NDSAV1
         IF (MOD(J,6) == 4) THEN
             CALL FMI2M(NTOP,MXY(1))
             CALL FMCSDIVI(MXY(1),-6,MXY(4))
             CALL FMSUB_R2(MXY(4),MXY(3))
         ELSE
             CALL FMI2M(NTOP,MXY(1))
             CALL FMCSDIVI(MXY(1),3,MXY(4))
             CALL FMSUB_R2(MXY(4),MXY(3))
         ENDIF

         J2 = J/2
         NUMBRN = J
         MBSBRN = MBASE

         CALL FMCSMPYI_R1(MXY(3),6)
         NTN = NTOP*(NTOP-1)
         LARGE = INT(INTMAX/NTOP)
         IF (NTN > MXBASE .OR. NTOP > LARGE) THEN
             CALL FMCSDIVI_R1(MXY(3),NTOP)
             NTN = NTOP - 1
             CALL FMCSDIVI_R1(MXY(3),NTN)
             NTN = NTOP - 2
             CALL FMCSDIVI(MXY(3),NTN,MBERN(J2))
         ELSE IF (NTN*(NTOP-2) > MXBASE .OR. NTN > LARGE) THEN
             CALL FMCSDIVI_R1(MXY(3),NTN)
             NTN = NTOP - 2
             CALL FMCSDIVI(MXY(3),NTN,MBERN(J2))
         ELSE
             NTN = NTN*(NTOP-2)
             CALL FMCSDIVI(MXY(3),NTN,MBERN(J2))
         ENDIF
         NDBERN(J2) = NDIG
      ENDDO

      CALL FMMPY(MBERN(N2),MXY(5),MXY(4))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(4))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(4))+J+1)) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(4))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(5),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(4),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  150 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(4),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBERN

      SUBROUTINE FMBER2(N,MA,MB)

!  Internal routine for small Bernoulli numbers.

!  MB = MA*B(N) for N an even integer between 2 and 26.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      INTEGER :: N2
      INTEGER :: NBTOP(13) = (/  &
              1,   1,  1,   1,  5, -691, 7, -3617, 43867, -174611, 854513, -236364091, 8553103 /)
      INTEGER :: NBBOT(13) = (/  &
              6, -30, 42, -30, 66, 2730, 6,   510,   798,     330,    138,       2730,       6 /)
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (N <= 0) THEN
          CALL FMEQ(MA,MB)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ELSE IF (N == 1) THEN
          CALL FMDIVI(MA,-2,MB)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ELSE IF (MOD(N,2) == 1) THEN
          CALL FMI2M(0,MB)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      N2 = N/2

      IF (N <= 26) THEN
          IF (NBTOP(N2) == 1) THEN
              CALL FMDIVI(MA,NBBOT(N2),MB)
          ELSE
              CALL FMMPYI(MA,NBTOP(N2),MB)
              CALL FMDIVI_R1(MB,NBBOT(N2))
          ENDIF
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBER2

      SUBROUTINE FMBETA(MA,MB,MC)

!  MC = beta(MA,MB).  beta(MA,MB) = gamma(MA) * gamma(MB) / gamma(MA+MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE,MZERO
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K10,K11,KASAVE,KB,KC,KFLKB,KFLNKB,KL,KOVUN,KR_RETRY,KRESLT,  &
                 KWRNSV,N,NB,NBOT,NDGOAL,NDOLD,NDSAVE,NGOAL,NK,NKB,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(22),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IEXTRA = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. (MWK(START(MA)+2) < -NDIG .OR. MWK(START(MB)+2) < -NDIG) .AND.  &
          MWK(START(MA)+2) > (-MXEXP) .AND. MWK(START(MB)+2) > (-MXEXP)              .AND.  &
          MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NDSAVE = NDIG
          NDIG = 2*NDIG + NGRD52
          IF (MWK(START(MA)+2) <= MWK(START(MB)+2)) THEN
              CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
              CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          ELSE
              CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
              CALL FMEQU(MB,MXY(1),NDSAVE,NDIG)
          ENDIF
          CALL FMABS(MXY(1),MXY(3))
          CALL FMABS(MXY(2),MXY(4))
          CALL FMADD(MXY(3),MXY(4),MXY(7))
          CALL FMSQR(MXY(7),MXY(3))
          IF (MWK(START(MXY(3))+2) <= MWK(START(MXY(7))+2) - NDSAVE) THEN
              CALL FMI2M(1,MXY(3))
              CALL FMDIV(MXY(3),MXY(1),MXY(4))
              CALL FMDIV(MXY(3),MXY(2),MXY(6))
              IF (MWK(START(MXY(4))+2) < MEXPOV) THEN
                  CALL FMADD(MXY(1),MXY(2),MXY(7))
                  CALL FMPI(MXY(8))
                  CALL FMSQR_R1(MXY(8))
                  CALL FMMPY(MXY(7),MXY(8),MXY(9))
                  CALL FMDIVI_R1(MXY(9),6)
                  CALL FMSUB(MXY(6),MXY(9),MXY(10))
                  CALL FMADD_R2(MXY(4),MXY(10))
                  CALL FMEQU(MXY(10),MC,NDIG,NDSAVE)
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  NDIG = NDSAVE
                  IF (MWK(START(MC)+2) < (-MXEXP) .OR. MWK(START(MC)+2) > MXEXP+1) GO TO 110
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1)
                      NCALL = NCALL - 1
                  ENDIF
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ELSE
              CALL FMI2M(1,MXY(3))
              CALL FMSUB(MXY(2),MXY(3),MXY(4))
              IF (MWK(START(MXY(4))+3) == 0) THEN
                  NDIG = NDSAVE
                  CALL FMDIV(MXY(3),MXY(1),MC)
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  IF (MWK(START(MC)+2) < (-MXEXP) .OR. MWK(START(MC)+2) > MXEXP+1) GO TO 110
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1)
                      NCALL = NCALL - 1
                  ENDIF
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ELSE
                  CALL FMDIV(MXY(3),MXY(1),MXY(4))
                  CALL FMEULR(MXY(5))
                  CALL FMPSI(MXY(2),MXY(6))
                  CALL FMADD(MXY(5),MXY(6),MXY(7))
                  CALL FMSUB(MXY(4),MXY(7),MXY(8))
                  CALL FMEQU(MXY(8),MC,NDIG,NDSAVE)
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  NDIG = NDSAVE
                  IF (MWK(START(MC)+2) < (-MXEXP) .OR. MWK(START(MC)+2) > MXEXP+1) GO TO 110
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1)
                      NCALL = NCALL - 1
                  ENDIF
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
      ENDIF

  110 CALL FMENT2('FMBETA   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(21))
      NUMTRY = 0

  130 JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(2),MXY(17))
      KROUND = JR
      IF (MWK(START(MXY(1))+3) == 0 .OR. MWK(START(MXY(2))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(22))
          KFLAG = -4
          GO TO 160
      ENDIF

!             See if any of the terms are negative integers.

      CALL FMINT(MXY(1),MXY(8))
      IF (MWK(START(MXY(1))) < 0) THEN
          IF (FMCOMP(MXY(1),'==',MXY(8))) THEN
              CALL FMST2M('UNKNOWN',MXY(22))
              KFLAG = -4
              GO TO 160
          ENDIF
      ENDIF
      CALL FMINT(MXY(2),MXY(9))
      IF (MWK(START(MXY(2))) < 0) THEN
          IF (FMCOMP(MXY(2),'==',MXY(9))) THEN
              CALL FMST2M('UNKNOWN',MXY(22))
              KFLAG = -4
              GO TO 160
          ENDIF
      ENDIF
      IF (FMCOMP(MXY(17),'==',MXY(1))) THEN
          IF (MWK(START(MXY(2))+2) > MEXPAB) THEN
              CALL FMABS(MXY(2),MXY(13))
              CALL FMDPM(DLOGMB,MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(13))
              J = (MWK(START(MXY(1))+2)+1)
              CALL FMMPYI_R1(MXY(13),J)
          ELSE
              CALL FMABS(MXY(2),MXY(13))
          ENDIF
          CALL FMI2M(1,MXY(6))
          CALL FMULP(MXY(6),MXY(7))
          IF (FMCOMP(MXY(13),'<=',MXY(7))) THEN
              CALL FMGAM(MXY(2),MXY(22))
              GO TO 160
          ENDIF
      ENDIF
      IF (FMCOMP(MXY(17),'==',MXY(2))) THEN
          IF (MWK(START(MXY(1))+2) > MEXPAB) THEN
              CALL FMABS(MXY(1),MXY(13))
              CALL FMDPM(DLOGMB,MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(13))
              J = (MWK(START(MXY(2))+2)+1)
              CALL FMMPYI_R1(MXY(13),J)
          ELSE
              CALL FMABS(MXY(1),MXY(13))
          ENDIF
          CALL FMI2M(1,MXY(6))
          CALL FMULP(MXY(6),MXY(7))
          IF (FMCOMP(MXY(13),'<=',MXY(7))) THEN
              CALL FMGAM(MXY(1),MXY(22))
              GO TO 160
          ENDIF
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1)))*MWK(START(MXY(1))+3) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+2) >= 1) THEN
              CALL FMST2M('UNDERFLOW',MXY(22))
              KFLAG = -6
              GO TO 160
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(2)))*MWK(START(MXY(2))+3) > 0 .AND. MWK(START(MXY(1))) > 0 .AND.  &
              MWK(START(MXY(1))+2) >= 1) THEN
              CALL FMST2M('UNDERFLOW',MXY(22))
              KFLAG = -6
              GO TO 160
          ENDIF
      ENDIF
      IF (MWK(START(MXY(17))+3) == 0) THEN
          CALL FMI2M(0,MXY(22))
          GO TO 140
      ELSE IF (MWK(START(MXY(17))) < 0) THEN
          CALL FMSUB(MXY(1),MXY(8),MXY(6))
          CALL FMSUB(MXY(2),MXY(9),MXY(13))
          CALL FMADD_R2(MXY(6),MXY(13))
          CALL FMINT(MXY(13),MXY(14))
          IF (FMCOMP(MXY(13),'==',MXY(14))) THEN
              CALL FMI2M(0,MXY(22))
              GO TO 140
          ENDIF
      ENDIF

!             See if any of the terms are small integers.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),N)
      KFLKB = KFLAG
      CALL FMM2I(MXY(2),K)
      KFLNKB = KFLAG
      CALL FMM2I(MXY(17),NK)
      KWARN = KWRNSV
      NB = N + K - 2
      KB = N - 1
      NKB = K - 1

      IF (KFLKB == 0 .AND. KFLNKB == 0) THEN
          IF (MIN(KB,NKB) <= 200) THEN
              CALL FMCMBI(NB,KB,MXY(22))
              CALL FMI2M(N+K-1,MXY(8))
              CALL FMMPY_R1(MXY(22),MXY(8))
              CALL FMI2M(1,MXY(6))
              CALL FMDIV_R2(MXY(6),MXY(22))
              GO TO 140
          ENDIF
      ENDIF
      NBOT = 0
      IF (KFLKB == 0 .AND. N <= 200) THEN
          CALL FMEQ(MXY(2),MXY(20))
          CALL FMPOCH(MXY(20),N,MXY(5))
          CALL FMFCTI(KB,MXY(11))
          CALL FMDIV(MXY(11),MXY(5),MXY(21))
          IF (ABS(MWK(START(MXY(21))+2)) < MXSAVE) THEN
              CALL FMEQ(MXY(21),MXY(22))
              GO TO 160
          ENDIF
          NBOT = 1
      ELSE IF (KFLNKB == 0 .AND. K <= 200) THEN
          CALL FMEQ(MXY(1),MXY(20))
          CALL FMPOCH(MXY(20),K,MXY(5))
          CALL FMFCTI(NKB,MXY(11))
          CALL FMDIV(MXY(11),MXY(5),MXY(21))
          IF (ABS(MWK(START(MXY(21))+2)) < MXSAVE) THEN
              CALL FMEQ(MXY(21),MXY(22))
              GO TO 160
          ENDIF
          NBOT = 1
      ENDIF
      IF (NBOT == 1) THEN
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQ(MXY(1),MXY(21))
          CALL FMADD(MXY(1),MXY(2),MXY(17))
      ENDIF

!             General case.  Use FMGAM, unless one of the numbers is too big.  If so, use FMLNGM.

      X = ALOGMB*REAL(MXEXP)
      CALL FMSP2M(X/LOG(X),MXY(7))
      CALL FMABS(MXY(17),MXY(18))
      CALL FMABS(MXY(1),MXY(19))
      CALL FMABS(MXY(2),MXY(3))
      IF (FMCOMP(MXY(18),'>=',MXY(7)) .OR. FMCOMP(MXY(19),'>=',MXY(7)) .OR.  &
          FMCOMP(MXY(3),'>=',MXY(7))) THEN

!             See if one argument is not very large and the other is
!             much larger.  For many of these cases, Stirling's formula
!             can be used to simplify Beta and avoid cancellation.

          IF (MWK(START(MXY(1))+2) > MWK(START(MXY(2))+2)) THEN
              CALL FMEQ(MXY(1),MXY(10))
              CALL FMEQ(MXY(2),MXY(11))
          ELSE
              CALL FMEQ(MXY(2),MXY(10))
              CALL FMEQ(MXY(1),MXY(11))
          ENDIF
          IF (MWK(START(MXY(10))+2) > NDIG .AND.  &
              MWK(START(MXY(10))+2) >= MWK(START(MXY(11))+2)+NDIG) THEN
              IF (MWK(START(MXY(11))) < 0) THEN
                  IF (MWK(START(MXY(11))+2) > NDIG) THEN
                      KFLAG = -9
                      CALL FMWRN2
                      NDIG = NDIG - IEXTRA
                      CALL FMST2M('UNKNOWN',MXY(22))
                      GO TO 160
                  ELSE
                      CALL FMI2M(2,MXY(18))
                      CALL FMEQ(MXY(11),MXY(19))
                      MWK(START(MXY(19))) = -MWK(START(MXY(19)))
                      CALL FMINT(MXY(19),MXY(6))
                      CALL FMMOD(MXY(6),MXY(18),MXY(12))
                      IF (MWK(START(MXY(12))+3) == 0) THEN
                          CALL FMADD(MXY(10),MXY(11),MXY(16))
                          CALL FMLN(MXY(16),MXY(6))
                          CALL FMMPY(MXY(11),MXY(6),MXY(16))
                          CALL FMI2M(1,MXY(6))
                          CALL FMADD(MXY(11),MXY(6),MXY(17))
                          CALL FMEQ(MXY(11),MXY(20))
                          CALL FMLNGM(MXY(17),MXY(4))
                          CALL FMSUB(MXY(4),MXY(16),MXY(6))
                          CALL FMEXP(MXY(6),MXY(13))
                          CALL FMDIV_R1(MXY(13),MXY(20))
                          CALL FMEQ(MXY(13),MXY(22))
                          GO TO 140
                      ENDIF
                  ENDIF
              ENDIF
              CALL FMADD(MXY(10),MXY(11),MXY(16))
              CALL FMLN(MXY(16),MXY(6))
              CALL FMMPY(MXY(11),MXY(6),MXY(16))
              CALL FMEQ(MXY(11),MXY(20))
              CALL FMLNGM(MXY(20),MXY(17))
              CALL FMSUB(MXY(17),MXY(16),MXY(6))
              CALL FMEXP(MXY(6),MXY(13))
              CALL FMEQ(MXY(13),MXY(22))
              GO TO 140
          ENDIF

!             See if both arguments are large.  For many of these cases, Stirling's formula can be
!             used to detect cases where the result will underflow.

          CALL FMDPM(1.0D7,MXY(6))
          IF (FMCOMP(MXY(1),'>',MXY(6)) .AND. FMCOMP(MXY(2),'>',MXY(6))) THEN
              CALL FMADD(MXY(1),MXY(2),MXY(6))
              CALL FMLN(MXY(6),MXY(15))
              CALL FMMPY_R2(MXY(6),MXY(15))
              IF (MWK(START(MXY(15))+2) /= MUNKNO .AND. MWK(START(MXY(15))+3) /= 0)  &
                  MWK(START(MXY(15))) = -MWK(START(MXY(15)))
              CALL FMLN(MXY(1),MXY(6))
              CALL FMMPY_R2(MXY(1),MXY(6))
              CALL FMADD_R1(MXY(15),MXY(6))
              CALL FMLN(MXY(2),MXY(6))
              CALL FMMPY_R2(MXY(2),MXY(6))
              CALL FMADD_R1(MXY(15),MXY(6))
              CALL FMEXP(MXY(15),MXY(16))
              IF (MWK(START(MXY(16))+2) == MEXPUN) THEN
                  CALL FMEQ(MXY(16),MXY(22))
                  GO TO 160
              ENDIF
          ENDIF

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          MZERO = 0
          IEXTRA = INT(MAX(MWK(START(MXY(17))+2),MWK(START(MXY(1))+2),MWK(START(MXY(2))+2),MZERO))
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          CALL FMADD(MXY(1),MXY(2),MXY(17))
          CALL FMI2M(1,MXY(10))
          CALL FMI2M(2,MXY(11))
          CALL FMEQ(MXY(17),MXY(22))
          K10 = 0
          K11 = 0
          KC = 0
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMINT(MXY(1),MXY(12))
              CALL FMMOD(MXY(12),MXY(11),MXY(13))
              IF (MWK(START(MXY(13))+3) == 0) THEN
                  K10 = 1
                  CALL FMADD_R1(MXY(1),MXY(10))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))) < 0) THEN
              CALL FMINT(MXY(2),MXY(12))
              CALL FMMOD(MXY(12),MXY(11),MXY(13))
              IF (MWK(START(MXY(13))+3) == 0) THEN
                  K11 = 1
                  CALL FMADD_R1(MXY(2),MXY(10))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(22))) < 0) THEN
              CALL FMINT(MXY(22),MXY(12))
              CALL FMMOD(MXY(12),MXY(11),MXY(13))
              IF (MWK(START(MXY(13))+3) == 0) THEN
                  KC = 1
                  CALL FMADD_R1(MXY(22),MXY(10))
              ENDIF
          ENDIF
          CALL FMLNGM(MXY(1),MXY(17))
          CALL FMLNGM(MXY(2),MXY(20))
          CALL FMADD_R1(MXY(17),MXY(20))
          CALL FMLNGM(MXY(22),MXY(20))
          CALL FMSUB(MXY(17),MXY(20),MXY(6))
          CALL FMEXP(MXY(6),MXY(17))
          IF (K10 == 1 .OR. K11 == 1 .OR. KC == 1) THEN
              CALL FMI2M(1,MXY(10))
              IF (K10 == 1) THEN
                  CALL FMSUB_R1(MXY(1),MXY(10))
                  CALL FMDIV_R1(MXY(17),MXY(1))
              ENDIF
              IF (K11 == 1) THEN
                  CALL FMSUB_R1(MXY(2),MXY(10))
                  CALL FMDIV_R1(MXY(17),MXY(2))
              ENDIF
              IF (KC == 1) THEN
                  CALL FMSUB_R1(MXY(22),MXY(10))
                  CALL FMMPY_R1(MXY(17),MXY(22))
              ENDIF
          ENDIF
          CALL FMEQ(MXY(17),MXY(22))
      ELSE
          CALL FMGAM(MXY(1),MXY(20))
          CALL FMGAM(MXY(2),MXY(1))
          CALL FMGAM(MXY(17),MXY(22))
          CALL FMMPY(MXY(20),MXY(1),MXY(8))
          CALL FMDIV_R2(MXY(8),MXY(22))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(22))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(22))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(22))+J+1)) GO TO 150
              ENDDO
              GO TO 160
          ENDIF
  150     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(22))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(22),MRETRY,NDOLD,NDIG)
          GO TO 130
      ENDIF

  160 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(22))+1) = MIN(MWK(START(MXY(22))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(22),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBETA

      SUBROUTINE FMCMBI(N,K,MA)

!  Internal routine for computing binomial coefficients for integers.

!  MA = N choose K.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N,K
      INTEGER :: MA

      INTEGER :: INTNDG,J,KSTART,KT,L,LARGE,LARGED,NDIV,NDSAVE,NEXTD,NEXTN,NMPY,NTD,NTN
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      L = MIN(K,N-K)
      IF (L <= 0) THEN
          CALL FMI2M(1,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (L <= 1) THEN
          CALL FMI2M(N,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Find the largest value for N choose J using integers.

      NTN = N
      NTD = 1
      LARGE = INT(INTMAX/N)
      DO J = 2, L
         IF (NTN <= LARGE) THEN
             NTN = (NTN*((N+1)-J))/J
         ELSE
             CALL FMI2M(NTN,MA)
             NTN = (N+1) - J
             NTD = J
             GO TO 110
         ENDIF
      ENDDO

  110 IF (NTD == 1) THEN
          CALL FMI2M(NTN,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      INTNDG = INT(ALOGMX/ALOGMB + 1.0)
      NEXTN = NTN
      NEXTD = NTD
      KSTART = NTD + 1
      NDSAVE = NDIG

!             Compute the rest of N choose K.

      LARGED = MIN(LARGE,INT(MXBASE))
      DO KT = KSTART, L
         NEXTN = NEXTN - 1
         NEXTD = NEXTD + 1
         IF (NTN >= LARGE .OR. NTD >= LARGED) THEN
             NDIG = MAX(2,MIN(NDSAVE,INT(MWK(START(MA)+2))+INTNDG))
             CALL FMCSMPYI_R1(MA,NTN)
             CALL FMCSDIVI_R1(MA,NTD)
             NTN = NEXTN
             NTD = NEXTD
             CYCLE
         ENDIF
         NMPY = NTN*NEXTN
         NDIV = NTD*NEXTD
         IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
             NTN = NMPY
             NTD = NDIV
         ELSE
             CALL FMGCDI(NMPY,NDIV)
             IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                 NTN = NMPY
                 NTD = NDIV
             ELSE
                 NDIG = MAX(2,MIN(NDSAVE,INT(MWK(START(MA)+2))+INTNDG))
                 CALL FMCSMPYI_R1(MA,NTN)
                 CALL FMCSDIVI_R1(MA,NTD)
                 NTN = NEXTN
                 NTD = NEXTD
             ENDIF
         ENDIF
      ENDDO
      NDIG = MAX(2,MIN(NDSAVE,INT(MWK(START(MA)+2))+INTNDG))
      CALL FMGCDI(NTN,NTD)
      CALL FMCSMPYI_R1(MA,NTN)
      CALL FMCSDIVI_R1(MA,NTD)
      NDIG = NDSAVE
      MWK(START(MA)+1) = NINT(ALOGM2*NDSAVE)

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCMBI

      SUBROUTINE FMCOMB(MA,MB,MC)

!  MC = MA choose MB.  (Binomial coefficient -- uses gamma for non-integers)

!  MC = (MA)! / ( (MB)! * (MA-MB)! )

!  This routine extends this definition to allow negative integer values for MA and/or MB.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE,MZERO
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K09,K10,K11,KASAVE,KBOT,KC,KFLGK,KFLGN,KFLGNK,KL,KOVUN,KR_RETRY,  &
                 KRESLT,KSIGN,KWRNSV,LARGE,N,NBOT,NDGOAL,NDOLD,NDSAVE,NGOAL,NK,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      LOGICAL :: LC1,LC2,LC3
      REAL :: X
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(17),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K = 0
      IF (MWK(START(MA)) < 0) THEN
          K10 = NTRACE
          NTRACE = 0
          K11 = KWARN
          KWARN = 0
          CALL FMM2I(MA,J)
          IF (KFLAG == 0) K = 1
          NTRACE = K10
          KWARN = K11
      ENDIF

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MB)+2) < -NDIG .AND. K == 0) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOMB'
              CALL FMNTR(2,MA,MB,2,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(1))
              MWK(START(MXY(1))) = MWK(START(MA))
          ELSE
              CALL FMEQ(MA,MXY(1))
          ENDIF
          IF (MWK(START(MB)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(2))
              MWK(START(MXY(2))) = MWK(START(MB))
          ELSE
              CALL FMEQ(MB,MXY(2))
          ENDIF
          CALL FMSUB(MXY(1),MXY(2),MXY(3))
          IF (MWK(START(MXY(3))+3) /= 0) THEN
              CALL FMPI(MXY(4))
              CALL FMSQR(MXY(4),MXY(5))
              CALL FMDIVI(MXY(5),6,MXY(4))
              CALL FMI2M(1,MXY(6))
              CALL FMPGAM(2,MXY(6),MXY(5))
              CALL FMMPY_R1(MXY(5),MXY(1))
              CALL FMDIVI_R1(MXY(5),2)
              CALL FMADD_R1(MXY(4),MXY(5))
              CALL FMMPY_R1(MXY(3),MXY(4))
              CALL FMMPY_R1(MXY(3),MXY(2))
              CALL FMADD_R2(MXY(6),MXY(3))
          ELSE
              CALL FMI2M(1,MXY(3))
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          CALL FMEQ(MXY(3),MC)
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOMB'
              CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      CALL FMENT2('FMCOMB   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KSIGN = 1
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

  120 CALL FMSUB(MXY(1),MXY(2),MXY(15))
      IF (MWK(START(MXY(2))+3) == 0) THEN
          CALL FMI2M(1,MXY(17))
          GO TO 130
      ENDIF
      CALL FMI2M(1,MXY(3))
      CALL FMSUB(MXY(2),MXY(3),MXY(4))
      IF (MWK(START(MXY(4))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(17))
          GO TO 130
      ENDIF

!             See if any of the terms are negative integers.

      CALL FMI2M(1,MXY(11))
      K10 = 0
      IF (MWK(START(MXY(1))) < 0) THEN
          CALL FMINT(MXY(1),MXY(7))
          IF (FMCOMP(MXY(1),'==',MXY(7))) K10 = -1
          IF (MWK(START(MA)+2) == MEXPOV)  K10 = -1
      ENDIF
      K11 = 0
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL FMINT(MXY(2),MXY(8))
          IF (FMCOMP(MXY(2),'==',MXY(8))) K11 = -1
          IF (MWK(START(MB)+2) == MEXPOV)  K11 = -1
      ENDIF
      K09 = 0
      IF (FMCOMP(MXY(1),'<',MXY(2))) THEN
          CALL FMMOD(MXY(1),MXY(11),MXY(9))
          CALL FMMOD(MXY(2),MXY(11),MXY(10))
          CALL FMSUB_R2(MXY(9),MXY(10))
          CALL FMINT(MXY(10),MXY(9))
          IF (FMCOMP(MXY(10),'==',MXY(9))) K09 = -1
      ENDIF

      CALL FMI2M(2,MXY(10))

      IF (K11 == -1) THEN
          CALL FMI2M(0,MXY(17))
          GO TO 130
      ELSE IF (MWK(START(MXY(15))+3) == 0) THEN
          CALL FMI2M(1,MXY(17))
          GO TO 130
      ELSE IF (K09 == -1 .AND. K10 == 0) THEN
          CALL FMI2M(0,MXY(17))
          GO TO 130
      ELSE IF (K10 == -1 .AND. K09 == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(17))
          KFLAG = -4
          GO TO 150
      ELSE IF (K10 == -1 .AND. K09 == -1) THEN
          JR = KROUND
          KROUND = 1
          CALL FMMOD(MXY(2),MXY(10),MXY(12))
          IF (MWK(START(MXY(12))+3) /= 0) KSIGN = -1
          CALL FMSUB(MXY(2),MXY(1),MXY(12))
          CALL FMSUB(MXY(12),MXY(11),MXY(1))
          CALL FMSUB(MXY(1),MXY(2),MXY(15))
          KROUND = JR
      ENDIF

!             Check for an obviously overflowed result.

      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1)))*MWK(START(MXY(1))+3) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+2) >= 1 .AND. MWK(START(MXY(2))+2) < MEXPOV) THEN
              CALL FMST2M('OVERFLOW',MXY(17))
              KFLAG = -5
              GO TO 150
          ENDIF
      ENDIF
      IF (MWK(START(MXY(1))+2) >= 10000) THEN
          CALL FMI2M(1,MXY(5))
          IF (FMCOMP(MXY(2),'>',MXY(5)) .AND. FMCOMP(MXY(2),'<',MXY(1))) THEN
              CALL FMSUB(MXY(1),MXY(2),MXY(5))
              CALL FMMIN(MXY(2),MXY(5),MXY(13))
              CALL FMSUB(MXY(1),MXY(13),MXY(5))
              CALL FMADDI(MXY(5),1)
              CALL FMDIV(MXY(5),MXY(13),MXY(12))
              CALL FMLN(MXY(12),MXY(5))
              CALL FMADDI(MXY(5),1)
              CALL FMMPY(MXY(13),MXY(5),MXY(12))
              CALL FMDPM(6.283185D0,MXY(3))
              CALL FMMPY(MXY(3),MXY(13),MXY(5))
              CALL FMLN(MXY(5),MXY(3))
              CALL FMDIVI(MXY(3),2,MXY(5))
              CALL FMSUB_R1(MXY(12),MXY(5))
              CALL FMEXP(MXY(12),MXY(4))
              IF (MWK(START(MXY(4))+2) == MEXPOV) THEN
                  CALL FMST2M('OVERFLOW',MXY(17))
                  KFLAG = -5
                  GO TO 150
              ENDIF
          ENDIF
      ENDIF

!             See if any of the terms are small integers.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),N)
      CALL FMM2I(MXY(2),K)
      KFLGK = KFLAG
      CALL FMM2I(MXY(15),NK)
      KFLGNK = KFLAG
      KWARN = KWRNSV

      CALL FMI2M(1,MXY(5))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(5),MXY(3))
      CALL FMSUB_R1(MXY(3),MXY(5))
      KROUND = JR
      IF (KFLGK == 0 .AND. MWK(START(MXY(3))+3) == 0) THEN
          CALL FMI2M(2,MXY(17))
          CALL FMMOD(MXY(2),MXY(17),MXY(5))
          CALL FMEQ(MXY(5),MXY(17))
          IF (MWK(START(MXY(17))+3) == 0) THEN
              CALL FMDIV(MXY(1),MXY(2),MXY(17))
              IF (MWK(START(MXY(17))+2) /= MUNKNO .AND. MWK(START(MXY(17))+3) /= 0)  &
                  MWK(START(MXY(17))) = -MWK(START(MXY(17)))
          ELSE
              CALL FMDIV(MXY(1),MXY(2),MXY(17))
          ENDIF
          GO TO 130
      ENDIF
      IF (KFLGK == 0 .AND. KFLGNK == 0 .AND. N /= 0) THEN
          IF (MIN(K,NK) <= 200) THEN
              CALL FMCMBI(N,K,MXY(17))
              GO TO 130
          ENDIF
      ENDIF
      NBOT = 0
      IF (KFLGK == 0 .AND. K <= 200) NBOT = K
      IF (KFLGNK == 0 .AND. NK <= 200) NBOT = NK
      IF (NBOT > 0) THEN
          LARGE = INT(MXBASE/NBOT)
          KBOT = 1
          CALL FMEQ(MXY(1),MXY(7))
          CALL FMEQ(MXY(1),MXY(8))
          CALL FMI2M(-1,MXY(9))
          DO J = 2, NBOT
             CALL FMADD_R1(MXY(7),MXY(9))
             CALL FMMPY_R2(MXY(7),MXY(8))
             KBOT = KBOT*J
             IF (KBOT >= LARGE) THEN
                 CALL FMDIVI_R1(MXY(8),KBOT)
                 KBOT = 1
             ENDIF
          ENDDO
          CALL FMDIVI(MXY(8),KBOT,MXY(17))
          GO TO 130
      ENDIF

!             General case.  Use FMFACT, unless one of the numbers is too big.  If so, use FMLNGM.

      X = ALOGMB*REAL(MXEXP)
      CALL FMSP2M(X/LOG(X),MXY(6))
      CALL FMABS(MXY(15),MXY(5))
      LC1 = FMCOMP(MXY(5),'>=',MXY(6))
      CALL FMABS(MXY(1),MXY(5))
      LC2 = FMCOMP(MXY(5),'>=',MXY(6))
      CALL FMABS(MXY(2),MXY(5))
      LC3 = FMCOMP(MXY(5),'>=',MXY(6))
      IF (LC1 .OR. LC2 .OR. LC3) THEN

!             See if the second argument is not very large and the first is much larger.
!             For many of these cases, Stirling's formula can be used to simplify Comb
!             and avoid cancellation.

          IF (MWK(START(MXY(1))+2) > MWK(START(MXY(2))+2) .AND. MWK(START(MXY(1))) > 0 .AND.  &
              MWK(START(MXY(2))) > 0) THEN
              CALL FMEQ(MXY(1),MXY(9))
              CALL FMEQ(MXY(2),MXY(10))
          ELSE
              CALL FMI2M(1,MXY(9))
              CALL FMI2M(1,MXY(10))
          ENDIF
          IF (MWK(START(MXY(9))+2) > NDIG .AND.  &
              MWK(START(MXY(9))+2) >= MWK(START(MXY(10))+2)+NDIG) THEN
              CALL FMI2M(1,MXY(5))
              CALL FMADD(MXY(10),MXY(5),MXY(16))
              CALL FMLN(MXY(9),MXY(5))
              CALL FMADDI(MXY(5),-1)
              CALL FMMPY(MXY(10),MXY(5),MXY(14))
              CALL FMADD_R2(MXY(10),MXY(14))
              CALL FMLNGM(MXY(16),MXY(15))
              CALL FMSUB(MXY(14),MXY(15),MXY(5))
              CALL FMEXP(MXY(5),MXY(12))
              CALL FMEQ(MXY(12),MXY(17))
              GO TO 130
          ENDIF

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          MZERO = 0
          IEXTRA = INT(MAX(MWK(START(MXY(15))+2),MWK(START(MXY(1))+2),MWK(START(MXY(2))+2),MZERO))
          IF (NDIG+IEXTRA > 3*10**5) THEN
              KFLAG = -4
              CALL FMST2M('UNKNOWN',MXY(17))
              GO TO 150
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          KFLGN = 1
          IF (K10 == -1 .AND. K09 == -1) THEN
              JR = KROUND
              KROUND = 1
              CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
              CALL FMM2I(MXY(1),N)
              KFLGN = KFLAG
              CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
              CALL FMSUB(MXY(2),MXY(1),MXY(12))
              CALL FMI2M(1,MXY(11))
              CALL FMSUB(MXY(12),MXY(11),MXY(1))
              KROUND = JR
          ENDIF

          CALL FMSUB(MXY(1),MXY(2),MXY(15))
          IF (KFLGN == 0 .AND. N == -1) MWK(START(MXY(15))+1) = MWK(START(MXY(1))+1)
          CALL FMI2M(1,MXY(9))
          CALL FMI2M(2,MXY(10))
          CALL FMADD(MXY(15),MXY(9),MXY(17))
          CALL FMADD_R1(MXY(1),MXY(9))
          CALL FMADD_R1(MXY(2),MXY(9))
          K10 = 0
          K11 = 0
          KC = 0
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMINT(MXY(1),MXY(11))
              CALL FMMOD(MXY(11),MXY(10),MXY(12))
              IF (MWK(START(MXY(12))+3) == 0) THEN
                  K10 = 1
                  CALL FMADD_R1(MXY(1),MXY(9))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))) < 0) THEN
              CALL FMINT(MXY(2),MXY(11))
              CALL FMMOD(MXY(11),MXY(10),MXY(12))
              IF (MWK(START(MXY(12))+3) == 0) THEN
                  K11 = 1
                  CALL FMADD_R1(MXY(2),MXY(9))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(17))) < 0) THEN
              CALL FMINT(MXY(17),MXY(11))
              CALL FMMOD(MXY(11),MXY(10),MXY(12))
              IF (MWK(START(MXY(12))+3) == 0) THEN
                  KC = 1
                  CALL FMADD_R1(MXY(17),MXY(9))
              ENDIF
          ENDIF
          CALL FMLNGM(MXY(1),MXY(15))
          CALL FMLNGM(MXY(2),MXY(16))
          CALL FMSUB_R1(MXY(15),MXY(16))
          CALL FMLNGM(MXY(17),MXY(16))
          CALL FMSUB_R1(MXY(15),MXY(16))
          CALL FMEXP(MXY(15),MXY(4))
          IF (K10 == 1 .OR. K11 == 1 .OR. KC == 1) THEN
              CALL FMI2M(1,MXY(9))
              IF (K10 == 1) THEN
                  CALL FMSUB_R1(MXY(1),MXY(9))
                  CALL FMDIV_R1(MXY(4),MXY(1))
              ENDIF
              IF (K11 == 1) THEN
                  CALL FMSUB_R1(MXY(2),MXY(9))
                  CALL FMMPY_R1(MXY(4),MXY(2))
              ENDIF
              IF (KC == 1) THEN
                  CALL FMSUB_R1(MXY(17),MXY(9))
                  CALL FMMPY_R1(MXY(4),MXY(17))
              ENDIF
          ENDIF
          CALL FMEQ(MXY(4),MXY(17))
      ELSE
          CALL FMFACT(MXY(1),MXY(16))
          CALL FMFACT(MXY(2),MXY(3))
          CALL FMFACT(MXY(15),MXY(17))
          CALL FMMPY(MXY(17),MXY(3),MXY(7))
          CALL FMDIV(MXY(16),MXY(7),MXY(17))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(17))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(17))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(17))+J+1)) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(17))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(17),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  150 MWK(START(MXY(17))) = KSIGN*MWK(START(MXY(17)))
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(17))+1) = MIN(MWK(START(MXY(17))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(17),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOMB

      FUNCTION FMDPLG(A)

!  Internal routine for computing an approximation to Log(Gamma(A)) using Stirling's formula.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: FMDPLG,A
      INTENT (IN) :: A

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (A > 0.0D0) THEN
          FMDPLG = -A + (A-0.5D0)*LOG(A) + DLOGTP/2.0D0
      ELSE IF (A < 0.0D0) THEN
          IF (ABS(A) < 1.0D+8) THEN
              FMDPLG = -(A-1.0D0) - (0.5D0-A)*LOG(1.0D0-A) - DLOGTP/2.0D0 -  &
                       LOG(ABS(SIN(DPPI*A))+1.0D-10) + DLOGPI
          ELSE
              FMDPLG = -(A-1.0D0) - (0.5D0-A)*LOG(1.0D0-A) - DLOGTP/2.0D0 + DLOGPI
          ENDIF
      ELSE

!             A = 0 is really an approximation for some value in [-1,1].

          FMDPLG = 0.0D0
      ENDIF
      RETURN
      END FUNCTION FMDPLG

      SUBROUTINE FMENT2(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision, overflow threshold, etc., upon entry
!  to an FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result immediately
!           (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KASAVE,KOVUN
      INTEGER :: K
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM)
      CALL FMARG2(NROUTN,NARGS,MA,MB,KRESLT)

      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      MXSAVE = MXEXP
      KASAVE = KACCSW
      IF (NCALL == 1 .OR. RAISE_NDIG > 0) THEN
          K = INT(NGRD52 + 1 + 0.002*NDIG + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          IF (KRESLT == 9 .OR. KRESLT == 10 .OR. KRESLT >= 13) THEN
              IF (KRAD == 1) THEN
                  CALL FMPI(MC)
              ELSE
                  CALL FMI2M(180,MC)
              ENDIF
              IF (KRESLT <= 10) CALL FMDIVI_R1(MC,2)
              IF (KRESLT >= 14) CALL FMDIVI_R1(MC,4)
              IF (KRESLT == 9 .OR. KRESLT == 14) MWK(START(MC)) = -1
              CALL FMEQU_R1(MC,NDIG,NDSAVE)
              NDIG = NDSAVE
              IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
              RETURN
          ENDIF

          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (NTRACE /= 0 .AND. NROUTN /= 'FMIBTA') THEN
              CALL FMNTR(1,MC,MC,1,1)
          ENDIF
          NCALL = NCALL - 1
          RETURN
      ENDIF

!             Extend the overflow/underflow threshold.

      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE FMENT2

      SUBROUTINE FMEULR(MA)

!  MA = Euler's constant ( 0.5772156649... )

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      CHARACTER(2315) :: STRING
      INTEGER :: K,KASAVE,NDMB,NDSAVE,NDSV
      INTEGER :: NUMBER_USED_SAVE
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMEULR'
      IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
          WRITE (KW,"(' Input to FMEULR')")
      ENDIF
      KASAVE = KACCSW

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = INT(5.0/ALOGMT + 2.0 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
          NDIG = MAX(NDIG+K,2)
      ENDIF

!             Check to see if Euler's constant has previously been saved in base MBASE with
!             sufficient precision.

      IF (MBSEUL == MBASE .AND. NDGEUL >= NDIG) THEN
          CALL FMEQU(M_EULER,MA,NDGEUL,NDSAVE)
      ELSE

!             Euler's constant is slower to compute than the other saved constants, so more digits
!             are stored in STRING for quick conversion.

          NDMB = INT(2300.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              STRING = '0.57721566490153286060651209008240243104215933593992359880576723488486'//  &
              '7726777664670936947063291746749514631447249807082480960504014486542836224173997'//  &
              '6449235362535003337429373377376739427925952582470949160087352039481656708532331'//  &
              '5177661152862119950150798479374508570574002992135478614669402960432542151905877'//  &
              '5535267331399254012967420513754139549111685102807984234877587205038431093997361'//  &
              '3725530608893312676001724795378367592713515772261027349291394079843010341777177'//  &
              '8088154957066107501016191663340152278935867965497252036212879226555953669628176'//  &
              '3887927268013243101047650596370394739495763890657296792960100901512519595092224'//  &
              '3501409349871228247949747195646976318506676129063811051824197444867836380861749'//  &
              '4551698927923018773910729457815543160050021828440960537724342032854783670151773'//  &
              '9439870030237033951832869000155819398804270741154222781971652301107356583396734'//  &
              '8717650491941812300040654693142999297779569303100503086303418569803231083691640'//  &
              '0258929708909854868257773642882539549258736295961332985747393023734388470703702'//  &
              '8441292016641785024873337908056275499843459076164316710314671072237002181074504'//  &
              '4418664759134803669025532458625442225345181387912434573501361297782278288148945'//  &
              '9098638460062931694718871495875254923664935204732436410972682761608775950880951'//  &
              '2620840454447799229915724829251625127842765965708321461029821461795195795909592'//  &
              '2704208989627971255363217948873764210660607065982561990102880756125199137511678'//  &
              '2176436190570584407835735015800560774579342131449885007864151716151945657061704'//  &
              '3245075008168705230789093704614306684817916496842549150496724312183783875356489'//  &
              '4950868454102340601622508515583867234944187880440940770106883795111307872023426'//  &
              '3952269209716088569083825113787128368204911789259447848619911852939102930990592'//  &
              '5526691727446892044386971114717457157457320393520912231608508682755889010945168'//  &
              '1181016874975470969366671210206304827165895049327314860874940207006742590918248'//  &
              '7596213738423114426531350292303175172257221628324883811245895743862398703757662'//  &
              '8551303314392999540185313414158621278864807611003015211965780068117773763501681'//  &
              '8389733896639868957932991456388644310370608078174489957958324579418962026049841'//  &
              '0439225078604603625277260229196829958609883390137871714226917883819529844560791'//  &
              '6051972797360475910251099577913351579177225150254929324632502874767794842158405'//  &
              '07599290401855764599018627262'
              CALL FMST2M(STRING,M_EULER)
              MWK(START(M_EULER)+1) = NINT(NDIG*ALOGM2)
              MBSEUL = MBASE
              NDGEUL = NDIG
              IF (ABS(MWK(START(M_EULER)+2)) > 10) NDGEUL = 0
              CALL FMEQU(M_EULER,MA,NDIG,NDSAVE)
              NDIG = NDSV
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMEULR_B(M_EULER)
              MWK(START(M_EULER)+1) = NINT(NDIG*ALOGM2)
              MBSEUL = MBASE
              NDGEUL = NDIG
              IF (ABS(MWK(START(M_EULER)+2)) > 10) NDGEUL = 0
              CALL FMEQU(M_EULER,MA,NDIG,NDSAVE)
              NDIG = NDSV
          ENDIF
      ENDIF

      NDIG = NDSAVE
      KACCSW = KASAVE
      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEULR

      SUBROUTINE FMEULR_B(MB)

!  MB = Euler's constant = .577215...

!  Binary splitting version.
!  Called by FMEULR for large NDIG.  Faster and saves memory by not using Bernoulli numbers.

!  Sum f(x) = 1 + x/(1!)^2 + x^2/(2!)^2 + ...
!  and g(x) = H(1)*x/(1!)^2 + H(2)*x^2/(2!)^2 + ...
!  where H(n) = 1 + 1/2 + ... + 1/n.

!  As x --> infinity, g(x)/f(x) - Ln(x)/2 --> Euler's constant.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MB
      REAL (KIND(1.0D0)) :: MD2B,MXSAVE
      INTEGER :: K,KASAVE,KT,N,NDSAVE
      INTENT (INOUT) :: MB
      INTEGER :: MXY(7),NUMBER_USED_SAVE,X

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      X = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Determine X, variable in the series.

      N = NDIG*DLOGMB/4
      DO
         K = N
         DO
            KT = K/2
            IF (2*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/3
            IF (3*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/5
            IF (5*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/7
            IF (7*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         IF (K == 1) EXIT
         N = N + 1
      ENDDO

      CALL IMI2M(N,MXY(1))
      CALL IMSQR(MXY(1),X)

!             Determine K, the number of terms to sum in the series.

      K = 3.5912D0*N
      CALL FMEULR_PTDCV(0,K,MXY(1),MXY(2),MXY(3),MXY(4),MXY(5),X)
      IF (MWK(START(MXY(3))+2) >= NDIG) THEN
          CALL FMEQ(MXY(3),MXY(7))
      ELSE
          CALL IMI2FM(MXY(3),MXY(7))
      ENDIF
      CALL FMSQR(MXY(7),MXY(4))
      IF (MWK(START(MXY(2))+2) >= NDIG) THEN
          CALL FMEQ(MXY(2),MXY(1))
      ELSE
          CALL IMI2FM(MXY(2),MXY(1))
      ENDIF
      CALL FMDIV(MXY(1),MXY(4),MXY(6))
      CALL FMADDI(MXY(6),1)

      CALL FMMPY(MXY(7),MXY(4),MXY(1))
      IF (MWK(START(MXY(5))+2) >= NDIG) THEN
          CALL FMEQ(MXY(5),MXY(4))
      ELSE
          CALL IMI2FM(MXY(5),MXY(4))
      ENDIF
      CALL FMDIV(MXY(4),MXY(1),MXY(2))

      CALL FMDIV(MXY(2),MXY(6),MXY(5))
      CALL FMLNI(N,MXY(1))
      CALL FMSUB(MXY(5),MXY(1),M_EULER)

!             Round the result and return.

      MD2B = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
      MWK(START(MXY(3))+1) = MD2B
      CALL FMEXIT(M_EULER,MB,NDSAVE,MXSAVE,KASAVE,0)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEULR_B

      RECURSIVE SUBROUTINE FMEULR_PTDCV(A,B,MP,MT,MD,MC,MV,MX)

!  This routine does the binary splitting for computing Euler's constant.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP,MT,MD,MC,MV,MX
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP,MT,MD,MC,MV,MX
      INTEGER :: MXY(10),NUMBER_USED_SAVE,J,JP,JD,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*MWK(START(MX)+2) ) + 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF
      JP = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -  &
                    ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 ) / DLOGMB + 10
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      JD = RESULT_SIZE
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      CALL IMI2M(A,MXY(1))
      IF (MWK(START(MXY(1))+2) > MWK(START(MX)+2)) THEN
          RESULT_SIZE = MWK(START(MX)+2) + 4*JD
      ELSE
          RESULT_SIZE = JP + 2*JD
      ENDIF
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = RESULT_SIZE + JD
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MV <= 0) THEN
          CALL IMDEFINE(MV,RESULT_SIZE)
      ELSE IF (SIZE_OF(MV) < RESULT_SIZE) THEN
          CALL IMDEFINE(MV,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 12) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)

          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MX,MXY(2),MP)

          CALL IMI2M(1,MD)
          DO J = A, B-1, 2
             CALL IMMPYI(MD,J+1,MXY(1))
             CALL IMMPYI(MXY(1),J+2,MD)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MD,B+1,MXY(1))
              CALL IMEQ(MXY(1),MD)
          ENDIF

          CALL IMI2M(0,MC)
          DO J = A, B
             CALL IMDIVI(MD,J+1,MXY(2))
             CALL IMADD(MC,MXY(2),MXY(3))
             CALL IMEQ(MXY(3),MC)
          ENDDO

!             MT is the T sum
!             MXY(1) is the next term
!             MV is the V sum
!             MXY(3) is the harmonic sum in the V terms

          CALL IMI2M(0,MT)
          CALL IMI2M(0,MV)
          CALL IMSQR(MD,MXY(1))
          CALL IMI2M(0,MXY(3))
          DO J = A, B
             CALL IMDIVI(MXY(1),J+1,MXY(2))
             CALL IMDIVI(MXY(2),J+1,MXY(1))
             CALL IMMPY(MXY(1),MX,MXY(2))
             CALL IMEQ(MXY(2),MXY(1))
             CALL IMADD(MT,MXY(1),MXY(2))
             CALL IMEQ(MXY(2),MT)

             CALL IMDIVI(MD,J+1,MXY(4))
             CALL IMADD(MXY(3),MXY(4),MXY(5))
             CALL IMEQ(MXY(5),MXY(3))
             CALL IMMPY(MXY(1),MXY(3),MXY(5))
             CALL IMADD(MV,MXY(5),MXY(2))
             CALL IMEQ(MXY(2),MV)
          ENDDO
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMEULR_PTDCV(A,M-1,MXY(1),MXY(2),MXY(3),MXY(4),MXY(5),MX)
      CALL FMEULR_PTDCV(M,B,MXY(6),MXY(7),MXY(8),MXY(9),MXY(10),MX)
      CALL IM_OR_FM_MPY(MXY(1),MXY(7),MT)
      CALL IM_OR_FM_SQR(MXY(8),MP)
      CALL IM_OR_FM_MPY(MXY(4),MXY(8),MD)

!             MP and MC are not needed in FMEULR_B, so their calculations can be skipped at the
!             top level of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(9),MXY(3),MXY(4))
          CALL IM_OR_FM_ADD(MD,MXY(4),MC)
      ELSE
          CALL IMI2M(0,MC)
      ENDIF

      CALL IM_OR_FM_MPY(MD,MT,MXY(4))
      CALL IM_OR_FM_MPY(MP,MXY(8),MV)
      CALL IM_OR_FM_MPY(MV,MXY(5),MXY(9))
      CALL IM_OR_FM_ADD(MXY(9),MXY(4),MV)
      CALL IM_OR_FM_MPY(MXY(3),MXY(1),MXY(4))
      CALL IM_OR_FM_MPY(MXY(4),MXY(10),MXY(9))
      CALL IM_OR_FM_ADD(MV,MXY(9),MXY(4))
      CALL IM_OR_FM_EQ(MXY(4),MV)

      CALL IM_OR_FM_MPY(MXY(3),MXY(8),MD)

      CALL IM_OR_FM_MPY(MP,MXY(2),MXY(3))
      CALL IM_OR_FM_ADD(MXY(3),MT,MXY(8))
      CALL IM_OR_FM_EQ(MXY(8),MT)

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(1),MXY(6),MP)
      ELSE
          CALL IMI2M(0,MP)
      ENDIF

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          IF (TEMPV(MV) == -1) TEMPV(MV) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMEULR_PTDCV

      SUBROUTINE FMEXT2(MT,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Upon exit from an FM routine, the result MT (having precision NDIG) is rounded and returned
!  in MC (having precision NDSAVE).  The values of NDIG, MXEXP, and KACCSW are restored.
!  KOVUN is nonzero if one of the routine's input arguments was overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT
      INTENT (INOUT) :: MC,NDSAVE,MXSAVE,KASAVE,KOVUN
      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      CALL FMEQU(MT,MC,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF ((MWK(START(MC)+2) == MUNKNO .AND. KFLAG /= -9)     &
         .OR. (MWK(START(MC)+2) == MEXPUN .AND. KOVUN == 0)  &
         .OR. (MWK(START(MC)+2) == MEXPOV .AND. KOVUN == 0)) CALL FMWRN2
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      KACCSW = KASAVE
      RETURN
      END SUBROUTINE FMEXT2

      SUBROUTINE FMFACT(MA,MB)

!  MB = MA!  ( = GAMMA(MA+1))

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMFACT'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMEULR(MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(3))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB(MXY(1),MXY(3),MB)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMFACT'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      CALL FMENT2('FMFACT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMADDI(MXY(1),1)
      CALL FMGAM(MXY(1),MXY(2))
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFACT

      SUBROUTINE FMFCTI(NUM,MA)

!  MA = NUM factorial, where NUM is an integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NUM
      INTEGER :: MA

      INTEGER :: J,JK,K,LARGE
      INTENT (IN) :: NUM
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMI2M(1,MA)
      IF (NUM <= 1) THEN
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      J = NUM
      K = 1
      LARGE = INT(INTMAX/J)
      DO JK = 2, J
         K = K*JK
         IF (K > LARGE) THEN
             CALL FMCSMPYI_R1(MA,K)
             K = 1
         ENDIF
      ENDDO
      IF (K > 1) CALL FMMPYI_R1(MA,K)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFCTI

      SUBROUTINE FMGAM(MA,MB)

!  MB = GAMMA(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,X,Z
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K1,K2,KASAVE,KDIFF,KFL,KL,KOVUN,KC_RETRY,KR_RETRY,KRESLT,  &
                 KRFLCT,KRSAVE,KSIGN,KWRNSV,KWSAVE,LARGE,LSHIFT,NDGOAL,NDOLD,NDSAV1,NDSAV2,       &
                 NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(17),MJSUMS(LJSUMS),MRETRY,NUMBER_USED_SAVE
      INTEGER, SAVE :: C(0:196) = -3, NDIG_C = 0
      REAL (KIND(1.0D0)), SAVE :: MBASE_C = 0

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMGAM'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMI2M(1,MXY(1))
          CALL FMDIV(MXY(1),MA,MXY(2))
          CALL FMEULR(MXY(1))
          CALL FMSUB(MXY(2),MXY(1),MB)
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (KFLAG == -5 .AND. MWK(START(MA)+2) > MEXPUN) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMGAM'
              CALL FMWRN2
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMGAM'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      CALL FMENT2('FMGAM    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0
      KC_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             See if there is a small integer separating this argument from the last one.

      IF (MBASE == MBSGAM .AND. NDIG <= NDGGAM) THEN
          IF (MWK(START(MA)) == -1) THEN
              CALL FMINT(MXY(1),MXY(10))
              IF (FMCOMP(MXY(1),'==',MXY(10))) THEN
                  CALL FMST2M('UNKNOWN',MXY(11))
                  KFLAG = -4
                  GO TO 220
              ENDIF
          ENDIF
          CALL FMSUB(MXY(1),M_GAMMA_MA,MXY(7))
          IF (MWK(START(MXY(7))+3) == 0) THEN
              CALL FMEQ(M_GAMMA_MB,MXY(11))
              GO TO 220
          ENDIF
          KWRNSV = KWARN
          KWARN = 0
          CALL FMM2I(MXY(7),KDIFF)
          KWARN = KWRNSV
          IF (KFLAG == 0 .AND. ABS(KDIFF) <= 50) THEN
              IF (KDIFF > 0) THEN
                  CALL FMEQ(M_GAMMA_MA,MXY(10))
              ELSE
                  CALL FMEQ(MXY(1),MXY(10))
              ENDIF
              CALL FMEQ(MXY(10),MXY(9))
              DO J = 1, ABS(KDIFF)-1
                 CALL FMI2M(1,MXY(5))
                 CALL FMADD_R1(MXY(10),MXY(5))
                 CALL FMMPY_R1(MXY(9),MXY(10))
              ENDDO
              IF (KDIFF > 0) THEN
                  CALL FMMPY(M_GAMMA_MB,MXY(9),MXY(11))
              ELSE
                  CALL FMDIV(M_GAMMA_MB,MXY(9),MXY(11))
              ENDIF
              GO TO 200
          ENDIF
      ENDIF
      CALL FMEQ(MXY(1),MXY(15))

!             Near zero Gamma(x) is about 1/x.

  120 IF (MWK(START(MXY(15))+2) < (-NDIG-3)) THEN
          CALL FMI2M(1,MXY(5))
          CALL FMDIV(MXY(5),MXY(15),MXY(11))
          GO TO 200
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDPM(DBLE(-0.5),MXY(7))
      IF (FMCOMP(MXY(15),'<=',MXY(7))) THEN
          KRFLCT = 1
          KFL = 0
          IF (MWK(START(MXY(1))+2) <= NDSAVE) THEN
              CALL FMINT(MXY(15),MXY(10))
              IF (FMCOMP(MXY(15),'==',MXY(10))) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(11))
              KFLAG = -4
              GO TO 220
          ELSE
              CALL FMI2M(1,MXY(5))
              CALL FMSUB_R2(MXY(5),MXY(15))
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      CALL FMNINT(MXY(15),MXY(2))
      CALL FMSUB(MXY(15),MXY(2),MXY(6))
      MWK(START(MXY(6))+1) = MWK(START(MXY(1))+1)
      CALL FMM2DP(MXY(6),Z)
      Z = MAX(ABS(Z),1.0D-50)
      IF (KFLAG /= 0 .OR. ABS(Z) >= 1) THEN
          NMETHD = 2
      ELSE
          IF (190*LOG(Z) - 77*DLOGTN >= -(NDIG+1)*DLOGMB .OR. -190*DLOGTN >= -NDIG*DLOGMB) THEN
              NMETHD = 2
          ENDIF
      ENDIF
      CALL FMM2DP(MXY(15),X)
      IF (KFLAG /= 0) THEN
          NMETHD = 2
      ELSE IF (NMETHD == 1) THEN
          IF (X > 145 - (8+NDIG*DLOGMB/(25*DLOGTN))*LOG(Z) .OR. X > 250) NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 180

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      IF (MWK(START(MA)) > 0 .AND. NDSAVE+NGRD52 < NDIG .AND. KR_RETRY == 0 .AND. KC_RETRY == 0)  &
          NDIG = NDSAVE + NGRD52

!             Since precision may have changed, check again to see if the saved value from a
!             previous call can be used as a shortcut.

      IF (MBASE == MBSGAM .AND. NDIG <= NDGGAM) THEN
          IF (MWK(START(MA)) == -1) THEN
              CALL FMINT(MXY(1),MXY(10))
              IF (FMCOMP(MXY(1),'==',MXY(10))) THEN
                  CALL FMST2M('UNKNOWN',MXY(11))
                  KFLAG = -4
                  GO TO 220
              ENDIF
          ENDIF
          CALL FMSUB(MXY(1),M_GAMMA_MA,MXY(7))
          IF (MWK(START(MXY(7))+3) == 0) THEN
              CALL FMEQ(M_GAMMA_MB,MXY(11))
              GO TO 220
          ENDIF
          KWRNSV = KWARN
          KWARN = 0
          CALL FMM2I(MXY(7),KDIFF)
          KWARN = KWRNSV
          IF (KFLAG == 0 .AND. ABS(KDIFF) <= 50) THEN
              IF (KDIFF > 0) THEN
                  CALL FMEQ(M_GAMMA_MA,MXY(10))
              ELSE
                  CALL FMEQ(MXY(1),MXY(10))
              ENDIF
              CALL FMEQ(MXY(10),MXY(9))
              DO J = 1, ABS(KDIFF)-1
                 CALL FMI2M(1,MXY(5))
                 CALL FMADD_R1(MXY(10),MXY(5))
                 CALL FMMPY_R1(MXY(9),MXY(10))
              ENDDO
              IF (KDIFF > 0) THEN
                  CALL FMMPY(M_GAMMA_MB,MXY(9),MXY(11))
              ELSE
                  CALL FMDIV(M_GAMMA_MB,MXY(9),MXY(11))
              ENDIF
              GO TO 200
          ENDIF
      ENDIF
      CALL FMM2I(MXY(2),LSHIFT)
      LSHIFT = LSHIFT - 3
      IF (NDIG_C < NDIG .OR. MBASE_C /= MBASE) THEN
          CALL FMGAM_C(NDIG_C,MBASE_C,C)
      ENDIF
      J2 = (0.38*LOG(Z) + 4.1)*(NDIG*DLOGMB/(84*DLOGTN))
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      NDSAV1 = NDIG
      DO J = 1, 2
         CALL FMEQ(C(J-1),MJSUMS(J))
      ENDDO
      CALL FMSQR(MXY(6),MXY(5))
      CALL FMEQ(MXY(5),MXY(17))
      NTERM = 1
  130 IF (NTERM > 1) THEN
          K = NDIG
          NDIG = NDSAV1
          CALL FMCSMPY_R1(MXY(17),MXY(5))
          NDIG = K
      ENDIF
      DO J = 1, 2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(17),MXY(4))
         CALL FMCSMPY_R1(MXY(4),C(NTERM))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0 .OR. NTERM == 13) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130
  140 KFL = KFLAG
      KFLAG = 0
      CALL FMCSNSUMS(2,MJSUMS)
      NDIG = NDSAV1
      CALL FMEQ(MJSUMS(2),MXY(16))
      CALL FMEQ(MXY(6),MXY(3))
      CALL FMCSMPY_R1(MXY(16),MXY(3))
      CALL FMCSADD_R1(MXY(16),MJSUMS(1))
      IF (KFL == 0) THEN
          CALL FMCSMPY_R1(MXY(17),MXY(5))
      ELSE
          CALL FMI2M(0,MXY(8))
          GO TO 170
      ENDIF
      CALL FMI2M(1,MXY(4))
      DO J = 14, J2+13
         CALL FMADD(C(J),MXY(4),MJSUMS(J-13))
      ENDDO
      CALL FMIPWR(MXY(6),J2,MXY(5))
      CALL FMEQ(MXY(5),MXY(7))
      NTERM = J2 + 13
  150 IF (NTERM > J2+13) CALL FMCSMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(7),MXY(4))
         CALL FMCSMPY_R1(MXY(4),C(NTERM))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0 .OR. NTERM == 196) GO TO 160
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 150
  160 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      NDIG = NDSAV1
      IF (NTERM == 196) THEN
          GO TO 180
      ENDIF
      CALL FMI2M(1,MXY(4))
      CALL FMSUB(MJSUMS(J2),MXY(4),MXY(8))
      CALL FMEQ(MXY(6),MXY(3))
      MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(3))
         CALL FMSUB_R1(MJSUMS(J2-J+1),MXY(4))
         CALL FMCSADD_R1(MXY(8),MJSUMS(J2-J+1))
      ENDDO

!             Recover from using a shifted argument.

  170 CALL FMCSMPY_R1(MXY(8),MXY(17))
      CALL FMADD(MXY(8),MXY(16),MXY(10))
      IF (LSHIFT < 0) THEN
          CALL FMEQ(MXY(15),MXY(3))
          CALL FMEQ(MXY(15),MXY(14))
          DO J = 2, -LSHIFT
             CALL FMADDI(MXY(14),1)
             CALL FMCSMPY_R1(MXY(3),MXY(14))
          ENDDO
          CALL FMDIV_R1(MXY(10),MXY(3))
      ENDIF
      IF (LSHIFT > 0) THEN
          IF (MOD(LSHIFT,4) == 0) THEN
              CALL FMI2M(1,MXY(3))
              CALL FMEQ(MXY(6),MXY(14))
              CALL FMADDI(MXY(14),3)
          ELSE
              CALL FMEQ(MXY(6),MXY(3))
              CALL FMADDI(MXY(3),3)
              CALL FMEQ(MXY(3),MXY(14))
              DO J = 1, MOD(LSHIFT,4)-1
                 CALL FMADDI(MXY(14),1)
                 CALL FMCSMPY_R1(MXY(3),MXY(14))
              ENDDO
              CALL FMADDI(MXY(14),1)
          ENDIF
          LSHIFT = LSHIFT - MOD(LSHIFT,4)

!             The product Z*(Z+1)*...*(Z+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(14) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

          CALL FMI2M(1,MXY(11))
          IF (LSHIFT > 0) THEN
              CALL FMSQR(MXY(14),MXY(6))
              CALL FMMPY(MXY(14),MXY(6),MXY(7))
              CALL FMSQR(MXY(6),MXY(8))
              CALL FMCSMPYI(MXY(7),6,MXY(12))
              CALL FMCSADD_R1(MXY(8),MXY(12))
              CALL FMCSMPYI(MXY(6),11,MXY(12))
              CALL FMCSADD_R1(MXY(8),MXY(12))
              CALL FMCSMPYI(MXY(14),6,MXY(12))
              CALL FMCSADD_R1(MXY(8),MXY(12))
              CALL FMEQ(MXY(8),MXY(11))
              CALL FMCSMPYI_R1(MXY(7),16)
              DO K = 0, LSHIFT-8, 4
                 CALL FMCSADD_R1(MXY(8),MXY(7))
                 K2 = 24*(2*K + 7)
                 CALL FMCSMPYI(MXY(6),K2,MXY(12))
                 CALL FMCSADD_R1(MXY(8),MXY(12))
                 IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                     K1 = 8*(6*K*K + 42*K + 79)
                     CALL FMCSMPYI(MXY(14),K1,MXY(12))
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ELSE
                     K1 = 48*K
                     CALL FMCSMPYI(MXY(14),K1,MXY(12))
                     CALL FMCSMPYI_R1(MXY(12),K)
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                     K1 = 336*K + 632
                     CALL FMCSMPYI(MXY(14),K1,MXY(12))
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ENDIF
                 IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                     K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                     CALL FMADDI(MXY(8),K0)
                 ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12))
                     K0 = K*K + 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0)
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ELSE
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12))
                     CALL FMCSMPYI(MXY(12),K,MXY(9))
                     CALL FMCSMPYI_R1(MXY(9),K)
                     CALL FMCSADD_R1(MXY(8),MXY(9))
                     K0 = 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0)
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ENDIF
                 CALL FMCSMPY_R1(MXY(11),MXY(8))
              ENDDO
          ENDIF
          CALL FMCSMPY_R1(MXY(11),MXY(3))
          CALL FMCSMPY_R1(MXY(10),MXY(11))
      ENDIF
      CALL FMEQ(MXY(10),MXY(11))
      GO TO 190

!             Method 2.  Use the Ln(Gamma(z)) asymptotic series, then use exp.
!                        To speed the asymptotic series calculation,
!                        increase the argument by LSHIFT.

  180 KWSAVE = KWARN
      KWARN = 0
      CALL FMM2I(MXY(15),INTA)
      KWARN = KWSAVE

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)
      IF (KFLAG == 0) THEN
          IF (INTA <= MAX(200,INT(DLOGMB*NDIG))) THEN
              IF (INTA <= 2) THEN
                  CALL FMI2M(1,MXY(11))
                  GO TO 190
              ENDIF
              INTA = INTA - 1
              CALL FMFCTI(INTA,MXY(11))
              GO TO 190
          ENDIF
      ENDIF

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(5))
          CALL FMADD(MXY(15),MXY(5),MXY(14))
      ELSE
          CALL FMEQ(MXY(15),MXY(14))
      ENDIF

!             Get Gamma for the shifted argument.

!             Compute IEXTRA, the number of extra digits required to compensate for cancellation
!             error when the argument is large.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(14))+2))-1,0),INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(14),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(15),NDIG,NDIG+IEXTRA)
      ENDIF
      NDSAV2 = NDIG
      NDIG = NDIG + IEXTRA
      CALL FMLNGM(MXY(14),MXY(4))
      CALL FMEXP(MXY(4),MXY(11))

      NDIG = NDSAV2

!             Reverse the shifting.
!             The product MA*(MA+1)*...*(MA+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(6)  is Z
!             MXY(7)  is Z**2
!             MXY(8)  is Z**3
!             MXY(9)  is (Z+K)*...*(Z+K+3)
!             MXY(12) is the current product

      CALL FMEQ(MXY(15),MXY(6))
      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(6),MXY(7))
          CALL FMMPY(MXY(6),MXY(7),MXY(8))
          CALL FMSQR(MXY(7),MXY(9))
          CALL FMCSMPYI(MXY(8),6,MXY(13))
          CALL FMCSADD_R1(MXY(9),MXY(13))
          CALL FMCSMPYI(MXY(7),11,MXY(13))
          CALL FMCSADD_R1(MXY(9),MXY(13))
          CALL FMCSMPYI(MXY(6),6,MXY(13))
          CALL FMCSADD_R1(MXY(9),MXY(13))
          CALL FMEQ(MXY(9),MXY(12))
          CALL FMCSMPYI_R1(MXY(8),16)
          LARGE = INTMAX
          DO K = 0, LSHIFT-8, 4
             CALL FMCSADD_R1(MXY(9),MXY(8))
             K2 = 24*(2*K + 7)
             CALL FMCSMPYI(MXY(7),K2,MXY(13))
             CALL FMCSADD_R1(MXY(9),MXY(13))
             IF (K <= SQRT(REAL(LARGE)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMCSMPYI(MXY(6),K1,MXY(13))
                 CALL FMCSADD_R1(MXY(9),MXY(13))
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(6),K1,MXY(13))
                 CALL FMCSMPYI_R1(MXY(13),K)
                 CALL FMCSADD_R1(MXY(9),MXY(13))
                 K1 = 336*K + 632
                 CALL FMCSMPYI(MXY(6),K1,MXY(13))
                 CALL FMCSADD_R1(MXY(9),MXY(13))
             ENDIF
             IF (K <= (REAL(LARGE)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(9),K0)
             ELSE IF (K <= SQRT(REAL(LARGE)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(13))
                 K0 = K*K + 7*K + 15
                 CALL FMCSMPYI_R1(MXY(13),K0)
                 CALL FMCSADD_R1(MXY(9),MXY(13))
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(13))
                 CALL FMCSMPYI(MXY(13),K,MXY(10))
                 CALL FMCSMPYI_R1(MXY(10),K)
                 CALL FMCSADD_R1(MXY(9),MXY(10))
                 K0 = 7*K + 15
                 CALL FMCSMPYI_R1(MXY(13),K0)
                 CALL FMCSADD_R1(MXY(9),MXY(13))
             ENDIF
             CALL FMCSMPY_R1(MXY(12),MXY(9))
          ENDDO
          CALL FMDIV_R1(MXY(11),MXY(12))
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

  190 IF (KRFLCT == 1) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(15),MXY(7))
          CALL FMDIVI(MXY(7),2,MXY(8))
          CALL FMINT(MXY(8),MXY(2))
          CALL FMMPYI(MXY(2),2,MXY(9))
          KSIGN = -1
          IF (FMCOMP(MXY(7),'==',MXY(9))) KSIGN = 1
          CALL FMSUB(MXY(15),MXY(7),MXY(10))
          MWK(START(MXY(10))+1) = MWK(START(MXY(15))+1)
          CALL FMPI(MXY(12))
          CALL FMMPY_R1(MXY(12),MXY(10))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMSIN(MXY(12),MXY(3))
          MWK(START(MXY(3))) = KSIGN*MWK(START(MXY(3)))
          KRAD = KRSAVE
          CALL FMDIV_R2(MPISAV,MXY(3))
          CALL FMDIV_R2(MXY(3),MXY(11))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  200 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(11))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(11))+J+1)) GO TO 210
              ENDDO
              GO TO 220
          ENDIF
  210     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(11))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(15))
          KC_RETRY = 1
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  220 MACMAX = NINT(NDSAVE*ALOGM2)
      J = MWK(START(MXY(11))+1)
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)

      CALL FMEQ(MXY(1),M_GAMMA_MA)
      CALL FMEQ(MXY(11),M_GAMMA_MB)
      MWK(START(M_GAMMA_MB)+1) = J
      NDGGAM = NDIG
      IF (ABS(MWK(START(M_GAMMA_MB)+2)) > MEXPOV) NDGGAM = 0
      MBSGAM = MBASE

      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMGAM

      SUBROUTINE FMGAM_C(NDIG_C,MBASE_C,C)

!  Initialize the constants used in the gamma polynomial.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: C(0:196),NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      INTENT (INOUT) :: C,NDIG_C,MBASE_C
      INTEGER :: NDSAVE
      CHARACTER(220) :: ST

      NDSAVE = NDIG
      NDIG = MAX(NDIG,NINT(210*DLOGTN/DLOGMB))
      NDIG_C = NDIG
      MBASE_C = MBASE

      ST = " 2 "
      CALL FMST2M(ST,C(0))
      ST = " 1.845568670196934278786975819835195137915681328120152802388465530" //  &
           "230264546444670658126105873416506500970737105500385835038078991971" //  &
           "02691432755165200471015292749299933251412532452465211441480948350581017M+0"
      CALL FMST2M(ST,C(1))
      ST = " 1.246464995951346528971255032754062122751889033636657384469089862" //  &
           "717670083765963530684050979376234434063149542816318341831199882570" //  &
           "54136293454241409125655601075903604372266188019198826399323980756659507M+0"
      CALL FMST2M(ST,C(2))
      ST = " 5.749941689206122275465545297069514629181683280995911506411578080" //  &
           "726118046263102563376406423582057300595042023225863076035376079997" //  &
           "58104823944616583929664137138189407083120305067949277678404599957423943M-1"
      CALL FMST2M(ST,C(3))
      ST = " 2.300749407541140630184757374755110638744965329574536384291172327" //  &
           "224547634301735916779398033223621567106468104559113876289562540922" //  &
           "49810183476230067472728208959273220898874770326648720581128183324434328M-1"
      CALL FMST2M(ST,C(4))
      ST = " 7.371504661602386878317788712652808511825657580343462427360683175" //  &
           "509260544574956944742301697314778437297368730369274995615677873789" //  &
           "35133238331475104267889872993214666032986278826546933416543800481312385M-2"
      CALL FMST2M(ST,C(5))
      ST = " 2.204110936751696733001055930504381988327566876073187686154801967" //  &
           "909973103233273981903764688650115297934327575508639951789708251337" //  &
           "92707722587521058280471694968009955629145006098566559417433720825728363M-2"
      CALL FMST2M(ST,C(6))
      ST = " 5.448754075820309416743506865467445124448139461938118242185774040" //  &
           "091229588005782816224467061542163141883870132680748064163312525326" //  &
           "79285947455982778971828128624591203392889667559929450792010659863151692M-3"
      CALL FMST2M(ST,C(7))
      ST = " 1.355220860239435200782800511692912879531376156061699075016521316" //  &
           "639789508602632933261809843993626303860552687494426922068347662436" //  &
           "50638664308894605216771132545723510121680479395222846647397509645416658M-3"
      CALL FMST2M(ST,C(8))
      ST = " 2.647856630454963762916703027588487719988377646494592862588577877" //  &
           "670108768701128952589855350528375734341831836105261848089596212014" //  &
           "43438318203511988335596380750860411655605437077878364306986421443576571M-4"
      CALL FMST2M(ST,C(9))
      ST = " 6.120306281920072864297933044336079606323020239995311203374612431" //  &
           "474530317806041317622369821667524651305326663533305730887143946711" //  &
           "61266460849960962516510977842732486514289292246744768624817147886489117M-5"
      CALL FMST2M(ST,C(10))
      ST = " 8.505579174881354789674853004022777303159200477826996950880457101" //  &
           "421412876328884015915508261943090083057713903043228932335601231203" //  &
           "40141960454601937991265277526358454689641320642200080030286310049533045M-6"
      CALL FMST2M(ST,C(11))
      ST = " 2.406177240131441866815352548925218907359016756341071832415175589" //  &
           "258269044824185640836078834625474374503849871861065571818953770220" //  &
           "34975008487473056363745663434694457043463856223590513289898353487696130M-6"
      CALL FMST2M(ST,C(12))
      ST = " 8.802390990648096801589149015845004893557805933708362167755975543" //  &
           "372057695537675243732864757390172399681575843089705450975708832670" //  &
           "47894590480007482518734894597525237926945509694423313414680575733951262M-8"
      CALL FMST2M(ST,C(13))
      ST = " 1.142227645342158377586670448383448546854299529797736913759691985" //  &
           "910949533336448816683159056251333466684021985223318722135340801690" //  &
           "72260625981817135095639775689249807942339836246106905787385604364337194M-7"
      CALL FMST2M(ST,C(14))
      ST = " 1.631475210082743727954198968671352602693131133480080900245408554" //  &
           "939316524124591839852475746114674778530360919625180046232777005122" //  &
           "27236317509067632839828070252526276470500723929148927321567689434907911M-8"
      CALL FMST2M(ST,C(15))
      ST = " 8.623497389978272698928826543954910754554854080065660353539135917" //  &
           "773916063595516849273098040739690585246037837539507713246122281847" //  &
           "07020525306666205624027189054003604432165771697650991757066138256773314M-9"
      CALL FMST2M(ST,C(16))
      ST = " 2.441104025235454263800352688428668916552720940475516379601031040" //  &
           "328703631852876301331001731922670655825329213688582617123340479731" //  &
           "30453030855966898642614830460583649086634599347191276139711017402687474M-9"
      CALL FMST2M(ST,C(17))
      ST = " 8.729150638722326041474546798911555513733749137711634358293958504" //  &
           "106518519494766446793260191698472463238634461285021617971659072089" //  &
           "64830740638437222612735276515039966197638188663669442608898762584643632M-10"
      CALL FMST2M(ST,C(18))
      ST = " 2.839029513083401421929170732563229229668325235436226039051054572" //  &
           "783508115759922623716045941336385750870556656615699867502848974601" //  &
           "25690803078266597331301210600902409196080711025610915592408863593987027M-10"
      CALL FMST2M(ST,C(19))
      ST = " 9.560889804988413908509285509380646041154360005479482459192247765" //  &
           "357528992664976535701311631674646910607500850899901331610584447013" //  &
           "61092693917685042900085585432034263673380064316273851782544357969469641M-11"
      CALL FMST2M(ST,C(20))
      ST = " 3.178270013361840262252491679259206811383776452439447460847595023" //  &
           "655033077497304599287176316699672432816255052883697868521388307529" //  &
           "40383229860610241927494715179896090660025570060233690995092455619052433M-11"
      CALL FMST2M(ST,C(21))
      ST = " 1.061093469576602661180070676287816314794459534888083832039943125" //  &
           "106258601567850805437194313637331057164170163808855202657895983163" //  &
           "75070581362231098256864140947088822349901059528755152892715695385840670M-11"
      CALL FMST2M(ST,C(22))
      ST = " 3.536842812699221803341361602631772393030775267007960695600138342" //  &
           "475056171314799106864974683735705965078815702431194850519988946394" //  &
           "60297349449303074734807619318567432754104422976962193319806157373676528M-12"
      CALL FMST2M(ST,C(23))
      ST = " 1.179381890210746859019626609111101179189547278121204798102640669" //  &
           "089589106613555171765287658695791241618592970217136500883583515937" //  &
           "07042245469783966737397377617384891192343427489490590732643362286614565M-12"
      CALL FMST2M(ST,C(24))
      ST = " 3.931867733137363527554885326768660997026944151573526847589071835" //  &
           "861161866217034417877097706264724092166846479646830599648529767479" //  &
           "29972500613317852095515147938660038231478063008302625870299351511379064M-13"
      CALL FMST2M(ST,C(25))
      ST = " 1.310821437225892696503587059884518604419875759028225403332569486" //  &
           "263124550715228960875605764084965585015810053174223154386683364225" //  &
           "82940623880095674287091265178854323811489670635974124477257044106228515M-13"
      CALL FMST2M(ST,C(26))
      ST = " 4.369852680143739417301538884456930730266716017178643408797678607" //  &
           "489727662002478005547544394166113056281405054193512564204527806783" //  &
           "21820023428536694798337606178682340961609542697763176968052664696930530M-14"
      CALL FMST2M(ST,C(27))
      ST = " 1.456734329592486133181460315029414930377211960023817769883504280" //  &
           "093804008390039009055883271224157190963826905955811848380812603165" //  &
           "54224971663883071707665069028985176275185941888330865659033519170133935M-14"
      CALL FMST2M(ST,C(28))
      ST = " 4.856068671580721652825423134564758955030518962120078212851284455" //  &
           "507593020938761405142314134920533228978526051606006790133466381223" //  &
           "50359680218686853748359459683818517509731959413893343189086282950465935M-15"
      CALL FMST2M(ST,C(29))
      ST = " 1.618761872087034547065539210485881034248882944054015543045073210" //  &
           "910330056730122088065602760823181836215863575050044591541254549198" //  &
           "06533155170588574561959173365139660326081560892373137180542173284519690M-15"
      CALL FMST2M(ST,C(30))
      ST = " 5.396053371990928374785154960328771472570021055817837913960904096" //  &
           "760099091618418168792262897777467993922856366402610309885017994638" //  &
           "31375328961628239846054792847689945091796341112338488175505578851091459M-16"
      CALL FMST2M(ST,C(31))
      ST = " 1.798729611660976774380774106560359446517486065245326232319884896" //  &
           "239912275072122853296640979664466879259429595297450987702461004648" //  &
           "40931772056892963070221773391675849856440134420289464625930506084236358M-16"
      CALL FMST2M(ST,C(32))
      ST = " 5.995878246226820269265104853882744953833262677515218945976170565" //  &
           "702779924974464149394857574835844004490020924890860726739848899923" //  &
           "95696324825550829660096649087698612645940055809410964879423696294173532M-17"
      CALL FMST2M(ST,C(33))
      ST = " 1.998654305589399275726998250553254783542933078465976133420153128" //  &
           "272381058668053909214099708471764295907486937756314951544992358421" //  &
           "97144228984621236873733301083447645823872653994272286143235273563570481M-17"
      CALL FMST2M(ST,C(34))
      ST = " 6.662251581403731529306004514600953655139824062623862163440755266" //  &
           "354957947460012639499946309112697689542491881916960750384664086547" //  &
           "74220845245988438400136805239697524619278380861197973816032911820925462M-18"
      CALL FMST2M(ST,C(35))
      ST = " 2.220768169107932862809420803989156159852745026278540490315171027" //  &
           "166630658162840832652660890951304947572979341837638582334903909155" //  &
           "05010378303851983844455677013599258308919578609796169265316664802443791M-18"
      CALL FMST2M(ST,C(36))
      ST = " 7.402604670809900203376581979566914810234491834807160670117173102" //  &
           "679048535794208132168246922357691220447769517665621319685807754668" //  &
           "30524972355162004213858351086934604282899918908012797069231868984875389M-19"
      CALL FMST2M(ST,C(37))
      ST = " 2.467545917514843068413870814987535001534095121397550756283431485" //  &
           "174239672848806618511211094654861620856356668212851618482113031080" //  &
           "96983868763519240779629920703298714890476973363239861006308885857104223M-19"
      CALL FMST2M(ST,C(38))
      ST = " 8.225180627404782368968305939492307217250324537166525666738082095" //  &
           "443986514199471391717760463558674271532612180804614900051667267307" //  &
           "84828422378491452316833093910246472565776447483034439499635086721544230M-20"
      CALL FMST2M(ST,C(39))
      ST = " 2.741733768240659509936720350920901622511204615005846102750077012" //  &
           "225034115334522335690591847723821637675971676287391586929140867246" //  &
           "24157389063680220659693708857804287064240054553450007399411745938008177M-20"
      CALL FMST2M(ST,C(40))
      ST = " 9.139129792265891288417212538920834449088699985871081943229349237" //  &
           "308947859965368326191615768810794304428951588196306949098368574539" //  &
           "28605395142908365050404570472066333401820331325326810443520131888072775M-21"
      CALL FMST2M(ST,C(41))
      ST = " 3.046380905361179933871534873717109530976853470108494529882869084" //  &
           "727927972747326006151030730201866380503024676995328258901563345953" //  &
           "00658838459344187262962809267579300899208726174226364547735769503160384M-21"
      CALL FMST2M(ST,C(42))
      ST = " 1.015461378786517931007333337553073166997854684093926238094172044" //  &
           "744795968432075139196598233114739312125317801492097820991352317417" //  &
           "40293799704807080092075189476011412233026066523677916838565466920346563M-21"
      CALL FMST2M(ST,C(43))
      ST = " 3.384873955149684581869145002322761445395722444488361773402583112" //  &
           "448446196579967067830143563552847474861011075678427137967175986491" //  &
           "77423399240122512958345857834877457342567505386357823149491980041361130M-22"
      CALL FMST2M(ST,C(44))
      ST = " 1.128291991521080392925404045314099582618612165311869719114516335" //  &
           "417518456246100356538652790526704797786336190873078001030469915965" //  &
           "30342451983442856226503526150387619863083398681667798679726159209459487M-22"
      CALL FMST2M(ST,C(45))
      ST = " 3.760974987926624413050052192380026663425879102031305346359345746" //  &
           "935876097802220422384767553022229983969369775506060549782771493660" //  &
           "85309029600033693383948806798756523782518697759939484580588143464857350M-23"
      CALL FMST2M(ST,C(46))
      ST = " 1.253658750025309164633924716897191398251340412647146221607418983" //  &
           "652266605895765756004913716691084072256991264216324248980009909612" //  &
           "59662905496332238803040488263666172235045176892125202448596644986008747M-23"
      CALL FMST2M(ST,C(47))
      ST = " 4.178863551880140415652989937671280452129584936360929800867252116" //  &
           "863675482287565904618697224054245640513684845309376666513701521263" //  &
           "52903495786573790786121590010548700491620543046740323819627331118835276M-24"
      CALL FMST2M(ST,C(48))
      ST = " 1.392954780243262418680115701340497736540387201421965383888625288" //  &
           "310091918535511115914306440504769869531128337443764472227581178596" //  &
           "20874940378776837220110757980964940848165877287239082243508787832464445M-24"
      CALL FMST2M(ST,C(49))
      ST = " 4.643183258187456757363871480237105948494753871341586050997508099" //  &
           "595411224954239240596072142323602079719155358372134330760070497787" //  &
           "55364393549841452404607067507295993200758608506748675165475527877530949M-25"
      CALL FMST2M(ST,C(50))
      ST = " 1.547727917073673030893407669122051522765823276651858723363536117" //  &
           "860559780947473082931957648716608923599799859242924550204192502327" //  &
           "93202961853805884072569165830891801693280119768515402102389811485890830M-25"
      CALL FMST2M(ST,C(51))
      ST = " 5.159093467774295934623929324290510691555682927619718795937537456" //  &
           "443748751641411020603883876314313578961537671360400477911224749990" //  &
           "32619951820624633170971754679797702479266215176809962392844181877752600M-26"
      CALL FMST2M(ST,C(52))
      ST = " 1.719697925307095214819334128534788375205527844306001827485335608" //  &
           "178891188953930792336558066117385344867670787386310361133421997787" //  &
           "32437687430376200145015883834569265381524778650808598371769510961689717M-26"
      CALL FMST2M(ST,C(53))
      ST = " 5.732326674479775700977445632081415478242873164984623088760026987" //  &
           "046479843038489986034336241981077004936330751439598114357862316445" //  &
           "25391747885525449466566054526270451667824579066863518701758860381778789M-27"
      CALL FMST2M(ST,C(54))
      ST = " 1.910775622357349859006177503807224410484768271435458299879734511" //  &
           "091872750666800933837592866045341090057920381872911981841539613531" //  &
           "34532853835424993139130432850991078908443110651776717566117546886621263M-27"
      CALL FMST2M(ST,C(55))
      ST = " 6.369252235018181185695546747418083648737457861666758649658733495" //  &
           "450326624296352111648047112820334535082139732219092514871542197623" //  &
           "45438407830542732130710826023492126216948058010058111121438710893185370M-28"
      CALL FMST2M(ST,C(56))
      ST = " 2.123084118462838161068146373210838937742442106504888126619598244" //  &
           "689122838503449807948835352511168142442994048637204680573237012416" //  &
           "88214862798756633312023510560919642366853351380446601871574640377801289M-28"
      CALL FMST2M(ST,C(57))
      ST = " 7.076947161851452988857602069175395219260001742350326617810798286" //  &
           "412997417428572002897367283988898197215995346896337658412178803828" //  &
           "71600585988840954970771671278144596708302210216220397647874970105717455M-29"
      CALL FMST2M(ST,C(58))
      ST = " 2.358982412360992050118851554506979955647201613693684896233810502" //  &
           "944787306402820374939041591698662853950957584483745174219063623695" //  &
           "13294756585697364356697316138631583855315160276428811116906407698998717M-29"
      CALL FMST2M(ST,C(59))
      ST = " 7.863274770562928683386208182169555716408523732927181605570254642" //  &
           "783489336698077228912261535122643231786047779260925663715692218511" //  &
           "54079525591282153925777222923833127312465613000068227777044732926174616M-30"
      CALL FMST2M(ST,C(60))
      ST = " 2.621091605860885533233898952848549221472883408639509048156174492" //  &
           "952501040386862212314276518084902725209461671925415533723193076219" //  &
           "02166363594957080995260573241730794841247260537467180156250342238881167M-30"
      CALL FMST2M(ST,C(61))
      ST = " 8.736972058719399393773664808053499235464951884789194640368079086" //  &
           "177143026321168823182202095050518931856284116458482040667912530023" //  &
           "17830489701338487555343938051214348611787932621065770035562250631323146M-31"
      CALL FMST2M(ST,C(62))
      ST = " 2.912324029368913239221905377728027928932487827862157086587586846" //  &
           "896450700145411015082377114761533704468584083695734375828642409882" //  &
           "69259984928264053284030731675607849783920249775114691953904644907709015M-31"
      CALL FMST2M(ST,C(63))
      ST = " 9.707746789052497475085146052433896715360382198339051019251763880" //  &
           "518185755627159066562273677244070805548234512751403592056913207327" //  &
           "80251017233714875898746055682870640485635412611964103637495935078818638M-32"
      CALL FMST2M(ST,C(64))
      ST = " 3.235915602473196442669228672981134089711213167383910530833953829" //  &
           "792990006951794162312454635926395818450571401725370707981435503583" //  &
           "55570191731695332982121199537121246583519326445577596987891273510182193M-32"
      CALL FMST2M(ST,C(65))
      ST = " 1.078638535688323258277639294637321095007154872462571028231301143" //  &
           "605467142930516231430752807470673434147256477737840344704980947455" //  &
           "43053554636974298772295627289032328328373036848556849010802235448385016M-32"
      CALL FMST2M(ST,C(66))
      ST = " 3.595461789454222217017444496718864771407199081151484546256978274" //  &
           "929484367469843471052909175769814275173782972424785067903628062172" //  &
           "38267851839020384161912309600523898207350166920811200389438694198073310M-33"
      CALL FMST2M(ST,C(67))
      ST = " 1.198487264108026960553291549779110538131003576080453431007006512" //  &
           "268160233237697351800460921121832519391521815357041008416084888598" //  &
           "27557131190172270346227678454195010189227547853345612460399635783630149M-33"
      CALL FMST2M(ST,C(68))
      ST = " 3.994957549418305520762016700744032876853769637744488924267188269" //  &
           "584393732051483805590060972426573672962844815489806656051668047426" //  &
           "97928538442568628891602616126915832496578665989847126282893366534237083M-34"
      CALL FMST2M(ST,C(69))
      ST = " 1.331652517070655772993246798258154050119486912201311455268437349" //  &
           "114193156345900532664095994600506577877633489606677937802093759650" //  &
           "12137846480275713137733722530126859812615084188357652189387132980702776M-34"
      CALL FMST2M(ST,C(70))
      ST = " 4.438841725063570781178568100283946176488573680079007649477905193" //  &
           "017992386971455066988895758316824569677887493778455225021106826855" //  &
           "29026392300941094435783945574507271437954562521405284456074260144096753M-35"
      CALL FMST2M(ST,C(71))
      ST = " 1.479613908728203152730390143133201780942639054825565044507758917" //  &
           "773304661939287594029105088656760879117520103897129013490206639754" //  &
           "87435121659508261905208347102886094942106298340234319457765604513963509M-35"
      CALL FMST2M(ST,C(72))
      ST = " 4.932046363361542755686335602696750869830288252199443432734105813" //  &
           "943462260083819436478927601708900720110450661448493818380083105762" //  &
           "71590161306544076696091310423964644508740590548145866774529617253109923M-36"
      CALL FMST2M(ST,C(73))
      ST = " 1.644015454687397316689944677831911620211552013511192085616959005" //  &
           "082583370344704494312506871603969621047795163740944612049682148927" //  &
           "59356353337859121253234322350982876222750860528515262326476034089950266M-36"
      CALL FMST2M(ST,C(74))
      ST = " 5.480051516208532057249213551633236335403175178397767120722791995" //  &
           "833335758082301610732726590856354303605009314671070073367443285322" //  &
           "81719944336949977298072286244404059176341969451639495219169668432874625M-37"
      CALL FMST2M(ST,C(75))
      ST = " 1.826683838882145937413050728363254416465068672788666223790911345" //  &
           "427048802205722820790024964162626522627539834294555447603439041292" //  &
           "92403842411688509922659248102884925797066250995812515878053578599537543M-37"
      CALL FMST2M(ST,C(76))
      ST = " 6.088946129972074589720378401074071029218658010685074635511831120" //  &
           "277695386768911269891962771874827650899040106965903278757448364187" //  &
           "28574155937467016044284632565747254397900833533383192879263530571086410M-38"
      CALL FMST2M(ST,C(77))
      ST = " 2.029648710081921896663063938682967174463636477103609117669608797" //  &
           "346033378612490707724833983253281429017993058131396854118481222339" //  &
           "85407951679907254491401107628467015394676060959591476686232563916557226M-38"
      CALL FMST2M(ST,C(78))
      ST = " 6.765495700501148906774995358078228324235325066490434291070320211" //  &
           "666634035845840680799492809322166392640915607858746928019847633868" //  &
           "45020162815858209793574963810268541266706689851018528823213713218014553M-39"
      CALL FMST2M(ST,C(79))
      ST = " 2.255165233557401948601014902186205602789864371948507888958512686" //  &
           "894666882870433310683786297682141353940837232625056953901094633832" //  &
           "03813175465801305121046951268786662654220745685289766957573976902789674M-39"
      CALL FMST2M(ST,C(80))
      ST = " 7.517217445333887278263065941349084170211801907036126548415826613" //  &
           "097540864542220787119574822998915671722740530800746773131556370537" //  &
           "17036257265431709600760536998990725283074006064618438905604324155029841M-40"
      CALL FMST2M(ST,C(81))
      ST = " 2.505739148480265955233204413682186719497131266833487675446538783" //  &
           "092174430438507742800231748635072748340810415087125614579378635688" //  &
           "66151322710496155055815000392267489014427962480151154107924769960320348M-40"
      CALL FMST2M(ST,C(82))
      ST = " 8.352463828356645340468994201986157494921881256993571664141509541" //  &
           "823273109890101870519752598083111861872055684078254288142631302953" //  &
           "90656071678927672118181416754149675034388261080192075026592829943869784M-41"
      CALL FMST2M(ST,C(83))
      ST = " 2.784154609474488152611480955615773344997254762720123569187499710" //  &
           "482501105031142742130099147104245620254144813103304543108707461283" //  &
           "03676294384838274788281739537719423506089439601147338491518140111085245M-41"
      CALL FMST2M(ST,C(84))
      ST = " 9.280515364970643106573953106487348079696240473524263398418948085" //  &
           "686805363427549650077259362814392417398055197835215069289928148824" //  &
           "67963286545183505632254520821084189068903494611293308100453524544737026M-42"
      CALL FMST2M(ST,C(85))
      ST = " 3.093505121670801685004800389514423527223386419080428824653989649" //  &
           "679279518505124420083928960371367692487927529341787666280479065858" //  &
           "20227384416309509890526585569312748427209499872674012860539332555258032M-42"
      CALL FMST2M(ST,C(86))
      ST = " 1.031168373893747390707549843146989045155823157470502623225595250" //  &
           "851710797449759760498072278428597174778192322827019231254514348869" //  &
           "35739852926303601231003771300391351671865972802045601948838060198753437M-42"
      CALL FMST2M(ST,C(87))
      ST = " 3.437227912987858374961865176796344063877564237772445606496240106" //  &
           "757864483254589585823971686699471956766584959383102055399682270269" //  &
           "52352941784639649980429822410674941181991395320188803002740041936488314M-43"
      CALL FMST2M(ST,C(88))
      ST = " 1.145742637664794559805828100464320725242403637362145522388352767" //  &
           "861006812839084798058391247493282342027006725688139044431839514660" //  &
           "53654774876669055000807030176806220727453288403581728457403167939166997M-43"
      CALL FMST2M(ST,C(89))
      ST = " 3.819142125554752953067839505315181594779066795846739238810201522" //  &
           "091877503536260790984284322275300395166507566249167177334314175598" //  &
           "37162971702086753249324866744493897786886912065021929714836592305111972M-44"
      CALL FMST2M(ST,C(90))
      ST = " 1.273047375186277089451795607705259637601635385366665197585993775" //  &
           "074526908019448436164455682411887757929212685231623835262681489558" //  &
           "82648858340071059461127000212205125717165045854603000054982553620290401M-44"
      CALL FMST2M(ST,C(91))
      ST = " 4.243491250624322227579766750508513228093573956231840709615359110" //  &
           "716873987770463557146491514771994072759888669351546219633295358033" //  &
           "66517307409098637643711145428866491214789294814344532842968257523643745M-45"
      CALL FMST2M(ST,C(92))
      ST = " 1.414497083542290391545199323374869916206725399320438141384531327" //  &
           "265477522477777915006882588147304129058542612492747596977199928651" //  &
           "94869243918440516701383178149493577193540062534758351817970713054178365M-45"
      CALL FMST2M(ST,C(93))
      ST = " 4.714990278476425427697520544930204334035129865733446210245204030" //  &
           "355616997118279522525088487975375771703855109208249987771017533193" //  &
           "90291285366875213381956263086437252260808891626942562877561594888642475M-46"
      CALL FMST2M(ST,C(94))
      ST = " 1.571663426159339506535953571864003053494761363991342538284158655" //  &
           "584260596318169435197761794741189000363244392470381778816827538385" //  &
           "70503152182049565811831241089687440405169499752285888183719228270040702M-46"
      CALL FMST2M(ST,C(95))
      ST = " 5.238878087199125931711927428699616143954533668740342266002176483" //  &
           "066317524800888207882487253378527961702366607212427983576029574311" //  &
           "70477008468882187587684440329802260450306316947736342927462019072062451M-47"
      CALL FMST2M(ST,C(96))
      ST = " 1.746292695733373871385356099575152433557917368382321044143123707" //  &
           "125733276511427813036854586467480879063125488695590156424518309858" //  &
           "40776387319594992052236593986791986838450118314507991811649011797951517M-47"
      CALL FMST2M(ST,C(97))
      ST = " 5.820975652445409306654690542379619928753899950100022072575451976" //  &
           "896049502425251330032699117677706811131644722750272961660598812323" //  &
           "95528274546713027672214860795936676307396171912021238503162387066702843M-48"
      CALL FMST2M(ST,C(98))
      ST = " 1.940325217482010536060783297163692278507114464120206717431891734" //  &
           "053010284461713330551549047577932453595163579118201359494986630173" //  &
           "01494093463680448771677875123107012368194613913742739952428603002168229M-48"
      CALL FMST2M(ST,C(99))
      ST = " 6.467750724940553704809014908981646231351194700919134365131054499" //  &
           "044206347270309742459318050095528539735477919872551695967650699099" //  &
           "88953248180134764653841795790617888566272316181621003159336089850848991M-49"
      CALL FMST2M(ST,C(100))
      ST = " 2.155916908313647547754610174771515398662821458991609891428955252" //  &
           "290583442620154212776250181824196267358169201447214242363354724316" //  &
           "89903280067672089810407626181445703141886320049309134936640041251647199M-49"
      CALL FMST2M(ST,C(101))
      ST = " 7.186389694379149274561055379686410434878982979762824712204962808" //  &
           "871607736477144813893452054031932010405337926726732941950536667006" //  &
           "84810252591610140816882396575440916998193275137670082479286587744869582M-50"
      CALL FMST2M(ST,C(102))
      ST = " 2.395463231459797453698442182708267050312141998051092331530640409" //  &
           "893924848764443035384500574394756654315653015364123642221973250880" //  &
           "68362683781580014370472600811020274312157465907532281112816349722673774M-50"
      CALL FMST2M(ST,C(103))
      ST = " 7.984877438199527417773369963127799969498648440970510669498583482" //  &
           "161029591317677710672043612633451504552983943030656888570069226104" //  &
           "04295259910858734307563648182821156659161484763549481645932818220413101M-51"
      CALL FMST2M(ST,C(104))
      ST = " 2.661625812733226448952431335647978161413961687446878335164533806" //  &
           "702910875419295287094135193138742564146281522194125689011703047524" //  &
           "45739306220536816835347815852152246454806822705745730784267021864361647M-51"
      CALL FMST2M(ST,C(105))
      ST = " 8.872086042444214770744709174167341653906439941556420653788154173" //  &
           "929048445735834186760727780453829909511846845819831435241835442504" //  &
           "04079891107632829549289090071219101574622546793854950277712602194795534M-52"
      CALL FMST2M(ST,C(106))
      ST = " 2.957362014148103242140721175656428119533141966179427551155676500" //  &
           "671725653671481845278656623962048055150306031384279834386038577295" //  &
           "72584556615286334177021422182622284915641930082182710316087748100105028M-52"
      CALL FMST2M(ST,C(107))
      ST = " 9.857873380493756603533616420387300817360969314828251071875082336" //  &
           "698703611411040709238371719721287012785465953801003782742219530827" //  &
           "73983924014324680294547858829752678323087789357138505841177563631130388M-53"
      CALL FMST2M(ST,C(108))
      ST = " 3.285957793497938650277342040351753052374376933619786220663421040" //  &
           "427587332321480401454840426545683394351958951963755749546928108005" //  &
           "75979757809361423163013264428850345811205867029087095522459004260861910M-53"
      CALL FMST2M(ST,C(109))
      ST = " 1.095319264499317829033981510140817754508285369349556399833223737" //  &
           "174998151312514038433336840462205568158214000003108865975414472963" //  &
           "70581756862795260586373374661842883378795511151785344346238350698780645M-53"
      CALL FMST2M(ST,C(110))
      ST = " 3.651064214997738460800440485464116453512465873766107387248343452" //  &
           "458997203837952291715916094766655886246438013372552836368973829605" //  &
           "29202550932685485563387565304843167421189066345923958359568125707813957M-54"
      CALL FMST2M(ST,C(111))
      ST = " 1.217021404999249244605272366723881223583838603878543320302210671" //  &
           "409056933719216026722268770996716099812270381542447122348883231949" //  &
           "38922656964910194439295935941196896773701049861546343314133034224282491M-54"
      CALL FMST2M(ST,C(112))
      ST = " 4.056738016664171876197055085310199605151026698635243534713457892" //  &
           "107296169062875134691895441571499550130093746425411512549327123228" //  &
           "16601740468340561446321921103466463550189353682758076018331072415996381M-55"
      CALL FMST2M(ST,C(113))
      ST = " 1.352246005554725890610555164289246652995273648088741088360045973" //  &
           "623667364361191345555088170702142598112873445326035312084757222791" //  &
           "25547996491724650392650447881135472685838861374568021340343847835638534M-55"
      CALL FMST2M(ST,C(114))
      ST = " 4.507486685182424465064025894185168278371602793396197455600512532" //  &
           "406474418197117862785333707359281266142995363043310398030388775224" //  &
           "96855355439438225180328883970301863313369556592379689501165566142115306M-56"
      CALL FMST2M(ST,C(115))
      ST = " 1.502495561727476029111885802751588446409759610042467877987373043" //  &
           "860038180719787874668067312469292183193912200682893897594757683194" //  &
           "08099696091579813882633694420046951596146901116935629924246701724845131M-56"
      CALL FMST2M(ST,C(116))
      ST = " 5.008318539091589782265978940332517362043223441916201948536518072" //  &
           "099322344676502315123489826715051040283829780783100995910094849108" //  &
           "65034584595413084839701258466960248343166395950551930374997082566708225M-57"
      CALL FMST2M(ST,C(117))
      ST = " 1.669439513030530682061916213454823087218137831151025299167070973" //  &
           "190879095582514009353872307284741332656640434042133116166845579709" //  &
           "81635243531150493888288323800171093455101171326873303863260272601517849M-57"
      CALL FMST2M(ST,C(118))
      ST = " 5.564798376768437493472862129317060203208340292866327711857634512" //  &
           "795204118217070748492626708664751935590615442683377362519336018325" //  &
           "51004856969881087903485123401331518636537459253893877449123506707146950M-58"
      CALL FMST2M(ST,C(119))
      ST = " 1.854932792256146302807572731110803878429090610101994543365419672" //  &
           "049548214027388780306433203424820289079873088082231836000918687537" //  &
           "23334792833523598579662177790912527794946886117189075782702240392408839M-58"
      CALL FMST2M(ST,C(120))
      ST = " 6.183109307520488855150122490825215119994140805333496249840425315" //  &
           "260483680241891966697616887289397465885493861812930613441993149861" //  &
           "75026053269580573584851572426023443652902431378207237270671672948970109M-59"
      CALL FMST2M(ST,C(121))
      ST = " 2.061036435840163246497927510477654121008516108356441555748893883" //  &
           "538337771585715140176109550136417103188492842915425790968199189673" //  &
           "75115850238127872748852300922000306375635048830126739836684145179941549M-59"
      CALL FMST2M(ST,C(122))
      ST = " 6.870121452800544891946141735609200171965629448722202434217816987" //  &
           "853447483793178217562366316730782300693739885096060635165076652920" //  &
           "41995525029854871068500757566629399110685057219153231404821304733713204M-60"
      CALL FMST2M(ST,C(123))
      ST = " 2.290040484266848481553643087076101079355964961713023345779978400" //  &
           "982834140969803837340319397848019038722638870138573135003750122280" //  &
           "67644649360313184772818630784452829131845685063424590204739986167925734M-60"
      CALL FMST2M(ST,C(124))
      ST = " 7.633468280889495399107799895007148312706155591452982323077149986" //  &
           "120899748236386385448066771935353332443050965065257767414246512604" //  &
           "54742904592796348751455213798689879834161009662040701046444537526427115M-61"
      CALL FMST2M(ST,C(125))
      ST = " 2.544489426963165248184847366204930714902412817306190051775615959" //  &
           "530879632335665207219382767168166468926593335092194936311475724489" //  &
           "22045567698482778031098111145226005087891270132458202092192296860039337M-61"
      CALL FMST2M(ST,C(126))
      ST = " 8.481631423210551115155109723717829106916950881296846054083649985" //  &
           "810525218550324029659230629073310007635840875342630862789117074541" //  &
           "87098166442436318923705470772023710069850200723928832617470068484538900M-62"
      CALL FMST2M(ST,C(127))
      ST = " 2.827210474403517110353107867003629422731212331386162488716730521" //  &
           "351064005716979204840102164742676308078783782599324060431157817109" //  &
           "88654841674710921627884749621343607380343694451939622450448527669612216M-62"
      CALL FMST2M(ST,C(128))
      ST = " 9.424034914678390547763871121100990122397792341363117728757038903" //  &
           "649538172737671552516290289880795766718250080584367536271759196670" //  &
           "39697325553891033518536553021634662617083010606852575129875069462163167M-63"
      CALL FMST2M(ST,C(129))
      ST = " 3.141344971559463560901334931474821601568811602982335715041502627" //  &
           "827982932089655486622557870156127718095126494732372850918038888332" //  &
           "54551941638266722522763646352278545149136303285285604558173356388928708M-63"
      CALL FMST2M(ST,C(130))
      ST = " 1.047114990519821198212122783269017133872736396216455065194396848" //  &
           "772182771964575553018906528347835085989108829213513953424609300128" //  &
           "95630377523418163375718344777771305545237149991145713842104433495405185M-63"
      CALL FMST2M(ST,C(131))
      ST = " 3.490383301732737355486270459507822699258345311341941846849921659" //  &
           "545613492122376436148560471436321288125576975707576514288727189135" //  &
           "81234008256049155059395856211182401981576994675285833396791180771117772M-64"
      CALL FMST2M(ST,C(132))
      ST = " 1.163461100577579125523555448655563780187894154820747936001916075" //  &
           "833373823024344903789897831688942109838607391549196509166544386710" //  &
           "32984677138183863587254008956883033409075083480154979676313298835611005M-64"
      CALL FMST2M(ST,C(133))
      ST = " 3.878203668591930435982181400901299436435180157598905860060992780" //  &
           "769432703831655807641542938250104063615345695580486254706194715454" //  &
           "60229972174586144050891402920273633768999530012198276610097006412695734M-65"
      CALL FMST2M(ST,C(134))
      ST = " 1.292734556197310149719976276646194118747432707279683488755745696" //  &
           "740947679118453560585318506784845508484302703353713015155212188239" //  &
           "59563349122999271475430680808380714359508027924891221587469189007133570M-65"
      CALL FMST2M(ST,C(135))
      ST = " 4.309115187324367176714710446351861339597497796718143278961320946" //  &
           "586948534200778409616190905114541820432168004724255101140047339531" //  &
           "16503452628730864113604659140394417734969121530536316322243286765720986M-66"
      CALL FMST2M(ST,C(136))
      ST = " 1.436371729108122394983600863166786192397968628737741530628906208" //  &
           "660940944816769480739740878584831113565249313940195309419096432913" //  &
           "23986224865537803560999682866769231274805486620569029108114354610082602M-66"
      CALL FMST2M(ST,C(137))
      ST = " 4.787905763693741323475412996513093551712741258381159384549759206" //  &
           "662442822072738588515832300420257228803664662013090680472314997210" //  &
           "47994366822587964409268875557318665191628748298284520227769123490709406M-67"
      CALL FMST2M(ST,C(138))
      ST = " 1.595968587897913776207656861993669785407285064500745185434113800" //  &
           "096356494376241989760638754749237977344465547010132327612679509965" //  &
           "90606634208693254568607053260913032981301281185089491854456988622988789M-67"
      CALL FMST2M(ST,C(139))
      ST = " 5.319895292993045924981820864535497749048234307774210374132739226" //  &
           "662962493896584326632876715466366610480847242863534749368020824442" //  &
           "26347859777033625778816141835475590087036758263889428530371159240382397M-68"
      CALL FMST2M(ST,C(140))
      ST = " 1.773298430997681976066348119317279371541102493785396123709304532" //  &
           "963732653591086234204258910992398206481527117154837605280677866587" //  &
           "40860519847234648346851518177302296315561478928449266143246491562286927M-68"
      CALL FMST2M(ST,C(141))
      ST = " 5.910994769992273256235513308905467236327084289024213039675731610" //  &
           "148156011515848201203908937219678972731231236325011698208574736079" //  &
           "80168427550976937837979750480068076198135077050989661245596743172379630M-69"
      CALL FMST2M(ST,C(142))
      ST = " 1.970331589997424419415425997445581585340102744812802313473388703" //  &
           "562069927312660229009236127416616182518232875620838559077842053926" //  &
           "92349876121987505300275410560304423025355686582773348179088042892097570M-69"
      CALL FMST2M(ST,C(143))
      ST = " 6.567771966658081399727057227641186570727529727910776691977632634" //  &
           "165946988657121076389626270986170591723497353782252176685973776995" //  &
           "43528417602815951738160201869055681397572348387528732209187423794662534M-70"
      CALL FMST2M(ST,C(144))
      ST = " 2.189257322219360466994595051007995333389857163416210506204122933" //  &
           "434092909606199446262463730440462471061414357649669288454519822486" //  &
           "33439286916366526139243135196086518512441365472582736479048872262858017M-70"
      CALL FMST2M(ST,C(145))
      ST = " 7.297524407397868224362590109254773419614298510807208602130225559" //  &
           "169843334057978765051658253298688634379979983044623872624689424224" //  &
           "07554019829693239747911909633693703476580188084738005493123701521791467M-71"
      CALL FMST2M(ST,C(146))
      ST = " 2.432508135799289408382681708766459710814072648334087437525650247" //  &
           "402627470576079904894860765869748078205431190272078201162332612662" //  &
           "86925426506431278564366927546261623009686964819372619868333948357411039M-71"
      CALL FMST2M(ST,C(147))
      ST = " 8.108360452664298028596818159143547381983866077866697620113475392" //  &
           "867557609420149388391146208299955439299097511073088600020008797364" //  &
           "90254145831112916894519121436284980569670233198361465597386807462396245M-72"
      CALL FMST2M(ST,C(148))
      ST = " 2.702786817554766009695908457319192274936196517820205990720071929" //  &
           "267436760629307786446087225623272749165348119673554381961913455458" //  &
           "93050660537495047726291186100258874974179781198259808664194749915523789M-72"
      CALL FMST2M(ST,C(149))
      ST = " 9.009289391849220032728785940466253732893526544523495429162278552" //  &
           "296342689979948102270331957628702643264702399700740206586719143369" //  &
           "63516748801336419497668271497140970017083857566651892279908542196784275M-73"
      CALL FMST2M(ST,C(150))
      ST = " 3.003096463949740011011890954041623476083928522268342083771940551" //  &
           "403977301983996687445005688089790997335068650775774411500709972696" //  &
           "00052352997217396436659500075907900727290635046242137258265027272046707M-73"
      CALL FMST2M(ST,C(151))
      ST = " 1.001032154649913337029531966564025740882006821416233309378396854" //  &
           "352648141475996724306705629001209846327383244434702908491488661840" //  &
           "33666122248311247777472186264526745924646761167750923503037999124457410M-73"
      CALL FMST2M(ST,C(152))
      ST = " 3.336773848833044456828335032653876240316804704924144044073849579" //  &
           "816206165795104200289660358785996996484528456071385377435139123676" //  &
           "57709192610536558746890780425020107260403503414920896791666418548557679M-74"
      CALL FMST2M(ST,C(153))
      ST = " 1.112257949611014818958755021576306436637772541032306466006509854" //  &
           "188967690019629658157071337514432146127855476046945605695950179554" //  &
           "39845790791214616926248699635001115509938807913024195016995950944619712M-74"
      CALL FMST2M(ST,C(154))
      ST = " 3.707526498703382729922171432032250515805881149465794264372984724" //  &
           "327809012896984209000978195800679443631566152731613311969108735093" //  &
           "51590966384556456803036744807880814153226574822433894031208374029742738M-75"
      CALL FMST2M(ST,C(155))
      ST = " 1.235842166234460909984137514518387752942293928074591712157524109" //  &
           "560139067764692539980008571135341128797657051727809999365157975182" //  &
           "53322235173852278845187716078871110242776570216352174337398795667971328M-75"
      CALL FMST2M(ST,C(156))
      ST = " 4.119473887448203032778434343895875695597840528814474282367848794" //  &
           "205301550322451475974554397356862932040320235498247930630480575568" //  &
           "25417807718570483485133432555365627049395094885528093686245256557591509M-76"
      CALL FMST2M(ST,C(157))
      ST = " 1.373157962482734344263376419251248172548827589625457941472696797" //  &
           "100175825647692982915548765225643706779206935633946071637767635709" //  &
           "79966315426397983742300900492572704510866186342432593363321634147388215M-76"
      CALL FMST2M(ST,C(158))
      ST = " 4.577193208275781160777550837017921925055088338901698850930906043" //  &
           "311063967012540679380363564085256672110282867832397021602920753059" //  &
           "62941763379439217899247719980351463557310935320189195654346581389521961M-77"
      CALL FMST2M(ST,C(159))
      ST = " 1.525731069425260386985167951519330997746387629867941705993359606" //  &
           "803096607303855736985249240116888915751939824222470295586537784557" //  &
           "14766559903817261522752203057544899378743721133360484530771023423930290M-77"
      CALL FMST2M(ST,C(160))
      ST = " 5.085770231417534312974277748264028715371006669759625749888114997" //  &
           "040535088461914628203462029057668451395058320957895155954018999649" //  &
           "89570133824275977321769674422087255596053232511973102592783007464375573M-78"
      CALL FMST2M(ST,C(161))
      ST = " 1.695256743805844769769991874189352969259021005362418248962236686" //  &
           "450929128768148436336404059930819742510685161671532907373324896396" //  &
           "92385277655969091090205296324356998243606127274626181023449273081779115M-78"
      CALL FMST2M(ST,C(162))
      ST = " 5.650855812686156039218806037909235903455451213739689260418037318" //  &
           "509446943950605499341032642835238412850215403194710979806557582704" //  &
           "37936259002958165848823746298586989930806700558037154118861273544045145M-79"
      CALL FMST2M(ST,C(163))
      ST = " 1.883618604228718704933778437940690307805004962163899221957470918" //  &
           "058716333776074607305943978262640017375578856797709581746515819407" //  &
           "51489901662136678406269201616881521607807260952614167843862068838710312M-79"
      CALL FMST2M(ST,C(164))
      ST = " 6.278728680762256512126149402150794782943415735579294630724544224" //  &
           "964157228232060226941740181573870879258048900467741995915140892478" //  &
           "63661908097641164941373210234799596031030310767570648902522277881849187M-80"
      CALL FMST2M(ST,C(165))
      ST = " 2.092909560254085021914720610883566852288010979452630217312140514" //  &
           "778472364540695790415885690351086108014265966713921440025212436361" //  &
           "73967300532411889825601604598920039776377478055710366101143130338433473M-80"
      CALL FMST2M(ST,C(166))
      ST = " 6.976365200849595928554228570881565721048784920515468405614250170" //  &
           "741926248557408642176573843779290903009186026063040672689273898432" //  &
           "88910357288258162475303198325632084369407383550262099668489007926100917M-81"
      CALL FMST2M(ST,C(167))
      ST = " 2.325455066949873863603395561978748601800147911008192886172463050" //  &
           "451820515051068562317761231512963759254765453729061173550997868120" //  &
           "58407734788242875774377719715615329774495325545245938734484625573096582M-81"
      CALL FMST2M(ST,C(168))
      ST = " 7.751516889786273230324814807015203014115787760363240263773567207" //  &
           "238770582250611249333986919911192763902738500220512285746471179825" //  &
           "77571260191751902463570497659486034004412403189688932637270843323495731M-82"
      CALL FMST2M(ST,C(169))
      ST = " 2.583838963261950823749231801853943339353886424780054671299212593" //  &
           "953839989881747235093144189509781483529556454394968872792726683435" //  &
           "27643326289916001403186650841236534106807785205861848342075189337865239M-82"
      CALL FMST2M(ST,C(170))
      ST = " 8.612796544966339593458567326158368856673430376795891557224772538" //  &
           "947415233055213978085860502193079097945197318656791149694366866539" //  &
           "72822366330690625287806683992931214418731468102411025539925415006202370M-83"
      CALL FMST2M(ST,C(171))
      ST = " 2.870932181657563853681094248589222833815589612305003013771994066" //  &
           "486301003023979828481138638939770854259457931497871219438623202895" //  &
           "38689833732465547124246759187251713896087958971527124804970116015889039M-83"
      CALL FMST2M(ST,C(172))
      ST = " 9.569773927459502329186355848231519845153615256953762486987693008" //  &
           "642824433756506369875737104132534466116626389178752624525042798289" //  &
           "22548975065811830797487032916317956125950813783158098289413462007841293M-84"
      CALL FMST2M(ST,C(173))
      ST = " 3.189924642457193947274111017893685291988923107347172733780095937" //  &
           "504990242848262256269173114579259710506482337540368636019319969386" //  &
           "73520058153132922629586433368902183759949488890960340616457392616954301M-84"
      CALL FMST2M(ST,C(174))
      ST = " 1.063308229833233763649615961280021009800959973857039083389096247" //  &
           "411276485934365597139214502542489173998160641619626621325276246417" //  &
           "76894303109902050056828926820785431328629167285741168999780547981801651M-84"
      CALL FMST2M(ST,C(175))
      ST = " 3.544360766480896268661403387806726005830929777366570657261489401" //  &
           "694611013460386506117284436161560434270675994478125024682804092939" //  &
           "15998067887747220478181658639560020083789407982402045792182967207779297M-85"
      CALL FMST2M(ST,C(176))
      ST = " 1.181453391991692193233769222790948883554160416544364056162345177" //  &
           "930450135664579747942304147194452606107088227217835015752643760372" //  &
           "89824167494419232372153209806697818554092135462778008255059604732701717M-85"
      CALL FMST2M(ST,C(177))
      ST = " 3.938177969065104259816236800771282813142970611653130614923372425" //  &
           "876301727778466158006947186295720851119739977650492841350794668106" //  &
           "75909743699184418774259697017658821999190863053142757985704314111950238M-86"
      CALL FMST2M(ST,C(178))
      ST = " 1.312728231460229835781690690024789271337659581458734016769897717" //  &
           "615695172767934655904718896955205839028238358310418293184633392500" //  &
           "09974095126152086147719595157884930629859403536081952476482731834669587M-86"
      CALL FMST2M(ST,C(179))
      ST = " 4.375760815315077535413569523720083421030822320092520690986988142" //  &
           "097203566380515277459454385250926657264251938784637571214707790842" //  &
           "13901922704849922902680056772549256776092849835805341467509317300857668M-87"
      CALL FMST2M(ST,C(180))
      ST = " 1.458563929048378339389303099779179984031579246114615330084586060" //  &
           "391340363385450968349489278357541331271188532814617890065655968100" //  &
           "90864106047591784785100253214527821779035249121314752150297703091924694M-87"
      CALL FMST2M(ST,C(181))
      ST = " 4.861879359454319859107717556333622023158902013437521581162884873" //  &
           "340193641755594234893503470462192100416392001882798233766279202968" //  &
           "02742623676171486751287082335949083937364296608060437072511301740262916M-88"
      CALL FMST2M(ST,C(182))
      ST = " 1.620837575639336717669552632235434719742418568812043976527454822" //  &
           "311557369332525067245294696277568831932145434818066929071312277435" //  &
           "59667900060244610446776086220578843202917562200852939911588169882033048M-88"
      CALL FMST2M(ST,C(183))
      ST = " 5.402795219201229254205787739591614371703058387299744106863813045" //  &
           "890074410469634798352875615158044666258805327295738061277040804255" //  &
           "11706167845408641690753715592108911157218063444936673090628364776228851M-89"
      CALL FMST2M(ST,C(184))
      ST = " 1.799216964519093606731199173063133848252752532638951929530332271" //  &
           "088757960440794118609774620691669941349561692799601479867289303361" //  &
           "36573900179559749556590933182210908857440047681409893684369308365396546M-89"
      CALL FMST2M(ST,C(185))
      ST = " 5.997366309057088767075246255186377444897385269608659113392135251" //  &
           "083240010154867782825603589060665479283491811344357943450419502328" //  &
           "30863890415054273770878371228558497389363862954168787497855394907612488M-90"
      CALL FMST2M(ST,C(186))
      ST = " 2.011301294926252140726377746074781953178862150579839442308024059" //  &
           "805516340858995612053131399074329904610352755793706433609739823274" //  &
           "35441280105568641478715458116693621474886783585502490686457813740208553M-90"
      CALL FMST2M(ST,C(187))
      ST = " 6.704482593621562564692904617177008442804824808114929721560806403" //  &
           "083889880113942537426720271890350736903006981375786722754398310176" //  &
           "64290862799510364108316770714557534855989672010291914054754244834573505M-91"
      CALL FMST2M(ST,C(188))
      ST = " 2.160351395289544486253218378105888708749936652071087348664876866" //  &
           "590595135247617954742090212769559780976713437175453455128216319294" //  &
           "79621451615761249300873617293850399062283747501629953564198534458556254M-91"
      CALL FMST2M(ST,C(189))
      ST = " 7.200419569439204992397564583120569704507791779761471734959614293" //  &
           "903195879211244064072895412909288124860635443865351473928153163314" //  &
           "35648140579845782685750371868061482151886800120453245481648754938151403M-92"
      CALL FMST2M(ST,C(190))
      ST = " 2.784319712626698759566042489347515628094423349698152057970857358" //  &
           "347754564870738442303737360847085557292665631767832280403826508366" //  &
           "53961878379952572306276562137966777737866334027041960083257419418474932M-92"
      CALL FMST2M(ST,C(191))
      ST = " 9.284263699802481030477799658347338855061343963325012856142524485" //  &
           "337551481107985173202144915554476793675287039218856327451603285101" //  &
           "60910890143062738353240079101453208140103839949856135593728282192403791M-93"
      CALL FMST2M(ST,C(192))
      ST = " 1.469128321729119845643778628274835930841237239875100463308434786" //  &
           "723561392709397386626554407894406027910890887423959020221165249040" //  &
           "77624688503604251276023392875008399104638564047518405899300367036809361M-93"
      CALL FMST2M(ST,C(193))
      ST = " 4.886379978539319342120516219783307378314461447995883185804991015" //  &
           "296960664895043875586362313203658735183472813064062209400386162722" //  &
           "42806131645480493919198786449897808824436924850601891974937230254873784M-94"
      CALL FMST2M(ST,C(194))
      ST = " 7.046670647920504479063472745872909513874517692559573509267252909" //  &
           "755965774748698930668458487567120021155413053722800379339662049820" //  &
           "26470884186471084008635684699341681154401901074420825646205892400124466M-94"
      CALL FMST2M(ST,C(195))
      ST = " 2.351541158501990523752731183260855698650611680331234753194545827" //  &
           "615066582884384059556932538832948082760844393963381962615300495238" //  &
           "72892129343291577201989578726783775602985638203462774865396580295272103M-94"
      CALL FMST2M(ST,C(196))

      NDIG = NDSAVE

      END SUBROUTINE FMGAM_C

      SUBROUTINE FMIBTA(MX,MA,MB,MC)

!  MC = Incomplete Beta(MX,MA,MB)

!  Integral from 0 to MX of  t**(MA-1) * (1-t)**(MB-1)  dt.

!  0 <= MX <= 1,    0 < MA,    0 <= MB.

!  Some comments below refer to this function and its arguments as B(x,a,b).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MX,MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACCX,MACMAX,MLA,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JCHECK,JEXTRA,K,KASAVE,KASHIFT,KBIGAB,KBSHIFT,KFLAG1,KICK,KL,KOVUN,    &
                 KR_RETRY,KRESLT,KRS,KRSAVE,K_RETURN_CODE,NCSAVE,NDGOAL,NDIG2,NDOLD,NDS,NDSAV1,  &
                 NDSAVE,NGOAL,NMETHD,NTERMS,NUMTRY,NWDS1
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MX,MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(37),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      CALL FMIBTA3(MX,MA,MB,MC,MXY,K_RETURN_CODE)
      IF (K_RETURN_CODE == 1) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      NCSAVE = NCALL
      CALL FMENT2('FMIBTA   ',MX,MA,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NCALL = NCSAVE + 1
      KRS = KRESLT
      IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
          NDS = NDIG
          NDIG = NDSAVE
          IF (NTRACE < 0) THEN
              CALL FMNTRJ(MB,NDIG)
          ELSE
              CALL FMPRNT(MB)
          ENDIF
          NDIG = NDS
      ENDIF
      KRESLT = KRS
      IF (MWK(START(MB)+2) == MUNKNO .OR. MWK(START(MX)) < 0 .OR. MWK(START(MA)) < 0 .OR.  &
          MWK(START(MB)) < 0) THEN
          KRESLT = 12
          KFLAG = -4
      ENDIF
      IF (KRESLT /= 0) THEN
          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (KFLAG == -4) THEN
              IF (MWK(START(MX)+2) /= MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
                  MWK(START(MB)+2) /= MUNKNO) THEN
                  CALL FMWRN2
              ENDIF
          ENDIF
          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCX = MWK(START(MX)+1)
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MX,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)

!             Handle cases where at least one of X, A, B is underflow or overflow.
!             Increasing any underflowed values to 1/HUGE makes the calculations more stable.
!             If A is underflow and the final result is overflow, it is safe to return overflow.
!             If X is underflow and the final result is underflow, it is safe to return underflow.
!             If B is underflow, it is replaced by zero.
!             Similarly, decreasing any overflowed A or B values to HUGE and then getting a final
!             result of underflow means it is safe to return underflow.
!             Any cases where the inequalities conflict, such as A = underflow, B = overflow,
!             will return unknown.

      KBIGAB = 0
      IF (MWK(START(MA)+2) == MEXPOV) THEN
          CALL FMBIG(MXY(2))
          MWK(START(MXY(2))+2) = MXSAVE + 1
          KBIGAB = -1
      ENDIF
      IF (MWK(START(MB)+2) == MEXPOV) THEN
          CALL FMBIG(MXY(3))
          MWK(START(MXY(3))+2) = MXSAVE + 1
          KBIGAB = -1
      ENDIF
      IF (MWK(START(MX)+2) == MEXPUN) THEN
          CALL FMBIG(MXY(1))
          MWK(START(MXY(1))+2) = MXSAVE + 1
          CALL FMI2M(1,MXY(12))
          CALL FMDIV_R2(MXY(12),MXY(1))
          KBIGAB = -1
      ENDIF
      IF (MWK(START(MA)+2) == MEXPUN) THEN
          CALL FMBIG(MXY(2))
          MWK(START(MXY(2))+2) = MXSAVE + 1
          CALL FMI2M(1,MXY(12))
          CALL FMDIV_R2(MXY(12),MXY(2))
          IF (KBIGAB < 0) THEN
              KBIGAB = -9
              CALL FMI2M(0,MXY(21))
              GO TO 200
          ELSE
              KBIGAB = 1
          ENDIF
      ENDIF
      IF (MWK(START(MB)+2) == MEXPUN) THEN
          CALL FMI2M(1,MXY(12))
          IF (FMCOMP(MXY(1),'/=',MXY(12))) THEN
              CALL FMI2M(0,MXY(3))
          ENDIF
      ENDIF
      NUMTRY = 0
      NDGOAL = 0
      NWDS1 = 0
      KASHIFT = 0
      KBSHIFT = 0

!             Check for special cases.

  120 KICK = 0
      CALL FMIBTA2(K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD)
      IF (K_RETURN_CODE == 1) GO TO 180
      IF (K_RETURN_CODE == 2) GO TO 200

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series for B(x,a,b),
!                    = 2 means use continued fraction expansion 1 for B(x,a,b),
!                    = 3 means use the convergent series for B(1-x,b,a).
!                    = 4 means use continued fraction expansion 1 for B(1-x,b,a).
!                    = 5 means use continued fraction expansion 2 for B(x,a,b).
!                    = 6 means use continued fraction expansion 2 for B(1-x,b,a).

      CALL FMSQR(MXY(2),MXY(12))
      CALL FMDPM(DBLE(.00173),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(6))
      CALL FMSQR(MXY(3),MXY(12))
      CALL FMDPM(DBLE(.01253),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.21583),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.03891),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(9.14350),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.11709),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(.62633),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(33))

      CALL FMDPM(DBLE(.29217),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(6))
      CALL FMDPM(DBLE(2.09304),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(1.53724),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.29217),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(2.09304),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(34))

      CALL FMSQR(MXY(2),MXY(12))
      CALL FMDPM(DBLE(.04038),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(6))
      CALL FMSQR(MXY(3),MXY(12))
      CALL FMDPM(DBLE(.05754),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.02670),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.56206),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(0.13746),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.87312),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(.20334),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(35))

      CALL FMDPM(DBLE(.64584),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(6))
      CALL FMDPM(DBLE(.64584),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(6.31958),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.64584),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(36))

      CALL FMSQR(MXY(2),MXY(12))
      CALL FMDPM(DBLE(.11637),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(6))
      CALL FMSQR(MXY(3),MXY(12))
      CALL FMDPM(DBLE(.10718),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.92626),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.05518),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(0.28962),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.99773),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(.56855),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(37))

      IF (FMCOMP(MXY(1),'<=',MXY(33))) THEN
          NMETHD = 1
      ELSE IF (FMCOMP(MXY(1),'>=',MXY(34))) THEN
          NMETHD = 3
      ELSE IF (FMCOMP(MXY(1),'<',MXY(37))) THEN
          IF (FMCOMP(MXY(1),'<',MXY(35))) THEN
              NMETHD = 2
          ELSE
              NMETHD = 4
          ENDIF
      ELSE
          IF (FMCOMP(MXY(1),'<',MXY(36))) THEN
              NMETHD = 5
          ELSE
              NMETHD = 6
          ENDIF
      ENDIF
      IF (MWK(START(MXY(3))+2) <= 0 .AND. MWK(START(MXY(2))+2)+NDIG < 0) THEN
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) GO TO 140
      IF (NMETHD == 5) GO TO 150
      IF (NMETHD == 3 .OR. NMETHD == 4 .OR. NMETHD == 6) GO TO 160

!             Method 1.  Use the Pochhammer(1-B,N)*X**N/((A+N)*N!) series.

!             MXY(15) and MXY(21) hold the positive and negative parts of the current sum.
!             MXY(17) is the current term.
!             MXY(18) is J-B.
!             MXY(19) is 1.
!             MXY(20) is A+J.

  130 JEXTRA = INT(0.06*NDIG)
      IF (NDIG+JEXTRA > NDIG) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMI2M(1,MXY(17))
      CALL FMDIV(MXY(17),MXY(2),MXY(15))
      CALL FMI2M(0,MXY(21))
      CALL FMEQ(MXY(3),MXY(18))
      IF (MWK(START(MXY(18))+2) /= MUNKNO .AND. MWK(START(MXY(18))+3) /= 0)  &
          MWK(START(MXY(18))) = -MWK(START(MXY(18)))
      CALL FMEQ(MXY(2),MXY(20))
      CALL FMI2M(1,MXY(19))
      CALL FMI2M(0,MXY(16))
      CALL FMI2M(0,MXY(22))
      JCHECK = 5
      NDSAV1 = NDIG

!             Method 1 summation loop.

      KRSAVE = KROUND
      KROUND = 1
      METHOD1:    DO J = 1, NTERMS
         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(18),MXY(19))
         IF (MWK(START(MXY(18))+3) == 0) MWK(START(MXY(18))+1) = MWK(START(MXY(19))+1)
         NDIG2 = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(15))+2)-MWK(START(MXY(17))+2)),  &
                                       NDSAV1-INT(MWK(START(MXY(21))+2)-MWK(START(MXY(17))+2))))
         NDIG = NDIG2
         CALL FMCSMPY_R1(MXY(17),MXY(18))
         CALL FMCSMPY_R1(MXY(17),MXY(1))
         IF (J > 1) CALL FMDIVI_R1(MXY(17),J)
         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(20),MXY(19))
         NDIG = NDIG2
         CALL FMCSDIV(MXY(17),MXY(20),MXY(16))

         NDIG = NDSAV1
         IF (INT(MWK(START(MXY(16)))) < 0) THEN
             CALL FMADD_R2(MXY(16),MXY(21))
         ELSE
             CALL FMADD_R2(MXY(16),MXY(15))
         ENDIF

         IF (KFLAG < 0) EXIT
         IF (MOD(J,JCHECK) == 0) THEN
             CALL FMADD(MXY(15),MXY(21),MXY(16))
             DO K = NDIG+1, 1, -1
                IF (MWK(START(MXY(16))+K+1) /= MWK(START(MXY(22))+K+1)) THEN
                    CALL FMEQ(MXY(16),MXY(22))
                    CYCLE METHOD1
                ENDIF
             ENDDO
             EXIT
         ENDIF
      ENDDO METHOD1
      KROUND = KRSAVE

      CALL FMPWR(MXY(1),MXY(2),MXY(12))
      CALL FMADD(MXY(15),MXY(21),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(21))

      IF (NMETHD == 1) THEN
          GO TO 180
      ELSE
          GO TO 170
      ENDIF

!             Method 2.  Continued fraction expansion for B(x,a,b).

!             MXY(22) is the current approximation.
!             MXY(21) is the term in the sum, S(k).
!             MXY(19), MXY(20) are the latest denominators, Q(k-1) and Q(k).

  140 JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0)) + NGRD52 + INT(0.152*NDIG)
      IF (NDIG+JEXTRA > NDIG) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(19))
      CALL FMI2M(1,MXY(20))
      CALL FMI2M(1,MXY(21))
      CALL FMEQ(MXY(21),MXY(22))
      CALL FMEQ(MXY(2),MXY(24))
      CALL FMADD(MXY(2),MXY(3),MXY(25))
      CALL FMEQ(MXY(2),MXY(26))
      CALL FMI2M(1,MXY(12))
      CALL FMADD(MXY(2),MXY(12),MXY(27))
      CALL FMEQ(MXY(3),MXY(28))
      CALL FMSQR(MXY(2),MXY(29))
      CALL FMADD(MXY(29),MXY(26),MXY(30))
      CALL FMSUB(MXY(29),MXY(26),MXY(31))
      MWK(START(MXY(31))+1) = MWK(START(MXY(30))+1)
      CALL FMMPY(MXY(24),MXY(25),MXY(12))
      CALL FMMPY(MXY(12),MXY(1),MXY(7))
      CALL FMDIV(MXY(7),MXY(30),MXY(33))
      IF (MWK(START(MXY(33))+2) /= MUNKNO .AND. MWK(START(MXY(33))+3) /= 0)  &
          MWK(START(MXY(33))) = -MWK(START(MXY(33)))
      CALL FMMPY(MXY(33),MXY(19),MXY(18))
      CALL FMADD(MXY(20),MXY(18),MXY(17))
      CALL FMMPY(MXY(18),MXY(21),MXY(12))
      CALL FMDIV(MXY(12),MXY(17),MXY(21))
      IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
          MWK(START(MXY(21))) = -MWK(START(MXY(21)))
      CALL FMADD_R1(MXY(22),MXY(21))
      CALL FMEQ(MXY(20),MXY(19))
      CALL FMEQ(MXY(17),MXY(20))

!             Method 2 continued fraction loop.

      KRSAVE = KROUND
      KROUND = 1
      DO J = 1, NTERMS
         CALL FMADDI(MXY(24),1)
         CALL FMADDI(MXY(25),1)
         CALL FMADDI(MXY(26),2)
         CALL FMADDI(MXY(27),2)
         CALL FMADDI(MXY(28),-1)
         MWK(START(MXY(28))+1) = MWK(START(MXY(27))+1)
         CALL FMMPYI(MXY(26),4,MXY(15))
         CALL FMADDI(MXY(15),-4)
         CALL FMCSADD_R1(MXY(29),MXY(15))
         MWK(START(MXY(29))+1) = MWK(START(MXY(27))+1)
         CALL FMADD(MXY(29),MXY(26),MXY(30))
         CALL FMSUB(MXY(29),MXY(26),MXY(31))

         CALL FMEQ(MXY(28),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(1))
         CALL FMMPYI_R1(MXY(15),J)
         CALL FMCSDIV(MXY(15),MXY(31),MXY(33))

         CALL FMEQ(MXY(33),MXY(18))
         CALL FMCSMPY_R1(MXY(18),MXY(19))
         CALL FMADD(MXY(20),MXY(18),MXY(17))
         CALL FMEQ(MXY(18),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(21))
         CALL FMCSDIV(MXY(15),MXY(17),MXY(21))
         IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
             MWK(START(MXY(21))) = -MWK(START(MXY(21)))

         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(22),MXY(21))
         KFLAG1 = KFLAG

         CALL FMEQ(MXY(20),MXY(19))
         CALL FMEQ(MXY(17),MXY(20))
         NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-MWK(START(MXY(21))+2))))
         CALL FMEQ(MXY(24),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(25))
         CALL FMCSMPY_R1(MXY(15),MXY(1))
         CALL FMCSDIV(MXY(15),MXY(30),MXY(33))
         IF (MWK(START(MXY(33))+2) /= MUNKNO .AND. MWK(START(MXY(33))+3) /= 0)  &
             MWK(START(MXY(33))) = -MWK(START(MXY(33)))

         CALL FMEQ(MXY(33),MXY(18))
         CALL FMCSMPY_R1(MXY(18),MXY(19))
         CALL FMADD(MXY(20),MXY(18),MXY(17))
         CALL FMEQ(MXY(18),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(21))
         CALL FMCSDIV(MXY(15),MXY(17),MXY(21))
         IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
             MWK(START(MXY(21))) = -MWK(START(MXY(21)))

         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(22),MXY(21))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(20),MXY(19))
         CALL FMEQ(MXY(17),MXY(20))
         NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-MWK(START(MXY(21))+2))))
      ENDDO
      KROUND = KRSAVE

      CALL FMLN(MXY(1),MXY(19))
      CALL FMMPY_R1(MXY(19),MXY(2))
      IF (MWK(START(MXY(1))+2)*(-10) >= NDIG) THEN
          CALL FMEQ(MXY(1),MXY(15))
          CALL FMEQ(MXY(1),MXY(20))
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(1))
             CALL FMDIVI(MXY(15),K,MXY(12))
             CALL FMADD_R1(MXY(20),MXY(12))
             IF (KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY_R1(MXY(20),MXY(3))
          IF (MWK(START(MXY(20))+2) /= MUNKNO .AND. MWK(START(MXY(20))+3) /= 0)  &
              MWK(START(MXY(20))) = -MWK(START(MXY(20)))
      ELSE
          CALL FMI2M(1,MXY(12))
          CALL FMSUB_R1(MXY(12),MXY(1))
          CALL FMLN(MXY(12),MXY(20))
          CALL FMMPY_R1(MXY(20),MXY(3))
      ENDIF
      CALL FMADD(MXY(19),MXY(20),MXY(12))
      CALL FMEXP(MXY(12),MXY(21))
      CALL FMMPY_R2(MXY(22),MXY(21))
      IF (MWK(START(MXY(21))+2) == MUNKNO) THEN
          IF (MWK(START(MXY(22)))*MWK(START(MXY(22))+3) > 0) THEN
              CALL FMLN(MXY(22),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
          ELSE
              CALL FMEQ(MXY(22),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMLN(MXY(13),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
              IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
                  MWK(START(MXY(21))) = -MWK(START(MXY(21)))
          ENDIF
      ENDIF
      IF (ABS(MWK(START(MXY(21))+2)) < MEXPOV) CALL FMDIV_R1(MXY(21),MXY(2))
      IF (NMETHD == 2) THEN
          GO TO 180
      ELSE
          GO TO 170
      ENDIF

!             Method 5.  Continued fraction expansion 2 for B(x,a,b).

!             MXY(22) is the current approximation.
!             MXY(21) is the term in the sum, S(k).
!             MXY(19), MXY(20) are the latest denominators, Q(k-1) and Q(k).

  150 JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0)) + INT(0.07*NDIG)
      IF (NDIG+JEXTRA > NDIG) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      NDSAV1 = NDIG
      CALL FMSQR(MXY(1),MXY(23))
      CALL FMI2M(1,MXY(12))
      CALL FMSUB(MXY(2),MXY(12),MXY(24))
      MWK(START(MXY(24))+1) = MWK(START(MXY(23))+1)
      CALL FMADD(MXY(2),MXY(3),MXY(25))
      CALL FMADDI(MXY(25),-1)
      MWK(START(MXY(25))+1) = MWK(START(MXY(23))+1)
      CALL FMEQ(MXY(24),MXY(26))
      CALL FMI2M(1,MXY(12))
      CALL FMADD(MXY(2),MXY(12),MXY(27))
      CALL FMEQ(MXY(3),MXY(28))
      CALL FMI2M(1,MXY(7))
      CALL FMSUB(MXY(2),MXY(7),MXY(12))
      CALL FMSQR(MXY(12),MXY(29))
      MWK(START(MXY(29))+1) = MWK(START(MXY(23))+1)
      CALL FMI2M(2,MXY(12))
      CALL FMSUB(MXY(12),MXY(1),MXY(30))
      MWK(START(MXY(30))+1) = MWK(START(MXY(27))+1)
      IF (NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,NDIG)
          CALL FMMPY(MXY(2),MXY(19),MXY(7))
          CALL FMMPY(MXY(3),MXY(1),MXY(12))
          CALL FMSUB(MXY(7),MXY(12),MXY(31))
          CALL FMADDI(MXY(31),1)
      ELSE
          CALL FMADD(MXY(2),MXY(3),MXY(7))
          CALL FMMPY(MXY(7),MXY(1),MXY(12))
          CALL FMSUB(MXY(2),MXY(12),MXY(31))
          CALL FMADDI(MXY(31),1)
      ENDIF
      MWK(START(MXY(31))+1) = MWK(START(MXY(27))+1)
      CALL FMEQ(MXY(2),MXY(35))
      CALL FMI2M(2,MXY(7))
      CALL FMSUB(MXY(2),MXY(7),MXY(12))
      CALL FMMPYI(MXY(12),4,MXY(36))
      MWK(START(MXY(36))+1) = MWK(START(MXY(36))+1)

      CALL FMI2M(1,MXY(33))
      CALL FMMPY(MXY(35),MXY(31),MXY(12))
      CALL FMDIV(MXY(12),MXY(27),MXY(34))

      CALL FMI2M(1,MXY(19))
      CALL FMEQ(MXY(34),MXY(20))
      CALL FMDIV(MXY(33),MXY(34),MXY(21))
      CALL FMEQ(MXY(21),MXY(22))

!             Method 5 continued fraction loop.

      KRSAVE = KROUND
      KROUND = 1
      DO J = 1, NTERMS
         CALL FMADDI(MXY(24),1)
         CALL FMADDI(MXY(25),1)
         CALL FMADDI(MXY(26),2)
         CALL FMADDI(MXY(27),2)
         CALL FMADDI(MXY(28),-1)
         MWK(START(MXY(28))+1) = MWK(START(MXY(27))+1)
         CALL FMADDI(MXY(36),8)
         CALL FMCSADD_R1(MXY(29),MXY(36))
         CALL FMCSADD_R1(MXY(31),MXY(30))
         CALL FMADDI(MXY(35),1)

         CALL FMEQ(MXY(24),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(25))
         CALL FMCSMPYI_R1(MXY(15),J)
         CALL FMCSMPY_R1(MXY(15),MXY(28))
         CALL FMCSMPY_R1(MXY(15),MXY(23))
         CALL FMCSDIV(MXY(15),MXY(29),MXY(33))

         CALL FMEQ(MXY(35),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(31))
         CALL FMCSDIV(MXY(15),MXY(27),MXY(34))
         CALL FMEQ(MXY(28),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(1))
         CALL FMCSMPYI_R1(MXY(15),J)
         CALL FMDIV_R1(MXY(15),MXY(26))
         CALL FMCSADD_R1(MXY(34),MXY(15))
         CALL FMADDI(MXY(34),J)

         CALL FMEQ(MXY(33),MXY(18))
         CALL FMCSMPY_R1(MXY(18),MXY(19))
         CALL FMEQ(MXY(34),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(20))
         CALL FMADD(MXY(15),MXY(18),MXY(17))
         CALL FMEQ(MXY(18),MXY(15))
         CALL FMCSMPY_R1(MXY(15),MXY(21))
         CALL FMCSDIV(MXY(15),MXY(17),MXY(21))
         IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
             MWK(START(MXY(21))) = -MWK(START(MXY(21)))

         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(22),MXY(21))

!             Check for convergence.

         IF (KFLAG == 1) THEN
             EXIT
         ENDIF

         CALL FMEQ(MXY(20),MXY(19))
         CALL FMEQ(MXY(17),MXY(20))
         NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-MWK(START(MXY(21))+2))))
      ENDDO
      KROUND = KRSAVE
      NDIG = NDSAV1

      CALL FMI2M(1,MXY(12))
      IF (FMCOMP(MXY(1),'==',MXY(12)) .AND. NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,NDIG)
          CALL FMMPY_R1(MXY(19),MXY(2))
          IF (MWK(START(MXY(19))+2) /= MUNKNO .AND. MWK(START(MXY(19))+3) /= 0)  &
              MWK(START(MXY(19))) = -MWK(START(MXY(19)))
      ELSE IF (MWK(START(MX)+2) <= -1 .AND. NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,NDIG)
          CALL FMEQ(MXY(19),MXY(15))
          CALL FMEQ(MXY(19),MXY(20))
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(19))
             CALL FMDIVI(MXY(15),K,MXY(12))
             CALL FMADD_R1(MXY(20),MXY(12))
             IF (KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY(MXY(20),MXY(2),MXY(19))
          IF (MWK(START(MXY(19))+2) /= MUNKNO .AND. MWK(START(MXY(19))+3) /= 0)  &
              MWK(START(MXY(19))) = -MWK(START(MXY(19)))
      ELSE
          CALL FMLN(MXY(1),MXY(19))
          CALL FMMPY_R1(MXY(19),MXY(2))
      ENDIF
      IF (NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(20),NDSAVE,NDIG)
          CALL FMLN(MXY(20),MXY(10))
          CALL FMMPY(MXY(10),MXY(3),MXY(20))
      ELSE IF (MWK(START(MXY(1))+2) <= -1) THEN
          CALL FMEQ(MXY(1),MXY(15))
          CALL FMEQ(MXY(1),MXY(20))
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(1))
             CALL FMDIVI(MXY(15),K,MXY(12))
             CALL FMADD_R1(MXY(20),MXY(12))
             IF (KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY_R1(MXY(20),MXY(3))
          IF (MWK(START(MXY(20))+2) /= MUNKNO .AND. MWK(START(MXY(20))+3) /= 0)  &
              MWK(START(MXY(20))) = -MWK(START(MXY(20)))
      ELSE
          CALL FMI2M(1,MXY(12))
          CALL FMSUB_R1(MXY(12),MXY(1))
          CALL FMLN(MXY(12),MXY(20))
          CALL FMMPY_R1(MXY(20),MXY(3))
      ENDIF
      CALL FMADD(MXY(19),MXY(20),MXY(12))
      CALL FMEXP(MXY(12),MXY(21))
      CALL FMMPY_R1(MXY(21),MXY(22))
      IF (MWK(START(MXY(21))+2) == MUNKNO) THEN
          IF (MWK(START(MXY(22)))*MWK(START(MXY(22))+3) > 0) THEN
              CALL FMLN(MXY(22),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
          ELSE
              CALL FMEQ(MXY(22),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMLN(MXY(13),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
              IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
                  MWK(START(MXY(21))) = -MWK(START(MXY(21)))
          ENDIF
      ENDIF
      IF (NMETHD == 5) THEN
          GO TO 180
      ELSE
          GO TO 170
      ENDIF

!             Method 3, 4, or 6.  B(X,A,B) = B(A,B) - B(1-X,B,A).

  160 MLA = MWK(START(MXY(1))+1)
      CALL FMI2M(1,MXY(12))
      CALL FMSUB_R2(MXY(12),MXY(1))
      MWK(START(MXY(1))+1) = MLA
      DO J = -1, NDIG+1
         MLA = MWK(START(MXY(2))+J+1)
         MWK(START(MXY(2))+J+1) = MWK(START(MXY(3))+J+1)
         MWK(START(MXY(3))+J+1) = MLA
      ENDDO
      IF (NMETHD == 3) THEN
          GO TO 130
      ELSE IF (NMETHD == 4) THEN
          GO TO 140
      ELSE
          GO TO 150
      ENDIF
  170 K = NWDS1
      CALL FMEQ(MXY(21),MXY(30))
      CALL FMBETA(MXY(2),MXY(3),MXY(32))
      NWDS1 = INT(MAX(MWK(START(MXY(32))+2),MWK(START(MXY(30))+2)))
      CALL FMSUB(MXY(32),MXY(30),MXY(21))
      NWDS1 = MAX(0,NWDS1-INT(MWK(START(MXY(21))+2)))
      IF (K /= NWDS1 .AND. NUMTRY >= 1) THEN
          IF (KASHIFT == 0 .AND. KBSHIFT == 0) MWK(START(MXY(21))+1) = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(21))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      K = KFLAG
      IF (KICK < 0) MWK(START(MXY(21))+1) = KICK

!             Reverse the translation if KASHIFT is positive.
!             This is used when a is small and a retry was required because of cancellation.

      IF (KASHIFT > 0 .AND. MWK(START(MXY(21))+1) > 0) THEN
          CALL FMEQU(MX,MXY(22),NDSAVE,NDIG)
          CALL FMEQU(MA,MXY(23),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(24),NDSAVE,NDIG)
          IF (KBSHIFT > 0) CALL FMADDI(MXY(24),KBSHIFT)
          CALL FMI2M(1,MXY(19))
          CALL FMADD(MXY(23),MXY(24),MXY(16))
          CALL FMI2M(1,MXY(12))
          CALL FMADD(MXY(23),MXY(12),MXY(7))
          CALL FMDIV(MXY(16),MXY(7),MXY(20))
          CALL FMI2M(1,MXY(12))
          CALL FMSUB(MXY(12),MXY(22),MXY(17))
          CALL FMEQ(MXY(22),MXY(18))
          CALL FMMPY(MXY(20),MXY(22),MXY(12))
          CALL FMADD_R1(MXY(19),MXY(12))
          CALL FMEQ(MXY(16),MXY(14))
          CALL FMEQ(MXY(23),MXY(15))
          CALL FMADDI(MXY(15),1)
          DO J = 2, KASHIFT-1
             CALL FMADDI(MXY(14),1)
             CALL FMADDI(MXY(15),1)
             CALL FMMPY_R1(MXY(20),MXY(14))
             CALL FMDIV_R1(MXY(20),MXY(15))
             CALL FMMPY_R1(MXY(18),MXY(22))
             CALL FMMPY(MXY(20),MXY(18),MXY(13))
             CALL FMADD_R1(MXY(19),MXY(13))
          ENDDO
          IF (MWK(START(MXY(22))+2)*(-10) >= NDIG) THEN
              CALL FMEQ(MXY(22),MXY(15))
              CALL FMEQ(MXY(22),MXY(17))
              DO K = 2, NTERMS
                 CALL FMMPY_R1(MXY(15),MXY(22))
                 CALL FMDIVI(MXY(15),K,MXY(12))
                 CALL FMADD_R1(MXY(17),MXY(12))
                 IF (KFLAG /= 0) EXIT
              ENDDO
              CALL FMMPY(MXY(17),MXY(24),MXY(12))
              IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0)  &
                  MWK(START(MXY(12))) = -MWK(START(MXY(12)))
              CALL FMEXP(MXY(12),MXY(18))
              CALL FMEQ(MXY(19),MXY(15))
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY(MXY(19),MXY(12),MXY(7))
              CALL FMMPY(MXY(7),MXY(18),MXY(12))
              CALL FMDIV(MXY(12),MXY(23),MXY(19))
              IF (MWK(START(MXY(19))+2) == MUNKNO) THEN
                  CALL FMLN(MXY(22),MXY(12))
                  CALL FMMPY(MXY(23),MXY(12),MXY(19))
                  CALL FMLN(MXY(15),MXY(12))
                  CALL FMADD_R2(MXY(12),MXY(19))
                  CALL FMMPY(MXY(17),MXY(24),MXY(12))
                  CALL FMSUB_R1(MXY(19),MXY(12))
                  CALL FMLN(MXY(23),MXY(12))
                  CALL FMSUB_R2(MXY(19),MXY(12))
                  CALL FMEXP(MXY(12),MXY(19))
              ENDIF
          ELSE
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMPWR(MXY(17),MXY(24),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMDIV_R1(MXY(19),MXY(23))
          ENDIF
          CALL FMMPY(MXY(21),MXY(20),MXY(12))
          CALL FMI2M(KASHIFT-1,MXY(7))
          CALL FMADD_R2(MXY(16),MXY(7))
          CALL FMMPY_R1(MXY(12),MXY(7))
          CALL FMDIV(MXY(12),MXY(23),MXY(20))
          CALL FMADD(MXY(20),MXY(19),MXY(21))
      ENDIF

!             Reverse the translation if KBSHIFT is positive.
!             This is used when x is close to 1, b is small, and a retry was required because
!             of cancellation.

      IF (KBSHIFT > 0 .AND. MWK(START(MXY(21))+1) > 0) THEN
          CALL FMEQU(MX,MXY(22),NDSAVE,NDIG)
          CALL FMEQU(MA,MXY(23),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(24),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(19))
          CALL FMI2M(1,MXY(12))
          CALL FMADD(MXY(24),MXY(12),MXY(7))
          CALL FMADD(MXY(23),MXY(24),MXY(12))
          CALL FMDIV(MXY(12),MXY(7),MXY(20))
          CALL FMADD(MXY(23),MXY(24),MXY(16))
          CALL FMI2M(1,MXY(12))
          CALL FMSUB(MXY(12),MXY(22),MXY(17))
          CALL FMEQ(MXY(17),MXY(18))
          CALL FMMPY(MXY(20),MXY(18),MXY(12))
          CALL FMADD_R1(MXY(19),MXY(12))
          CALL FMEQ(MXY(16),MXY(14))
          CALL FMEQ(MXY(24),MXY(15))
          CALL FMADDI(MXY(15),1)
          DO J = 2, KBSHIFT-1
             CALL FMADDI(MXY(14),1)
             CALL FMADDI(MXY(15),1)
             CALL FMMPY_R1(MXY(20),MXY(14))
             CALL FMDIV_R1(MXY(20),MXY(15))
             CALL FMMPY_R1(MXY(18),MXY(17))
             CALL FMMPY(MXY(20),MXY(18),MXY(13))
             CALL FMADD_R1(MXY(19),MXY(13))
          ENDDO
          IF (MWK(START(MXY(22))+2)*(-10) >= NDIG) THEN
              CALL FMEQ(MXY(22),MXY(15))
              CALL FMEQ(MXY(22),MXY(17))
              DO K = 2, NTERMS
                 CALL FMMPY_R1(MXY(15),MXY(22))
                 CALL FMDIVI(MXY(15),K,MXY(12))
                 CALL FMADD_R1(MXY(17),MXY(12))
                 IF (KFLAG /= 0) EXIT
              ENDDO
              CALL FMMPY(MXY(17),MXY(24),MXY(12))
              IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0)  &
                  MWK(START(MXY(12))) = -MWK(START(MXY(12)))
              CALL FMEXP(MXY(12),MXY(17))
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY(MXY(19),MXY(12),MXY(7))
              CALL FMMPY(MXY(7),MXY(17),MXY(12))
              CALL FMDIV(MXY(12),MXY(24),MXY(19))
          ELSE
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMPWR(MXY(17),MXY(24),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMDIV_R1(MXY(19),MXY(24))
          ENDIF
          CALL FMMPY(MXY(21),MXY(20),MXY(12))
          CALL FMI2M(KBSHIFT-1,MXY(7))
          CALL FMADD_R2(MXY(16),MXY(7))
          CALL FMMPY_R1(MXY(12),MXY(7))
          CALL FMDIV(MXY(12),MXY(24),MXY(20))
          CALL FMSUB(MXY(20),MXY(19),MXY(21))
      ENDIF
      IF (NCALL <= 1) THEN
          NGOAL = 1.06*(INT(REAL(NDSAVE)*ALOGM2) + 29)
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
      IF (MWK(START(MXY(21))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              IF (MWK(START(MXY(21))+3) == 0 .OR. K < 0) GO TO 190
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(21))+J+1)) GO TO 190
              ENDDO
              CALL FMI2M(1,MXY(15))
              MWK(START(MXY(21))+1) = MWK(START(MXY(15))+1)
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(21))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          IF (MWK(START(MXY(21))+1) < 0) NDIG = NDOLD + 10*2**NUMTRY
          IF (ABS(MWK(START(MX)+2)) >= MEXPOV .OR. ABS(MWK(START(MA)+2)) >= MEXPOV .OR.  &
              ABS(MWK(START(MB)+2)) >= MEXPOV) THEN
              CALL FMST2M('UNKNOWN',MXY(21))
              KFLAG = -4
              GO TO 200
          ENDIF
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQU_R1(MXY(2),NDSAVE,NDIG)
          CALL FMEQU_R1(MXY(3),NDSAVE,NDIG)
          IF (NMETHD == 3 .OR. NMETHD == 4 .OR. NMETHD == 6) THEN
              CALL FMEQU(MX,MXY(1),NDSAVE,NDIG)
              DO J = -1, NDIG+1
                 MLA = MWK(START(MXY(2))+J+1)
                 MWK(START(MXY(2))+J+1) = MWK(START(MXY(3))+J+1)
                 MWK(START(MXY(3))+J+1) = MLA
              ENDDO
          ENDIF

          IF (KASHIFT > 0) THEN
              CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
              IF (KASHIFT <= 2000) THEN
                  KASHIFT = 9*KASHIFT
              ELSE
                  KASHIFT = NDIG
              ENDIF
              CALL FMADDI(MXY(2),KASHIFT)
          ENDIF
          IF (KBSHIFT > 0) THEN
              CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
              IF (KBSHIFT <= 2000) THEN
                  KBSHIFT = 9*KBSHIFT
              ELSE
                  KBSHIFT = NDIG
              ENDIF
              CALL FMADDI(MXY(3),KBSHIFT)
          ENDIF

!             Check to see if a retry is about to be done for small a and large b.
!             If so, raise a by 2*NDIG to reduce the potential cancellation error.

          CALL FMI2M(200,MXY(12))
          IF (NUMTRY == 0 .AND. FMCOMP(MXY(2),'<=',MXY(12)) .AND. FMCOMP(MXY(3),'>=',MXY(2))) THEN
              KASHIFT = 2*NDIG
              CALL FMADDI(MXY(2),2*NDIG)
          ENDIF

!             Check to see if a retry is about to be done for a > 100 and b < 2.
!             If so, raise b by 2*NDIG to reduce the potential cancellation error.

          CALL FMI2M(100,MXY(12))
          CALL FMI2M(2,MXY(7))
          IF (NUMTRY == 0 .AND. FMCOMP(MXY(2),'>=',MXY(12)) .AND. FMCOMP(MXY(3),'<=',MXY(7))) THEN
              KBSHIFT = 2*NDIG
              CALL FMADDI(MXY(3),2*NDIG)
          ENDIF

          CALL FMI2M(40*NUMTRY,MXY(12))
          CALL FMI2M(100,MXY(7))
          IF (NUMTRY > 0 .AND. KASHIFT == 0 .AND. FMCOMP(MXY(2),'<=',MXY(12))  &
              .AND. FMCOMP(MXY(3),'>=',MXY(7))) THEN
              KASHIFT = 2*NDIG
              CALL FMADDI(MXY(2),2*NDIG)
          ENDIF

          CALL FMI2M(40*NUMTRY,MXY(12))
          CALL FMI2M(100,MXY(7))
          IF (NUMTRY > 0 .AND. KBSHIFT == 0 .AND. FMCOMP(MXY(2),'>=',MXY(12))  &
              .AND. FMCOMP(MXY(3),'<=',MXY(7))) THEN
              KBSHIFT = 2*NDIG
              CALL FMADDI(MXY(3),2*NDIG)
          ENDIF

          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(21),MRETRY,NDOLD,NDIG)
          IF (KASHIFT == 2*NDIG .OR. KBSHIFT == 2*NDIG) THEN
              NDIG = MAX(NDIG,NDOLD+2)
          ENDIF
          GO TO 120
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(21))+1) = MIN(MWK(START(MXY(21))+1),MACCX,MACCA,MACCB,MACMAX)
      MXEXP = MXSAVE
      CALL FMEQU(MXY(21),MXY(20),NDIG,NDSAVE)
      IF (KBIGAB /= 0) THEN
          IF ((MWK(START(MXY(20))+2) >= -MXSAVE  .AND. KBIGAB == -1) .OR.  &
              (MWK(START(MXY(20))+2) <= MXSAVE+1 .AND. KBIGAB ==  1) .OR. (KBIGAB == -9)) THEN
              CALL FMST2M('UNKNOWN',MXY(21))
              KFLAG = -4
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(21),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIBTA

      SUBROUTINE FMIBTA2(K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD)

!  Check for various special cases in Incomplete Beta.

      USE FMVALS
      IMPLICIT NONE

      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J4,JR,JSWITCH,K,KRSAVE,K_RETURN_CODE,N,NDSAV1,NMETHD,NTERMS,NUMTRY,NUP
      INTEGER, PARAMETER :: KPRIME(8) = (/ 2, 3, 5, 7, 11, 13, 17, 19 /)
      LOGICAL, EXTERNAL :: FMCOMP
      INTEGER :: MXY(37),MJSUMS(LJSUMS)
      INTENT (INOUT) :: K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD

      MJSUMS = -2
      K_RETURN_CODE = 0
      CALL FMI2M(0,MXY(32))
      NDSAV1 = NDIG

!             If B is small, use more guard digits.

      CALL FMDPM(1.0D-10,MXY(12))
      IF (FMCOMP(MXY(3),'<=',MXY(12))) THEN
          IEXTRA = NGRD52
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
          NDIG = NDIG + IEXTRA
      ENDIF

      NTERMS = INT(INTMAX/10)
      NMETHD = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(21))
          K_RETURN_CODE = 1
          RETURN
      ENDIF
      CALL FMI2M(1,MXY(28))
      IF (FMCOMP(MXY(28),'==',MXY(1))) THEN
          IEXTRA = NGRD52
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
          NDIG = NDIG + IEXTRA
          CALL FMBETA(MXY(2),MXY(3),MXY(31))
          CALL FMEQ(MXY(31),MXY(21))
          K_RETURN_CODE = 1
          RETURN
      ELSE IF (MWK(START(MXY(1))) < 0 .OR. FMCOMP(MXY(1),'>',MXY(28))) THEN
          CALL FMST2M('UNKNOWN',MXY(21))
          KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      IF (MWK(START(MXY(2))) < 0 .OR. MWK(START(MXY(2))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(21))
          KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      IF (MWK(START(MXY(3))) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(21))
          KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      JR = NUMTRY
      IF (MWK(START(MXY(2))+2) < (-NDIG) .AND. MWK(START(MXY(3))+2) < (-NDIG)) THEN
          CALL FMSUB(MXY(28),MXY(1),MXY(12))
          CALL FMLN(MXY(12),MXY(21))
          CALL FMDIV(MXY(28),MXY(2),MXY(12))
          CALL FMSUB(MXY(12),MXY(21),MXY(13))
          CALL FMPWR(MXY(1),MXY(2),MXY(12))
          CALL FMMPY(MXY(13),MXY(12),MXY(21))
          K_RETURN_CODE = 1
          RETURN
      ENDIF
      CALL FMI2M(1,MXY(12))
      CALL FMSUB(MXY(12),MXY(3),MXY(7))
      CALL FMMPY(MXY(1),MXY(7),MXY(12))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(12),MXY(28),MXY(7))
      KROUND = JR
      IF (FMCOMP(MXY(7),'==',MXY(28))) THEN
          CALL FMLN(MXY(1),MXY(12))
          CALL FMMPY(MXY(2),MXY(12),MXY(21))
          CALL FMLN(MXY(2),MXY(12))
          CALL FMSUB_R2(MXY(21),MXY(12))
          CALL FMEXP(MXY(12),MXY(21))
          K_RETURN_CODE = 2
          RETURN
      ENDIF

!             When A or B is large, check for an underflowed result.

      CALL FMDPM(1.0D+7,MXY(12))
      IF (FMCOMP(MXY(2),'>',MXY(12)) .OR. FMCOMP(MXY(3),'>',MXY(12))) THEN

!             If B is much larger than A, approximate BETA(A,B) and use that as an upper bound.

          IF (MWK(START(MXY(3))+2) >= MWK(START(MXY(2))+2)+NDIG) THEN
              CALL FMADD(MXY(3),MXY(2),MXY(12))
              CALL FMLN(MXY(12),MXY(23))
              CALL FMMPY_R2(MXY(2),MXY(23))
              CALL FMEQ(MXY(2),MXY(27))
              CALL FMLNGM(MXY(27),MXY(24))
              CALL FMSUB(MXY(24),MXY(23),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF

!             If A > 2 > B, use the bound
!                C = min( X , (A-2)/(A+B-2) )
!                BETA(X,A,B) < (A-1)*X/B * C**(A-2) * (1-C)**B
!
!             An alternate bound is also tried:
!                C = min( X , (A-1)/(A+B-2) )
!                BETA(X,A,B) < C**A * (1-C)**(1-B)

          CALL FMI2M(2,MXY(12))
          IF (FMCOMP(MXY(2),'>',MXY(12)) .AND. FMCOMP(MXY(3),'<',MXY(12))) THEN
              CALL FMI2M(2,MXY(6))
              CALL FMSUB(MXY(2),MXY(6),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV_R1(MXY(12),MXY(7))
              CALL FMMIN(MXY(1),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(12))
              CALL FMSUB_R2(MXY(2),MXY(12))
              CALL FMLN(MXY(12),MXY(27))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMADD_R1(MXY(27),MXY(12))
              CALL FMLN(MXY(3),MXY(12))
              CALL FMSUB_R1(MXY(27),MXY(12))
              CALL FMI2M(2,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(21))
              CALL FMLN(MXY(23),MXY(12))
              CALL FMMPY_R2(MXY(21),MXY(12))
              CALL FMADD_R1(MXY(27),MXY(12))
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(7),MXY(23),MXY(12))
              CALL FMLN(MXY(12),MXY(21))
              CALL FMMPY(MXY(3),MXY(21),MXY(12))
              CALL FMADD_R1(MXY(27),MXY(12))
              CALL FMEXP(MXY(27),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMI2M(2,MXY(6))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV_R1(MXY(12),MXY(7))
              CALL FMMIN(MXY(1),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(7),MXY(23),MXY(12))
              CALL FMLN(MXY(12),MXY(27))
              CALL FMSUB(MXY(3),MXY(7),MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(27))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMMPY_R2(MXY(2),MXY(12))
              CALL FMADD_R2(MXY(12),MXY(27))
              CALL FMEXP(MXY(27),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF

!             If A > 2 and B > 2, use the bound
!                C = min( X , (A-1)/(A+B-2) )
!                BETA(X,A,B) < X * C**(A-1) * (1-C)**(B-1)

          CALL FMI2M(2,MXY(12))
          IF (FMCOMP(MXY(2),'>',MXY(12)) .AND. FMCOMP(MXY(3),'>',MXY(12))) THEN
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMI2M(2,MXY(6))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV_R1(MXY(12),MXY(7))
              CALL FMMIN(MXY(1),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(7),MXY(23),MXY(12))
              CALL FMLN(MXY(12),MXY(27))
              CALL FMSUB(MXY(3),MXY(7),MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(27))
              CALL FMLN(MXY(23),MXY(12))
              CALL FMSUB(MXY(2),MXY(7),MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(12))
              CALL FMADD_R2(MXY(12),MXY(27))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMADD_R2(MXY(12),MXY(27))
              CALL FMEXP(MXY(27),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for cases where X is large enough so that at this precision, B(X,A,B) = B(A,B).
!             These are often unstable, so it is better to use Beta.

      CALL FMI2M(1,MXY(12))
      CALL FMI2M(2,MXY(6))
      CALL FMADD(MXY(2),MXY(3),MXY(7))
      IF (FMCOMP(MXY(2),'>',MXY(12)) .AND. FMCOMP(MXY(7),'>',MXY(6))) THEN
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMI2M(2,MXY(6))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV(MXY(12),MXY(7),MXY(31))
          CALL FMI2M(1,MXY(12))
          CALL FMADD(MXY(2),MXY(3),MXY(7))
          CALL FMADDI(MXY(7),-3)
          IF (FMCOMP(MXY(31),'<',MXY(12)) .AND. FMCOMP(MXY(1),'>',MXY(31)) .AND.  &
              MWK(START(MXY(7))+3) /= 0) THEN
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(6))
              CALL FMSUB(MXY(3),MXY(7),MXY(12))
              CALL FMMPY_R2(MXY(6),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(6))
              CALL FMI2M(3,MXY(7))
              CALL FMSUB_R2(MXY(6),MXY(7))
              CALL FMDIV(MXY(12),MXY(7),MXY(30))
              IF (MWK(START(MXY(30))) >= 0) THEN
                  CALL FMI2M(1,MXY(7))
                  CALL FMSUB_R2(MXY(2),MXY(7))
                  CALL FMSQRT(MXY(30),MXY(12))
                  CALL FMADD(MXY(7),MXY(12),MXY(30))
                  CALL FMADD(MXY(2),MXY(3),MXY(7))
                  CALL FMI2M(2,MXY(6))
                  CALL FMSUB_R1(MXY(7),MXY(6))
                  CALL FMDIV_R1(MXY(30),MXY(7))
              ELSE
                  CALL FMDPM(DBLE(1.1),MXY(30))
              ENDIF
              CALL FMI2M(1,MXY(12))
              IF (FMCOMP(MXY(30),'>',MXY(31)) .AND. FMCOMP(MXY(30),'<',MXY(12)) .AND.  &
                  FMCOMP(MXY(1),'>=',MXY(30))) THEN

!                 Approximate B(A,B).

                  JR = KROUND
                  KROUND = 1
                  CALL FMADD(MXY(2),MXY(3),MXY(12))
                  KROUND = JR
                  IF (FMCOMP(MXY(12),'==',MXY(2))) THEN
                      CALL FMLN(MXY(3),MXY(12))
                      CALL FMDPM(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(3),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(29))
                      CALL FMSUB_R1(MXY(29),MXY(3))
                      CALL FMDPM(DLOGTP/2.0D0,MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                      CALL FMLN(MXY(2),MXY(12))
                      CALL FMMPY_R2(MXY(3),MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                  ELSE IF (FMCOMP(MXY(12),'==',MXY(3))) THEN
                      CALL FMLN(MXY(2),MXY(12))
                      CALL FMDP2M(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(2),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(29))
                      CALL FMSUB_R1(MXY(29),MXY(2))
                      CALL FMDPM(DLOGTP/2.0D0,MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                      CALL FMLN(MXY(3),MXY(12))
                      CALL FMMPY_R2(MXY(2),MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                  ELSE
                      CALL FMLN(MXY(2),MXY(12))
                      CALL FMDP2M(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(2),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(29))
                      CALL FMLN(MXY(3),MXY(12))
                      CALL FMDP2M(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(3),MXY(7))
                      CALL FMMPY_R2(MXY(7),MXY(12))
                      CALL FMADD_R1(MXY(29),MXY(12))
                      CALL FMADD(MXY(2),MXY(3),MXY(12))
                      CALL FMLN(MXY(12),MXY(7))
                      CALL FMDP2M(0.5D0,MXY(6))
                      CALL FMSUB_R2(MXY(12),MXY(6))
                      CALL FMMPY(MXY(6),MXY(7),MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                      CALL FMDPM(DLOGTP/2.0D0,MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                  ENDIF
                  CALL FMEXP(MXY(29),MXY(9))
                  CALL FMEQ(MXY(9),MXY(29))

!                 Bound the area from X to 1.

                  CALL FMI2M(1,MXY(12))
                  JR = KROUND
                  KROUND = 1
                  CALL FMSUB(MXY(12),MXY(1),MXY(7))
                  KROUND = JR
                  IF (FMCOMP(MXY(7),'==',MXY(12))) THEN
                      CALL FMLN(MXY(1),MXY(12))
                      CALL FMI2M(1,MXY(6))
                      CALL FMSUB(MXY(2),MXY(6),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(28))
                      CALL FMSUB(MXY(3),MXY(6),MXY(7))
                      CALL FMMPY(MXY(1),MXY(7),MXY(12))
                      CALL FMSUB_R1(MXY(28),MXY(12))
                      CALL FMSUB(MXY(6),MXY(1),MXY(12))
                      CALL FMDIVI_R1(MXY(12),2)
                      CALL FMLN(MXY(12),MXY(13))
                      CALL FMSUB_R1(MXY(28),MXY(13))
                  ELSE
                      CALL FMLN(MXY(1),MXY(12))
                      CALL FMI2M(1,MXY(6))
                      CALL FMSUB(MXY(2),MXY(6),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(28))
                      CALL FMSUB(MXY(3),MXY(6),MXY(7))
                      CALL FMSUB(MXY(6),MXY(1),MXY(12))
                      CALL FMLN(MXY(12),MXY(13))
                      CALL FMMPY_R2(MXY(7),MXY(13))
                      CALL FMADD_R1(MXY(28),MXY(13))
                      CALL FMDIVI_R1(MXY(12),2)
                      CALL FMLN(MXY(12),MXY(13))
                      CALL FMADD_R1(MXY(28),MXY(13))
                  ENDIF
                  CALL FMEXP(MXY(28),MXY(9))
                  CALL FMEQ(MXY(9),MXY(28))
                  JR = KROUND
                  KROUND = 1
                  CALL FMSUB(MXY(29),MXY(28),MXY(12))
                  KROUND = JR
                  IF (FMCOMP(MXY(12),'==',MXY(29))) THEN
                      CALL FMEQ(MXY(28),MXY(33))
                      CALL FMBETA(MXY(2),MXY(3),MXY(31))
                      JR = KROUND
                      KROUND = 1
                      CALL FMSUB(MXY(31),MXY(33),MXY(12))
                      KROUND = JR
                      IF (FMCOMP(MXY(12),'==',MXY(31))) THEN
                          MWK(START(MXY(31))+1) = 1.06*MWK(START(MXY(31))+1)
                          CALL FMEQ(MXY(31),MXY(21))
                          K_RETURN_CODE = 1
                          RETURN
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ELSE IF (MWK(START(MXY(2))+2) < 1 .AND. FMCOMP(MXY(3),'>',MXY(12))) THEN

!                 Approximate B(A,B).

          JR = KROUND
          KROUND = 1
          CALL FMADD(MXY(2),MXY(3),MXY(12))
          KROUND = JR
          IF (FMCOMP(MXY(12),'==',MXY(2))) THEN
              CALL FMLN(MXY(3),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(3),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(29))
              CALL FMSUB_R1(MXY(29),MXY(3))
              CALL FMDPM(DLOGTP/2.0D0,MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
              CALL FMLN(MXY(2),MXY(12))
              CALL FMMPY_R2(MXY(3),MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
          ELSE IF (FMCOMP(MXY(12),'==',MXY(3))) THEN
              CALL FMLN(MXY(2),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(2),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(29))
              CALL FMSUB_R1(MXY(29),MXY(2))
              CALL FMDPM(DLOGTP/2.0D0,MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
              CALL FMLN(MXY(3),MXY(12))
              CALL FMMPY_R2(MXY(2),MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
          ELSE
              CALL FMLN(MXY(2),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(2),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(29))
              CALL FMLN(MXY(3),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(3),MXY(7))
              CALL FMMPY_R2(MXY(7),MXY(12))
              CALL FMADD_R1(MXY(29),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(12))
              CALL FMLN(MXY(12),MXY(7))
              CALL FMDP2M(0.5D0,MXY(6))
              CALL FMSUB_R2(MXY(12),MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
              CALL FMDPM(DLOGTP/2.0D0,MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
          ENDIF
          CALL FMEXP(MXY(29),MXY(9))
          CALL FMEQ(MXY(9),MXY(29))

!                 Bound the area from X to 1.

          CALL FMI2M(1,MXY(12))
          JR = KROUND
          KROUND = 1
          CALL FMSUB(MXY(12),MXY(1),MXY(7))
          KROUND = JR
          IF (FMCOMP(MXY(7),'==',MXY(12))) THEN
              CALL FMLN(MXY(1),MXY(12))
              CALL FMI2M(1,MXY(6))
              CALL FMSUB(MXY(2),MXY(6),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(28))
              CALL FMSUB(MXY(3),MXY(6),MXY(7))
              CALL FMMPY(MXY(1),MXY(7),MXY(12))
              CALL FMSUB_R1(MXY(28),MXY(12))
              CALL FMSUB(MXY(6),MXY(1),MXY(12))
              CALL FMDIVI_R1(MXY(12),2)
              CALL FMLN(MXY(12),MXY(13))
              CALL FMSUB_R1(MXY(28),MXY(13))
              CALL FMEXP(MXY(28),MXY(9))
              CALL FMEQ(MXY(9),MXY(28))
          ELSE
              CALL FMLN(MXY(1),MXY(12))
              CALL FMI2M(1,MXY(6))
              CALL FMSUB(MXY(2),MXY(6),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(28))
              CALL FMSUB(MXY(3),MXY(6),MXY(7))
              CALL FMSUB(MXY(6),MXY(1),MXY(12))
              CALL FMLN(MXY(12),MXY(13))
              CALL FMMPY_R2(MXY(7),MXY(13))
              CALL FMADD_R1(MXY(28),MXY(13))
              CALL FMDIVI_R1(MXY(12),2)
              CALL FMLN(MXY(12),MXY(13))
              CALL FMADD_R1(MXY(28),MXY(13))
              CALL FMEXP(MXY(28),MXY(9))
              CALL FMEQ(MXY(9),MXY(28))
          ENDIF
          JR = KROUND
          KROUND = 1
          CALL FMSUB(MXY(29),MXY(28),MXY(12))
          KROUND = JR
          IF (FMCOMP(MXY(12),'==',MXY(29))) THEN
              CALL FMBETA(MXY(2),MXY(3),MXY(31))
              MWK(START(MXY(31))+1) = 1.06*MWK(START(MXY(31))+1)
              CALL FMEQ(MXY(31),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF
      ENDIF

!             If B is small enough, use one of two series or an asymptotic series,
!             depending on the size of X and A.

      CALL FMI2M(1,MXY(6))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(6),MXY(3),MXY(7))
      CALL FMADD(MXY(2),MXY(3),MXY(12))
      KROUND = JR
      IF ((FMCOMP(MXY(7),'==',MXY(6)) .AND. FMCOMP(MXY(12),'==',MXY(2))) ) THEN
          CALL FMDP2M(0.5D0,MXY(12))
          IF (FMCOMP(MXY(1),'<=',MXY(12))) THEN
              CALL FMI2M(0,MXY(22))
              CALL FMEQ(MXY(1),MXY(23))
              CALL FMI2M(1,MXY(7))
              CALL FMADD(MXY(2),MXY(7),MXY(12))
              CALL FMDIV(MXY(23),MXY(12),MXY(24))
              CALL FMEQ(MXY(2),MXY(14))
              CALL FMADDI(MXY(14),1)
              NDSAV1 = NDIG
              DO J = 2, NTERMS
                 CALL FMADD_R1(MXY(22),MXY(24))
                 IF (KFLAG /= 0 .AND. J >= 3) EXIT
                 NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-  &
                                                         MWK(START(MXY(24))+2))+1))
                 CALL FMMPY_R1(MXY(23),MXY(1))
                 CALL FMADDI(MXY(14),1)
                 CALL FMDIV(MXY(23),MXY(14),MXY(24))
                 NDIG = NDSAV1
              ENDDO
              CALL FMPWR(MXY(1),MXY(2),MXY(12))
              CALL FMI2M(1,MXY(6))
              CALL FMDIV(MXY(6),MXY(2),MXY(7))
              CALL FMADD(MXY(7),MXY(22),MXY(6))
              CALL FMMPY(MXY(12),MXY(6),MXY(22))
              CALL FMEQ(MXY(22),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF
          CALL FMDP2M(0.5D0,MXY(12))
          CALL FMI2M(20,MXY(7))
          IF ((FMCOMP(MXY(1),'>',MXY(12)) .AND. FMCOMP(MXY(2),'<',MXY(7)))) THEN
              CALL FMI2M(0,MXY(22))
              CALL FMI2M(1,MXY(12))
              CALL FMSUB(MXY(12),MXY(1),MXY(25))
              CALL FMI2M(1,MXY(7))
              CALL FMADD(MXY(3),MXY(7),MXY(12))
              CALL FMPWR(MXY(25),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(12))
              CALL FMSUB(MXY(12),MXY(2),MXY(7))
              CALL FMMPY_R2(MXY(7),MXY(23))

              CALL FMEQ(MXY(23),MXY(24))
              NDSAV1 = NDIG
              DO J = 2, NTERMS
                 CALL FMADD_R1(MXY(22),MXY(24))
                 IF (KFLAG /= 0 .AND. J >= 3) EXIT
                 NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-  &
                                                         MWK(START(MXY(24))+2))+1))
                 CALL FMI2M(J,MXY(7))
                 CALL FMSUB(MXY(7),MXY(2),MXY(12))
                 CALL FMMPY(MXY(23),MXY(12),MXY(7))
                 CALL FMMPY(MXY(7),MXY(25),MXY(12))
                 CALL FMDIVI(MXY(12),J,MXY(23))
                 CALL FMDIVI(MXY(23),J,MXY(24))
                 NDIG = NDSAV1
              ENDDO
              CALL FMLN(MXY(25),MXY(12))
              CALL FMI2M(1,MXY(7))
              CALL FMDIV(MXY(7),MXY(2),MXY(6))
              CALL FMSUB(MXY(6),MXY(12),MXY(7))
              CALL FMSUB(MXY(7),MXY(22),MXY(23))
              CALL FMEULR(MXY(24))
              CALL FMI2M(1,MXY(12))
              CALL FMADD(MXY(2),MXY(12),MXY(25))
              CALL FMPSI(MXY(25),MXY(11))
              CALL FMEQ(MXY(11),MXY(25))
              CALL FMSUB(MXY(23),MXY(24),MXY(12))
              CALL FMSUB(MXY(12),MXY(25),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF

          CALL FMDP2M(0.5D0,MXY(12))
          CALL FMI2M(20,MXY(7))
          IF ((FMCOMP(MXY(1),'>',MXY(12)) .AND. FMCOMP(MXY(2),'>=',MXY(7)))) THEN
              CALL FMSP2M(0.7*REAL(NDIG)*ALOGMT,MXY(28))
              IF (FMCOMP(MXY(2),'>=',MXY(28))) THEN
                  NUP = 0
                  CALL FMEQ(MXY(2),MXY(32))
                  CALL FMI2M(0,MXY(33))
              ELSE
                  CALL FMSUB(MXY(28),MXY(2),MXY(12))
                  CALL FMADDI(MXY(12),1)
                  CALL FMM2I(MXY(12),NUP)
                  CALL FMI2M(NUP,MXY(12))
                  CALL FMADD(MXY(2),MXY(12),MXY(32))
                  CALL FMI2M(1,MXY(33))
                  CALL FMEQ(MXY(2),MXY(23))
                  NDSAV1 = NDIG
                  DO J = 1, NUP-1
                     CALL FMMPY_R1(MXY(23),MXY(1))
                     CALL FMI2M(J,MXY(12))
                     CALL FMADD(MXY(2),MXY(12),MXY(7))
                     CALL FMDIV(MXY(23),MXY(7),MXY(24))
                     NDIG = NDSAV1
                     CALL FMADD_R1(MXY(33),MXY(24))
                     NDIG = MIN(NDSAV1,  &
                            MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(33))+2)-MWK(START(MXY(24))+2))+1))
                  ENDDO
                  NDIG = NDSAV1
                  CALL FMPWR(MXY(1),MXY(2),MXY(12))
                  CALL FMMPY(MXY(33),MXY(12),MXY(13))
                  CALL FMI2M(1,MXY(7))
                  CALL FMSUB(MXY(7),MXY(1),MXY(12))
                  CALL FMPWR(MXY(12),MXY(3),MXY(33))
                  CALL FMMPY_R2(MXY(13),MXY(33))
                  CALL FMDIV_R1(MXY(33),MXY(2))
              ENDIF

              CALL FMI2M(1,MXY(7))
              CALL FMDIVI(MXY(7),2,MXY(12))
              CALL FMSUB(MXY(32),MXY(12),MXY(29))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMMPY(MXY(29),MXY(12),MXY(30))
              IF (MWK(START(MXY(30))+2) /= MUNKNO .AND. MWK(START(MXY(30))+3) /= 0)  &
                  MWK(START(MXY(30))) = -MWK(START(MXY(30)))
              CALL FMIGM2(MXY(3),MXY(30),MXY(31))
              CALL FMPWR(MXY(30),MXY(3),MXY(12))
              CALL FMEQ(MXY(30),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMEXP(MXY(13),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(13))
              CALL FMDIV_R1(MXY(31),MXY(13))
              CALL FMEQ(MXY(31),MXY(22))
              CALL FMSQR(MXY(29),MXY(12))
              CALL FMMPYI(MXY(12),4,MXY(23))
              CALL FMI2M(1,MXY(24))
              CALL FMI2M(1,MXY(25))
              CALL FMI2M(1,MXY(26))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMDIVI(MXY(12),2,MXY(7))
              CALL FMSQR(MXY(7),MXY(28))
              NDSAV1 = NDIG
              J4 = 0
              KRSAVE = KROUND
              KROUND = 1
              DO J = 1, NTERMS
                 JSWITCH = MAX(2,INT(NDIG*DLOGMB/(2.0D0*LOG(23.0)) + 2))
                 IF (J < JSWITCH) THEN
                     J4 = 0
                     CALL FMMPYI_R1(MXY(25),4)
                     CALL FMMPYI(MXY(26),2*J-1,MXY(12))
                     CALL FMMPYI(MXY(12),2*J,MXY(26))
                     CALL FMI2M(2,MXY(7))
                     CALL FMSUB(MXY(7),MXY(25),MXY(12))
                     CALL FMDIV(MXY(12),MXY(26),MXY(27))
                     CALL FMBERN(2*J,MXY(27),MXY(8))
                     CALL FMEQ(MXY(8),MXY(27))
                 ELSE
                     IF (J4 == 0) THEN
                         J4 = 1
                         N = 2*J
                         DO K = 1, 8
                            CALL FMI2M(KPRIME(K),MJSUMS(K))
                            CALL FMIPWR(MJSUMS(K),N,MXY(12))
                            CALL FMEQ(MXY(12),MJSUMS(K))
                         ENDDO
                     ELSE
                         DO K = 1, 8
                            CALL FMMPYI_R1(MJSUMS(K),KPRIME(K)**2)
                         ENDDO
                     ENDIF
                     CALL FMPI(MXY(18))
                     CALL FMI2M(1,MXY(14))
                     CALL FMI2M(1,MXY(15))
                     DO K = 1, 8
                        CALL FMEQ(MJSUMS(K),MXY(17))
                        CALL FMI2M(KPRIME(K)**2-1,MXY(12))
                        JR = KROUND
                        KROUND = 1
                        CALL FMSUB(MXY(17),MXY(14),MXY(7))
                        CALL FMDIV_R2(MXY(12),MXY(7))
                        CALL FMSUB(MXY(14),MXY(7),MXY(16))
                        KROUND = JR
                        CALL FMI2M(1,MXY(12))
                        IF (FMCOMP(MXY(16),'==',MXY(12))) EXIT
                        CALL FMMPY_R1(MXY(15),MXY(16))
                     ENDDO
                     CALL FMEQ(MJSUMS(1),MXY(17))
                     CALL FMI2M(-1,MXY(7))
                     CALL FMSQR(MXY(18),MXY(13))
                     CALL FMDIV(MXY(7),MXY(13),MXY(12))
                     CALL FMI2M(2,MXY(7))
                     CALL FMSUB(MXY(7),MXY(17),MXY(6))
                     CALL FMI2M(8,MXY(7))
                     CALL FMSUB_R1(MXY(7),MXY(17))
                     CALL FMDIV(MXY(6),MXY(7),MXY(13))
                     CALL FMMPY(MXY(12),MXY(13),MXY(7))
                     CALL FMMPY(MXY(7),MXY(15),MXY(16))
                     CALL FMMPY_R2(MXY(16),MXY(27))
                 ENDIF
                 CALL FMI2M(2*J-2,MXY(7))
                 CALL FMADD(MXY(3),MXY(7),MXY(12))
                 CALL FMMPY(MXY(12),MXY(31),MXY(7))
                 CALL FMMPYI(MXY(7),2*J-1,MXY(31))
                 CALL FMI2M(2*J-1,MXY(7))
                 CALL FMADD(MXY(30),MXY(7),MXY(12))
                 CALL FMMPY(MXY(24),MXY(12),MXY(7))
                 CALL FMADD_R1(MXY(31),MXY(7))
                 CALL FMDIV_R1(MXY(31),MXY(23))
                 CALL FMMPY_R1(MXY(24),MXY(28))
                 CALL FMMPY(MXY(27),MXY(31),MXY(19))
                 NDIG = NDSAV1
                 CALL FMADD_R1(MXY(22),MXY(19))
                 IF (KFLAG /= 0 .AND. J >= 3) EXIT
                 NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-  &
                                                         MWK(START(MXY(19))+2))+1))
              ENDDO
              KROUND = KRSAVE
              NDIG = NDSAV1
              CALL FMPWR(MXY(1),MXY(29),MXY(12))
              CALL FMLN(MXY(1),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMPWR(MXY(13),MXY(3),MXY(21))
              CALL FMMPY(MXY(22),MXY(12),MXY(7))
              CALL FMMPY_R2(MXY(7),MXY(21))
              CALL FMADD_R2(MXY(33),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF
      ENDIF

!             If A or B is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(2))+2)),INT(MWK(START(MXY(3))+2)),0) ,  &
                   INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      RETURN
      END SUBROUTINE FMIBTA2

      SUBROUTINE FMIBTA3(MX,MA,MB,MC,MXY,K_RETURN_CODE)

!  Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MX,MA,MB,MC
      INTEGER :: J,J1,J2,K,K1,K2,K_RETURN_CODE,KRSAVE,NDS,NDSAVE
      INTENT (IN) :: MX,MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(37)

      J = NTRACE
      NTRACE = 0
      K = KWARN
      KWARN = 0
      NDSAVE = NDIG
      KRSAVE = KROUND
      KROUND = 1
      CALL FMI2M(1,MXY(1))
      CALL FMSUB(MXY(1),MX,MXY(2))
      IF (MWK(START(MX)) < 0 .OR. MWK(START(MXY(2))) < 0 .OR. MWK(START(MA)) < 0 .OR.  &
          MWK(START(MB)) < 0) GO TO 110
      IF (KRSAVE /= 1 .AND. (MWK(START(MXY(2))+3) == 0 .OR. MWK(START(MX)+2) < -NDIG .OR.  &
                             MWK(START(MA)+2) < -NDIG .OR. MWK(START(MB)+2) < -NDIG)) THEN
          IF (MWK(START(MXY(2))+3) == 0) THEN
              KROUND = KRSAVE
              CALL FMBETA(MA,MB,MC)
              K_RETURN_CODE = 1
          ELSE IF (MWK(START(MX)+3) == 0) THEN
              KROUND = KRSAVE
              CALL FMI2M(0,MC)
              K_RETURN_CODE = 1
          ELSE
              NDIG = NDIG + NGRD52
              CALL FMEQU(MX,MXY(1),NDSAVE,NDIG)
              CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
              CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
              CALL FMI2M(1,MXY(4))
              CALL FMSUB(MXY(4),MXY(3),MXY(5))
              CALL FMMPY(MXY(1),MXY(5),MXY(6))
              CALL FMADD(MXY(2),MXY(4),MXY(7))
              CALL FMDIV(MXY(6),MXY(7),MXY(8))
              CALL FMDIV(MXY(4),MXY(2),MXY(9))
              IF (MWK(START(MXY(9))+2) - MWK(START(MXY(8))+2) > NDIG) THEN
                  CALL FMPWR(MXY(1),MXY(2),MXY(10))
                  IF (MWK(START(MXY(10))+2) > MEXPUN .AND. MWK(START(MXY(10))+2) < MEXPOV) THEN
                      CALL FMDIV(MXY(10),MXY(2),MXY(11))
                      CALL FMMPY(MXY(10),MXY(8),MXY(12))
                      IF (MWK(START(MA)+2) < -NDSAVE) THEN
                          CALL FMLN(MXY(1),MXY(13))
                          CALL FMADD_R1(MXY(12),MXY(13))
                          CALL FMEQU(MXY(9),MXY(5),NDIG,NDSAVE)
                          CALL FMEQU(MXY(13),MXY(6),NDIG,NDSAVE)
                          NDIG = NDSAVE
                          KROUND = KRSAVE
                          CALL FMADD(MXY(5),MXY(6),MC)
                          K_RETURN_CODE = 1
                      ELSE IF (MWK(START(MXY(11))+2) < MEXPOV) THEN
                          CALL FMEQU(MXY(11),MXY(5),NDIG,NDSAVE)
                          CALL FMEQU(MXY(5),MXY(13),NDSAVE,NDIG)
                          CALL FMSUB(MXY(11),MXY(13),MXY(8))
                          IF (MWK(START(MXY(8))+3) == 0) THEN
                              CALL FMEQU(MXY(12),MXY(6),NDIG,NDSAVE)
                              NDIG = NDSAVE
                              KROUND = KRSAVE
                              CALL FMADD(MXY(5),MXY(6),MC)
                              IF (MWK(START(MC)+2) == MUNKNO) THEN
                                  J1 = MWK(START(MXY(5))+2)
                                  K1 = MWK(START(MXY(6))+2)
                                  J2 = J1
                                  IF (J1 /= MEXPUN .AND. J1 < 0) J2 = J1 + 2*NDIG
                                  IF (J1 /= MEXPOV .AND. J1 > 0) J2 = J1 - 2*NDIG
                                  K2 = K1
                                  IF (K1 /= MEXPUN .AND. K1 < 0) K2 = K1 + 2*NDIG
                                  IF (K1 /= MEXPOV .AND. K1 > 0) K2 = K1 - 2*NDIG
                                  MWK(START(MXY(5))+2) = J2
                                  MWK(START(MXY(6))+2) = K2
                                  CALL FMADD(MXY(5),MXY(6),MC)
                                  K2 = MWK(START(MC)+2) - (J2 - J1) - (K2 - K1)
                                  IF (MWK(START(MC)+2) /= MUNKNO) MWK(START(MC)+2) = K2
                              ENDIF
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQU(MXY(11),MC,NDIG,NDSAVE)
                          ENDIF
                          K_RETURN_CODE = 1
                      ENDIF
                  ENDIF
              ENDIF
              IF (K_RETURN_CODE /= 1) THEN
                  CALL FMI2M(1,MXY(4))
                  CALL FMSUB(MXY(4),MXY(1),MXY(5))
                  CALL FMPWR(MXY(5),MXY(3),MXY(6))
                  CALL FMDIV(MXY(4),MXY(3),MXY(7))
                  CALL FMSUB(MXY(4),MXY(2),MXY(8))
                  CALL FMMPY(MXY(1),MXY(8),MXY(9))
                  CALL FMADD(MXY(3),MXY(4),MXY(10))
                  CALL FMDIV(MXY(9),MXY(10),MXY(11))
                  IF (MWK(START(MXY(6))+2) <= MEXPUN) THEN
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMBETA(MA,MB,MC)
                      K_RETURN_CODE = 1
                  ELSE
                      CALL FMADD(MXY(7),MXY(11),MXY(12))
                      CALL FMMPY(MXY(6),MXY(12),MXY(8))
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMBETA(MA,MB,MC)
                      IF (MWK(START(MC)+2) - MWK(START(MXY(8))+2) > NDIG) K_RETURN_CODE = 1
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

  110 KFLAG = 0
      NTRACE = J
      KWARN = K
      NDIG = NDSAVE
      KROUND = KRSAVE
      IF (K_RETURN_CODE == 1) THEN
          IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MX)+2) /= MUNKNO .AND.  &
              MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIBTA'
              KFLAG = -4
              CALL FMWRN2
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MX)+2)) < MEXPOV .AND.  &
                   ABS(MWK(START(MA)+2))  < MEXPOV .AND. ABS(MWK(START(MB)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIBTA'
              IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
              CALL FMWRN2
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIBTA'
              CALL FMNTR(2,MX,MA,2,1)
              IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
                  NDS = NDIG
                  NDIG = NDSAVE
                  IF (NTRACE < 0) THEN
                      CALL FMNTRJ(MB,NDIG)
                  ELSE
                      CALL FMPRNT(MB)
                  ENDIF
                  NDIG = NDS
              ENDIF
              CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMIBTA3

      SUBROUTINE FMIGM1(MA,MB,MC)

!  MC = Incomplete Gamma(MA,MB)

!  Integral from 0 to MB of e**(-t) * t**(MA-1)  dt.

!  This is (lower case) gamma(a,x).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      DOUBLE PRECISION :: FMDPLG,X,A,B,ERR,SMALL,BIG,TOL,T1,BIGJ,YT
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MAXE,MODA2,MXSAVE
      INTEGER :: IEXTRA,INTA,INTG,J,JEXTRA,JR,JTERMS,K,KASAVE,KFLAG1,KFLAGA,KFLAGI,KFLAGX,KFLGOK,  &
                 KL,KOVUN,KR_RETRY,KRESLT,K_RETURN_CODE,KRSAVE,KWRNSV,KXNEG,LESS,NDGOAL,NDIG2,     &
                 NDOLD,NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NMNNDG,NMXDIF,NT,NTERMS,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: C,C1,C2,D,T,TLNB,Y
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(15),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      IF (MWK(START(MB)+3) == 0) GO TO 110

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. (MWK(START(MA)+2) < -NDIG .OR. MWK(START(MB)+2) < -NDIG)) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NDSAVE = NDIG
          KRSAVE = KROUND
          KROUND = 1
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(3))
          CALL FMADD(MXY(1),MXY(3),MXY(4))
          IF (MWK(START(MXY(1))+3) /= 0 .AND. MWK(START(MXY(4))+3) /= 0) THEN
              CALL FMDIV(MXY(2),MXY(4),MXY(6))
              CALL FMMPY(MXY(6),MXY(1),MXY(5))
              IF (MWK(START(MXY(3))+2) - MWK(START(MXY(5))+2) > NDIG) THEN
                  CALL FMPWR(MXY(2),MXY(1),MXY(6))
                  CALL FMDIV(MXY(6),MXY(1),MXY(7))
                  CALL FMEQU(MXY(7),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
                  CALL FMSUB(MXY(7),MXY(8),MXY(6))
                  IF (MWK(START(MXY(6))+3) == 0) THEN
                      CALL FMMPY(MXY(5),MXY(7),MXY(8))
                      CALL FMEQU(MXY(7),MXY(9),NDIG,NDSAVE)
                      CALL FMEQU(MXY(8),MXY(6),NDIG,NDSAVE)
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMSUB(MXY(9),MXY(6),MC)
                      IF (MWK(START(MC)+2) == MUNKNO) THEN
                          CALL FMI2M(2,MXY(9))
                          CALL FMMOD(MA,MXY(9),MXY(8))
                          IF (MWK(START(MB)) < 0 .AND. MWK(START(MXY(8))+3) /= 0) THEN
                              IF (KRSAVE ==  2) KROUND = -1
                              IF (KRSAVE == -1) KROUND =  2
                          ENDIF
                          CALL FMI2M(1,MXY(8))
                          CALL FMSUB(MXY(8),MXY(5),MXY(6))
                          CALL FMMPY(MXY(7),MXY(6),MC)
                      ENDIF
                  ELSE
                      CALL FMSUB(MXY(3),MXY(5),MXY(6))
                      CALL FMMPY(MXY(6),MXY(7),MXY(8))
                      KROUND = KRSAVE
                      CALL FMEQU(MXY(8),MC,NDIG,NDSAVE)
                  ENDIF
                  K_RETURN_CODE = 1
              ENDIF
              IF (K_RETURN_CODE /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
                  CALL FMDIV(MXY(3),MXY(1),MXY(4))
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(6),MXY(5),NDSAVE,NDIG)
                  CALL FMSUB(MXY(4),MXY(5),MXY(6))
                  IF (MWK(START(MXY(6))+3) == 0) THEN
                      CALL FMI2M(0,MXY(5))
                      CALL FMSUB(MXY(5),MXY(2),MXY(6))
                      CALL FMEI(MXY(6),MXY(7))
                      CALL FMLN(MXY(2),MXY(8))
                      CALL FMSUB(MXY(7),MXY(8),MXY(9))
                      CALL FMEULR(MXY(10))
                      CALL FMSUB(MXY(9),MXY(10),MXY(11))
                      CALL FMPWR(MXY(2),MXY(1),MXY(5))
                      CALL FMMPY(MXY(5),MXY(11),MXY(12))
                      CALL FMADD(MXY(8),MXY(12),MXY(13))
                      CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                      CALL FMEQU(MXY(13),MXY(7),NDIG,NDSAVE)
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMADD(MXY(6),MXY(7),MC)
                      K_RETURN_CODE = 1
                  ENDIF
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  CALL FMNTR(2,MA,MB,2,1)
                  NCALL = NCALL - 1
              ENDIF
              IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
                  MWK(START(MB)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  KFLAG = -4
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV .AND.  &
                       ABS(MWK(START(MB)+2))  < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  CALL FMNTR(1,MC,MC,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

  110 CALL FMENT2('FMIGM1   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

  130 NTERMS = INT(INTMAX/10)

!             Check for special cases.

!             See if A is small enough so that the result is X**A/A.

      CALL FMI2M(1,MXY(5))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(5),MXY(4))
      KROUND = JR
      IF (FMCOMP(MXY(4),'==',MXY(5))) THEN
          CALL FMPWR(MXY(2),MXY(1),MXY(5))
          CALL FMDIV(MXY(5),MXY(1),MXY(13))
          IF (MWK(START(MXY(13))+2) /= MUNKNO) GO TO 200
      ENDIF

!             Check to see if X is large enough so that the result is Gamma(A).

      CALL FMI2M(1,MXY(5))
      CALL FMDIV(MXY(1),MXY(2),MXY(4))
      MWK(START(MXY(4))) = 1
      CALL FMDPM(DBLE(0.001),MXY(3))
      IF (FMCOMP(MXY(2),'>',MXY(5)) .AND. FMCOMP(MXY(4),'<=',MXY(3))) THEN
          CALL FMI2M(1,MXY(4))
          CALL FMSUB(MXY(1),MXY(4),MXY(5))
          CALL FMLN(MXY(2),MXY(6))
          CALL FMMPY(MXY(5),MXY(6),MXY(4))
          CALL FMSUB(MXY(4),MXY(2),MXY(6))
          CALL FMEXP(MXY(6),MXY(15))
          IF (MWK(START(MXY(15))+2) /= MUNKNO) THEN
              CALL FMGAM(MXY(1),MXY(14))
              CALL FMSUB_R1(MXY(14),MXY(15))
              IF (MWK(START(MXY(14))+2) > MWK(START(MXY(15))+2)+NDIG .AND.  &
                  MWK(START(MXY(14))+2) /= MUNKNO) THEN
                  CALL FMEQ(MXY(14),MXY(13))
                  GO TO 200
              ENDIF
          ENDIF
      ENDIF

!             A,X are double precision approximations to the two arguments to this function.
!             INTA = A if A is a small integer.  It is used to limit the number of terms used in
!                    the asymptotic series and in the continued fraction expansion.

      INTA = NTERMS
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),INTG)
      KFLAGI = KFLAG
      IF (KFLAG == 0) INTA = INTG
      CALL FMM2DP(MXY(1),A)
      KFLAGA = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          A = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) A = -A
          KFLAGA = 0
      ENDIF
      CALL FMM2DP(MXY(2),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(2))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(2))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      KWARN = KWRNSV

!             If A or X is large in magnitude, use more guard digits.

      J = MWK(START(MXY(1))+2)
      IF (MWK(START(MXY(1))+3) >= SQRT(DBLE(MBASE))) J = J + 1
      K = MWK(START(MXY(2))+2)
      IF (MWK(START(MXY(2))+3) >= SQRT(DBLE(MBASE))) K = K + 1
      IEXTRA = MIN(MAX(J,K,0) , INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDOLD = NDIG
      NDIG = NDIG + IEXTRA

!             KXNEG = 1 if X is negative and A is a positive integer.

      KXNEG = 0

!             MODA2 = MOD(A,2) when KXNEG is 1.

      MODA2 = 0

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(2))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))) > 0) THEN
              IF (MWK(START(MXY(2))+3) == 0) THEN
                  CALL FMI2M(0,MXY(13))
                  GO TO 180
              ENDIF
              IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) > 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(13))
                  KFLAG = -5
                  GO TO 180
              ELSE IF (MWK(START(MXY(2))) > 0) THEN
                  CALL FMI2M(1,MXY(13))
                  IF (FMCOMP(MXY(2),'<=',MXY(13))) THEN
                      CALL FMST2M('UNDERFLOW',MXY(13))
                      KFLAG = -6
                      GO TO 180
                  ELSE
                      CALL FMST2M('OVERFLOW',MXY(13))
                      KFLAG = -5
                      GO TO 180
                  ENDIF
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) > 0) THEN
              CALL FMGAM(MXY(1),MXY(15))
              CALL FMEQ(MXY(15),MXY(13))
              GO TO 180
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) < 0 .AND.  &
              MWK(START(MXY(1))) > 0.AND. MWK(START(MXY(1))+3) > 0) THEN
              IF (MWK(START(MXY(1))+2) /= MEXPOV) THEN
                  CALL FMINT(MXY(1),MXY(12))
                  IF (FMCOMP(MXY(1),'==',MXY(12))) THEN
                      CALL FMI2M(2,MXY(9))
                      CALL FMMOD(MXY(12),MXY(9),MXY(5))
                      CALL FMEQ(MXY(5),MXY(9))
                      IF (MWK(START(MXY(9))+3) /= 0) THEN
                          CALL FMST2M('-OVERFLOW',MXY(13))
                          KFLAG = -5
                          GO TO 180
                      ELSE
                          CALL FMST2M('OVERFLOW',MXY(13))
                          KFLAG = -5
                          GO TO 180
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
          CALL FMST2M('UNKNOWN',MXY(13))
          KFLAG = -4
          GO TO 200
      ENDIF

      IF (MWK(START(MXY(1))+2) == MEXPUN .OR. MWK(START(MXY(2))+2) == MEXPUN) THEN
          CALL FMABS(MXY(1),MXY(4))
          CALL FMI2M(1,MXY(5))
          IF (FMCOMP(MXY(4),'<',MXY(5)) .AND. MWK(START(MXY(2))+2) == MEXPUN) THEN
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ENDIF
          CALL FMABS(MXY(1),MXY(4))
          CALL FMI2M(1,MXY(5))
          IF (FMCOMP(MXY(4),'>=',MXY(5)) .AND. MWK(START(MXY(2))+2) == MEXPUN .AND.  &
              MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(13))
              KFLAG = -6
              GO TO 200
          ENDIF
      ENDIF

      IF (MWK(START(MXY(1))) < 0 .OR. MWK(START(MXY(1))+3) == 0) THEN
          CALL FMINT(MXY(1),MXY(12))
          IF (FMCOMP(MXY(1),'==',MXY(12))) THEN
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+3) == 0) THEN
          IF (MWK(START(MXY(1))) <= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ELSE
              CALL FMI2M(0,MXY(13))
              GO TO 200
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL FMINT(MXY(1),MXY(12))
          IF (FMCOMP(MXY(1),'==',MXY(12))) THEN
              KXNEG = 1
              CALL FMI2M(2,MXY(9))
              CALL FMMOD(MXY(12),MXY(9),MXY(5))
              CALL FMEQ(MXY(5),MXY(9))
              IF (MWK(START(MXY(9))+3) /= 0) MODA2 = 1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      CALL FMMAX(MXY(1),MXY(2),MXY(5))
      CALL FMMIN(MXY(1),MXY(2),MXY(6))
      CALL FMDPM(1.0D6,MXY(3))
      CALL FMDPM(1.0D2,MXY(4))
      IF (FMCOMP(MXY(5),'>=',MXY(3)) .AND. FMCOMP(MXY(6),'>=',MXY(4))) THEN
          CALL FMI2M(1,MXY(5))
          CALL FMSUB(MXY(1),MXY(5),MXY(7))
          CALL FMMIN(MXY(7),MXY(2),MXY(8))
          CALL FMADDI(MXY(8),-1)
          CALL FMLN(MXY(8),MXY(5))
          CALL FMMPY(MXY(7),MXY(5),MXY(4))
          CALL FMSUB(MXY(4),MXY(8),MXY(5))
          CALL FMEXP(MXY(5),MXY(10))
          IF ((MWK(START(MXY(10))+2) == MEXPOV .AND. MWK(START(MXY(10))) > 0) .OR.  &
              MWK(START(MXY(10))+2) > MXSAVE+1) THEN
              CALL FMST2M('OVERFLOW',MXY(13))
              KFLAG = -5
              GO TO 180
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(5))
      IF (FMCOMP(MXY(1),'==',MXY(5)) .AND. MWK(START(MXY(2))+2) >= 0) THEN
          IF (ABS(MWK(START(MXY(2))+2)) < MEXPOV) THEN
              CALL FMEQ(MXY(2),MXY(6))
              IF (MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
                  MWK(START(MXY(6))) = -MWK(START(MXY(6)))
              CALL FMEXP(MXY(6),MXY(7))
              CALL FMSUB(MXY(5),MXY(7),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO) GO TO 200
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      CALL FMI2M(-10000,MXY(8))
      CALL FMI2M(10000,MXY(9))
      CALL FMABS(MXY(1),MXY(11))
      CALL FMABS(MXY(2),MXY(12))
      CALL FMSUB(MXY(12),MXY(11),MXY(10))

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      IF (KFLAGA /= 0 .OR. KFLAGX /= 0) THEN
          CALL FMDIV(MXY(12),MXY(11),MXY(10))
          CALL FMI2M(1,MXY(8))
          CALL FMSUB(MXY(8),MXY(10),MXY(9))
          IF (MWK(START(MXY(9))) < 0) THEN
              NMETHD = 2
          ELSE
              NMETHD = 1
          ENDIF
      ELSE
          T1 = FMDPLG(A)
          SMALL = T1 - FMDPLG(-ABS(X)) - (A+ABS(X))*LOG(ABS(X))
          TOL = -DBLE(NDIG+2)*DLOGMB - 12.0D0
          B = 1.0D0
          IF (A > ABS(X)) B = A - ABS(X)
          BIG = T1 - FMDPLG(A-B) - B*LOG(ABS(X))

          IF (FMCOMP(MXY(10),'<=',MXY(8))) THEN
              NMETHD = 1
          ELSE IF (FMCOMP(MXY(10),'>=',MXY(9)) .AND. MWK(START(MXY(1))) > 0  &
                   .AND. MWK(START(MXY(2))) > 0) THEN
              NMETHD = 3
              IF (SMALL < TOL+BIG) NMETHD = 2
          ELSE IF (FMCOMP(MXY(10),'>=',MXY(9))) THEN
              NMETHD = 3
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(8))
              IF (FMCOMP(MXY(2),'>=',MXY(8))) THEN
                  KFLAG = -5
                  CALL FMST2M('OVERFLOW',MXY(13))
                  GO TO 180
              ENDIF

              C2 = REAL(DBLE(NDSAVE)*DLOGMB)
              C1 = REAL(DBLE(C2)/10.0D0 + A + 10.0D0)
              C2 = REAL(MAX( 10.0D0 , DBLE(C2)/6.0D0 , A - 3.5D0*A/(SQRT(A)+1.0D0)))
              IF (X < C1) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
              IF (X > C2) THEN
                  NMETHD = 3
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
          ELSE IF (MWK(START(MXY(1))) < 0 .AND. MWK(START(MXY(2))) > 0) THEN
              TLNB = REAL(NDIG)*ALOGMB
              C = 0.75/TLNB**0.35
              D = 0.80*TLNB**0.70
              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T = REAL(-A) - D/C
                  Y = D + C*T/2.0 + (C/2.0)*SQRT(T**2 + T + (2.0/C)**2)
                  IF (X > Y) THEN
                      NMETHD = 3
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE
                  CALL FMDPM(DBLE(C),MXY(5))
                  CALL FMMPY(MXY(5),MXY(1),MXY(8))
                  MWK(START(MXY(8))) = 1
                  IF (FMCOMP(MXY(2),'>',MXY(8))) THEN
                      NMETHD = 3
                  ELSE
                      NMETHD = 1
                  ENDIF
              ENDIF
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) < 0) THEN
              CALL FMDPM(DBLE(-0.8),MXY(5))
              CALL FMMPY(MXY(5),MXY(1),MXY(8))
              IF (FMCOMP(MXY(8),'<',MXY(2))) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170

!             Method 1.  Use the X**N/Pochhammer(A+1,N) series.

!             MXY(13) is the current sum.
!             MXY(9) is the current term.
!             MXY(8) is (A+N)/X.
!             MXY(14) is 1/X

!             Raise the precision if A is negative and near an integer, to compensate
!             for cancellation when (A+N)/X is near zero.

      IF (MWK(START(MXY(1))) < 0) THEN
          CALL FMNINT(MXY(1),MXY(13))
          CALL FMSUB(MXY(1),MXY(13),MXY(14))
          IEXTRA = MAX(-INT(MWK(START(MXY(14))+2)),0)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
      ENDIF

      JEXTRA = 0

  140 CALL FMI2M(1,MXY(13))
      CALL FMI2M(1,MXY(7))
      CALL FMADD(MXY(1),MXY(7),MXY(8))
      CALL FMDIV(MXY(2),MXY(8),MXY(9))
      CALL FMDIV_R1(MXY(8),MXY(2))
      CALL FMDIV(MXY(7),MXY(2),MXY(14))
      NDSAV1 = NDIG
      MAXE = 1

!             If A is negative and ABS(A) > ABS(X), the terms in the series first decrease,
!             then increase, then decrease.  Try to predict the number of extra digits required
!             to keep the precision from prematurely becoming too small.

      KFLGOK = 1
      IF (MWK(START(MXY(1))) < 0) THEN
          IF (KFLAGA == 0) THEN
              IF (ABS(A) > 1.0D3) THEN
                  NMETHD = 3
                  GO TO 170
              ENDIF
          ELSE
              NMETHD = 3
              GO TO 170
          ENDIF
          KFLGOK = 0
          CALL FMABS(MXY(1),MXY(3))
          CALL FMABS(MXY(2),MXY(4))
          IF (FMCOMP(MXY(3),'>',MXY(4))) THEN
              IF (JEXTRA == 0) THEN
                  IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                      T1 = FMDPLG(A+AINT(-ABS(X)-A)) - FMDPLG(A+1.0D0+AINT(ABS(X)-A))
                      T1 = (T1 + 2.0D0*ABS(X)*LOG(ABS(X)+1.0D-10))/DLOGMB
                      T1 = MAX(0.0D0,T1+1.0D0)
                      JEXTRA = T1
                  ENDIF
              ENDIF

!             If A is negative and ABS(A) is much bigger than ABS(X), the later increase in
!             the size of the terms can be ignored.

              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T1 = (AINT(X-A)*LOG(ABS(X)+1.0D-10) + FMDPLG(A+1.0D0)  &
                       - FMDPLG(A+1.0D0+AINT(X-A))) / DLOGMB
                  IF (T1 < -DBLE(NDIG)) KFLGOK = 1
              ELSE
                  KFLGOK = 1
              ENDIF
          ENDIF
      ENDIF

      NMNNDG = NDSAV1
      NMXDIF = 0
      K = 0
      IF (MWK(START(MA)) > 0 .AND. MWK(START(MB)) > 0) THEN
          K = 1
      ELSE IF (KFLAGA == 0) THEN
          IF (A > -1 .AND. MWK(START(MB)) > 0) K = 1
      ENDIF

!             Method 1 summation loop.

      DO J = 1, NTERMS
         NDIG = NDSAV1
         MAXE = MAX(MAXE,MWK(START(MXY(9))+2))
         IF (K == 1) THEN
             CALL FMCSADDNN_R1(MXY(13),MXY(9))
         ELSE
             CALL FMCSADD_R1(MXY(13),MXY(9))
         ENDIF
         IF (KFLAG /= 0) THEN
             IF (KFLGOK == 0 .AND. KFLAGA == 0 .AND. KFLAGX == 0) THEN
                 IF (DBLE(J) > X-A) EXIT
             ELSE
                 EXIT
             ENDIF
         ENDIF

         CALL FMCSADD_R1(MXY(8),MXY(14))

         NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(13))+2)-MWK(START(MXY(9))+2)))
         NDIG = MIN(NDSAV1,NDIG2+JEXTRA)
         NMNNDG = MIN(NMNNDG,NDIG)
         NMXDIF = MAX(NMXDIF,NDIG-NMNNDG)
         CALL FMCSDIV(MXY(9),MXY(8),MXY(5))
         CALL FMEQ(MXY(5),MXY(9))
      ENDDO

      IF (K == 1) CALL FMCSNORM(MXY(13))
      NDIG = NDSAV1
      IF (NMXDIF > JEXTRA+1) THEN
          JEXTRA = NMXDIF
          GO TO 140
      ENDIF

      CALL FMABS(MXY(2),MXY(5))
      CALL FMLN(MXY(5),MXY(6))
      CALL FMMPY(MXY(1),MXY(6),MXY(4))
      CALL FMSUB(MXY(4),MXY(2),MXY(14))
      CALL FMEXP(MXY(14),MXY(15))
      IF (MWK(START(MXY(15))+2) == MUNKNO) THEN
          CALL FMPWR(MXY(5),MXY(1),MXY(4))
          CALL FMEXP(MXY(2),MXY(6))
          CALL FMDIV(MXY(4),MXY(6),MXY(15))
      ENDIF
      CALL FMDIV(MXY(13),MXY(1),MXY(12))
      CALL FMMPY(MXY(15),MXY(12),MXY(11))
      IF (MWK(START(MXY(11))+2) == MUNKNO) THEN
          CALL FMLN(MXY(13),MXY(5))
          CALL FMLN(MXY(1),MXY(6))
          CALL FMADD(MXY(14),MXY(5),MXY(4))
          CALL FMSUB(MXY(4),MXY(6),MXY(14))
          CALL FMEXP(MXY(14),MXY(13))
      ELSE
          CALL FMEQ(MXY(11),MXY(13))
      ENDIF
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MWK(START(MXY(13))+2) /= MUNKNO  &
          .AND. MWK(START(MXY(13))+3) /= 0) THEN
          MWK(START(MXY(13))) = -MWK(START(MXY(13)))
      ENDIF

      GO TO 180

!             Method 2.  Use the Pochhammer(A-N,N)/X**N series.

!             MXY(13) is the current sum.
!             MXY(9) is the current term.
!             MXY(8) is (A-N)/X.
!             MXY(14) is -1/X

!             Raise the precision if A is positive and near an integer, to compensate for
!             cancellation when (A-N)/X is near zero.

  150 IF (MWK(START(MXY(1))) > 0) THEN
          CALL FMNINT(MXY(1),MXY(13))
          CALL FMSUB(MXY(1),MXY(13),MXY(14))
          IEXTRA = MAX(-INT(MWK(START(MXY(14))+2)),0)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
      ENDIF

      CALL FMGAM(MXY(1),MXY(15))
      IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          NT = INT(((A-1)*LOG(ABS(X)+1.0D-10) - X)/DLOGMB)
          LESS = MAX(0,INT(MWK(START(MXY(15))+2)) - NT - 1)
          IF (LESS > NDIG .AND. ABS(A) < ABS(X)) THEN
              CALL FMEQ(MXY(15),MXY(13))
              GO TO 180
          ENDIF
      ENDIF
      IF (KFLAG /= 0) THEN
          CALL FMEQ(MXY(15),MXY(13))
          GO TO 180
      ENDIF
      IF (KXNEG == 0) THEN
          CALL FMLN(MXY(2),MXY(14))
          CALL FMMPY(MXY(1),MXY(14),MXY(5))
          CALL FMSUB(MXY(5),MXY(2),MXY(13))
          CALL FMSUB_R2(MXY(13),MXY(14))
          CALL FMEXP(MXY(14),MXY(9))
      ELSE
          CALL FMI2M(1,MXY(5))
          CALL FMSUB(MXY(1),MXY(5),MXY(13))
          CALL FMPWR(MXY(2),MXY(13),MXY(14))
          CALL FMEXP(MXY(2),MXY(12))
          CALL FMDIV(MXY(14),MXY(12),MXY(9))
      ENDIF

!             Here MXY(9) is X**(A-1)/EXP(X).

      IF (MWK(START(MXY(9))+2) /= MUNKNO .AND. MWK(START(MXY(9))+3) /= 0)  &
          MWK(START(MXY(9))) = -MWK(START(MXY(9)))
      CALL FMEQ(MXY(15),MXY(13))
      CALL FMDIV(MXY(1),MXY(2),MXY(8))
      CALL FMI2M(1,MXY(5))
      CALL FMDIV(MXY(5),MXY(2),MXY(14))
      IF (MWK(START(MXY(14))+2) /= MUNKNO .AND. MWK(START(MXY(14))+3) /= 0)  &
          MWK(START(MXY(14))) = -MWK(START(MXY(14)))
      NDSAV1 = NDIG

!             Disable NDIG reduction until the terms in the sum begin to decrease in size.

      BIGJ = 0
      IF (KFLAGA == 0 .AND. KFLAGX == 0) BIGJ = ABS(A) - ABS(X)
      JTERMS = NTERMS
      IF (KFLAGI == 0 .AND. INTA > 0) THEN
          JTERMS = INTA
      ELSE IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          T1 = A + ABS(X)
          IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
      ENDIF

!             Method 2 summation loop.

      DO J = 1, JTERMS
         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(13),MXY(9))
         IF (KFLAG /= 0 .AND. J > 1) GO TO 160
         CALL FMCSADD_R1(MXY(8),MXY(14))
         IF (REAL(J) >= BIGJ) THEN
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(13))+2)-MWK(START(MXY(9))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
         ENDIF
         CALL FMCSMPY_R1(MXY(9),MXY(8))
      ENDDO

  160 NDIG = NDSAV1
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(13) is the term in the sum, S(k).
!             MXY(11), MXY(12) are the latest denominators, Q(k-1) and Q(k).

  170 CALL FMGAM(MXY(1),MXY(15))
      NDSAV1 = NDIG
      IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          YT = MIN(DBLE(HUGE(1))/11,AINT(((A-1)*LOG(ABS(X)+1.0D-10) - X)/DLOGMB))
          NT = HUGE(1)/10
          NT = MIN(DBLE(NT),YT)
          LESS = MAX(0,INT(MWK(START(MXY(15))+2)) - NT - 1)
          IF (LESS > NDIG) THEN
              CALL FMEQ(MXY(15),MXY(13))
              GO TO 180
          ENDIF
          NDIG = MIN(NDSAV1,MAX(NGRD22,NDIG-LESS))
      ENDIF
      JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMEQU(MXY(1),MXY(8),NDSAV1,NDIG)
      IF (MWK(START(MXY(8))+2) /= MUNKNO .AND. MWK(START(MXY(8))+3) /= 0)  &
          MWK(START(MXY(8))) = -MWK(START(MXY(8)))
      CALL FMI2M(1,MXY(11))
      CALL FMEQU(MXY(2),MXY(12),NDSAV1,NDIG)
      CALL FMI2M(1,MXY(5))
      CALL FMDIV(MXY(5),MXY(12),MXY(13))
      CALL FMEQ(MXY(13),MXY(14))

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, MIN(NTERMS,INTA-1)
         CALL FMADDI(MXY(8),1)
         CALL FMEQ(MXY(8),MXY(10))
         CALL FMCSMPY_R1(MXY(10),MXY(11))
         CALL FMADD(MXY(12),MXY(10),MXY(9))
         CALL FMEQ(MXY(10),MXY(6))
         CALL FMCSMPY_R1(MXY(6),MXY(13))
         CALL FMCSDIV(MXY(6),MXY(9),MXY(13))
         IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
             MWK(START(MXY(13))) = -MWK(START(MXY(13)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(13))
         KFLAG1 = KFLAG
         CALL FMEQ(MXY(12),MXY(11))
         CALL FMEQ(MXY(9),MXY(12))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(13))+2))))
         CALL FMCSMPYI(MXY(11),J,MXY(10))
         CALL FMEQ(MXY(2),MXY(6))
         CALL FMCSMPY_R1(MXY(6),MXY(12))
         CALL FMADD(MXY(6),MXY(10),MXY(9))
         CALL FMEQ(MXY(10),MXY(6))
         CALL FMCSMPY_R1(MXY(6),MXY(13))
         CALL FMCSDIV(MXY(6),MXY(9),MXY(13))
         IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
             MWK(START(MXY(13))) = -MWK(START(MXY(13)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(13))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(12),MXY(11))
         CALL FMEQ(MXY(9),MXY(12))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(13))+2))))
      ENDDO

      NDIG = NDSAV2
      CALL FMEQU_R1(MXY(14),NDIG,NDSAV1)
      NDIG = NDSAV1
      IF (MWK(START(MXY(2))) > 0) THEN
          CALL FMLN(MXY(2),MXY(5))
          CALL FMMPY(MXY(1),MXY(5),MXY(4))
          CALL FMSUB(MXY(4),MXY(2),MXY(5))
          CALL FMEXP(MXY(5),MXY(12))
      ELSE IF (KFLAGI == 0) THEN
          CALL FMEXP(MXY(2),MXY(13))
          CALL FMIPWR(MXY(2),INTA,MXY(5))
          CALL FMDIV(MXY(5),MXY(13),MXY(12))
      ELSE
          CALL FMABS(MXY(2),MXY(5))
          CALL FMLN(MXY(5),MXY(6))
          CALL FMMPY(MXY(1),MXY(6),MXY(4))
          CALL FMSUB(MXY(4),MXY(2),MXY(5))
          CALL FMEXP(MXY(5),MXY(12))
          IF (MODA2 == 1 .AND. MWK(START(MXY(12))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(12))+3) /= 0) MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      ENDIF

      IF (MWK(START(MXY(12))+2) /= MEXPOV) THEN
          CALL FMMPY(MXY(12),MXY(14),MXY(13))
      ELSE IF (MWK(START(MXY(12))+2)+MWK(START(MXY(14))+2) >= MXEXP2/2) THEN
          CALL FMEQ(MXY(12),MXY(13))
          IF (MWK(START(MXY(14))) < 0 .AND. MWK(START(MXY(13))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(13))+3) /= 0) MWK(START(MXY(13))) = -MWK(START(MXY(13)))
      ELSE
          CALL FMMPY(MXY(12),MXY(14),MXY(13))
      ENDIF
      CALL FMSUB_R2(MXY(15),MXY(13))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(13))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(13))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(13))+J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(13))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQU_R1(MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(13),MRETRY,NDOLD,NDIG)
          GO TO 130
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(13))+1) = MIN(MWK(START(MXY(13))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(13),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIGM1

      SUBROUTINE FMIGM2(MA,MB,MC)

!  MC = Incomplete Gamma(MA,MB)

!  Integral from MB to infinity of e**(-t) * t**(MA-1)  dt.

!  This is (upper case) Gamma(a,x).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      DOUBLE PRECISION :: FMDPLG,X,A,B,ERR,SMALL,BIG,TOL,T1,T2,BIGJ,C1,C2
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MAS,MAXM09,MBS,MODA2,MXSAVE
      INTEGER :: IEXTRA,INTA,INTG,J,JEXTRA,JR,JTERMS,K,KABIGR,KASAVE,KFLAG1,KFLAGA,KFLAGI,KFLAGX,  &
                 KFLGOK,KL,KMETH4,KOVUN,KR_RETRY,KRESLT,KRSAVE,KWRNSV,KXNEG,N,NDGOAL,NDIG2,NDOLD,  &
                 NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NMNNDG,NTERMS,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(20),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MB)) > 0 .AND. MWK(START(MA)+3) /= 0 .AND.   &
          MWK(START(MB)+2) < -NDIG - NGRD52) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NDSAVE = NDIG
          KRSAVE = KROUND
          KROUND = 1
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          CALL FMGAM(MXY(1),MXY(3))
          IF (MWK(START(MXY(3))+2) /= MUNKNO) THEN
              CALL FMIGM1(MXY(1),MXY(2),MXY(4))
              KROUND = KRSAVE
              CALL FMSUB(MXY(3),MXY(4),MXY(5))
              IF (MWK(START(MXY(5))+3) == 0 .OR.  &
                  MWK(START(MXY(5))+2) < MWK(START(MXY(3))+2)-NGRD52) THEN
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  NDIG = NDSAVE
                  GO TO 110
              ENDIF
          ELSE
              CALL FMM2I(MXY(1),KL)
              CALL FMIPWR(MXY(2),KL,MXY(4))
              IF (MWK(START(MXY(4))+2) /= MEXPOV) THEN
                  CALL FMDIVI_R1(MXY(4),-KL)
              ENDIF
              CALL FMTINY(MXY(5))
              KROUND = KRSAVE
              CALL FMSUB_R2(MXY(4),MXY(5))
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          CALL FMEQU(MXY(5),MC,NDIG,NDSAVE)
          NDIG = NDSAVE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              CALL FMNTR(2,MA,MB,2,1)
              NCALL = NCALL - 1
          ENDIF
          IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
              MWK(START(MB)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              KFLAG = -4
              CALL FMWRN2
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV .AND.  &
                   ABS(MWK(START(MB)+2))  < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
              CALL FMWRN2
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

  110 CALL FMENT2('FMIGM2   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      KMETH4 = 0
      NUMTRY = 0

  130 NTERMS = INT(INTMAX/10)

!             A,X are double precision approximations to the two arguments to this function.
!             INTA = A if A is a small integer.  It is used to limit the number of terms used
!                    in the asymptotic series and in the continued fraction expansion.

      INTA = NTERMS
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),INTG)
      KFLAGI = KFLAG
      IF (KFLAG == 0) INTA = INTG
      CALL FMM2DP(MXY(1),A)
      KFLAGA = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          A = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) A = -A
          KFLAGA = 0
      ENDIF
      CALL FMM2DP(MXY(2),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(2))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(2))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      KWARN = KWRNSV

!             If A or X is large in magnitude use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),INT(MWK(START(MXY(2))+2)),0) ,  &
                   INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             KXNEG = 1 if X is negative and A is a positive integer.

      KXNEG = 0

!             MODA2 = MOD(A,2) when KXNEG is 1.

      MODA2 = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(2))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))+3) /= 0 .AND.  &
              MWK(START(MXY(1))) > 0) THEN
              IF (MWK(START(MXY(2))+2) /= MEXPOV) THEN
                  CALL FMST2M('OVERFLOW',MXY(16))
                  KFLAG = -5
                  GO TO 190
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))+3) /= 0 .AND.  &
              MWK(START(MXY(2))) > 0) THEN
              CALL FMBIG(MXY(17))
              MWK(START(MXY(17))+2) = MXSAVE + 1
              CALL FMLN(MXY(17),MXY(7))
              CALL FMDIV(MXY(17),MXY(7),MXY(18))
              IF (FMCOMP(MXY(1),'<=',MXY(18))) THEN
                  CALL FMST2M('UNDERFLOW',MXY(16))
                  KFLAG = -6
                  GO TO 190
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(16))
                  KFLAG = -4
                  GO TO 210
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) < 0 .AND.  &
              MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) /= 0) THEN
              IF (MWK(START(MXY(1))+2) /= MEXPOV) THEN
                  CALL FMINT(MXY(1),MXY(15))
                  IF (FMCOMP(MXY(1),'==',MXY(15))) THEN
                      CALL FMI2M(2,MXY(12))
                      CALL FMMOD(MXY(15),MXY(12),MXY(7))
                      CALL FMEQ(MXY(7),MXY(12))
                      IF (MWK(START(MXY(12))+3) /= 0) THEN
                          CALL FMST2M('OVERFLOW',MXY(16))
                          KFLAG = -5
                          GO TO 190
                      ELSE
                          CALL FMST2M('-OVERFLOW',MXY(16))
                          KFLAG = -5
                          GO TO 190
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
          IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))) < 0 .AND.  &
              MWK(START(MXY(1))+3) /= 0) THEN
              IF (MWK(START(MXY(2))+2) /= MEXPOV .AND. MWK(START(MXY(2))) > 0 .AND.  &
                  MWK(START(MXY(2))+3) /= 0) THEN
                  CALL FMI2M(1,MXY(7))
                  IF (FMCOMP(MXY(2),'<',MXY(7))) THEN
                      CALL FMST2M('OVERFLOW',MXY(16))
                      KFLAG = -5
                      GO TO 190
                  ELSE
                      CALL FMST2M('UNDERFLOW',MXY(16))
                      KFLAG = -6
                      GO TO 190
                  ENDIF
              ENDIF
          ENDIF
          CALL FMST2M('UNKNOWN',MXY(16))
          KFLAG = -4
          GO TO 210
      ENDIF

      IF (MWK(START(MXY(1))+2) == MEXPUN .OR. MWK(START(MXY(2))+2) == MEXPUN) THEN
          IF (MWK(START(MXY(1))+2) == MEXPUN .AND. MWK(START(MXY(2))+2) == MEXPUN) THEN
              CALL FMST2M('UNKNOWN',MXY(16))
              KFLAG = -4
              GO TO 210
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPUN .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+3) /= 0                                        ) THEN
              IF (MWK(START(MXY(1))+2) >= 1 .AND. MWK(START(MXY(1))) > 0) THEN
                  CALL FMGAM(MXY(1),MXY(20))
                  CALL FMEQ(MXY(20),MXY(16))
                  GO TO 190
              ELSE IF (MWK(START(MXY(1))+2) >= 1 .AND. MWK(START(MXY(1))) < 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(16))
                  KFLAG = -5
                  GO TO 210
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(16))
                  KFLAG = -4
                  GO TO 210
              ENDIF
          ENDIF
      ENDIF

      IF (MWK(START(MXY(2))+3) == 0) THEN
          IF (MWK(START(MXY(1))) < 0 .OR. MWK(START(MXY(1))+3) == 0) THEN
              CALL FMST2M('UNKNOWN',MXY(16))
              KFLAG = -4
              GO TO 210
          ELSE
              CALL FMGAM(MXY(1),MXY(20))
              CALL FMEQ(MXY(20),MXY(16))
              GO TO 190
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL FMINT(MXY(1),MXY(15))
          IF (FMCOMP(MXY(1),'==',MXY(15)) .AND. MWK(START(MXY(1)))*MWK(START(MXY(1))+3) > 0) THEN
              KXNEG = 1
              CALL FMI2M(2,MXY(12))
              CALL FMMOD(MXY(15),MXY(12),MXY(7))
              CALL FMEQ(MXY(7),MXY(12))
              IF (MWK(START(MXY(12))+3) /= 0) MODA2 = 1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(16))
              KFLAG = -4
              GO TO 210
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+2) == MEXPUN) THEN
          IF (MWK(START(MXY(1))) < 0 .AND. MWK(START(MXY(1))+2) >= 1) THEN
              CALL FMST2M('OVERFLOW',MXY(16))
              KFLAG = -5
          ELSE
              CALL FMGAM(MXY(1),MXY(20))
              CALL FMEQ(MXY(20),MXY(16))
          ENDIF
          GO TO 190
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMI2M(0,MXY(1))
          MAS = 1
      ENDIF
      CALL FMMAX(MXY(1),MXY(2),MXY(7))
      CALL FMMIN(MXY(1),MXY(2),MXY(8))
      CALL FMDPM(1.0D6,MXY(3))
      CALL FMDPM(1.0D2,MXY(4))
      IF (FMCOMP(MXY(7),'>=',MXY(3)) .AND. FMCOMP(MXY(8),'>=',MXY(4))) THEN
          CALL FMI2M(1,MXY(7))
          CALL FMSUB(MXY(1),MXY(7),MXY(9))
          CALL FMMAX(MXY(9),MXY(2),MXY(11))
          CALL FMADDI(MXY(11),1)
          CALL FMLN(MXY(11),MXY(7))
          CALL FMMPY(MXY(9),MXY(7),MXY(4))
          CALL FMSUB(MXY(4),MXY(11),MXY(7))
          CALL FMEXP(MXY(7),MXY(13))
          IF ((MWK(START(MXY(13))+2) == MEXPOV .AND. MWK(START(MXY(13))) > 0 .AND.  &
              MWK(START(MXY(13))+3) /= 0) .OR. MWK(START(MXY(13))+2) > MXSAVE+1) THEN
              CALL FMST2M('OVERFLOW',MXY(16))
              KFLAG = -5
              GO TO 190
          ENDIF
      ENDIF

!             If A is 1 the result is exp(-X).

      CALL FMI2M(1,MXY(7))
      IF (FMCOMP(MXY(1),'==',MXY(7))) THEN
          IF (ABS(MWK(START(MXY(2))+2)) < MEXPOV) THEN
              CALL FMEQ(MXY(2),MXY(8))
              IF (MWK(START(MXY(8))+2) /= MUNKNO .AND. MWK(START(MXY(8))+3) /= 0)  &
                  MWK(START(MXY(8))) = -MWK(START(MXY(8)))
              CALL FMEXP(MXY(8),MXY(16))
              IF (MWK(START(MXY(16))+2) /= MUNKNO) GO TO 210
          ENDIF
      ENDIF

!             If A is negative and X is small, the result is -X**A / A.

      IF (MWK(START(MXY(1))) == -1 .AND. MWK(START(MXY(2))+2) < -NDIG) THEN
          CALL FMPWR(MXY(2),MXY(1),MXY(8))
          CALL FMDIV(MXY(8),MXY(1),MXY(16))
          IF (MWK(START(MXY(16))+2) == MUNKNO) THEN
              CALL FMLN(MXY(2),MXY(8))
              CALL FMMPY(MXY(8),MXY(1),MXY(9))
              CALL FMABS(MXY(1),MXY(10))
              CALL FMLN(MXY(10),MXY(11))
              CALL FMSUB(MXY(9),MXY(11),MXY(10))
              CALL FMEXP(MXY(10),MXY(16))
              IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
                  MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          ENDIF
          IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
              MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          IF (MWK(START(MXY(16))+2) /= MUNKNO) GO TO 210
      ENDIF
      IF (MWK(START(MXY(1))) == -1 .AND. MWK(START(MXY(2))) == 1 .AND.  &
          MWK(START(MXY(1))+2) > NDIG .AND.                             &
          MWK(START(MXY(1))+2) - MWK(START(MXY(2))+2) > NDIG) THEN
          CALL FMI2M(1,MXY(3))
          CALL FMSUB(MXY(3),MXY(1),MXY(4))
          CALL FMADD(MXY(4),MXY(2),MXY(6))
          CALL FMDIV(MXY(3),MXY(6),MXY(5))
          CALL FMSQR(MXY(1),MXY(4))
          CALL FMMPYI(MXY(2),2,MXY(6))
          CALL FMADDI(MXY(6),3)
          CALL FMMPY(MXY(1),MXY(6),MXY(7))
          CALL FMSUB(MXY(4),MXY(7),MXY(8))
          CALL FMDIV(MXY(5),MXY(8),MXY(9))
          CALL FMSUB(MXY(1),MXY(3),MXY(10))
          CALL FMMPY(MXY(10),MXY(9),MXY(11))
          IF (MWK(START(MXY(11))+2) /= MUNKNO) THEN
              CALL FMADD(MXY(5),MXY(11),MXY(12))
          ELSE
              CALL FMEQ(MXY(5),MXY(12))
          ENDIF
          CALL FMPWR(MXY(2),MXY(1),MXY(13))
          IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
              CALL FMEQ(MXY(13),MXY(16))
          ELSE
              CALL FMEXP(MXY(2),MXY(14))
              CALL FMMPY(MXY(12),MXY(13),MXY(15))
              CALL FMDIV(MXY(15),MXY(14),MXY(16))
          ENDIF
          IF (MWK(START(MXY(16))+2) /= MUNKNO) GO TO 210
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion,
!                    = 4 means use an O(A**2) formula.

      CALL FMI2M(-10000,MXY(11))
      CALL FMI2M(10000,MXY(12))
      CALL FMABS(MXY(1),MXY(14))
      CALL FMABS(MXY(2),MXY(15))
      CALL FMSUB(MXY(15),MXY(14),MXY(13))
      KABIGR = 1
      IF (MWK(START(MXY(13))+3) >= 0 .AND. MWK(START(MXY(13))) > 0) KABIGR = 0

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      IF (KFLAGA /= 0 .OR. KFLAGX /= 0) THEN
          CALL FMDIV(MXY(14),MXY(15),MXY(10))
          CALL FMI2M(1,MXY(8))
          CALL FMSUB(MXY(8),MXY(10),MXY(9))
          IF (MWK(START(MXY(9))) < 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          T1 = FMDPLG(A)
          SMALL = T1 - FMDPLG(-ABS(X)) - (A+ABS(X))*LOG(ABS(X))
          TOL = -DBLE(NDIG+2)*DLOGMB - 12.0D0
          B = 1.0D0
          IF (A > ABS(X)) B = A - ABS(X)
          BIG = T1 - FMDPLG(A-B) - B*LOG(ABS(X))

          NMETHD = 0
          IF (FMCOMP(MXY(13),'<=',MXY(11))) THEN
              IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) /= 0) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
          ELSE IF (FMCOMP(MXY(13),'>=',MXY(12)) .AND. MWK(START(MXY(1))) > 0 .AND.  &
                   MWK(START(MXY(1))+3) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.      &
                   MWK(START(MXY(2))+3) > 0) THEN
              NMETHD = 3
              IF (SMALL < TOL+BIG) NMETHD = 2
          ELSE IF (FMCOMP(MXY(13),'>=',MXY(12))) THEN
              NMETHD = 3
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
                   MWK(START(MXY(2))+3) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(11))
              IF (FMCOMP(MXY(2),'>=',MXY(11))) THEN
                  KFLAG = -5
                  CALL FMST2M('OVERFLOW',MXY(16))
                  GO TO 190
              ENDIF

              IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) /= 0) THEN
                  C2 = DBLE(NDSAVE)*DLOGMB/6.0D0
                  C1 = MAX( 10.0D0 , C2 , A )
                  C2 = MAX( 10.0D0 , C2 , A - 6.5D0*A/(SQRT(A)+1.0D0) )
              ELSE
                  C1 = MAX( 15.0D0 , DBLE(NDSAVE)*DLOGMB/5.0D0 )
                  C2 = C1
              ENDIF
              IF (X < MIN(C1,C2)) THEN
                  IF (-2*MWK(START(MXY(1))+2) > NDIG .OR. MWK(START(MXY(1))+3) == 0) THEN
                      NMETHD = 4
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE IF (X > C2) THEN
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
              IF (NMETHD == 0 .AND. X > C1) NMETHD = 3
              IF (NMETHD == 0) NMETHD = 1
          ELSE IF (MWK(START(MXY(1))) < 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+3) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(11))
              IF (FMCOMP(MXY(2),'>=',MXY(11))) THEN
                  KFLAG = -6
                  CALL FMST2M('UNDERFLOW',MXY(16))
                  GO TO 190
              ENDIF

              C1 = MAX( 10.0D0 , DBLE(NDSAVE)*DLOGMB/7.0D0 )
              C2 = -2.0D0*A
              IF (X < C1) THEN
                  IF (-2*MWK(START(MXY(1))+2) > NDIG) THEN
                      NMETHD = 4
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE IF (X > C2) THEN
                  T1 = FMDPLG(A)
                  SMALL = T1 - FMDPLG(-ABS(X)) - (A+ABS(X))*LOG(ABS(X))
                  TOL = -DBLE(NDIG+2)*DLOGMB - 12.0D0
                  B = 1.0D0
                  IF (A > ABS(X)) B = A - ABS(X)
                  BIG = T1 - FMDPLG(A-B) - B*LOG(ABS(X))
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
              IF (NMETHD == 0 .AND. X > C1) NMETHD = 3
              IF (NMETHD == 0) NMETHD = 1
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) > 0 .AND.  &
              MWK(START(MXY(2))) < 0) THEN
              CALL FMEQ(MXY(2),MXY(11))
              IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
                  MWK(START(MXY(11))) = -MWK(START(MXY(11)))
              CALL FMMPYI(MXY(1),2,MXY(12))
              IF (FMCOMP(MXY(11),'<',MXY(1))) THEN
                  NMETHD = 1
              ELSE IF (FMCOMP(MXY(11),'<',MXY(12))) THEN
                  NMETHD = 3
              ELSE
                  NMETHD = 3
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170
      IF (NMETHD == 4) GO TO 180

!             Method 1.  Use the X**N/Pochhammer(A+1,N) series.

!             MXY(16) is the current sum.
!             MXY(12) is the current term.
!             MXY(11) is (A+N)/X.
!             MXY(19) is 1/X

!             Raise the precision if A is negative and near an integer, to compensate for
!             cancellation when (A+N)/X is near zero.
!             Raise the precision if A is positive and near zero, since there will be cancellation
!             in subtracting the sum from Gamma(A).
!             If A is a negative integer use method 3 or 4.

      IEXTRA = 0
      IF (MWK(START(MXY(1))) < 0) THEN
          IF (KFLAGA == 0) THEN
              IF (ABS(A) > 1.0D3) THEN
                  NMETHD = 3
                  GO TO 170
              ENDIF
          ELSE
              NMETHD = 3
              GO TO 170
          ENDIF
          CALL FMNINT(MXY(1),MXY(16))
          IF (FMCOMP(MXY(16),'==',MXY(1))) THEN
              IF (KFLAGI == 0) THEN
                  IF (KFLAGX /= 0) THEN
                      GO TO 170
                  ELSE
                      IF (ABS(X) <= 20.0D0) THEN
                          C1 = 0.7D0*(DBLE(NDSAVE)*DLOGMB*(20.0D0-X))**0.75D0
                          IF (ABS(A) > C1) THEN
                              GO TO 170
                          ELSE
                              GO TO 180
                          ENDIF
                      ELSE
                          GO TO 170
                      ENDIF
                  ENDIF
              ELSE
                  GO TO 170
              ENDIF
          ENDIF
          CALL FMSUB(MXY(1),MXY(16),MXY(19))
          IEXTRA = MAX(-2*INT(MWK(START(MXY(19))+2)),-INT(MWK(START(MXY(1))+2))+1,0)
      ELSE
          IEXTRA = MAX(-INT(MWK(START(MXY(1))+2))+1,0)
      ENDIF

!             Raise the precision further as X increases in magnitude.

      IF (KFLAGX == 0 .AND. KFLAGA == 0) THEN
          T1 = (0.92D0 + (X-A) + (A-0.5D0)*LOG(ABS(A)+1.0D-10) -  &
               (A-1.0D0)*LOG(ABS(X)+1.0D-10))/DLOGMB
          IF (T1 > 0 .AND. ABS(X) > 1.0D0) THEN
              IF (A < 0.0D0 .OR. X >= A) THEN
                  IEXTRA = IEXTRA + MAX(0,INT(T1)+1)
              ENDIF
          ENDIF
      ENDIF

      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      JEXTRA = 0

  140 IF (KABIGR == 1) THEN
          CALL FMGAM(MXY(1),MXY(20))
          IF (KFLAG /= 0) THEN
              CALL FMEQ(MXY(20),MXY(16))
              GO TO 190
          ENDIF
          CALL FMEQ(MXY(20),MXY(16))
      ELSE
          CALL FMI2M(0,MXY(16))
      ENDIF

      MAXM09 = MWK(START(MXY(16))+2)

      CALL FMABS(MXY(2),MXY(19))
      CALL FMLN(MXY(19),MXY(6))
      CALL FMMPY_R2(MXY(1),MXY(6))
      CALL FMSUB_R1(MXY(6),MXY(2))
      CALL FMEXP(MXY(6),MXY(20))
      CALL FMDIV(MXY(20),MXY(1),MXY(12))
      IF (MWK(START(MXY(12))+2) == MUNKNO) THEN
          CALL FMLN(MXY(1),MXY(15))
          CALL FMSUB_R1(MXY(6),MXY(15))
          CALL FMEXP(MXY(6),MXY(12))
      ENDIF
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MWK(START(MXY(12))+2) /= MUNKNO  &
          .AND. MWK(START(MXY(12))+3) /= 0) THEN
          MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      ENDIF

      IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0) THEN
          MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      ENDIF
      CALL FMADD_R1(MXY(16),MXY(12))
      MAXM09 = MAX(MAXM09,MWK(START(MXY(16))+2))

      CALL FMI2M(1,MXY(9))
      CALL FMADD(MXY(1),MXY(9),MXY(11))
      CALL FMDIV_R1(MXY(12),MXY(11))
      CALL FMMPY_R1(MXY(12),MXY(2))
      CALL FMDIV_R1(MXY(11),MXY(2))
      CALL FMDIV(MXY(9),MXY(2),MXY(19))
      NDSAV1 = NDIG

!             If A is negative and ABS(A) > ABS(X), the terms in the series first decrease,
!             then increase, then decrease. Try to predict the number of extra digits required to
!             keep the precision from prematurely becoming too small.

      KFLGOK = 1
      IF (MWK(START(MXY(1))) < 0) THEN
          KFLGOK = 0
          MWK(START(MXY(1))) = 1
          MWK(START(MXY(2))) = 1
          IF (FMCOMP(MXY(1),'>',MXY(2))) THEN
              IF (JEXTRA == 0) THEN
                  IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                      T1 = FMDPLG(A+AINT(-ABS(X)-A)) - FMDPLG(A+1.0D0+AINT(ABS(X)-A))
                      T1 = (T1 + 2.0D0*ABS(X)*LOG(ABS(X)+1.0D-10))/DLOGMB
                      T1 = MAX(0.0D0,T1+1.0D0)
                      JEXTRA = T1
                  ENDIF
              ENDIF

!             If A is negative and ABS(A) is much bigger than ABS(X), then the later increase
!             in the size of the terms can be ignored.

              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T1 = (AINT(X-A)*LOG(ABS(X)+1.0D-10) + FMDPLG(A+1.0D0)  &
                       - FMDPLG(A+1.0D0+AINT(X-A))) / DLOGMB
                  IF (T1 < -DBLE(NDIG)) KFLGOK = 1
              ELSE
                  KFLGOK = 1
              ENDIF
          ENDIF
          MWK(START(MXY(1))) = MAS
          MWK(START(MXY(2))) = MBS
      ENDIF

      NMNNDG = NDSAV1

!             Method 1 summation loop.

      DO J = 1, NTERMS
         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(16),MXY(12))
         MAXM09 = MAX(MAXM09,MWK(START(MXY(16))+2))
         IF (KFLAG /= 0) THEN
             IF (KFLGOK == 0 .AND. KFLAGA == 0 .AND. KFLAGX == 0) THEN
                 IF (DBLE(J) > X-A) EXIT
             ELSE
                 EXIT
             ENDIF
         ENDIF

         CALL FMCSADD_R1(MXY(11),MXY(19))

         NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(16))+2)-MWK(START(MXY(12))+2)))
         NDIG = MIN(NDSAV1,NDIG2+JEXTRA)
         NMNNDG = MIN(NMNNDG,NDIG)
         CALL FMCSDIV(MXY(12),MXY(11),MXY(5))
         CALL FMEQ(MXY(5),MXY(12))
      ENDDO

      NDIG = NDSAV1
      IF (KABIGR == 0) THEN
          CALL FMEQ(MXY(16),MXY(19))
          CALL FMGAM(MXY(1),MXY(20))
          IF (KFLAG /= 0) THEN
              CALL FMEQ(MXY(20),MXY(16))
              GO TO 190
          ENDIF
          CALL FMADD(MXY(20),MXY(19),MXY(16))
      ENDIF

!             If too much cancellation occurred, raise the precision and do the calculation again.

      IEXTRA = NDIG - NDSAVE
      IF (INT(MAXM09-MWK(START(MXY(16))+2)) >= IEXTRA-NGRD52/2) THEN
          IEXTRA = IEXTRA + NGRD52
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          GO TO 140
      ENDIF

      GO TO 190

!             Method 2.  Use the Pochhammer(A-N,N)/X**N series.

!             MXY(16) is the current sum.
!             MXY(12) is the current term.
!             MXY(11) is (A-N)/X.
!             MXY(19) is -1/X

  150 CALL FMABS(MXY(2),MXY(19))
      CALL FMLN(MXY(19),MXY(6))
      CALL FMMPY(MXY(1),MXY(6),MXY(16))
      CALL FMSUB_R2(MXY(16),MXY(6))
      CALL FMSUB_R1(MXY(6),MXY(2))
      CALL FMEXP(MXY(6),MXY(12))
      IF (KXNEG == 1 .AND. MODA2 == 0 .AND. MWK(START(MXY(12))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(12))+3) /= 0) MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      IF (ABS(MWK(START(MXY(12))+2)) >= MXEXP2) THEN
          CALL FMEQ(MXY(12),MXY(16))
          GO TO 190
      ENDIF

!             Here MXY(12) is X**(A-1)/EXP(X).

      CALL FMI2M(0,MXY(16))
      CALL FMEQ(MXY(1),MXY(11))
      CALL FMDIV_R1(MXY(11),MXY(2))
      CALL FMI2M(1,MXY(9))
      CALL FMDIV(MXY(9),MXY(2),MXY(19))
      IF (MWK(START(MXY(19))+2) /= MUNKNO .AND. MWK(START(MXY(19))+3) /= 0)  &
          MWK(START(MXY(19))) = -MWK(START(MXY(19)))
      NDSAV1 = NDIG

!             Disable NDIG reduction until the terms in the sum begin to decrease in size.

      BIGJ = 0
      IF (KFLAGA == 0 .AND. KFLAGX == 0) BIGJ = ABS(A) - ABS(X)
      JTERMS = NTERMS
      IF (KFLAGI == 0 .AND. INTA > 0) THEN
          JTERMS = INTA
      ELSE IF (KFLAGX == 0) THEN
          IF (KFLAGA == 0) THEN
              T1 = A + ABS(X)
              IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
          ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
              T1 = ABS(X)
              IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
          ENDIF
      ENDIF

!             Method 2 summation loop.

      DO J = 1, JTERMS
         NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(16),MXY(12))
         IF (KFLAG /= 0 .AND. J > 1) GO TO 160
         CALL FMCSADD_R1(MXY(11),MXY(19))
         IF (REAL(J) >= BIGJ) THEN
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(16))+2)-MWK(START(MXY(12))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
         ENDIF
         CALL FMCSMPY_R1(MXY(12),MXY(11))
      ENDDO

  160 NDIG = NDSAV1
      GO TO 190

!             Method 3.  Use the continued fraction expansion.

!             MXY(19) is the current approximation.
!             MXY(16) is the term in the sum, S(k).
!             MXY(14), MXY(15) are the latest denominators, Q(k-1) and Q(k).

!             Raise the precision so that convergence of the continued fraction expansion
!             is easier to detect.

  170 JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))

!             Raise the precision further for small X if A is positive.

      IF (KFLAGX == 0 .AND. KFLAGA == 0) THEN
          T1 = (0.92D0 + (ABS(X)-A) + (A-0.5D0)*LOG(ABS(A)+1.0D-10) -  &
               (A-1.0D0)*LOG(ABS(X)+1.0D-10))/DLOGMB
          IF (T1 > 0.0D0 .AND. A > 0.0D0) THEN
              IF (ABS(X) < A) THEN
                  JEXTRA = JEXTRA + MAX(0,INT(1.5D0*T1)+1)
              ENDIF
          ENDIF
      ENDIF
      NDSAV1 = NDIG
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMEQU(MXY(1),MXY(11),NDSAV1,NDIG)
      IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
          MWK(START(MXY(11))) = -MWK(START(MXY(11)))
      CALL FMI2M(1,MXY(14))
      CALL FMEQU(MXY(2),MXY(15),NDSAV1,NDIG)
      CALL FMI2M(1,MXY(7))
      CALL FMDIV(MXY(7),MXY(15),MXY(16))
      CALL FMEQ(MXY(16),MXY(19))

      JTERMS = NTERMS
      IF (INTA > 0) JTERMS = INTA - 1

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, JTERMS
         CALL FMADDI(MXY(11),1)
         CALL FMEQ(MXY(11),MXY(13))
         CALL FMCSMPY_R1(MXY(13),MXY(14))
         CALL FMADD(MXY(15),MXY(13),MXY(12))
         CALL FMEQ(MXY(13),MXY(8))
         CALL FMCSMPY_R1(MXY(8),MXY(16))
         CALL FMCSDIV(MXY(8),MXY(12),MXY(16))
         IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
             MWK(START(MXY(16))) = -MWK(START(MXY(16)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(19),MXY(16))
         KFLAG1 = KFLAG
         CALL FMEQ(MXY(15),MXY(14))
         CALL FMEQ(MXY(12),MXY(15))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2))))
         CALL FMCSMPYI(MXY(14),J,MXY(13))
         CALL FMEQ(MXY(2),MXY(8))
         CALL FMCSMPY_R1(MXY(8),MXY(15))
         CALL FMADD(MXY(8),MXY(13),MXY(12))
         CALL FMEQ(MXY(13),MXY(8))
         CALL FMCSMPY_R1(MXY(8),MXY(16))
         CALL FMCSDIV(MXY(8),MXY(12),MXY(16))
         IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
             MWK(START(MXY(16))) = -MWK(START(MXY(16)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(19),MXY(16))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(15),MXY(14))
         CALL FMEQ(MXY(12),MXY(15))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2))))
      ENDDO

      NDIG = NDSAV2
      CALL FMEQU_R1(MXY(19),NDIG,NDSAV1)
      NDIG = NDSAV1
      CALL FMABS(MXY(2),MXY(15))
      CALL FMLN(MXY(15),MXY(6))
      CALL FMMPY_R2(MXY(1),MXY(6))
      CALL FMSUB_R1(MXY(6),MXY(2))
      CALL FMEXP(MXY(6),MXY(5))
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(5))+3) /= 0) MWK(START(MXY(5))) = -MWK(START(MXY(5)))
      IF (ABS(MWK(START(MXY(5))+2)) >= MXEXP2) THEN
          CALL FMEQ(MXY(5),MXY(16))
          IF (MWK(START(MXY(19))) < 0 .AND. MWK(START(MXY(16))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(16))+3) /= 0) MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          GO TO 190
      ENDIF

      CALL FMMPY(MXY(5),MXY(19),MXY(16))
      GO TO 190

!             Method 4.  Use the O(A**2) formula when A is small.

!             MXY(16) is the current term.
!             MXY(19) is the current sum.

!             Raise the precision if X is larger than A in magnitude.
!             The terms initially increase in size, and the final sum is small.

  180 IEXTRA = 0

!             If A is a negative integer, replace it by zero and later use a recurrence to recover
!             the original function value.

      IF (KFLAGI == 0 .AND. INTA < 0) THEN
          CALL FMI2M(0,MXY(1))
          A = 0.0D0
          KMETH4 = 1
      ENDIF

      IF (KFLAGX == 0) THEN
          IF (KFLAGA == 0) THEN
              T1 = ABS(X) - ABS(A)
          ELSE
              T1 = ABS(X)
          ENDIF
          IF (T1 > 0) THEN
              T2 = (T1 + LOG(T1))/DLOGMB
              IF (T2 > DBLE(MXEXP2/10)) T2 = DBLE(MXEXP2/10)
              IEXTRA = INT(MAX(0.0D0,T2))
          ENDIF
          T1 = ABS(X)+1.0D-10
          T2 = (T1 - 0.5D0*LOG(6.2831853D0*T1))/DLOGMB
          IF (T2 > DBLE(MXEXP2/10)) T2 = DBLE(MXEXP2/10)
          IEXTRA = IEXTRA + INT(MAX(0.0D0,T2))
      ENDIF

      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      CALL FMEULR(MXY(19))
      CALL FMEQ(MXY(19),MXY(20))
      MWK(START(MXY(19))) = -1
      CALL FMABS(MXY(2),MXY(16))
      CALL FMLN(MXY(16),MXY(15))
      CALL FMSUB_R1(MXY(19),MXY(15))
      IF (MWK(START(MXY(1))+3) /= 0 .AND. MWK(START(MXY(1))+2) >= -NDIG-1) THEN
          CALL FMSQR(MXY(15),MXY(7))
          CALL FMMPY(MXY(7),MXY(1),MXY(4))
          CALL FMDIVI(MXY(4),2,MXY(16))
          CALL FMSUB_R1(MXY(19),MXY(16))

          CALL FMSQR(MXY(20),MXY(14))
          CALL FMPI(MXY(13))
          CALL FMSQR(MXY(13),MXY(7))
          CALL FMDIVI(MXY(7),6,MXY(13))
          CALL FMADD(MXY(13),MXY(14),MXY(7))
          CALL FMMPY(MXY(7),MXY(1),MXY(4))
          CALL FMDIVI(MXY(4),2,MXY(14))
          CALL FMADD_R1(MXY(19),MXY(14))
      ENDIF

      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(14))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(14),MXY(13))
      KROUND = JR
      IF (FMCOMP(MXY(14),'==',MXY(13))) THEN
          CALL FMI2M(-1,MXY(16))
          DO J = 1, NTERMS
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
             CALL FMMPY_R1(MXY(16),MXY(2))
             IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
                 MWK(START(MXY(16))) = -MWK(START(MXY(16)))
             CALL FMDIVI_R1(MXY(16),J)
             CALL FMDIVI(MXY(16),J,MXY(15))
             NDIG = NDSAV1
             CALL FMADD_R1(MXY(19),MXY(15))
             IF (KFLAG /= 0) EXIT
          ENDDO
      ELSE
          CALL FMPWR(MXY(2),MXY(1),MXY(16))
          IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
              MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          CALL FMEQ(MXY(1),MXY(20))
          DO J = 1, NTERMS
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
             CALL FMMPY_R1(MXY(16),MXY(2))
             IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
                 MWK(START(MXY(16))) = -MWK(START(MXY(16)))
             CALL FMDIVI_R1(MXY(16),J)
             NDIG = NDSAV1
             CALL FMADD_R1(MXY(20),MXY(14))
             NDIG = MIN(NDSAV1,NDIG2)
             CALL FMDIV(MXY(16),MXY(20),MXY(15))
             NDIG = NDSAV1
             CALL FMADD_R1(MXY(19),MXY(15))
             IF (KFLAG /= 0) EXIT
          ENDDO
      ENDIF
      CALL FMEQ(MXY(19),MXY(16))

!             Use the recurrence relation if A was a negative integer.

      IF (KFLAGI == 0 .AND. INTA < 0) THEN
          N = -INTA
          CALL FMI2M(1,MXY(19))
          CALL FMDIV_R1(MXY(19),MXY(2))
          CALL FMEQ(MXY(19),MXY(15))
          CALL FMEQ(MXY(19),MXY(14))
          DO J = 1, N-1
             CALL FMMPYI_R1(MXY(15),J)
             CALL FMMPY_R1(MXY(15),MXY(14))
             IF (MWK(START(MXY(15))+2) /= MUNKNO .AND. MWK(START(MXY(15))+3) /= 0)  &
                 MWK(START(MXY(15))) = -MWK(START(MXY(15)))
             CALL FMADD_R1(MXY(19),MXY(15))
          ENDDO
          CALL FMEXP(MXY(2),MXY(14))
          CALL FMDIV_R1(MXY(19),MXY(14))
          CALL FMSUB_R1(MXY(16),MXY(19))
          CALL FMFCTI(N,MXY(14))
          CALL FMDIV_R1(MXY(16),MXY(14))
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(16))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(16))+3) /= 0) MWK(START(MXY(16))) = -MWK(START(MXY(16)))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(16))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(16))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(16))+J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(16))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          IF (KMETH4 == 1) THEN
              CALL FMI2M(INTA,MXY(1))
          ENDIF
          CALL FMEQU_R1(MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(16),MRETRY,NDOLD,NDIG)
          GO TO 130
      ENDIF

  210 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(16))+1) = MIN(MWK(START(MXY(16))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(16),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIGM2

      SUBROUTINE FMLNGM(MA,MB)

!  MB = LN(GAMMA(MA))

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR,X,Z
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K1,K2,KASAVE,KFL,KL,KOVUN,KC_RETRY,KR_RETRY,KRESLT,KRSAVE,  &
                 KSIGN,KWRNSV,LSHIFT,NDENOM,NDGOAL,NDIG2,NDMB,NDOLD,NDSAV1,NDSAVE,NDSV,NGOAL,      &
                 NMETHD,NMXDIF,NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(155) :: STRING
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MJSUMS(LJSUMS),MRETRY,NUMBER_USED_SAVE
      INTEGER, SAVE :: C(0:196) = -3, NDIG_C = 0
      REAL (KIND(1.0D0)), SAVE :: MBASE_C = 0

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMLNGM   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MAS = MWK(START(MA))
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0
      KC_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(13))
      NUMTRY = 0

!             Near zero Gamma(x) is about 1/x.

  120 IF (MWK(START(MXY(13))+2) < (-NDIG-3)) THEN
          CALL FMLN(MXY(13),MXY(10))
          IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
              MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          GO TO 190
      ENDIF

!             Check for special cases.

      IF (MAS < 0) THEN
          KFL = 0
          IF (MWK(START(MXY(1))+2) <= NDSAVE) THEN
              CALL FMINT(MXY(13),MXY(9))
              IF (FMCOMP(MXY(13),'==',MXY(9))) KFL = -4
              CALL FMI2M(2,MXY(10))
              MWK(START(MXY(9))) = 1
              CALL FMMOD(MXY(9),MXY(10),MXY(5))
              CALL FMEQ(MXY(5),MXY(10))
              IF (MWK(START(MXY(10))+3) == 0) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(10))
              KFLAG = -4
              GO TO 210
          ELSE
              CALL FMI2M(1,MXY(5))
              CALL FMSUB_R2(MXY(5),MXY(13))
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      CALL FMNINT(MXY(13),MXY(2))
      CALL FMSUB(MXY(13),MXY(2),MXY(6))
      MWK(START(MXY(6))+1) = MWK(START(MXY(1))+1)
      CALL FMM2DP(MXY(6),Z)
      Z = MAX(ABS(Z),1.0D-50)
      IF (KFLAG /= 0 .OR. ABS(Z) >= 1) THEN
          NMETHD = 2
      ELSE
          IF (190*LOG(Z) - 90*DLOGTN >= -NDIG*DLOGMB .OR. -190*DLOGTN >= -NDIG*DLOGMB) THEN
              NMETHD = 2
          ENDIF
      ENDIF
      CALL FMM2DP(MXY(13),X)
      IF (KFLAG /= 0) THEN
          NMETHD = 2
      ELSE IF (NMETHD == 1) THEN
          IF (X > 35 - 8*LOG(Z) + NDIG*DLOGMB/(2.5*DLOGTN) .OR. X > 250) NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      IF (MWK(START(MA)) > 0 .AND. NDSAVE+NGRD52 < NDIG .AND. KR_RETRY == 0 .AND. KC_RETRY == 0)  &
          NDIG = NDSAVE + NGRD52
      CALL FMM2I(MXY(2),LSHIFT)
      LSHIFT = LSHIFT - 3
      IF (NDIG_C < NDIG .OR. MBASE_C /= MBASE) THEN
          CALL FMLNGM_C(NDIG_C,MBASE_C,C)
      ENDIF
      J2 = 0.42*LOG(Z) + 7.9
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      NDSAV1 = NDIG
      DO J = 1, J2
         CALL FMEQ(C(J+1),MJSUMS(J))
      ENDDO
      CALL FMIPWR(MXY(6),J2,MXY(5))
      CALL FMEQ(MXY(5),MXY(7))
      NTERM = J2 + 1
  130 IF (NTERM > J2+1) CALL FMCSMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(7),MXY(4))
         CALL FMCSMPY_R1(MXY(4),C(NTERM))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0 .OR. NTERM == 196) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130
  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      NDIG = NDSAV1
      IF (NTERM == 196) THEN
          GO TO 150
      ENDIF
      CALL FMEQ(MJSUMS(J2),MXY(8))
      CALL FMEQ(MXY(6),MXY(3))
      MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(3))
         CALL FMCSADD_R1(MXY(8),MJSUMS(J2-J+1))
      ENDDO
      CALL FMSQR(MXY(6),MXY(3))
      CALL FMCSMPY_R1(MXY(8),MXY(3))
      CALL FMADD(MXY(8),C(0),MXY(10))
      CALL FMMPY(MXY(6),C(1),MXY(3))
      CALL FMADD_R1(MXY(10),MXY(3))

!             Recover from using a shifted argument.

      IF (LSHIFT < 0) THEN
          CALL FMEQ(MXY(13),MXY(3))
          CALL FMEQ(MXY(13),MXY(14))
          DO J = 2, -LSHIFT
             CALL FMADDI(MXY(14),1)
             CALL FMMPY_R1(MXY(3),MXY(14))
          ENDDO
          CALL FMLN(MXY(3),MXY(4))
          CALL FMSUB_R1(MXY(10),MXY(4))
      ENDIF
      IF (LSHIFT > 0) THEN
          IF (MOD(LSHIFT,4) == 0) THEN
              CALL FMI2M(1,MXY(3))
              CALL FMEQ(MXY(6),MXY(14))
              CALL FMADDI(MXY(14),3)
          ELSE
              CALL FMEQ(MXY(6),MXY(3))
              CALL FMADDI(MXY(3),3)
              CALL FMEQ(MXY(3),MXY(14))
              DO J = 1, MOD(LSHIFT,4)-1
                 CALL FMADDI(MXY(14),1)
                 CALL FMMPY_R1(MXY(3),MXY(14))
              ENDDO
              CALL FMADDI(MXY(14),1)
          ENDIF
          LSHIFT = LSHIFT - MOD(LSHIFT,4)

!             The product Z*(Z+1)*...*(Z+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(14) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

          CALL FMI2M(1,MXY(11))
          IF (LSHIFT > 0) THEN
              CALL FMSQR(MXY(14),MXY(6))
              CALL FMMPY(MXY(14),MXY(6),MXY(7))
              CALL FMSQR(MXY(6),MXY(8))
              CALL FMCSMPYI(MXY(7),6,MXY(12))
              CALL FMCSADD_R1(MXY(8),MXY(12))
              CALL FMCSMPYI(MXY(6),11,MXY(12))
              CALL FMCSADD_R1(MXY(8),MXY(12))
              CALL FMCSMPYI(MXY(14),6,MXY(12))
              CALL FMCSADD_R1(MXY(8),MXY(12))
              CALL FMEQ(MXY(8),MXY(11))
              CALL FMCSMPYI_R1(MXY(7),16)
              DO K = 0, LSHIFT-8, 4
                 CALL FMCSADD_R1(MXY(8),MXY(7))
                 K2 = 24*(2*K + 7)
                 CALL FMCSMPYI(MXY(6),K2,MXY(12))
                 CALL FMCSADD_R1(MXY(8),MXY(12))
                 IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                     K1 = 8*(6*K*K + 42*K + 79)
                     CALL FMCSMPYI(MXY(14),K1,MXY(12))
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ELSE
                     K1 = 48*K
                     CALL FMCSMPYI(MXY(14),K1,MXY(12))
                     CALL FMCSMPYI_R1(MXY(12),K)
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                     K1 = 336*K + 632
                     CALL FMCSMPYI(MXY(14),K1,MXY(12))
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ENDIF
                 IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                     K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                     CALL FMADDI(MXY(8),K0)
                 ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12))
                     K0 = K*K + 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0)
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ELSE
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12))
                     CALL FMCSMPYI(MXY(12),K,MXY(9))
                     CALL FMCSMPYI_R1(MXY(9),K)
                     CALL FMCSADD_R1(MXY(8),MXY(9))
                     K0 = 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0)
                     CALL FMCSADD_R1(MXY(8),MXY(12))
                 ENDIF
                 CALL FMCSMPY_R1(MXY(11),MXY(8))
              ENDDO
          ENDIF
          CALL FMMPY_R1(MXY(11),MXY(3))
          CALL FMLN(MXY(11),MXY(4))
          CALL FMADD_R1(MXY(10),MXY(4))
      ENDIF
      GO TO 180

!             Method 2.  Use the B(2n)/(2n*(2n-1)*X**(2n-1) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by LSHIFT.

  150 IEXTRA = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(13),INTA)
      KWARN = KWRNSV

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)
      IF (KFLAG == 0) THEN
          IF (LSHIFT > 0 .OR. INTA <= 10) THEN
              IF (INTA <= 2) THEN
                  CALL FMI2M(0,MXY(10))
                  GO TO 190
              ENDIF
              INTA = INTA - 1
              CALL FMFCTI(INTA,MXY(13))
              CALL FMLN(MXY(13),MXY(10))
              GO TO 190
          ENDIF
      ENDIF

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(5))
          CALL FMADD(MXY(13),MXY(5),MXY(12))
      ELSE
          CALL FMEQ(MXY(13),MXY(12))
      ENDIF

!             Sum the asymptotic series.

!       MXY(13) is Z
!       MXY(12) is Z + LSHIFT
!       MXY(9)  is X**J2 = (1/(Z+LSHIFT)**2)**J2
!       MXY(10) is the current power of X
!       MXY(11) is the current term in the sum
!       MJSUMS  is the partial sum

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(10))
      J = -2*J2
      CALL FMIPWR(MXY(12),J,MXY(9))
      IF (ABS(MWK(START(MXY(9))+2)) >= MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(12),-2,MXY(9))
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(10),MXY(11))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM*(NTERM-1)
         CALL FMCSDIVI(MXY(11),NDENOM,MJSUMS(J))
      ENDDO

      NDIG2 = NDIG
  160 CALL FMCSMPY_R1(MXY(10),MXY(9))

      NMXDIF = MIN(NDSAV1,NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(10),MXY(11))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM*(NTERM-1)
         IF (NTERM <= MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(11),NDENOM)
         ELSE
             CALL FMCSDIVI_R1(MXY(11),NTERM)
             NDENOM = NTERM - 1
             CALL FMCSDIVI_R1(MXY(11),NDENOM)
         ENDIF
         NDIG = NDSAV1
         CALL FMCSADD_R1(MJSUMS(J),MXY(11))
         NMXDIF = MAX(NMXDIF,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(11))+2)))
         NDIG = NDIG2
         IF (KFLAG /= 0) GO TO 170
      ENDDO
      NDIG2 = NMXDIF
      NDIG = NDIG2
      GO TO 160

!             Put the J2 concurrent sums back together.

  170 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMSQR(MXY(12),MXY(11))
          CALL FMI2M(1,MXY(5))
          CALL FMDIV_R2(MXY(5),MXY(11))
          CALL FMEQ(MJSUMS(J2),MXY(9))
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(9),MXY(11))
             CALL FMCSADD_R1(MXY(9),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(9),MJSUMS(1))
      ENDIF

!             Add the log terms to the asymptotic series.

!       MXY(10) is the current sum as the log terms are added
!       MXY(11) is now LN(Z+LSHIFT)

      CALL FMDIV(MJSUMS(1),MXY(12),MXY(10))
      CALL FMLN(MXY(12),MXY(11))
      IF (MBASE /= MBS2PI .OR. NDIG > NDG2PI) THEN
          NDMB = INT(150.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              STRING = '1.837877066409345483560659472811235279722794'//  &
              '94727556682563430308096553139185452079538948659727190'//  &
              '8395244011293249268674892733725763681587144311751830445'
              CALL FMST2M(STRING,M_LN_2PI)
              MWK(START(M_LN_2PI)+1) = NINT(NDIG*ALOGM2)
              MBS2PI = MBASE
              NDG2PI = NDIG
              IF (ABS(MWK(START(M_LN_2PI)+2)) > 10) NDG2PI = 0
              NDIG = NDSV
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(9))
              CALL FMMPYI(MXY(9),2,MXY(5))
              CALL FMLN(MXY(5),M_LN_2PI)
              MBS2PI = MBASE
              NDG2PI = NDIG
              IF (ABS(MWK(START(M_LN_2PI)+2)) > 10) NDG2PI = 0
              NDIG = NDSV
          ENDIF
      ENDIF
      CALL FMSUB(M_LN_2PI,MXY(11),MXY(5))
      CALL FMCSDIVI(MXY(5),2,MXY(9))
      CALL FMCSADD_R1(MXY(10),MXY(9))
      CALL FMSUB_R1(MXY(10),MXY(12))
      CALL FMMPY(MXY(11),MXY(12),MXY(9))
      CALL FMCSADD_R1(MXY(10),MXY(9))

!             Now the log of gamma of the shifted argument has been computed.  Reverse the shifting.
!             The product MA*(MA+1)*...*(MA+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(13) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(13),MXY(6))
          CALL FMMPY(MXY(13),MXY(6),MXY(7))
          CALL FMSQR(MXY(6),MXY(8))
          CALL FMCSMPYI(MXY(7),6,MXY(12))
          CALL FMCSADD_R1(MXY(8),MXY(12))
          CALL FMCSMPYI(MXY(6),11,MXY(12))
          CALL FMCSADD_R1(MXY(8),MXY(12))
          CALL FMCSMPYI(MXY(13),6,MXY(12))
          CALL FMCSADD_R1(MXY(8),MXY(12))
          CALL FMEQ(MXY(8),MXY(11))
          CALL FMCSMPYI_R1(MXY(7),16)
          DO K = 0, LSHIFT-8, 4
             CALL FMCSADD_R1(MXY(8),MXY(7))
             K2 = 24*(2*K + 7)
             CALL FMCSMPYI(MXY(6),K2,MXY(12))
             CALL FMCSADD_R1(MXY(8),MXY(12))
             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMCSMPYI(MXY(13),K1,MXY(12))
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(13),K1,MXY(12))
                 CALL FMCSMPYI_R1(MXY(12),K)
                 CALL FMCSADD_R1(MXY(8),MXY(12))
                 K1 = 336*K + 632
                 CALL FMCSMPYI(MXY(13),K1,MXY(12))
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(8),K0)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 K0 = K*K + 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0)
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 CALL FMCSMPYI(MXY(12),K,MXY(9))
                 CALL FMCSMPYI_R1(MXY(9),K)
                 CALL FMCSADD_R1(MXY(8),MXY(9))
                 K0 = 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0)
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ENDIF
             CALL FMCSMPY_R1(MXY(11),MXY(8))
          ENDDO
          CALL FMLN(MXY(11),MXY(4))
          CALL FMSUB_R1(MXY(10),MXY(4))
      ENDIF

!             Use the reflection formula if MA was negative.

  180 IF (MAS < 0) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(13),MXY(6))
          CALL FMDIVI(MXY(6),2,MXY(7))
          CALL FMINT(MXY(7),MXY(2))
          CALL FMMPYI(MXY(2),2,MXY(8))
          KSIGN = -1
          IF (FMCOMP(MXY(6),'==',MXY(8))) KSIGN = 1
          CALL FMSUB(MXY(13),MXY(6),MXY(9))
          MWK(START(MXY(9))+1) = MWK(START(MXY(13))+1)
          CALL FMPI(MXY(11))
          CALL FMMPY_R1(MXY(11),MXY(9))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMSIN(MXY(11),MXY(3))
          MWK(START(MXY(3))) = KSIGN*MWK(START(MXY(3)))
          KRAD = KRSAVE
          CALL FMDIV_R2(MPISAV,MXY(3))
          CALL FMLN(MXY(3),MXY(4))
          CALL FMSUB_R2(MXY(4),MXY(10))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(13))
          KC_RETRY = 1
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  210 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNGM

      SUBROUTINE FMLNGM_C(NDIG_C,MBASE_C,C)

!  Initialize the constants used in the log gamma polynomial.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: C(0:196),NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      INTENT (INOUT) :: C,NDIG_C,MBASE_C
      INTEGER :: NDSAVE
      CHARACTER(220) :: ST

      NDSAVE = NDIG
      NDIG = MAX(NDIG,NINT(210*DLOGTN/DLOGMB))
      NDIG_C = NDIG
      MBASE_C = MBASE

      ST = " 6.931471805599453094172321214581765680755001343602552541206800094" //  &
           "933936219696947156058633269964186875420014810205706857336855202357" //  &
           "58130557032670751635075961930727570828371435190307038623891673471123350M-1"
      CALL FMST2M(ST,C(0))
      ST = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      CALL FMST2M(ST,C(1))
      ST = " 1.974670334241132182362075833230125946094749506033992188677791146" //  &
           "850037352016004369168144503098793526520021594811685953398143623435" //  &
           "02503893967551473165433138415866654683881302547625503436070027398405779M-1"
      CALL FMST2M(ST,C(2))
      ST = " 2.568563438653142846657938717048333025499543078016629393075718511" //  &
           "394606859543769672881862453644508604873305259842023980616399866622" //  &
           "44277379254656124026333871513139276497866889063971918407474980813205213M-2"
      CALL FMST2M(ST,C(3))
      ST = " 4.955808427784547879000924135291975693687737979681726920744053861" //  &
           "030154046742211639227408985424979308247703477010685603646017893642" //  &
           "51133732050087867905480177194587022770925733154718370654381840105887655M-3"
      CALL FMST2M(ST,C(4))
      ST = " 1.135551028673985266273097291406833611416183900382562394838535580" //  &
           "760717957256296912008621311426667275924068293311321808560192355831" //  &
           "19416836702214436017528973257267436070719672792473025777796267055355048M-3"
      CALL FMST2M(ST,C(5))
      ST = " 2.863436640748566190863216318200879836362483388089269737347773340" //  &
           "553638169929829804623296564225284217131985270424264778996969080555" //  &
           "16975632152723012109455292088401608926031282713256898710394755277209657M-4"
      CALL FMST2M(ST,C(6))
      ST = " 7.668248313183240568536426425667994283765150931981520246901951022" //  &
           "878261676510504944242413055018913842306480735586784104096820283433" //  &
           "36343308283287191406517315813519407491295119077092395710810995273468308M-5"
      CALL FMST2M(ST,C(7))
      ST = " 2.138827474304242233565481358155815737009883123125254113877533157" //  &
           "286907184360179941090379654649639056545605878533625329428744350917" //  &
           "29963707838227249505773740942777859121824166285189382035452217278554155M-5"
      CALL FMST2M(ST,C(8))
      ST = " 6.140869564690490872529914712451165067316821654306283177401767753" //  &
           "894821139822105599229903018842906378733862871895584602819330080270" //  &
           "01700768138875158345454772076408505044108823934202891440461609291305270M-6"
      CALL FMST2M(ST,C(9))
      ST = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066543779584M-6"
      CALL FMST2M(ST,C(10))
      ST = " 5.370321926785962456620478609033153278577962007833744674032818230" //  &
           "963452927104275083493657782390759550975407401180548454361763677022" //  &
           "25719502127813332819843513403345897099400330508911246024488125358988974M-7"
      CALL FMST2M(ST,C(11))
      ST = " 1.621606923373582198331706449725800346740381669503777534126777710" //  &
           "016401617427540869007126583916228785817454388595224584374431558565" //  &
           "62424003947302186656188945000933064454593249101343833268069567881424866M-7"
      CALL FMST2M(ST,C(12))
      ST = " 4.946423680685744244896356595351648270045350075731820789781699205" //  &
           "590998801613945328568871293350300180372347783056466467421940336962" //  &
           "37993051766799459115354359781619794227922798691721786471256812355243228M-8"
      CALL FMST2M(ST,C(13))
      ST = " 1.521277205034494703893608109526767726401208246782019680016091878" //  &
           "150165553006261855592657131910806289218694348060771816544039319519" //  &
           "70268151503584997891542218258262605500864512242956007183617857332741602M-8"
      CALL FMST2M(ST,C(14))
      ST = " 4.710545468032903448567376337505841863247123878500437995526222151" //  &
           "143756151971538155623134503232957797896283285550201985050591879362" //  &
           "14529603180002288823222154049517099193894892610640999441314930078235979M-9"
      CALL FMST2M(ST,C(15))
      ST = " 1.466896634491983285717977295126452336811904470697069075224299192" //  &
           "939247071986642850302895153896641951172329934777380990036068940704" //  &
           "92049327640255496401589822485890032872392277699930611719523121420745147M-9"
      CALL FMST2M(ST,C(16))
      ST = " 4.590062735154278588407978252478287205347213340644341084689962143" //  &
           "111930858436518669786421571299766271527706531603537599776303515851" //  &
           "07346286911988982005532291493494947163957826550954358278107733999478261M-10"
      CALL FMST2M(ST,C(17))
      ST = " 1.442221874911031367580345522072474831788307406190652461104238910" //  &
           "857027803132223315927216471971838450273509423200923289440756059767" //  &
           "68857423403274844425475990232160708382227977333807182882605816718263351M-10"
      CALL FMST2M(ST,C(18))
      ST = " 4.547809165468029773462079480806624058657045422294384456641178682" //  &
           "659691101645601195358296330035349908208769392426188702234370516180" //  &
           "56888377164494448967006811680025457321926050295945478985302205704218490M-11"
      CALL FMST2M(ST,C(19))
      ST = " 1.438587332730565760193417246729718970937052978750282449255687568" //  &
           "655719501289180489881937394774257940434077254947095313349728878573" //  &
           "86843008158160916187514601728862636178280076324418505631445853717950171M-11"
      CALL FMST2M(ST,C(20))
      ST = " 4.563265937212529367600208240284116509275473219057499398885563766" //  &
           "090388563517935169737964577745895815190180995118452252225828163120" //  &
           "99722426850021624306978846433211406278468453662456948824141382999031282M-12"
      CALL FMST2M(ST,C(21))
      ST = " 1.451073916840454711281216045224320082808166284993163778021566315" //  &
           "255587037332552553079272066121649499425851990060321384124955433677" //  &
           "67207993278060823840271886615031403999360286605743411932260491743002791M-12"
      CALL FMST2M(ST,C(22))
      ST = " 4.624528056444812082051687967994458694688921677653576433580975534" //  &
           "968450053554049283580808625060631085218986361103614972923204710045" //  &
           "87054803107018718005909662543849301887854984204280816281128477629296891M-13"
      CALL FMST2M(ST,C(23))
      ST = " 1.476781612022755183419973250511459966182209498276769571800718539" //  &
           "731445227020086180343751505787486916705816774093130509272233480605" //  &
           "44047487934404934553435264532664986314948239961478420907068538648968405M-13"
      CALL FMST2M(ST,C(24))
      ST = " 4.724507827870744254820277464047378923678173249594725356053537843" //  &
           "069856328276686251584801735153843799291487544822727471278651677292" //  &
           "03640042606725210618105758740751314683086483423378587429797730710810703M-14"
      CALL FMST2M(ST,C(25))
      ST = " 1.513978913019171763487041148572556877568791963643984495346043449" //  &
           "018701962532639151560210080671482947559816365848586253646530778070" //  &
           "18537123717716793256274213468254921216965019092087180696648092689644960M-14"
      CALL FMST2M(ST,C(26))
      ST = " 4.858996725976554852006318671090915519699354289999749614013042503" //  &
           "935984106218549522233834213516072290014623125419558504921174284920" //  &
           "78107160688407534237846157628451620609106027079137343790816294845243811M-15"
      CALL FMST2M(ST,C(27))
      ST = " 1.561654519392582828714942943686889037831993268563190525220343034" //  &
           "296584463347814354645233174014087011036651133377861482059644157593" //  &
           "18350440790655464091846868252936233878726656395056209922850191735361446M-15"
      CALL FMST2M(ST,C(28))
      ST = " 5.025614514474191003429454120021263907058345057163756484675204032" //  &
           "160626854269473972760278335161149373855516115547324556053250680761" //  &
           "35960353957624688528998376864715123324194768194244608331227956016708835M-16"
      CALL FMST2M(ST,C(29))
      ST = " 1.619268063222415588245007073271189318378938728336204453480653557" //  &
           "646832121167874868009309695437374462682430335955717169955384406157" //  &
           "35461655626485084754177259606520323581270018242949002547200222070367875M-16"
      CALL FMST2M(ST,C(30))
      ST = " 5.223211739191891688145554861633126404312733249590231268939276354" //  &
           "483256718224458681957003067572062210319658187678206505904762786890" //  &
           "39036962584739426283467796928036615339321696596679043636072535930177735M-17"
      CALL FMST2M(ST,C(31))
      ST = " 1.686605565375918423742481404695259319639157222117507057462225591" //  &
           "850533083720983505743619854637504171953994487105802289063236646168" //  &
           "31565771482245546699030298377683203899275714959867483319947682463166471M-17"
      CALL FMST2M(ST,C(32))
      ST = " 5.451517284342611284349867604595522641598896765349022422637246200" //  &
           "744471171937423465939660935482207447703449379192989322923063888266" //  &
           "31229372543901089934035916918836653287495719335136501890625959613216773M-18"
      CALL FMST2M(ST,C(33))
      ST = " 1.763692929460761010585031266299209488371094586913873180122443276" //  &
           "358212007822366334544290589814884405499150265809186554929224793099" //  &
           "67159580614375385516830687382686358909934655641565142758100304193688125M-18"
      CALL FMST2M(ST,C(34))
      ST = " 5.710924940930289429222525846887709139266580644631501378754425400" //  &
           "402344096734033498368417722870024289649356569956325790061028789490" //  &
           "90201209337135311180824855625236387835485476090642686407138148182122938M-19"
      CALL FMST2M(ST,C(35))
      ST = " 1.850743092341469168679255116939946915034455019205428394047707184" //  &
           "730616709166372869327273711967997594444383081358747754694208065117" //  &
           "59243078812287887751986055564202797220696526499221359781019466183552083M-19"
      CALL FMST2M(ST,C(36))
      ST = " 6.002362311111352855438751511526624123122881372177829574698482082" //  &
           "268472189497794035844163044963208202280717860883655584808569201908" //  &
           "84840540664364095292197489013673097320200190188150543497148096517991518M-20"
      CALL FMST2M(ST,C(37))
      ST = " 1.948123521680466000278613877664857969433940710389346300112405920" //  &
           "570813255255307791273062459813736293577657819726099571791897412896" //  &
           "04499052083706223596278073126974722712855926508631000226750654451336437M-20"
      CALL FMST2M(ST,C(38))
      ST = " 6.327210499275762922454617564886905374837540270134647521961777337" //  &
           "241208973850468966202699863294902233722101674486074157046009900783" //  &
           "94943168708628546063295850691161365924829349560770067069849204243333875M-21"
      CALL FMST2M(ST,C(39))
      ST = " 2.056336517258456819404872718846500024771970712636992752800634217" //  &
           "390177588265180513218328462256818578504975537617618012477658735253" //  &
           "91357901005319898451317799466679533736509835947206121997945730419581125M-21"
      CALL FMST2M(ST,C(40))
      ST = " 6.687256410663997968707038300952324368643567824691228269512829884" //  &
           "600241200120276396209386234811912763595929600746527477568692380093" //  &
           "65846941054535500737409129245379236794232295378392955072876104303576437M-22"
      CALL FMST2M(ST,C(41))
      ST = " 2.176007902867600569564968838424519571170445852508011400529276121" //  &
           "985778848606677081067574991228552820893084306450020295730062213612" //  &
           "47319852047491615671942139635029927212587004293525094112235574131058548M-22"
      CALL FMST2M(ST,C(42))
      ST = " 7.084666872547745583697885218008349498259999765144828626416539742" //  &
           "112817790036483006355449086393842354631309401157315763399808881211" //  &
           "63034428362049804231045013084677403365104232875460124915055150115352532M-23"
      CALL FMST2M(ST,C(43))
      ST = " 2.307881457325186109702251558024026338622462538196464637417250145" //  &
           "271014677258724350821337105472668901649544195158107332539530013289" //  &
           "58690754615380156771062458199324618311119940721724411263802909784747175M-23"
      CALL FMST2M(ST,C(44))
      ST = " 7.521978024882350363251147127637517006885196169534728483482110729" //  &
           "767330760893859561440994301232670866451144204592673539313561020703" //  &
           "16229680624073031879503528876975581601231458676853213367966509358616500M-24"
      CALL FMST2M(ST,C(45))
      ST = " 2.452817457661126560656022558232578383346781683732614004543641047" //  &
           "950608697083659342320485224577786541964544409466877827518882696166" //  &
           "77785583812635059733861275531662340097681814492066607106278651398864552M-24"
      CALL FMST2M(ST,C(46))
      ST = " 8.002095926418321660462882983562136934827167736984869734245484961" //  &
           "990362339894468819446499270621544724743989273983343985659243797090" //  &
           "02617723679997529884675116233201816776147675793642923747702696525736417M-25"
      CALL FMST2M(ST,C(47))
      ST = " 2.611794321654760040868482915030344896471378127607902926579083608" //  &
           "600355795254414772701179436107007717915331779124504018381582369712" //  &
           "35303338971473297210813756554582658474866145972030534849911654352767572M-25"
      CALL FMST2M(ST,C(48))
      ST = " 8.528305842439874174397891979909201174136636691345390271985961340" //  &
           "951635472717713994160270983358301811012414732109357429143927205677" //  &
           "24451493207732247380061110874133984404716199859823728402868897884262789M-26"
      CALL FMST2M(ST,C(49))
      ST = " 2.785912715941407608332964765121774292928933289953979801676819715" //  &
           "042211815722358756877838540023159292634878096952517082899902453482" //  &
           "75453420374439979087786662261117071847545271472089893478013180932399900M-26"
      CALL FMST2M(ST,C(50))
      ST = " 9.104288632359302486087921738156084451459177031330022615977426375" //  &
           "389281113948847333526780396722062239770555955153203912544147152689" //  &
           "10635505098052873178484650793531962248685195239569728214014565219560910M-27"
      CALL FMST2M(ST,C(51))
      ST = " 2.976401736830878380813487190839719864305643062243346972314080928" //  &
           "571659774700309771395429511816849731798335554291299072632159561785" //  &
           "13853498257646786277128193242849488156599291079190249617494763928122532M-27"
      CALL FMST2M(ST,C(52))
      ST = " 9.734143269753073619444573395909866046087281775327043563820191216" //  &
           "592074666762884461637185638436344417629043795119832288445119716594" //  &
           "54681757554722607199255640890946515559342596226071714786376672991314824M-28"
      CALL FMST2M(ST,C(53))
      ST = " 3.184626928899218981583942072541398262319779552845939844429551688" //  &
           "572650417481499150961066174605543822869303332888433674715027707880" //  &
           "04490731942311456494319892555319423931924782646792891555889559629511546M-28"
      CALL FMST2M(ST,C(54))
      ST = " 1.042241493677369606594579977699800680670958579629702706075164525" //  &
           "911994152904008645633144958538688068689955477642378460321912420061" //  &
           "44713093711611925694102923080704525452321573189336778639403115171327402M-28"
      CALL FMST2M(ST,C(55))
      ST = " 3.412100013470891170294585716908258368140834550044525411190398041" //  &
           "104754921079862028936399162559763428726672165337980689582820113040" //  &
           "13416198464826440959995204574451765227502181269455928284526174312187664M-29"
      CALL FMST2M(ST,C(56))
      ST = " 1.117412841751556843302074248615568735696721287113186281328504084" //  &
           "312562222725968138902580374246217663276066641488490501477225640253" //  &
           "42579986440180416098324496187285052304475776686406646945052809161071102M-29"
      CALL FMST2M(ST,C(57))
      ST = " 3.660490274490043678026226644620183224238038689661082986523077162" //  &
           "981414308819425679643969633533180026092880760915904811622562886923" //  &
           "84487396264603185012812742600008480127678888705848700357490206046685979M-30"
      CALL FMST2M(ST,C(58))
      ST = " 1.199482671814381161791341850793296252666044625258418739613110049" //  &
           "104551626086380287997089537812232630867438710978470875637869385419" //  &
           "01607003246251775392139826953129400440619709892748008039595593739769704M-30"
      CALL FMST2M(ST,C(59))
      ST = " 3.931637604707211006390296608348190956772148951812063256727344243" //  &
           "900822542438555764328768554173091304365555553142603137727525766441" //  &
           "84525659723982712681986023184076666876842449810082867584381453291908627M-31"
      CALL FMST2M(ST,C(60))
      ST = " 1.289061499462497744696303533633690434193534414239284689686070597" //  &
           "676814880055275326028949838642762828605994974529472129232550363697" //  &
           "60950396038294052993668381573708577221742561680239596349647149571718672M-31"
      CALL FMST2M(ST,C(61))
      ST = " 4.227567257903962351790508597715893632841769835136110706800940837" //  &
           "829652461572432184043919015812076564236545988931174492991859433101" //  &
           "25778000859246543191517786955778130308647637177926547762610318839215217M-32"
      CALL FMST2M(ST,C(62))
      ST = " 1.386820999018780266062944049316369528834057757206382128765313047" //  &
           "270244006158501294298057326510552601141951742736581362353221200763" //  &
           "47128739854666116108186922912060771673278920840786086509429347218298547M-32"
      CALL FMST2M(ST,C(63))
      ST = " 4.550506387724437506082055927268146785006102873281969302732936243" //  &
           "298895572505202160358438794407807710437237187496655791039130216893" //  &
           "87511924875421792179416180376854086009363053011270507639350841775560466M-33"
      CALL FMST2M(ST,C(64))
      ST = " 1.493499528613739965372638972965391238482547633295265869054828367" //  &
           "829416466398480374395870941759362578697731625235707888992530344564" //  &
           "64118616870137110287959590352137938213456367349222761768780656871967062M-33"
      CALL FMST2M(ST,C(65))
      ST = " 4.902902483647573629190444872668433339026722693539103782664050983" //  &
           "225694025564768841074155141457059295428474046880275907189034299237" //  &
           "32944103681204447082846734232378539796234753927604216121433267289535418M-34"
      CALL FMST2M(ST,C(66))
      ST = " 1.609908275928169570082165607481456370083831087969406562557256167" //  &
           "364188362846846549047875066952892162692919458759129310778349489953" //  &
           "22770448873819282967830858947780630728913545194644474976588962028982890M-34"
      CALL FMST2M(ST,C(67))
      ST = " 5.287443841783967253336743861164853484418810262590989794938834387" //  &
           "073299404536655202675616502143848847208164288382903044431016858516" //  &
           "20009538336266282148044005430788026679223320414557498337146361309107021M-35"
      CALL FMST2M(ST,C(68))
      ST = " 1.736938072243109805185530725881959995611305822994512775248040487" //  &
           "238177289693647144646295113799732566680032754548503116064306224752" //  &
           "78198414114124592660116717229603109916607439068859873993478598764324167M-35"
      CALL FMST2M(ST,C(69))
      ST = " 5.707082233953717693925573957068774870416069447922801957662691273" //  &
           "270987710445603289113054181853887859043710418144298938936434365836" //  &
           "22910905014974542359781276508954019188261527426571788239315967868621528M-36"
      CALL FMST2M(ST,C(70))
      ST = " 1.875566930504197126372674019737550486762741857855257836323427280" //  &
           "225964790637523226088657691476666774290875901414134481518247331060" //  &
           "71906874659900660807946217987043810912477339050139457949133330400430348M-36"
      CALL FMST2M(ST,C(71))
      ST = " 6.165057963933168318023358517808802281756068067015463002715232153" //  &
           "371564234012532194529099415076087246371078651694171463516031915534" //  &
           "01898954460353148685542639895937235904606585101085654511370630295486436M-37"
      CALL FMST2M(ST,C(72))
      ST = " 2.026868371192165401197185010283739193718905421948964225522412850" //  &
           "262737204848695188406921800082238582127540011428039129914658458542" //  &
           "37634642867581786423872725394317163245280102057930986208119247853710652M-37"
      CALL FMST2M(ST,C(73))
      ST = " 6.664927525630725280315186707639828112376671188813408419458083523" //  &
           "173661970136566062651079390703015968881216092673504456192083877599" //  &
           "15804352132821230683566017780795660498858012885579266098347848714173428M-38"
      CALL FMST2M(ST,C(74))
      ST = " 2.192020608118261066539037933528189571558724587838583580744609163" //  &
           "952034074131032109073883254528947795371825396404707207594960566130" //  &
           "08388120561413633077336889145268058079508281341166298919160705693687869M-38"
      CALL FMST2M(ST,C(75))
      ST = " 7.210594104883918757684569353059178987815466143353338512729476387" //  &
           "590176795023385801954403484227849398454243048187188857331730164109" //  &
           "61130821394037069074892323683471141755158288684895958165035966426280590M-39"
      CALL FMST2M(ST,C(76))
      ST = " 2.372316675010334396327093341566291045560598544381746314200798914" //  &
           "361335388290174563770200693760939384221618459565684611293948349762" //  &
           "99760715272696457406804603245507893941691344795060823654575302742922341M-39"
      CALL FMST2M(ST,C(77))
      ST = " 7.806341195078978788896796569353844545546683670636287097360101000" //  &
           "674819867286255396945996712341079701193140494784764939652507657527" //  &
           "10776509577749635871445825212032538401033636476215858432876024174293608M-40"
      CALL FMST2M(ST,C(78))
      ST = " 2.569175583075068496597802624641121843008905917144485747977702000" //  &
           "084716234785945953181138133105853830584529894491272387561559175918" //  &
           "06056635101515773378678277304459406269213364274389438074596955963853941M-40"
      CALL FMST2M(ST,C(79))
      ST = " 8.456869627337005555483543945000411129981141780087868584229158532" //  &
           "975156474362982393176600086105992624536940685475408780825634971862" //  &
           "82928746682884903136048829786952212289839035702247341347744500864695940M-41"
      CALL FMST2M(ST,C(80))
      ST = " 2.784154609752488682347830682317399839437808496760216533359957844" //  &
           "108419936184123983123382869988781032193042150722634481595940148079" //  &
           "47471887024692990616525022991390619756225607915282611367773077871045722M-41"
      CALL FMST2M(ST,C(81))
      ST = " 9.167338349011185351110270732877594395344097568799016206592150045" //  &
           "211148681681966966935859814202597754161577071431235188923674247559" //  &
           "93097788462831296346214350780525347998671878506396254329112437194116937M-42"
      CALL FMST2M(ST,C(82))
      ST = " 3.018962829751912207860422524685002365325324396585948666388970238" //  &
           "468900826307200635678324473325455973126327818463443937367696783407" //  &
           "31216822788529908321030119923263022821575928202721712476375757572174960M-42"
      CALL FMST2M(ST,C(83))
      ST = " 9.943409320108569385064969631771335447816687861933253786118347289" //  &
           "942417796521205611575152291429262471820315825809582098019324351274" //  &
           "19736007449168383766428225696036997597572676990996005739875078089934258M-43"
      CALL FMST2M(ST,C(84))
      ST = " 3.275476011303678103893551709440913333007415558028940493123054436" //  &
           "102576111138063293549771997379461070822607505834700351586923416924" //  &
           "36130515829060972565436000080016114747837549174742969323583514548979337M-43"
      CALL FMST2M(ST,C(85))
      ST = " 1.079129693640085894851434181915227380977317782277815512357487683" //  &
           "235378082315776477576402633427103515916665364561427248912637998286" //  &
           "84497336603622824659763899982809691142662878118295489894583048485526949M-43"
      CALL FMST2M(ST,C(86))
      ST = " 3.555753013510719060083393999120543994047683529242126292544972222" //  &
           "356576357296720319402739291176562890757829588273748247638519856640" //  &
           "67480610895714757344602846046498898788815371622608783151322531494411842M-44"
      CALL FMST2M(ST,C(87))
      ST = " 1.171782243084804960250703836375832017652851729860152530408648875" //  &
           "579920584019031061094655011368498851035103058003948560022564877979" //  &
           "17046691205570131651535433024120306105982182247803947139577240760760240M-44"
      CALL FMST2M(ST,C(88))
      ST = " 3.862053834876472821052586382551496075098455346933359196501245526" //  &
           "180729685642432233621061970152222441386142907366726076208958805328" //  &
           "70627198276478969445218445704378235779473329084661077747371015095013204M-45"
      CALL FMST2M(ST,C(89))
      ST = " 1.273047375197605743053349834215496117644063043473174035166207181" //  &
           "768692059655110422250456339545311971995535730478050915338536261677" //  &
           "65444071293612365602178273688293636174364964871538328370023554265881805M-45"
      CALL FMST2M(ST,C(90))
      ST = " 4.196859478667449972989243439715623246016537566511261080114559563" //  &
           "758135987775813449384022624930316510736358259866183402630340459291" //  &
           "72668526906989173105067164347823743598675043393233726870416684054894389M-46"
      CALL FMST2M(ST,C(91))
      ST = " 1.383747146950471434825293091024083280747013661478053604841911598" //  &
           "022310276318757265593640560735257184999994184693906229160627176389" //  &
           "15615636692838842344470182112269725385554047172321124664394879685510285M-46"
      CALL FMST2M(ST,C(92))
      ST = " 4.562893817897541724781950430442496378260377512288497109803666040" //  &
           "621854629198431249084998659248405128970881921614143709856471314566" //  &
           "71187340235712918767373708561614114398918238461996856137728111624669887M-47"
      CALL FMST2M(ST,C(93))
      ST = " 1.504784131433391793257248428485220036318516611757628814861273953" //  &
           "241786001999746507693533747202375916340889614020197821617964401281" //  &
           "09223232430673952549932990159444752780504141754928914375319317506618075M-47"
      CALL FMST2M(ST,C(94))
      ST = " 4.963147661567547539987958807734897162902530398116312148944960055" //  &
           "796268377992054321453624007551095855206124470724586679336263613115" //  &
           "89091300344790164050318056261092913116282166570730942288235067198317928M-48"
      CALL FMST2M(ST,C(95))
      ST = " 1.637149402252630927456890226306016168030553715912510338166421018" //  &
           "082250171874970269061229738963393420354696075864382273796383465054" //  &
           "54500820509537840793087307985392209620656037379007014938893681782187286M-48"
      CALL FMST2M(ST,C(96))
      ST = " 5.400905244543393186874620589431418037639831941879628434368248998" //  &
           "722906347036053715166862260092049668825631280975790017953688626636" //  &
           "15617148734065300820447033765217546328421226646834925099741473350545005M-49"
      CALL FMST2M(ST,C(97))
      ST = " 1.781931322178944118647377674747852837095476406297808108639777839" //  &
           "710695191748931947375083891115191186633327477558489708276330078077" //  &
           "84355945700557484952518727190790584478520941307748997078811897348262566M-49"
      CALL FMST2M(ST,C(98))
      ST = " 5.879773386313522948360905422632431077145168395771420120384935880" //  &
           "807587039058575601777312600437920559716301465154041152414856698220" //  &
           "03215044402130085493835602372831521053966369492752843371900098859590805M-50"
      CALL FMST2M(ST,C(99))
      ST = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409600080862034828483316076995017274377332356098893076821893973234" //  &
           "40382503373462356947628021148992374363794778068565614630007284818985556M-50"
      CALL FMST2M(ST,C(100))
      ST = " 6.403713589053133873710962618711106281414140108122214547412024301" //  &
           "692917083153216025874647060197659674432573844849077628829246217574" //  &
           "60249742706649007645817489620506941120553080709097100788465375868770515M-51"
      CALL FMST2M(ST,C(101))
      ST = " 2.113644027759240612416047225977851974737748960538792675174058961" //  &
           "161021976645079782965719680309463063367873086114357869089879642560" //  &
           "91741774488093918815994311848793042306225840389086585033999559719325383M-51"
      CALL FMST2M(ST,C(102))
      ST = " 6.977077373185528123141201643198765846940778946562652437177053180" //  &
           "068202610894634761485494475059094517798144344611412525007119040744" //  &
           "47619138364742657951321893292966244857904586187576743960389378098756527M-52"
      CALL FMST2M(ST,C(103))
      ST = " 2.303330030250272718045226178470266630636882414669936525013604526" //  &
           "663877295122333165527547705932002051525319167095677157791507288736" //  &
           "64026571366295683502084852088545059435402597033343652161501470364354290M-52"
      CALL FMST2M(ST,C(104))
      ST = " 7.604645179238802714709378571216485567328230281028063584140295724" //  &
           "376585957946481904384646230934323963536666254241381678030728396763" //  &
           "58178737195689600607109967321748886837389095954530241223910865091320330M-53"
      CALL FMST2M(ST,C(105))
      ST = " 2.510967747861821044453112929896090858886255004999542279673792434" //  &
           "537208309423086735805390141224743694821441092754412288490320556507" //  &
           "90129078122051056660926795028903236517945321893911606739679056323908271M-53"
      CALL FMST2M(ST,C(106))
      ST = " 8.291669198546705061835867356103780154660596199979498029660459478" //  &
           "188005146704679300246430992623307755626947749069085299081605791921" //  &
           "74019998848391467377542111031322996337770209654839668772234104877607677M-54"
      CALL FMST2M(ST,C(107))
      ST = " 2.738298161248419586570035179837181952253572874107137240705415238" //  &
           "006265247194645939919863261646299211192029639655806078478918931977" //  &
           "00593190887265237361465699889511989159926295238433577049420127008639310M-54"
      CALL FMST2M(ST,C(108))
      ST = " 9.043920532563515029285236381202044755606494352793597664587001938" //  &
           "974036674170391738386361814188362066318933595609565234700634164118" //  &
           "70487847122956051574723330382189769818956900012640799709823774379723508M-55"
      CALL FMST2M(ST,C(109))
      ST = " 2.987234357725506677158331533521097034607039220763832901730464971" //  &
           "787758443274701147417241273125203557371693807601776736455273977366" //  &
           "05803089099448475489215616434095538698506543339535511526713482057801648M-55"
      CALL FMST2M(ST,C(110))
      ST = " 9.867741121615743267416100354228158234050959334204884456346592478" //  &
           "319239204688512319808683885900238794688432245788378036339502910311" //  &
           "95256267366461853050971201508370739481479021507935296576188223198846781M-56"
      CALL FMST2M(ST,C(111))
      ST = " 3.259878763390904147253084369202388245824453621447959285540458582" //  &
           "736012876275248713545534462435398177897630905297446122213135317168" //  &
           "82679622090783961983706156224847005117892642811444666243882001638133683M-56"
      CALL FMST2M(ST,C(112))
      ST = " 1.077010092919706009412412261729007614456466446787757717767031010" //  &
           "139026034411384632610387807051427675075586800080476142293720773922" //  &
           "20272670887152593395631417854201652294534598158204732976231392133784649M-56"
      CALL FMST2M(ST,C(113))
      ST = " 3.558542119880893194099946299932858465278352616190909402621150713" //  &
           "569585013772896155460681917876143100438779403865861290242704606012" //  &
           "88545096496889803741553260243082158570103416935736970008787448980973697M-57"
      CALL FMST2M(ST,C(114))
      ST = " 1.175866091786728245112848768043708292858352425382756439383320272" //  &
           "578862130652141603853077265569964741389836105657992359851950676535" //  &
           "04338748169984545024264075261487170842373741152762109550508117751868574M-57"
      CALL FMST2M(ST,C(115))
      ST = " 3.885764383777977106238860501037171757872128590510931610888692650" //  &
           "910285334868201439319749230933970529786352570062128138073985716014" //  &
           "24775116761936632328170508559558303761107738144547614997375397249406443M-58"
      CALL FMST2M(ST,C(116))
      ST = " 1.284184240792720746713802455067655929838349505783919451560002320" //  &
           "126603715783906155689196669126320213369826150934215436793861556561" //  &
           "85972584789613262065820990433273679374866590546774541475968702317884481M-58"
      CALL FMST2M(ST,C(117))
      ST = " 4.244337744992888045444183568112374868793650501308024498979691533" //  &
           "890762987246535790550234061933625766554201413681894303054318079987" //  &
           "15016824304537959514257416420938167100044999559848904364273216745412168M-59"
      CALL FMST2M(ST,C(118))
      ST = " 1.402890347084483369665088764818551961487912000082962187928218261" //  &
           "785089551297393342668713450909249794752403435631477836303274921114" //  &
           "55362046946784217832779503423966063510800253866244156993968505509787734M-59"
      CALL FMST2M(ST,C(119))
      ST = " 4.637331980640374010893092224461382977846892054658359797965131441" //  &
           "456865261185257586124099243621668370219467668437596174204742705530" //  &
           "83668639386769597559944266590300361763651777592096905886759195912398458M-60"
      CALL FMST2M(ST,C(120))
      ST = " 1.533002307649710027030813938667476629444482989777771349009392774" //  &
           "898001472950267391452028201567335345539750749325735733749863033002" //  &
           "69548753895579308292780126786018722213349444264135999363029954583214006M-60"
      CALL FMST2M(ST,C(121))
      ST = " 5.068122383213521254015903956436646089688648450514341540538884175" //  &
           "869469050644753957457320055403310802554634158264858859825705672789" //  &
           "91662731199394270951038339532656379827609414997054764442302975300731162M-61"
      CALL FMST2M(ST,C(122))
      ST = " 1.675639378731841475760363897846833007051598415558153712467179977" //  &
           "432925958506220080221518370999946501032024092613108461163906099341" //  &
           "82913060234132996850622927932164528031237880466865308048851412708423659M-61"
      CALL FMST2M(ST,C(123))
      ST = " 5.540420526452055898116485439538895779663375849440317942175183295" //  &
           "232404269513749797742436944684450241469393462030971608777003451754" //  &
           "24373370189591105970695273793446260615786377827169998532420885870021362M-62"
      CALL FMST2M(ST,C(124))
      ST = " 1.832032387413479669586574511502151686557921294324566012744100766" //  &
           "650543443902590363016386993218294974037346220641170740186656299364" //  &
           "35042400328594920807120027126914313294894904628053322733053994091135028M-62"
      CALL FMST2M(ST,C(125))
      ST = " 6.058308159436109652922013909249826504043342021872382519752917607" //  &
           "688622870375413804432273155114051562335231336139713200850863559312" //  &
           "92844948695425942146384859065918295663347978412467638683301971137894309M-63"
      CALL FMST2M(ST,C(126))
      ST = " 2.003534981860760581951442341610686092565547269730489837317963845" //  &
           "620455952950683642101005961045434369116586359058385158147557980542" //  &
           "11638367930496346396938524050401454422736023568038546321742832881166705M-63"
      CALL FMST2M(ST,C(127))
      ST = " 6.626274549383244408116266205294449505997555094384610044245319246" //  &
           "030550314415978028317676220529142615194623162680155029534077714720" //  &
           "63797428182476797631017411639144206566456794143210250637764789933866701M-64"
      CALL FMST2M(ST,C(128))
      ST = " 2.191636026669393443536074125395262735461777636080096892966692835" //  &
           "413006758477349117295402033106637857465621733449271837481434101507" //  &
           "59193133722553066298412025354918228064474978225340425161474540247412694M-64"
      CALL FMST2M(ST,C(129))
      ST = " 7.249257626675685867142261929211249822372411007081385395432760399" //  &
           "456066369908496028419563900512609131853389393280859633882497500591" //  &
           "28369747912197909028518904445517467819162688494876358555633787825066496M-65"
      CALL FMST2M(ST,C(130))
      ST = " 2.397973260732415138001223113122005679063725787264243397335901198" //  &
           "698321759116583811702053382300628630291425464911847398771216167493" //  &
           "18664813035306053986440746004247939745287869514463237143921611339050020M-65"
      CALL FMST2M(ST,C(131))
      ST = " 7.932689322119858073349921363235515368474949336836316506068072766" //  &
           "546624999168511473276482943408448126386413211956579156398290157039" //  &
           "88529011287347733351088257288781160869062308105566110665892110886142277M-66"
      CALL FMST2M(ST,C(132))
      ST = " 2.624348347167471822677772594888450230485642320545658876475286310" //  &
           "055771115343647866370773378641890749683248791810064619124781313040" //  &
           "39655556535083837498441324798836325222767712349195699260834872702802847M-66"
      CALL FMST2M(ST,C(133))
      ST = " 8.682545526698351997704083743124967023750577000605836108664866495" //  &
           "160128302689923574758622135053769717872441667362682928425542104432" //  &
           "66558278030150559101531475636719213636150787481043024038745922498650758M-67"
      CALL FMST2M(ST,C(134))
      ST = " 2.872743458216244845484563580154599626121124250656149184804291244" //  &
           "427536302457588668570923419780410649470498203175250876036620935134" //  &
           "64093415505201626499567870169234200516491544807537627932184985980888123M-67"
      CALL FMST2M(ST,C(135))
      ST = " 9.505401148509633647613758343551012792444980481501235466486933914" //  &
           "265907192633387738944843898328544931131135589195243791819300008378" //  &
           "30106163188879275241944204168059306729141838253133216063222884137562944M-68"
      CALL FMST2M(ST,C(136))
      ST = " 3.145339552791508936206896052221534466211147212254477273131941831" //  &
           "512277630670890754387204205624927221141107680833883854535942453092" //  &
           "60656013674364311521617359444957869733091866905428746679446531471773156M-68"
      CALL FMST2M(ST,C(137))
      ST = " 1.040849079063856819895496485119313778206922325391046796592400903" //  &
           "438704272609812766874547219070728506140021601572906667448239089200" //  &
           "17410157182972609752570220147431398012450147044399178635448118006623721M-68"
      CALL FMST2M(ST,C(138))
      ST = " 3.444536520642979399033002670688986667656937918697573314979061458" //  &
           "919964194677753822933252127653285396401597050249715424969440622451" //  &
           "73896561346967424455299327210221686160915541794905027119226479284135693M-69"
      CALL FMST2M(ST,C(139))
      ST = " 1.139977562784224133216265743521281955028156700765266508712800967" //  &
           "848831883748374530246175200161064830753252846881090666971108606926" //  &
           "84608508079113604819022125345471848395222113457719457394701080327610407M-69"
      CALL FMST2M(ST,C(140))
      ST = " 3.772975385101451028879155185726947819831206176127486435982734889" //  &
           "252802708561571080135558366656253315506022065599884895931599609988" //  &
           "98731864477490133149597217959601291802546927566215903357984266276909864M-70"
      CALL FMST2M(ST,C(141))
      ST = " 1.248801711970198579225912046586232268562301776030667048611621632" //  &
           "465628194502888533349817467748088996697006070450714611279370044918" //  &
           "58919189486279287758063253685579639080251285807174486835285307209688606M-70"
      CALL FMST2M(ST,C(142))
      ST = " 4.133562776218372917707434109108607724393370061767622907143777544" //  &
           "878888798728408345872714164317266154909605719593487267350335578853" //  &
           "93934162223974482538311480054078977999291506457599828857537063130739588M-71"
      CALL FMST2M(ST,C(143))
      ST = " 1.368285826387100294053441225148146980381219160778152569563356532" //  &
           "725964967014895839699806485363534911338607141236453063094587484467" //  &
           "66893839721308893253877636532577439328086482952402541207429714733339152M-71"
      CALL FMST2M(ST,C(144))
      ST = " 4.529497908040056144676469409188309794321421988959637669575342522" //  &
           "116514782664298860106021153887341542873949848678983271520138033675" //  &
           "79495262187662834453100157981375055331539396277574179995789688030466410M-72"
      CALL FMST2M(ST,C(145))
      ST = " 1.499491316588603061306884181776653655545748070661401693040695069" //  &
           "053696590521220167504120163356893714569898088385033607285458815124" //  &
           "35872442007725124320485376254435248066997500475451183595538404386947583M-72"
      CALL FMST2M(ST,C(146))
      ST = " 4.964302317957733490235530469745361589786652164074076392491530822" //  &
           "224428024784809035798407669056637309772933378074926314581475254129" //  &
           "86616192319821312175154821971972127073013580628971532023157018109185362M-73"
      CALL FMST2M(ST,C(147))
      ST = " 1.643586578242763114833507846160154608374622266203265530676336751" //  &
           "694818277497961440503117616606491252858317008970780154993421364483" //  &
           "78099010504715300393033107665724003113140293042459780949957368683890959M-73"
      CALL FMST2M(ST,C(148))
      ST = " 5.441852652794830894311470706477538221849565053218214215349180811" //  &
           "064294636030553844028448630827867613349267037250477900533924480506" //  &
           "82460851565237813605665759673888889710736177209599734575799006709861746M-74"
      CALL FMST2M(ST,C(149))
      ST = " 1.801857878369844007118484883880761798414766692597217574900046197" //  &
           "360262152730609587228705384643316107409543482294232641569660175011" //  &
           "79519154781224338457932814908298988696375455365226741142441036489254992M-74"
      CALL FMST2M(ST,C(150))
      ST = " 5.966416815794185453763830530254737531064047428340471319398688069" //  &
           "007552470288020366752010161084016011730287854271568912859552337203" //  &
           "41453128747443716412531087761908717466819377449540627696187031359721010M-75"
      CALL FMST2M(ST,C(151))
      ST = " 1.975721357861671060279948825620105307975444162740595055137362881" //  &
           "848246417197234999961571849669754470375412457219647332906833168922" //  &
           "68071772240997929407621098946132582262214118221958928604276333611006417M-75"
      CALL FMST2M(ST,C(152))
      ST = " 6.542693821241263641717538449532346497940622472878710087928587547" //  &
           "135890790293782933631752384033436259896798958027902059478261401316" //  &
           "51898760968041471004067759299223993845873964885693255185054469449588983M-76"
      CALL FMST2M(ST,C(153))
      ST = " 2.166736265476002894293516585134968365492470343594290484160425853" //  &
           "634757103189631345447367869704134537187600769397997799583921963715" //  &
           "66991272921221434244459511112119776440312273606272563588060032932425347M-76"
      CALL FMST2M(ST,C(154))
      ST = " 7.175857739425902058446366213267163717870002184056285139492810907" //  &
           "165151388326241994224874557956711286862577806517065215553936524682" //  &
           "13250466673505382651861797375923534026910443196181011966541606084919661M-77"
      CALL FMST2M(ST,C(155))
      ST = " 2.376619550450886365485623751880291284047099214872959375092451724" //  &
           "342950586001550942436415678973426556922327249108654045209317268184" //  &
           "82082947451080863768578126711240615665895962605984771627264126442044223M-77"
      CALL FMST2M(ST,C(156))
      ST = " 7.871606154359623630068573317612764902762392638995019862408631291" //  &
           "008061939353640535233024537980362873819209185759931590349366135182" //  &
           "14586054502659862300174333186280592070419277216786077915707312111770211M-78"
      CALL FMST2M(ST,C(157))
      ST = " 2.607261954081141160150797999367222244498208263011867403220673096" //  &
           "800582313576057737826578818707489920864730296871775420774049041364" //  &
           "79431809641123667403151516016216413258555378265536018764789936965838617M-78"
      CALL FMST2M(ST,C(158))
      ST = " 8.636213600520341807753750476732474442820999819309686673192125811" //  &
           "444182648267187160168499080611902341484327275294303024770270222135" //  &
           "59223769662625003083305590998863860730206646251762971580585644914132026M-79"
      CALL FMST2M(ST,C(159))
      ST = " 2.860745755172363223898311967180521130986380848162555027528393662" //  &
           "915983444061966784564310775020004680613450195420353857249494047775" //  &
           "73818249551580545509645629320363387364925214204842915131007525800466880M-79"
      CALL FMST2M(ST,C(160))
      ST = " 9.476590493324598214557576012349336522703693594124571054279111616" //  &
           "798531592192686914431167230715058815630334239433475110837262090138" //  &
           "33301645943249512127076707890530532222551337127599066189782985037412169M-80"
      CALL FMST2M(ST,C(161))
      ST = " 3.139364340381194056746408425980351704553046571903970795447364975" //  &
           "882887158738580119004810652625014397096678884159435971472598704137" //  &
           "54339572525201214956186891250608510839418632104354221549889413573604846M-80"
      CALL FMST2M(ST,C(162))
      ST = " 1.040034812150826026710373679719002963399053176200107466780745572" //  &
           "000065388516270021753222010998681619656807884101412895225381983273" //  &
           "03585371769586543699202508103518904235084186177627200599704020839402387M-80"
      CALL FMST2M(ST,C(163))
      ST = " 3.445643788223265129236923220146442325334098948153988879546081638" //  &
           "282932221486522368247949883425191269877715114051526159278376683546" //  &
           "54478379087683377717562788666572331232941361970188301510421846831598762M-81"
      CALL FMST2M(ST,C(164))
      ST = " 1.141587032865869378324299022323731794401778416670178670987733185" //  &
           "814446261010130113286467916958273916598065282809528144498877625408" //  &
           "51786835211126241486118129987351739916755135907809166050772678111097018M-81"
      CALL FMST2M(ST,C(165))
      ST = " 3.782366675158000172438186031560392817938018879105893232376963665" //  &
           "758045582935962507746785156805849115039876109316259116490068195664" //  &
           "22154600940352929680886350387924367311407243398433694317491879496500728M-82"
      CALL FMST2M(ST,C(166))
      ST = " 1.253239257637571101011205444147249909041208363526150999161557930" //  &
           "530122175707904339132697555874221097743565894565280785124100424739" //  &
           "12341727673603475533755872933253879415498534305672767854397632835354647M-82"
      CALL FMST2M(ST,C(167))
      ST = " 4.152598333838791095457780574441131208990623618377645706663873970" //  &
           "409219842573498216786365580094065012089293058629821760308697172924" //  &
           "25649947447826939431820718042482922400940273337175959594512550863844028M-83"
      CALL FMST2M(ST,C(168))
      ST = " 1.376008915348001441142775089390756952291415569331728264389528531" //  &
           "840532583703944779638084800244642630871018954424019239838171107774" //  &
           "08455142709222529998017403722473530832343485779953472597270935996990435M-83"
      CALL FMST2M(ST,C(169))
      ST = " 4.559715817525503407894512559569944355041250549999373143331298588" //  &
           "042902011136449984273691723063087171534265607563490346238292992622" //  &
           "43694334064073133108518335548127416155718965768703096927698154664008186M-84"
      CALL FMST2M(ST,C(170))
      ST = " 1.511016937693380717359102098553590521576253151812935620881255183" //  &
           "676747573506694189735416802045982192198119977018955499638830448943" //  &
           "99139906962195905603908709462882471176378436053656496936740374119626233M-84"
      CALL FMST2M(ST,C(171))
      ST = " 5.007439851661721308524939431791288925473304269198627995505717966" //  &
           "042698143618956580402359781596868665105789229557574207071195578504" //  &
           "34784490998580851675508563655209200033656690762499193037679456058834741M-85"
      CALL FMST2M(ST,C(172))
      ST = " 1.659498369200591197022274845367449670587666822869779371596678693" //  &
           "434849663818573237359515507605355977016921178742109368988856546946" //  &
           "53987167820516459592809407463255771494757163532540963217681912265486931M-85"
      CALL FMST2M(ST,C(173))
      ST = " 5.499870074123138278587253453863123198782240874965235399880295435" //  &
           "189868323747896824633224719144787009990778913499316775325760318709" //  &
           "84151200565534853443611640092085568829894647596561585415506088061475496M-86"
      CALL FMST2M(ST,C(174))
      ST = " 1.822814104787822173171970582684126136729373783986451680232463776" //  &
           "995284747235440436579147791215434063408671873139502336867256882493" //  &
           "52907684446136684618467464533340860151713404827732293178363163584088691M-86"
      CALL FMST2M(ST,C(175))
      ST = " 6.041524022149206216514749478207951898414628220569359023936273098" //  &
           "431129999705544414314317322005670901754042242107672777454004410860" //  &
           "23728922114946882252911249911639377024536952401619252235639914064675297M-87"
      CALL FMST2M(ST,C(176))
      ST = " 2.002463416328745336974658582823885810920380274053175588795927666" //  &
           "714050828711674000372182654975669270167646317724425684411171485274" //  &
           "63888736139146918349514677140009027878433312540016907441088200168772901M-87"
      CALL FMST2M(ST,C(177))
      ST = " 6.637378732657623720229439419358377518409139927005258254140285180" //  &
           "914849963099373381335080302807182958739736822642496046941955995156" //  &
           "47580543357281795983541588632113533651700800850371216214989020246965499M-88"
      CALL FMST2M(ST,C(178))
      ST = " 2.200102767530555026604991024957956952823900377482112800591761008" //  &
           "660084843014248387788035100004987819764909462237889078992186315330" //  &
           "60158332375064476625052936559137839280476740402400480416136592265795082M-88"
      CALL FMST2M(ST,C(179))
      ST = " 7.292933318740382159132169272746181235841016457994964554263454208" //  &
           "492201073732473833848574569619679758849986320998185690723690770932" //  &
           "41462402016226262443880472321890006685113024701301315267987027615012503M-89"
      CALL FMST2M(ST,C(180))
      ST = " 2.417513092202831923304643749980362419472891672259150932920867637" //  &
           "832384236931175709234025174145241123797309720555077484497334156484" //  &
           "70273284353674851435852469743857826682908838509841004308849506350039697M-89"
      CALL FMST2M(ST,C(181))
      ST = " 8.014099523920820532691698949493969623669374514095447937521752186" //  &
           "098803953643697356090844942590659454999844318173870304557001940555" //  &
           "42525475893078866822127874440270390910047929036227162217460866884004221M-90"
      CALL FMST2M(ST,C(182))
      ST = " 2.657079598189421611225399332494614836172370837056707080573411081" //  &
           "077314111961101307612637519570469581636094934124837596398237792257" //  &
           "42836805118176886050043438632186029854385799944806006391590874149011746M-90"
      CALL FMST2M(ST,C(183))
      ST = " 8.808801832338891822547417575762619398673718065912507825752674890" //  &
           "111044965171749095170501464417801064468367983054179217820785485005" //  &
           "97684256880162841894825031174637280632623961080123218247631394854404406M-91"
      CALL FMST2M(ST,C(184))
      ST = " 2.917871827472767744801985504187470385461224411949197505438209784" //  &
           "552995184888997609387528889784137922680585612807183342956402094608" //  &
           "01943529407670923901992925226137852941513101357366936300944346484030974M-91"
      CALL FMST2M(ST,C(185))
      ST = " 9.673909686763801191886681572020182885252222531903039060187477306" //  &
           "277095817639315200476096440352681128855627885542339760940019503157" //  &
           "11902076792371625818162067652299279665268178569377108196296372219380510M-92"
      CALL FMST2M(ST,C(186))
      ST = " 3.225317339965144219466139388048879231367171359221844461940917969" //  &
           "250112356759739827102732375554724422636709224874307206769709880215" //  &
           "16808317218174915989091357841379986431733603301918969106178493014736385M-92"
      CALL FMST2M(ST,C(187))
      ST = " 1.069410576590312480755235192735211157086107353088423400669923656" //  &
           "677428694478915259443669100953558846603833879903904822845298497420" //  &
           "71143211982703738257538091316334035362562254796294606412951506359364815M-92"
      CALL FMST2M(ST,C(188))
      ST = " 3.436230247075590625300285568770398628374034305782922085529568066" //  &
           "268230300872273810320168642643487560176713818087616304872506761508" //  &
           "46310739710431810178913824922315129263580429076241251322833952169352928M-93"
      CALL FMST2M(ST,C(189))
      ST = " 1.139260014627810596016761865641404521146852141822567620126418127" //  &
           "549772266075482248466335323616377804969776249070578213315603095439" //  &
           "66803478295001515092190429139446518480363880483757347561526976211621457M-93"
      CALL FMST2M(ST,C(190))
      ST = " 4.343070458433874603042514728830057473477940614398096372223763568" //  &
           "372476710887610850250214061613248238834003723272762897566055896217" //  &
           "49542103193171278645483518744915143059042740324768324837960269146747307M-94"
      CALL FMST2M(ST,C(191))
      ST = " 1.440667367566540553672654836910082201055609375400592746447756244" //  &
           "176284526124155943246633922603816785133029633668454281491778597874" //  &
           "45028943290797079216498815025085467176654584077190605132981537168513742M-94"
      CALL FMST2M(ST,C(192))
      ST = " 2.384816222561370113514027430584139466337689187141928475880205055" //  &
           "969980605519512189876139389796445441195296187421190296481218115986" //  &
           "36517542721807591974162349259651427967273755554095270040863620533051177M-95"
      CALL FMST2M(ST,C(193))
      ST = " 7.891080859500628750618564157769100520532680589132484946442038829" //  &
           "299825933371426348457257350822254140519284945880389565858120333678" //  &
           "80845449586455112014663973071181240064800376338635797974159751681049875M-96"
      CALL FMST2M(ST,C(194))
      ST = " 1.059066626703749406081450817511793688125712964427249229411570236" //  &
           "550112600348902027013047427990927965524515088187243012802502472093" //  &
           "22261048153901594967680556527547070843534915035469463356163636215773539M-95"
      CALL FMST2M(ST,C(195))
      ST = " 3.516498583838005375775193339944623281315914658931041130875008620" //  &
           "636983702886095342086986357214180450129972642316547945003279723791" //  &
           "81126461652035134771983947459420613651499692168433361308886876030693800M-96"
      CALL FMST2M(ST,C(196))

      NDIG = NDSAVE

      END SUBROUTINE FMLNGM_C

      SUBROUTINE FMPGAM(N,MA,MB)

!  MB = POLYGAMMA(N,MA)      (Nth Derivative of PSI)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTA,J,J2,JN,JNC,JSTART,K,KASAVE,KFL,KL,KOVUN,KR_RETRY,KRESLT,     &
                 KRFLCT,KRSAVE,KWRNSV,K_RETURN_CODE,LSHIFT,N1,NBOT,NC,NDGOAL,NDIG2,NDOLD,  &
                 NDSAV1,NDSAVE,NDSV2,NGOAL,NMXDIF,NTERM,NTOP,NUMTRY

!             Set the coefficients used in computing various derivatives of COT(Pi*X)
!             for the reflection formula.

      INTEGER :: KGCD(14) =  &
              (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      INTEGER :: KCOEFF(56) = (/                                                     &
                    1,          1,              3, 1,     3, 2,                      &
                    15, 15, 2,                  45, 60, 17,                          &
                    315, 525, 231, 17,          315, 630, 378, 62,                   &
                    2835, 6615, 5040, 1320, 62,                                      &
                    14175, 37800, 34965, 12720, 1382,                                &
                    155925, 467775, 509355, 238425, 42306, 1382,                     &
                    467775, 1559250, 1954260, 1121670, 280731, 21844,                &
                    6081075, 22297275, 31621590, 21531510, 7012005,  907725, 21844,  &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(13),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. N >= 0) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(0,MXY(2))
          CALL FMSUB(MXY(2),MXY(1),MXY(3))
          CALL FMIPWR(MXY(3),-N-1,MXY(4))
          IF (N >= 2) THEN
              CALL FMI2M(N,MXY(6))
              CALL FMFACT(MXY(6),MXY(7))
              CALL FMMPY_R1(MXY(4),MXY(7))
          ENDIF
          IF (N == 0) THEN
              CALL FMEULR(MXY(2))
              CALL FMMPYI(MXY(2),-1,MXY(5))
          ELSE IF (MOD(N,2) == 1) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMBERN(N+1,MXY(2),MXY(3))
              CALL FMABS(MXY(3),MXY(6))
              CALL FMPI(MXY(7))
              CALL FMIPWR(MXY(7),N+1,MXY(8))
              CALL FMMPY(MXY(6),MXY(8),MXY(7))
              CALL FMI2M(2,MXY(2))
              CALL FMIPWR(MXY(2),N-1,MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),(N+1)/2,MXY(5))
          ELSE
              CALL FMI2M(1,MXY(2))
              CALL FMBERN(N,MXY(2),MXY(3))
              CALL FMABS(MXY(3),MXY(6))
              CALL FMPI(MXY(7))
              CALL FMIPWR(MXY(7),N,MXY(8))
              CALL FMMPY(MXY(6),MXY(8),MXY(7))
              CALL FMI2M(2,MXY(2))
              CALL FMIPWR(MXY(2),N-2,MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),N/2,MXY(10))
              CALL FMI2M(1,MXY(2))
              CALL FMBERN(N+2,MXY(2),MXY(3))
              CALL FMABS(MXY(3),MXY(6))
              CALL FMPI(MXY(7))
              CALL FMIPWR(MXY(7),N+2,MXY(8))
              CALL FMMPY(MXY(6),MXY(8),MXY(7))
              CALL FMI2M(2,MXY(2))
              CALL FMIPWR(MXY(2),N,MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),(N+2)/2,MXY(11))
              CALL FMMPY(MXY(10),MXY(11),MXY(9))
              CALL FMSQRT(MXY(9),MXY(10))
              CALL FMI2M(0,MXY(8))
              CALL FMSUB(MXY(8),MXY(10),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPGAM'
                  CALL FMNTRI(2,N,1)
                  CALL FMNTR(2,MA,MA,1,0)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMPGAM'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMPGAM   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(13))
      NUMTRY = 0

  120 IF (N == 0) THEN
          CALL FMPSI(MXY(1),MXY(10))
          GO TO 160
      ENDIF
      IF (N < 0 .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(10))
          KFLAG = -4
          GO TO 180
      ENDIF

!             Near zero PGAM(x) is about n!/(-x)**(n+1).

      IF (MWK(START(MXY(13))+2) < (-NDIG-1)) THEN
          CALL FMFCTI(N,MXY(12))
          IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
              MWK(START(MXY(13))) = -MWK(START(MXY(13)))
          CALL FMIPWR(MXY(13),N+1,MXY(11))
          CALL FMDIV(MXY(12),MXY(11),MXY(10))
          GO TO 160
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDP2M(-0.5D0,MXY(5))
      IF (FMCOMP(MXY(13),'<=',MXY(5))) THEN
          KRFLCT = 1
          KFL = 0
          IF (MWK(START(MA)+2) <= NDSAVE) THEN
              CALL FMINT(MXY(13),MXY(9))
              IF (FMCOMP(MXY(13),'==',MXY(9))) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(10))
              KFLAG = -4
              GO TO 180
          ELSE
              CALL FMI2M(1,MXY(4))
              CALL FMSUB_R2(MXY(4),MXY(13))
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) > NDIG+3) THEN
          CALL FMIPWR(MXY(13),-N,MXY(10))
          IF (MWK(START(MXY(10))+2) /= MEXPUN) THEN
              CALL FMFCTI(N-1,MXY(9))
              CALL FMMPY_R1(MXY(10),MXY(9))
          ENDIF
          IF (MOD(N-1,2) == 1 .AND. MWK(START(MXY(10))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          IF (KROUND /= 1) THEN
              IF (MWK(START(MXY(10))+2) /= MEXPUN) THEN
                  CALL FMMPYI(MXY(10),N,MXY(4))
                  CALL FMDIVI_R1(MXY(4),2)
                  CALL FMDIV_R1(MXY(4),MXY(13))
                  CALL FMADD_R1(MXY(10),MXY(4))
              ENDIF
          ENDIF
          GO TO 160
      ENDIF

!             To speed the asymptotic series calculation, increase the argument by LSHIFT.

      IEXTRA = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(13),INTA)
      KWARN = KWRNSV

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
          LSHIFT = LSHIFT + (7*N)/20
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(4))
          CALL FMADD(MXY(13),MXY(4),MXY(12))
      ELSE
          CALL FMEQ(MXY(13),MXY(12))
      ENDIF

!             Sum the asymptotic series.

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(13) is Z
!             MXY(12) is Z + LSHIFT
!             MXY(9) is X**J2 = (1/(Z+LSHIFT)**2)**J2
!             MXY(10) is the current power of X times the quotient of factorials in each term
!             MXY(11) is the current term in the sum
!             MXY(8) is (N+1)!
!             MJSUMS holds the partial sums

      NDSAV1 = NDIG
      CALL FMFCTI(N+1,MXY(8))
      CALL FMDIVI(MXY(8),2,MXY(10))
      J = -2*J2
      CALL FMIPWR(MXY(12),J,MXY(9))
      IF (ABS(MWK(START(MXY(9))+2)) >= MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(12),-2,MXY(9))
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(10),MJSUMS(J))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 180
         ENDIF
         NTOP = (N+NTERM)*(N+NTERM+1)
         CALL FMCSMPYI_R1(MXY(10),NTOP)
         NBOT = (NTERM+1)*(NTERM+2)
         CALL FMCSDIVI_R1(MXY(10),NBOT)
      ENDDO

      NDIG2 = NDIG
  130 CALL FMCSMPY_R1(MXY(10),MXY(9))
      NMXDIF = MIN(NDSAV1,NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(10),MXY(11))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 180
         ENDIF
         NDIG = NDSAV1
         CALL FMCSADD_R1(MJSUMS(J),MXY(11))
         IF (KFLAG /= 0) THEN
             GO TO 140
         ELSE
             NMXDIF = MAX(NMXDIF,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(11))+2)))
             NDIG = NDIG2
             IF (N+NTERM > INTMAX/(N+NTERM+1) .OR. N+NTERM > MXBASE/(N+NTERM+1)) THEN
                 CALL FMCSMPYI_R1(MXY(10),N+NTERM)
                 CALL FMCSMPYI_R1(MXY(10),N+NTERM+1)
                 CALL FMCSDIVI_R1(MXY(10),NTERM+1)
                 CALL FMCSDIVI_R1(MXY(10),NTERM+2)
             ELSE
                 NTOP = (N+NTERM)*(N+NTERM+1)
                 CALL FMCSMPYI_R1(MXY(10),NTOP)
                 NBOT = (NTERM+1)*(NTERM+2)
                 CALL FMCSDIVI_R1(MXY(10),NBOT)
             ENDIF
         ENDIF
      ENDDO
      NDIG2 = NMXDIF
      NDIG = NDIG2
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMI2M(1,MXY(9))
          CALL FMSQR(MXY(12),MXY(11))
          CALL FMDIV_R2(MXY(9),MXY(11))
          CALL FMEQ(MJSUMS(J2),MXY(9))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(9),MXY(11))
             CALL FMADD_R1(MXY(9),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(9),MJSUMS(1))
      ENDIF
      CALL FMIPWR(MXY(12),N+2,MXY(6))
      CALL FMDIV_R1(MJSUMS(1),MXY(6))

!             Add the initial terms to the asymptotic series.

      CALL FMDIVI(MXY(8),N+1,MXY(9))
      CALL FMDIVI(MXY(9),N,MXY(8))
      CALL FMMPYI(MXY(12),2,MXY(7))
      CALL FMI2M(N,MXY(10))
      CALL FMADD_R1(MXY(7),MXY(10))
      CALL FMMPY_R1(MXY(7),MXY(8))
      CALL FMMPYI_R1(MXY(6),2)
      CALL FMDIV_R1(MXY(6),MXY(12))
      CALL FMDIV(MXY(7),MXY(6),MXY(10))
      CALL FMADD_R2(MJSUMS(1),MXY(10))
      IF (MOD(N-1,2) == 1 .AND. MWK(START(MXY(10))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))

!             Now PGAM of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA)**(N+1) + ... + 1/(MA+LSHIFT-1)**(N+1) is computed.

!             MXY(13) is Z
!             MXY(9) is N!
!             MXY(10) is the sum of the asymptotic series
!             MXY(11) is the sum 1/(MA)**(N+1) + ... + 1/(MA+LSHIFT-1)**(N+1)

      IF (LSHIFT > 0) THEN
          CALL FMI2M(1,MXY(6))
          CALL FMEQ(MXY(13),MXY(7))
          N1 = -(N + 1)
          CALL FMIPWR(MXY(7),N1,MXY(11))
          DO K = 1, LSHIFT-1
             CALL FMADD_R1(MXY(7),MXY(6))
             CALL FMIPWR(MXY(7),N1,MXY(12))
             CALL FMADD_R1(MXY(11),MXY(12))
          ENDDO
          CALL FMMPY_R2(MXY(9),MXY(11))
          IF (MOD(N+1,2) == 1 .AND. MWK(START(MXY(11))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(11))+3) /= 0) MWK(START(MXY(11))) = -MWK(START(MXY(11)))
          CALL FMADD_R1(MXY(10),MXY(11))
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

      IF (KRFLCT == 1) THEN

!             MXY(11) is COT(Pi*Z)
!             MXY(9) is MXY(11)**2

!             Reduce the argument before multiplying by Pi.

          CALL FMMPYI(MXY(13),2,MXY(5))
          CALL FMINT(MXY(5),MXY(9))
          IF (FMCOMP(MXY(5),'==',MXY(9))) THEN
              CALL FMI2M(0,MXY(11))
              CALL FMEQ(MXY(11),MXY(9))
              CALL FMI2M(1,MXY(5))
          ELSE
              CALL FMNINT(MXY(13),MXY(5))
              CALL FMSUB(MXY(13),MXY(5),MXY(9))
              NDSV2 = NDIG
  150         CALL FMPI(MXY(11))
              CALL FMMPY_R1(MXY(11),MXY(9))
              KRSAVE = KRAD
              KRAD = 1
              CALL FMTAN(MXY(11),MXY(2))
              CALL FMEQ(MXY(2),MXY(11))
              KRAD = KRSAVE
              IF ((MWK(START(MXY(11))+2) < 0 .OR. MWK(START(MXY(11))+2) > 1) .AND.  &
                  NDSV2 == NDIG) THEN
                  IEXTRA = INT(MAX(-MWK(START(MXY(11))+2),MWK(START(MXY(11))+2)))
                  IF (IEXTRA > 0) THEN
                      CALL FMEQU_R1(MXY(9),NDIG,NDIG+IEXTRA)
                  ENDIF
                  NDIG = NDIG + IEXTRA
                  GO TO 150
              ENDIF

              NDIG = NDSV2
              CALL FMI2M(1,MXY(5))
              CALL FMDIV_R2(MXY(5),MXY(11))
              CALL FMSQR(MXY(11),MXY(9))
          ENDIF
          NC = (N+1)/2

!             For N up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*Z).  For larger N, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          IF (N <= 14) THEN
              JSTART = (N*N + 4 - MOD(N,2))/4
              IF (N <= 2) THEN
                  CALL FMI2M(1,MXY(6))
              ELSE
                  CALL FMMPYI(MXY(9),KCOEFF(JSTART),MXY(6))
              ENDIF
              DO J = 2, NC
                 CALL FMI2M(KCOEFF(JSTART+J-1),MXY(7))
                 CALL FMADD_R1(MXY(6),MXY(7))
                 IF (J < NC) CALL FMMPY_R1(MXY(6),MXY(9))
              ENDDO
              IF (MOD(N,2) == 0) CALL FMMPY_R1(MXY(6),MXY(11))
              IF (N > 1) CALL FMMPYI_R1(MXY(6),KGCD(N))
          ELSE
              IF (NC > LJSUMS) THEN
                  KFLAG = -12
                  CALL FMWRN2
                  WRITE (KW,                                                  &
                         "(' For PGAM(',I5,',*) with NDIG =',I5,',',I7,"  //  &
                         "' words are needed'/' in array MJSUMS.',"       //  &
                         "'  The current dimension of MJSUMS IS',I7/)"        &
                        ) N,NDIG,NC*(NDIG+3),LJSUMS
                  MXEXP = MXSAVE
                  NDIG = NDSAVE
                  CALL FMST2M('UNKNOWN',MB)
                  IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
                  KACCSW = KASAVE
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MB) == -1) TEMPV(MB) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF

              DO J = 1, 7
                 CALL FMI2M(KCOEFF(J+49),MJSUMS(J))
                 CALL FMMPYI_R1(MJSUMS(J),KGCD(14))
              ENDDO
              DO JN = 15, N
                 JNC = (JN+1)/2
                 DO K = JNC, 2, -1
                    IF (K == JNC .AND. MOD(JN,2) == 1) THEN
                        CALL FMEQ(MJSUMS(K-1),MJSUMS(K))
                    ELSE
                        CALL FMADD_R2(MJSUMS(K-1),MJSUMS(K))
                        CALL FMMPYI_R1(MJSUMS(K),JN-2*(K-1))
                    ENDIF
                 ENDDO
                 CALL FMMPYI_R1(MJSUMS(1),JN)
              ENDDO

!             MJSUMS now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              CALL FMEQ(MJSUMS(1),MXY(6))
              DO J = 2, NC
                 CALL FMMPY_R1(MXY(6),MXY(9))
                 CALL FMADD_R1(MXY(6),MJSUMS(J))
              ENDDO
              IF (MOD(N,2) == 0) CALL FMMPY_R1(MXY(6),MXY(11))
          ENDIF

!             To complete the calculation of the Nth derivative of Cot, multiply the polynomial
!             in Cot**2 by Csc**2.

          CALL FMADD(MXY(9),MXY(5),MXY(7))
          CALL FMMPY_R1(MXY(6),MXY(7))

          CALL FMPI(MXY(7))
          CALL FMIPWR(MPISAV,N+1,MXY(7))
          CALL FMMPY_R1(MXY(6),MXY(7))
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(10))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          CALL FMADD_R1(MXY(10),MXY(6))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(13))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPGAM

      SUBROUTINE FMPOCH(MA,N,MB)

!  MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)       (Pochhammer's symbol)

!  MB = Gamma(MA+N)/Gamma(MA)

!  For negative N, Pochhammer(MA,N) = 1/Pochhammer(MA+N,-N).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: N
      REAL (KIND(1.0D0)) :: MA2,MAS,MACCA,MACMAX,MBSIGN,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K0,K1,K2,KASAVE,KL,KLAST,KM08,KMB,KOVUN,KR_RETRY,KRESLT,  &
                 KRSAVE,K_RETURN_CODE,LT,NDGOAL,NDOLD,NDSAVE,NGOAL,NT,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: T
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. N /= 0 .AND. N /= 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          NT = ABS(N) - 1
          IF (N < 0) NT = NT + 1
          CALL FMI2M(NT,MXY(2))
          CALL FMFACT(MXY(2),MXY(3))
          CALL FMMPY(MXY(1),MXY(3),MXY(4))
          IF (NT <= 20) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMI2M(1,MXY(5))
              DO K1 = 2, NT
                 CALL FMDIVI(MXY(2),K1,MXY(6))
                 CALL FMADD_R1(MXY(5),MXY(6))
              ENDDO
          ELSE
              CALL FMI2M(NT,MXY(7))
              CALL FMLN(MXY(7),MXY(5))
              CALL FMEULR(MXY(6))
              CALL FMADD_R1(MXY(5),MXY(6))
              CALL FMI2M(1,MXY(2))
              CALL FMDIV(MXY(2),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),2,MXY(6))
              CALL FMADD_R1(MXY(5),MXY(6))
              CALL FMSQR(MXY(8),MXY(9))
              CALL FMDIVI(MXY(9),12,MXY(6))
              CALL FMSUB_R1(MXY(5),MXY(6))
              CALL FMSQR(MXY(9),MXY(8))
              CALL FMDIVI(MXY(8),120,MXY(6))
              CALL FMADD_R1(MXY(5),MXY(6))
          ENDIF
          IF (N > 0) THEN
              CALL FMEQ(MXY(4),MXY(6))
              CALL FMMPY(MXY(4),MXY(5),MXY(8))
              CALL FMMPY(MXY(1),MXY(8),MXY(7))
          ELSE
              IF (MOD(NT,2) == 0) THEN
                  CALL FMI2M(1,MXY(2))
              ELSE
                  CALL FMI2M(-1,MXY(2))
              ENDIF
              CALL FMDIV(MXY(2),MXY(3),MXY(6))
              CALL FMMPY(MXY(6),MXY(5),MXY(8))
              CALL FMMPY(MXY(1),MXY(8),MXY(7))
          ENDIF
          IF (MWK(START(MXY(6))+2) - MWK(START(MXY(7))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(6))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(6),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(9),NDIG,NDSAVE)
              CALL FMEQU(MXY(9),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(6),MXY(8),MXY(9))
              IF (MWK(START(MXY(9))+3) == 0) THEN
                  CALL FMEQU(MXY(6),MXY(8),NDIG,NDSAVE)
                  CALL FMEQU(MXY(7),MXY(9),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(8),MXY(9),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(8))) > 0) THEN
                          IF (MWK(START(MXY(9))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(9))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(9))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(9))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(6),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTRI(2,N,0)
                  NCALL = NCALL - 1
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  KFLAG = -4
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMPOCH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      CALL FMNTRI(2,N,0)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MA2 = MWK(START(MA)+3)
      MAS = MWK(START(MA))
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NT = N
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(13))
      NUMTRY = 0

!             Check for special cases.

  120 IEXTRA = 0
      IF (N == 0) THEN
          CALL FMI2M(1,MXY(11))
          GO TO 160
      ENDIF
      IF (NT < 0) THEN
          CALL FMADDI(MXY(1),NT)
          CALL FMEQ(MXY(1),MXY(13))
          NT = -NT
          MA2 = MWK(START(MXY(1))+3)
          MAS = MWK(START(MXY(1)))
      ENDIF
      IF (MA2 == 0) THEN
          IF (NT > 0) THEN
              CALL FMI2M(0,MXY(11))
              GO TO 140
          ELSE
              CALL FMST2M('UNKNOWN',MXY(11))
              KFLAG = -4
              GO TO 160
          ENDIF
      ENDIF
      IF (NT == 0) THEN
          CALL FMI2M(1,MXY(11))
          GO TO 140
      ELSE IF (NT == 1) THEN
          CALL FMEQU(MXY(1),MXY(11),NDSAVE,NDIG)
          GO TO 140
      ENDIF
      CALL FMI2M(1,MXY(4))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(4),MXY(5))
      KROUND = JR
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(11))
          IF (MAS < 0) MWK(START(MXY(11))) = (-1)**NT
          GO TO 140
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          IF (NT == 2) THEN
              CALL FMST2M('UNDERFLOW',MXY(11))
              IF (MAS < 0) MWK(START(MXY(11))) = -1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(11))
              KFLAG = -4
          ENDIF
          GO TO 160
      ELSE IF (FMCOMP(MXY(5),'==',MXY(4))) THEN
          T = NDIG
          J = INT(15.21*SQRT(T)*ALOGMT + 42.87*SQRT(T) + 30.0)
          IF (NT <= J) THEN
              K1 = NT - 1
              CALL FMFCTI(K1,MXY(11))
              CALL FMMPY_R2(MXY(1),MXY(11))
              GO TO 140
          ENDIF
      ENDIF

!             Look for cases where overflow is easy to detect.

      CALL FMI2M(NT,MXY(9))
      CALL FMABS(MXY(13),MXY(7))
      IF (MWK(START(MXY(13))+2) > 0 .AND. FMCOMP(MXY(9),'<',MXY(7))) THEN
          CALL FMADD(MXY(13),MXY(9),MXY(8))
          MWK(START(MXY(8))) = 1
          CALL FMMIN(MXY(7),MXY(8),MXY(10))
          IF (INT(MWK(START(MXY(10))+2))-1 > INTMAX/NT) THEN
              CALL FMST2M('OVERFLOW',MXY(11))
              IF (MWK(START(MXY(13))) > 0) THEN
                  MWK(START(MXY(11))) = 1
              ELSE
                  MWK(START(MXY(11))) = (-1)**MOD(NT,2)
              ENDIF
              KFLAG = -5
              GO TO 140
          ENDIF
      ENDIF

!             For large values of MA, the result is MA**NT.

      LT = NDIG + 3 + INT(2.0D0*LOG(DBLE(NT))/DLOGMB)
      IF (MWK(START(MXY(1))+2) > LT) THEN
          CALL FMIPWR(MXY(13),NT,MXY(11))
          IF (KROUND /= 1 .AND. NT > 1) THEN
              IF (ABS(MWK(START(MXY(11))+2)) /= MEXPOV) THEN
                  CALL FMDIV(MXY(11),MXY(13),MXY(8))
                  IF (MOD(NT,2) == 0) THEN
                      CALL FMMPYI_R1(MXY(8),NT-1)
                      CALL FMMPYI_R1(MXY(8),NT/2)
                  ELSE
                      CALL FMMPYI_R1(MXY(8),(NT-1)/2)
                      CALL FMMPYI_R1(MXY(8),NT)
                  ENDIF
                  CALL FMADD_R1(MXY(11),MXY(8))
              ENDIF
          ENDIF
          GO TO 140
      ENDIF

      MBSIGN = 1
      IF (MAS < 0) THEN
          CALL FMINT(MXY(13),MXY(8))
          CALL FMI2M(NT,MXY(9))
          JR = KROUND
          KROUND = 1
          CALL FMADD(MXY(13),MXY(9),MXY(10))
          KROUND = JR
          IF (FMCOMP(MXY(13),'==',MXY(8))) THEN

!                  If MA is a negative integer and MA+NT is positive, then the result is zero.

              IF (MWK(START(MXY(10)))*MWK(START(MXY(10))+3) > 0) THEN
                  CALL FMI2M(0,MXY(11))
                  GO TO 140
              ENDIF
          ENDIF

!                  If MA is negative and MA+NT-1 is negative, then use the reflection formula
!                  Pochhammer(MA,NT) = (-1)**NT*Pochhammer(-MA-(NT-1),NT).

          CALL FMI2M(1,MXY(11))
          IF (FMCOMP(MXY(10),'<',MXY(11))) THEN

!                 Extra guard digits may be required to insure the reflection formula is accurate.

              IEXTRA = MAX(INT(MWK(START(MXY(13))+2)),IEXTRA)
              IF (IEXTRA > 0) THEN
                  CALL FMEQU_R1(MXY(13),NDIG,NDIG+IEXTRA)
              ENDIF
              NDIG = NDIG + IEXTRA
              CALL FMI2M(NT-1,MXY(11))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMSUB_R1(MXY(13),MXY(11))
              IF (MOD(NT,2) == 1) MBSIGN = -1
          ENDIF
      ENDIF

!             If NT is large enough, it is faster to use two calls to FMLNGM.
!             The formula below gives a rough approximation of where to change methods.

      T = NDIG
      J = INT(15.21*SQRT(T)*ALOGMT + 42.87*SQRT(T) + 25.03)
      IF (NT > J) THEN
          CALL FMI2M(NT,MXY(4))
          CALL FMADD(MXY(13),MXY(4),MXY(14))

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          IF (MAX(MWK(START(MXY(13))+2),MWK(START(MXY(14))+2)) > IEXTRA) THEN
              IEXTRA = INT(MAX(MWK(START(MXY(13))+2),MWK(START(MXY(14))+2)))
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(13),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA

          CALL FMI2M(-1,MXY(15))
          IF (IEXTRA > 0) THEN
              CALL FMI2M(NT,MXY(4))
              CALL FMADD(MXY(13),MXY(4),MXY(14))
          ENDIF
          CALL FMI2M(2,MXY(9))
          KMB = 0
          IF (MWK(START(MXY(13))) < 0) THEN
              CALL FMMOD(MXY(13),MXY(9),MXY(8))
              IF (FMCOMP(MXY(8),'>',MXY(15))) KMB = 1
          ENDIF
          KM08 = 0
          IF (MWK(START(MXY(14))) < 0) THEN
              CALL FMMOD(MXY(14),MXY(9),MXY(8))
              IF (FMCOMP(MXY(8),'>',MXY(15))) KM08 = 1
          ENDIF
          CALL FMI2M(1,MXY(15))
          IF (MWK(START(MXY(13))) < 0 .AND. KMB == 1) THEN
              CALL FMEQ(MXY(13),MXY(15))
              CALL FMI2M(1,MXY(4))
              CALL FMADD(MXY(13),MXY(4),MXY(2))
              CALL FMLNGM(MXY(2),MXY(13))
          ELSE
              CALL FMLNGM(MXY(13),MXY(3))
              CALL FMEQ(MXY(3),MXY(13))
          ENDIF
          IF (MWK(START(MXY(14))) < 0 .AND. KM08 == 1) THEN
              CALL FMI2M(-1,MXY(7))
              CALL FMADD_R1(MXY(14),MXY(7))
              CALL FMMPY(MXY(15),MXY(14),MXY(2))
              CALL FMLNGM(MXY(2),MXY(14))
          ELSE
              CALL FMLNGM(MXY(14),MXY(3))
              CALL FMEQ(MXY(3),MXY(14))
          ENDIF

          CALL FMSUB(MXY(14),MXY(13),MXY(11))
          CALL FMEXP(MXY(11),MXY(2))
          CALL FMMPY(MXY(2),MXY(15),MXY(11))
          GO TO 130
      ENDIF

!             Compute the product Z*(Z+1)*...*(Z+NT-1) four terms at a time to reduce the number
!             of FMMPY calls.

!             MXY(13) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

!             If MXY(13) is negative and MXY(13)+NT is positive, extra digits are required when
!             MXY(13) is close to an integer.

      IF (MWK(START(MXY(13))) < 0) THEN
          CALL FMI2M(NT,MXY(8))
          CALL FMADD(MXY(13),MXY(8),MXY(9))
          IF (MWK(START(MXY(9)))*MWK(START(MXY(9))+3) > 0) THEN
              CALL FMNINT(MXY(13),MXY(10))
              IF (MWK(START(MXY(10))+3) /= 0) THEN
                  CALL FMSUB(MXY(13),MXY(10),MXY(9))
                  IEXTRA = MAX(IEXTRA,NDIG-NDSAVE)
                  IF (MAX(MWK(START(MXY(13))+2),MWK(START(MXY(9))+2)) > IEXTRA) THEN
                      IEXTRA = INT(MAX(MWK(START(MXY(13))+2),MWK(START(MXY(9))+2)))
                  ENDIF
                  IF (IEXTRA > 0) THEN
                      CALL FMEQU_R1(MXY(13),NDIG,NDIG+IEXTRA)
                  ENDIF
                  NDIG = NDIG + IEXTRA
              ENDIF
          ENDIF
      ENDIF

      CALL FMI2M(1,MXY(11))
      IF (NT >= 4) THEN
          CALL FMSQR(MXY(13),MXY(6))
          CALL FMMPY(MXY(13),MXY(6),MXY(7))
          CALL FMSQR(MXY(6),MXY(8))
          CALL FMCSMPYI(MXY(7),6,MXY(12))
          CALL FMCSADD_R1(MXY(8),MXY(12))
          CALL FMCSMPYI(MXY(6),11,MXY(12))
          CALL FMCSADD_R1(MXY(8),MXY(12))
          CALL FMCSMPYI(MXY(13),6,MXY(12))
          CALL FMCSADD_R1(MXY(8),MXY(12))
          CALL FMEQ(MXY(8),MXY(11))
          CALL FMCSMPYI_R1(MXY(7),16)
          DO K = 0, NT-8, 4
             CALL FMCSADD_R1(MXY(8),MXY(7))
             K2 = 24*(2*K + 7)
             CALL FMCSMPYI(MXY(6),K2,MXY(12))
             CALL FMCSADD_R1(MXY(8),MXY(12))
             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMCSMPYI(MXY(13),K1,MXY(12))
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(13),K1,MXY(12))
                 CALL FMCSMPYI_R1(MXY(12),K)
                 CALL FMCSADD_R1(MXY(8),MXY(12))
                 K1 = 336*K + 632
                 CALL FMCSMPYI(MXY(13),K1,MXY(12))
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(8),K0)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 K0 = K*K + 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0)
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 CALL FMCSMPYI(MXY(12),K,MXY(9))
                 CALL FMCSMPYI_R1(MXY(9),K)
                 CALL FMCSADD_R1(MXY(8),MXY(9))
                 K0 = 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0)
                 CALL FMCSADD_R1(MXY(8),MXY(12))
             ENDIF
             CALL FMCSMPY_R1(MXY(11),MXY(8))
          ENDDO
      ENDIF

      KLAST = (NT/4)*4
      DO J = KLAST, NT-1
         CALL FMI2M(J,MXY(9))
         CALL FMCSADD_R1(MXY(9),MXY(13))
         CALL FMCSMPY_R1(MXY(11),MXY(9))
      ENDDO

!             If the reflection formula was used, multiply by (-1)**NT.

  130 MWK(START(MXY(11))) = MBSIGN*MWK(START(MXY(11)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(11))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(11))+J+1)) GO TO 150
              ENDDO
              GO TO 160
          ENDIF
  150     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(11))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(13))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  160 MACMAX = NINT(NDSAVE*ALOGM2)
      IF (N < 0) THEN
          CALL FMI2M(1,MXY(6))
          CALL FMDIV_R2(MXY(6),MXY(11))
      ENDIF
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPOCH

      SUBROUTINE FMPSI(MA,MB)

!  MB = PSI(MA)      (Derivative of Ln(Gamma(MA))

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,X,Z
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K0B,K1,K1B,K2,KASAVE,KFL,KL,KOVUN,KC_RETRY,KR_RETRY,   &
                 KRESLT,KRFLCT,KRSAVE,KWRNSV,K_RETURN_CODE,LSHIFT,NDENOM,NDGOAL,NDIG2,NDOLD,  &
                 NDSAV1,NDSAVE,NGOAL,NMETHD,NMXDIF,NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(11),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE
      INTEGER, SAVE :: C(0:196) = -3, NDIG_C = 0
      REAL (KIND(1.0D0)), SAVE :: MBASE_C = 0

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(0,MXY(2))
          CALL FMSUB(MXY(2),MXY(1),MXY(3))
          CALL FMI2M(1,MXY(2))
          CALL FMDIV(MXY(2),MXY(3),MXY(4))
          CALL FMEULR(MXY(6))
          CALL FMMPYI(MXY(6),-1,MXY(5))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPSI'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMPSI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0
      KC_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(11))
      NUMTRY = 0

!             Near zero Psi(x) is about -1/x.

  120 IF (MWK(START(MXY(11))+2) < (-NDIG-1)) THEN
          CALL FMI2M(-1,MXY(3))
          CALL FMDIV(MXY(3),MXY(11),MXY(8))
          GO TO 190
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDPM(DBLE(-0.5),MXY(4))
      IF (FMCOMP(MXY(11),'<=',MXY(4))) THEN
          KRFLCT = 1
          KFL = 0
          IF (MWK(START(MA)+2) <= NDSAVE) THEN
              CALL FMINT(MXY(11),MXY(7))
              IF (FMCOMP(MXY(11),'==',MXY(7))) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(8))
              KFLAG = -4
              GO TO 210
          ELSE
              CALL FMI2M(1,MXY(3))
              CALL FMSUB_R2(MXY(3),MXY(11))
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      CALL FMNINT(MXY(11),MXY(2))
      CALL FMSUB(MXY(11),MXY(2),MXY(6))
      MWK(START(MXY(6))+1) = MWK(START(MXY(1))+1)
      CALL FMM2DP(MXY(6),Z)
      Z = MAX(ABS(Z),1.0D-50)
      IF (KFLAG /= 0 .OR. ABS(Z) >= 1) THEN
          NMETHD = 2
      ELSE
          IF (190*LOG(Z) - 90*DLOGTN >= -NDIG*DLOGMB .OR. -190*DLOGTN >= -NDIG*DLOGMB) THEN
              NMETHD = 2
          ENDIF
      ENDIF
      CALL FMM2DP(MXY(11),X)
      IF (KFLAG /= 0) THEN
          NMETHD = 2
      ELSE IF (NMETHD == 1) THEN
          IF (X > 35 - 8*LOG(Z) + NDIG*DLOGMB/(2.5*DLOGTN) .OR. X > 250) NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      IF (MWK(START(MA)) > 0 .AND. NDSAVE+NGRD52 < NDIG .AND. KR_RETRY == 0 .AND. KC_RETRY == 0)  &
          NDIG = NDSAVE + NGRD52
      CALL FMM2I(MXY(2),LSHIFT)
      LSHIFT = LSHIFT - 3
      IF (NDIG_C < NDIG .OR. MBASE_C /= MBASE) THEN
          CALL FMPSI_C(NDIG_C,MBASE_C,C)
      ENDIF
      J2 = 0.42*LOG(Z) + 7.9
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      NDSAV1 = NDIG
      DO J = 1, J2
         CALL FMEQ(C(J),MJSUMS(J))
      ENDDO
      CALL FMIPWR(MXY(6),J2,MXY(5))
      CALL FMEQ(MXY(5),MXY(7))
      NTERM = J2
  130 IF (NTERM > J2) CALL FMCSMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(7),MXY(4))
         CALL FMCSMPY_R1(MXY(4),C(NTERM))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0 .OR. NTERM == 196) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130
  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      NDIG = NDSAV1
      IF (NTERM == 196) THEN
          GO TO 150
      ENDIF
      CALL FMEQ(MJSUMS(J2),MXY(8))
      CALL FMEQ(MXY(6),MXY(3))
      MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(3))
         CALL FMCSADD_R1(MXY(8),MJSUMS(J2-J+1))
      ENDDO
      CALL FMCSMPY_R1(MXY(8),MXY(6))
      CALL FMADD_R1(MXY(8),C(0))

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA-LSHIFT) + ... + 1/(MA-1) is computed.

!             MXY(11) is Z
!             MXY(4) is Z**2
!             MXY(5) is 16*Z**3
!             MXY(6) is the current four-term numerator
!             MXY(7) is the current four-term denominator
!             MXY(9) is the current sum

      IF (LSHIFT < 0) THEN
          CALL FMI2M(-1,MXY(4))
          CALL FMEQ(MXY(11),MXY(5))
          DO J = 1, -LSHIFT
             CALL FMCSDIV(MXY(4),MXY(5),MXY(7))
             CALL FMCSADD_R1(MXY(8),MXY(7))
             CALL FMSUB_R1(MXY(5),MXY(4))
          ENDDO
      ENDIF
      IF (LSHIFT > 0) THEN
          CALL FMADDI(MXY(11),-LSHIFT)
          IF (MOD(LSHIFT,4) /= 0) THEN
              CALL FMI2M(1,MXY(4))
              CALL FMEQ(MXY(11),MXY(5))
              DO J = 1, MOD(LSHIFT,4)
                 CALL FMCSDIV(MXY(4),MXY(5),MXY(7))
                 CALL FMCSADD_R1(MXY(8),MXY(7))
                 CALL FMCSADD_R1(MXY(5),MXY(4))
              ENDDO
              CALL FMADDI(MXY(11),MOD(LSHIFT,4))
          ENDIF
          LSHIFT = LSHIFT - MOD(LSHIFT,4)
      ENDIF
      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(11),MXY(4))
          CALL FMMPY(MXY(11),MXY(4),MXY(5))
          CALL FMSQR(MXY(4),MXY(6))
          CALL FMCSMPYI(MXY(5),6,MXY(10))
          CALL FMCSADD_R1(MXY(6),MXY(10))
          CALL FMCSMPYI(MXY(4),11,MXY(10))
          CALL FMCSADD_R1(MXY(6),MXY(10))
          CALL FMCSMPYI(MXY(11),6,MXY(10))
          CALL FMADD(MXY(6),MXY(10),MXY(7))
          CALL FMCSMPYI(MXY(5),4,MXY(6))
          CALL FMCSMPYI(MXY(4),18,MXY(10))
          CALL FMCSADD_R1(MXY(6),MXY(10))
          CALL FMCSMPYI(MXY(11),22,MXY(10))
          CALL FMCSADD_R1(MXY(6),MXY(10))
          CALL FMI2M(6,MXY(10))
          CALL FMCSADD_R1(MXY(6),MXY(10))
          CALL FMCSDIV(MXY(6),MXY(7),MXY(9))
          CALL FMCSMPYI_R1(MXY(5),16)
          DO K = 4, LSHIFT-4, 4
             CALL FMCSADD_R1(MXY(7),MXY(5))

             CALL FMCSMPYI(MXY(4),48,MXY(10))
             CALL FMCSADD_R1(MXY(6),MXY(10))

             K2 = 8*(6*K - 3)
             CALL FMCSMPYI(MXY(4),K2,MXY(10))
             CALL FMCSADD_R1(MXY(7),MXY(10))

             K1 = 16*(6*K - 3)
             CALL FMCSMPYI(MXY(11),K1,MXY(10))
             CALL FMCSADD_R1(MXY(6),MXY(10))

             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K - 6*K + 7)
                 CALL FMCSMPYI(MXY(11),K1,MXY(10))
                 CALL FMCSADD_R1(MXY(7),MXY(10))

                 CALL FMI2M(K1,MXY(10))
                 CALL FMCSADD_R1(MXY(6),MXY(10))
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(11),K1,MXY(10))
                 CALL FMCSMPYI_R1(MXY(10),K)
                 CALL FMCSADD_R1(MXY(7),MXY(10))
                 K1B = 8*(-6*K + 7)
                 CALL FMCSMPYI(MXY(11),K1B,MXY(10))
                 CALL FMCSADD_R1(MXY(7),MXY(10))

                 CALL FMI2M(K1,MXY(10))
                 CALL FMCSMPYI_R1(MXY(10),K)
                 CALL FMCSADD_R1(MXY(6),MXY(10))
                 CALL FMI2M(K1B,MXY(10))
                 CALL FMCSADD_R1(MXY(6),MXY(10))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K - 1)*(K*K - K + 3)
                 CALL FMI2M(K0,MXY(10))
                 CALL FMCSADD_R1(MXY(7),MXY(10))
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10))
                 K0B = K*K - K + 3
                 CALL FMCSMPYI_R1(MXY(10),K0B)
                 CALL FMCSADD_R1(MXY(7),MXY(10))
             ELSE
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10))
                 CALL FMCSMPYI_R1(MXY(10),K)
                 CALL FMCSMPYI_R1(MXY(10),K)
                 CALL FMCSADD_R1(MXY(7),MXY(10))
                 K0B = -K + 3
                 CALL FMI2M(K0,MXY(10))
                 CALL FMCSMPYI_R1(MXY(10),K0B)
                 CALL FMCSADD_R1(MXY(7),MXY(10))
             ENDIF
             CALL FMCSDIV(MXY(6),MXY(7),MXY(10))
             CALL FMCSADD_R1(MXY(9),MXY(10))
          ENDDO
          CALL FMCSADD_R1(MXY(8),MXY(9))
      ENDIF
      GO TO 180

!             Method 2.  Use the B(2n)/(2n*X**(2n) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by LSHIFT.

  150 IEXTRA = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(11),INTA)
      KWARN = KWRNSV

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(3))
          CALL FMADD(MXY(11),MXY(3),MXY(10))
      ELSE
          CALL FMEQ(MXY(11),MXY(10))
      ENDIF

!             Sum the asymptotic series.

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(11) is Z
!             MXY(10) is Z + LSHIFT
!             MXY(7) is X**J2 = (1/(Z+LSHIFT)**2)**J2
!             MXY(8) is the current power of X
!             MXY(9) is the current term in the sum
!             MJSUMS is the partial sum

      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(8))
      J = -2*J2
      CALL FMIPWR(MXY(10),J,MXY(7))
      IF (ABS(MWK(START(MXY(7))+2)) >= MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(10),-2,MXY(7))
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(8),MXY(9))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(8))
             KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM
         CALL FMDIVI(MXY(9),NDENOM,MJSUMS(J))
      ENDDO

      NDIG2 = NDIG
  160 CALL FMMPY_R1(MXY(8),MXY(7))
      NMXDIF = MIN(NDSAV1,NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(8),MXY(9))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(8))
             KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM
         CALL FMDIVI_R1(MXY(9),NDENOM)
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(9))
         NMXDIF = MAX(NMXDIF,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(9))+2)))
         NDIG = NDIG2
         IF (KFLAG /= 0) GO TO 170
      ENDDO
      NDIG2 = NMXDIF
      NDIG = NDIG2
      GO TO 160

!             Put the J2 concurrent sums back together.

  170 NDIG = NDSAV1
      CALL FMI2M(1,MXY(7))
      CALL FMSQR(MXY(10),MXY(9))
      CALL FMDIV_R2(MXY(7),MXY(9))
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(7))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(7),MXY(9))
             CALL FMADD_R1(MXY(7),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(7),MJSUMS(1))
      ENDIF

!             Add the log term to the asymptotic series.

!             MXY(8) is the current sum as the log terms are added
!             MXY(9) is now LN(Z+LSHIFT)

      CALL FMMPY(MJSUMS(1),MXY(9),MXY(8))
      CALL FMLN(MXY(10),MXY(9))
      CALL FMI2M(1,MXY(4))
      CALL FMDIV(MXY(4),MXY(10),MXY(5))
      CALL FMDIVI_R1(MXY(5),2)
      CALL FMSUB_R2(MXY(9),MXY(5))
      CALL FMSUB_R2(MXY(5),MXY(8))

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA) + ... + 1/(MA+LSHIFT-1) is computed.

!             MXY(11) is Z
!             MXY(4) is Z**2
!             MXY(5) is 16*Z**3
!             MXY(6) is the current four-term numerator
!             MXY(7) is the current four-term denominator
!             MXY(9) is the current sum

      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(11),MXY(4))
          CALL FMMPY(MXY(11),MXY(4),MXY(5))
          CALL FMSQR(MXY(4),MXY(6))
          CALL FMMPYI(MXY(5),6,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMMPYI(MXY(4),11,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMMPYI(MXY(11),6,MXY(10))
          CALL FMADD(MXY(6),MXY(10),MXY(7))
          CALL FMMPYI(MXY(5),4,MXY(6))
          CALL FMMPYI(MXY(4),18,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMMPYI(MXY(11),22,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMI2M(6,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMDIV(MXY(6),MXY(7),MXY(9))
          CALL FMMPYI_R1(MXY(5),16)
          DO K = 4, LSHIFT-4, 4
             CALL FMADD_R1(MXY(7),MXY(5))

             CALL FMMPYI(MXY(4),48,MXY(10))
             CALL FMADD_R1(MXY(6),MXY(10))

             K2 = 8*(6*K - 3)
             CALL FMMPYI(MXY(4),K2,MXY(10))
             CALL FMADD_R1(MXY(7),MXY(10))

             K1 = 16*(6*K - 3)
             CALL FMMPYI(MXY(11),K1,MXY(10))
             CALL FMADD_R1(MXY(6),MXY(10))

             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K - 6*K + 7)
                 CALL FMMPYI(MXY(11),K1,MXY(10))
                 CALL FMADD_R1(MXY(7),MXY(10))

                 CALL FMI2M(K1,MXY(10))
                 CALL FMADD_R1(MXY(6),MXY(10))
             ELSE
                 K1 = 48*K
                 CALL FMMPYI(MXY(11),K1,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(7),MXY(10))
                 K1B = 8*(-6*K + 7)
                 CALL FMMPYI(MXY(11),K1B,MXY(10))
                 CALL FMADD_R1(MXY(7),MXY(10))

                 CALL FMI2M(K1,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(6),MXY(10))
                 CALL FMI2M(K1B,MXY(10))
                 CALL FMADD_R1(MXY(6),MXY(10))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K - 1)*(K*K - K + 3)
                 CALL FMI2M(K0,MXY(10))
                 CALL FMADD_R1(MXY(7),MXY(10))
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10))
                 K0B = K*K - K + 3
                 CALL FMMPYI_R1(MXY(10),K0B)
                 CALL FMADD_R1(MXY(7),MXY(10))
             ELSE
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(7),MXY(10))
                 K0B = -K + 3
                 CALL FMI2M(K0,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K0B)
                 CALL FMADD_R1(MXY(7),MXY(10))
             ENDIF
             CALL FMDIV(MXY(6),MXY(7),MXY(10))
             CALL FMADD_R1(MXY(9),MXY(10))
          ENDDO
          CALL FMSUB_R1(MXY(8),MXY(9))
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

  180 IF (KRFLCT == 1) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(11),MXY(4))
          CALL FMSUB(MXY(11),MXY(4),MXY(7))
          MWK(START(MXY(7))+1) = MWK(START(MXY(11))+1)
          CALL FMPI(MXY(9))
          CALL FMMPY_R1(MXY(9),MXY(7))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMTAN(MXY(9),MXY(2))
          KRAD = KRSAVE
          CALL FMDIV_R2(MPISAV,MXY(2))
          CALL FMADD_R1(MXY(8),MXY(2))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(8))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(8))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(8))+J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(8))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(11))
          KC_RETRY = 1
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  210 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(8))+1) = MIN(MWK(START(MXY(8))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPSI

      SUBROUTINE FMPSI_C(NDIG_C,MBASE_C,C)

!  Initialize the constants used in the psi polynomial.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: C(0:196),NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      INTENT (INOUT) :: C,NDIG_C,MBASE_C
      INTEGER :: NDSAVE
      CHARACTER(220) :: ST

      NDSAVE = NDIG
      NDIG = MAX(NDIG,NINT(210*DLOGTN/DLOGMB))
      NDIG_C = NDIG
      MBASE_C = MBASE

      ST = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      CALL FMST2M(ST,C(0))
      ST = " 3.949340668482264364724151666460251892189499012067984377355582293" //  &
           "700074704032008738336289006197587053040043189623371906796287246870" //  &
           "05007787935102946330866276831733309367762605095251006872140054796811559M-1"
      CALL FMST2M(ST,C(1))
      ST = " 7.705690315959428539973816151144999076498629234049888179227155534" //  &
           "183820578631309018645587360933525814619915779526071941849199599867" //  &
           "32832137763968372079001614539417829493600667191915755222424942439615639M-2"
      CALL FMST2M(ST,C(2))
      ST = " 1.982323371113819151600369654116790277475095191872690768297621544" //  &
           "412061618696884655690963594169991723299081390804274241458407157457" //  &
           "00453492820035147162192070877834809108370293261887348261752736042355062M-2"
      CALL FMST2M(ST,C(3))
      ST = " 5.677755143369926331365486457034168057080919501912811974192677903" //  &
           "803589786281484560043106557133336379620341466556609042800961779155" //  &
           "97084183511072180087644866286337180353598363962365128888981335276775240M-3"
      CALL FMST2M(ST,C(4))
      ST = " 1.718061984449139714517929790920527901817490032853561842408664004" //  &
           "332182901957897882773977938535170530279191162254558867398181448333" //  &
           "10185379291633807265673175253040965355618769627954139226236853166325794M-3"
      CALL FMST2M(ST,C(5))
      ST = " 5.367773819228268397975498497967595998635605652387064172831365716" //  &
           "014783173557353460969689138513239689614536514910748872867774198403" //  &
           "35440315798301033984562121069463585243906583353964676997567696691427804M-4"
      CALL FMST2M(ST,C(6))
      ST = " 1.711061979443393786852385086524652589607906498500203291102026525" //  &
           "829525747488143952872303723719711245236484702826900263542995480733" //  &
           "83970966270581799604618992754222287297459333028151505628361773822843426M-4"
      CALL FMST2M(ST,C(7))
      ST = " 5.526782608221441785276923241206048560585139488875654859661590978" //  &
           "505339025839895039306912716958615740860476584706026142537397072243" //  &
           "01530691324987642510909294868767654539697941540782602296415448362507489M-5"
      CALL FMST2M(ST,C(8))
      ST = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066541508011M-5"
      CALL FMST2M(ST,C(9))
      ST = " 5.907354119464558702282526469936468606435758208617119141436100054" //  &
           "059798219814702591843023560629835506072948141298603299797940044724" //  &
           "48291452340594666101827864743680486809340363559802370626936931930763706M-6"
      CALL FMST2M(ST,C(10))
      ST = " 1.945928308048298637998047739670960416088458003404533040952133252" //  &
           "019681940913049042808551900699474542980945266314269501249317870278" //  &
           "74908804736762623987426734001119677345511898921612599921683514419564006M-6"
      CALL FMST2M(ST,C(11))
      ST = " 6.430350784891467518365263573957142751058955098451367026716208967" //  &
           "268298442098128927139532681355390234484052117973406407648522438051" //  &
           "09390967296839296849960667716105732496299638299238322412706670233440209M-7"
      CALL FMST2M(ST,C(12))
      ST = " 2.129788087048292585451051353337474816961691545494827552022528629" //  &
           "410231774208766597829719984675128804906172087285080543161655047327" //  &
           "58375412105018997048159105561567647701210317140138410056728113033026445M-7"
      CALL FMST2M(ST,C(13))
      ST = " 7.065818202049355172851064506258762794870685817750656993289333226" //  &
           "715634227957307233434701754849436696844424928325302977575887819043" //  &
           "21794404770003433234833231074275648790842338915961498517998739808022623M-8"
      CALL FMST2M(ST,C(14))
      ST = " 2.347034615187173257148763672202323738899047153115310520358878708" //  &
           "702795315178628560484632246234627121875727895643809584057710305127" //  &
           "87278924224408794242543715977424052595827644319888981305672643671262471M-8"
      CALL FMST2M(ST,C(15))
      ST = " 7.803106649762273600293563029213088249090262679095379843972935643" //  &
           "290282459342081738636916671209602661597101103726013919619715976946" //  &
           "82488687750381269409404895538941410178728305136626722016628210197601304M-9"
      CALL FMST2M(ST,C(16))
      ST = " 2.595999374839856461644621939730454697218953331143174429987630039" //  &
           "542650045638001968668989649549309210492316961761661920993360907581" //  &
           "83943362125894719965856782417889275088010359200837997812612518790010306M-9"
      CALL FMST2M(ST,C(17))
      ST = " 8.640837414389256569577951013532585711448386302359330467618239497" //  &
           "053413093126642271180763027067164825596661845609758534245303980743" //  &
           "08087916612539453037312942192048368911659495539677311896754022319241514M-10"
      CALL FMST2M(ST,C(18))
      ST = " 2.877174665461131520386834493459437941874105957500564898511375137" //  &
           "311439002578360979763874789548515880868154509894190626699457757147" //  &
           "73686016316321832375029203457725272356560152718132192583462548282779007M-10"
      CALL FMST2M(ST,C(19))
      ST = " 9.582858468146311671960437304596644669478493760020748737659683908" //  &
           "789815983387663856449725613266381211899380089748749729674239142554" //  &
           "09417096385045411044655577509743953184783848043803078810843691683066120M-11"
      CALL FMST2M(ST,C(20))
      ST = " 3.192362617049000364818675299493504182177965826984960311647445893" //  &
           "562291482131615616774398545467628898736874378132707045074901954090" //  &
           "87857585211733812448598150553069088798592369166325857786128311238584878M-11"
      CALL FMST2M(ST,C(21))
      ST = " 1.063641452982306778871888232638725499778451985860322579723624373" //  &
           "042743512317431335223585983763945149600366863053831443772337083310" //  &
           "55022604714614305141359222385085339434173650339778299984225419876751487M-11"
      CALL FMST2M(ST,C(22))
      ST = " 3.544275868854612440207935801227503918837302795864246972321724495" //  &
           "355468544848206832825003613889968600093960257823513222253360353453" //  &
           "05713971042571842928244634878395967156692305652444148244943360077022711M-12"
      CALL FMST2M(ST,C(23))
      ST = " 1.181126956967686063705069366011844730919543312398681339013384460" //  &
           "767464082069171562896200433788460949822871886205681867819662919323" //  &
           "00910010651681302654526439685187828766124647111195799560742489176171727M-12"
      CALL FMST2M(ST,C(24))
      ST = " 3.936345173849846585066306986288647881678859105474359687899712967" //  &
           "448625102584861794056546209745855663655522551206324259480980022982" //  &
           "48196521666063662466312955017462793017857218058858813422030279362129550M-13"
      CALL FMST2M(ST,C(25))
      ST = " 1.311929116013669810041706041194547190318825658299932395783521476" //  &
           "062715708679008371003135237649339518303948243863280796328717056928" //  &
           "61088933385870034244218462559681704119429612455202721574336572434693909M-13"
      CALL FMST2M(ST,C(26))
      ST = " 4.372632654299231920401840242323289305929581151976933470616960496" //  &
           "030436497373880193006652887239443630902623173458012149767003641260" //  &
           "91381234213835299457171231108226264358946266150962591099913744278927353M-14"
      CALL FMST2M(ST,C(27))
      ST = " 1.457428209197515390994541694806166533046920066577489380555809169" //  &
           "326581787738147452100480717196733318418099673508724121255442697420" //  &
           "79428502647711159673409529291257489352915130912350484504348941167745402M-14"
      CALL FMST2M(ST,C(28))
      ST = " 4.857804189667246764735021219813567955136816185008613360441960672" //  &
           "940496363503624604027929086312123388047291007867151509866153218472" //  &
           "06384966879455254262531778810269062220190874499923455125800419069661498M-15"
      CALL FMST2M(ST,C(29))
      ST = " 1.619195639149486423325122007106269185336947307372971693371175669" //  &
           "889809582649582191406670950947339285199094038180244016830476463936" //  &
           "02101458401269222147875016156102854033684337727151883392617646517180429M-15"
      CALL FMST2M(ST,C(30))
      ST = " 5.397137809202938955975940495024829822845303110776022583879121893" //  &
           "921705867907147218379583534840013350252782358738567325002357267738" //  &
           "61010468743185749436896970436317859962951219444890985968097249049622718M-16"
      CALL FMST2M(ST,C(31))
      ST = " 1.799000703833061723835456309516522471727635932565177399470291246" //  &
           "245675486739349743760088108709128457742138295133686476564611083127" //  &
           "88305692939487359678233270751804270008374154159339121093086571227836484M-16"
      CALL FMST2M(ST,C(32))
      ST = " 5.996555960166587435989106305417312260461721595507168812416307139" //  &
           "617920826596045537450588005370606978697110903751234286759364296538" //  &
           "88342574088876310757201262943137995532500249048583561327234609512080698M-17"
      CALL FMST2M(ST,C(33))
      ST = " 1.998823729325601300227884046410698198743303225621025482564048890" //  &
           "140820433856911724428946203004508501377274799484714026521360076321" //  &
           "81570423267997358911300788282146663959893146975667195154844645417775406M-17"
      CALL FMST2M(ST,C(34))
      ST = " 6.662675132429289007245318420983808894124038069139542218571745865" //  &
           "030220152998942329578185363084791339999779092891491916899149034423" //  &
           "33275083724236395937279776479045434110852072326963373822046800189057081M-18"
      CALL FMST2M(ST,C(35))
      ST = " 2.220874055111200556512338059264850925555466107705796942638438370" //  &
           "439334710114183793262340326636387034843865608526952566379170604706" //  &
           "27391000045814717730873567070447343919893162122347939701787863570280570M-18"
      CALL FMST2M(ST,C(36))
      ST = " 7.402869382385770801058732735126460283848974699479515940427142498" //  &
           "169090369970169606837637347292197915595099714959178372809210169004" //  &
           "97096397918083614643468550094209927318490673314894967308013075647465808M-19"
      CALL FMST2M(ST,C(37))
      ST = " 2.467612094717547539757300850305893096186640705352512533565093161" //  &
           "524071499801682896819052946685011871151619653049568921247943861305" //  &
           "74027835796362386640519365699573759086773066188473623555158872217826510M-19"
      CALL FMST2M(ST,C(38))
      ST = " 8.225346069033827277619490875386000099087882850547971011202536869" //  &
           "560710353060722052873313849027274314019902150470472049910634941015" //  &
           "65431604021316042692200940962539817779136949003756418974351775701389418M-20"
      CALL FMST2M(ST,C(39))
      ST = " 2.741775128372239167169885703390452991143862808123403590500260252" //  &
           "686098892049313322445848356272884233074331136306076265803163875838" //  &
           "39997245835097889674208425702496742768010046284312175596063967715214956M-20"
      CALL FMST2M(ST,C(40))
      ST = " 9.139233192043922392172869121382982198915872580533647882222959712" //  &
           "340271164148043740483814963159921847750954087090085242066261297172" //  &
           "38743378565324605175470969019495974103495135080039518080872470260574797M-21"
      CALL FMST2M(ST,C(41))
      ST = " 3.046406755195530600990090643743590284251799899012276309359112089" //  &
           "108511649715687692732843107149352212491463042497645778261917818921" //  &
           "00104801732363345270093806101054860184893098558607015592900408049840396M-21"
      CALL FMST2M(ST,C(42))
      ST = " 1.015467841223081888268990685530571588993883516806444440463590063" //  &
           "919246457993838714361388326407974316725799445869567226317393205847" //  &
           "41823934922206879509013719077372316295552261963694116207153809783055715M-21"
      CALL FMST2M(ST,C(43))
      ST = " 3.384890111197057663463016207436882653098338276290627817566949828" //  &
           "395298842402236802648447435554701889903014892066703092691102459316" //  &
           "42305364341869125221913232186873905776329877020426296097438946487577807M-22"
      CALL FMST2M(ST,C(44))
      ST = " 1.128296030524118217901770376786986056339519574517002442090074882" //  &
           "057280000658483297467423203305781809303690428354763800658686040236" //  &
           "71779144955091790824204211870513439500061673502868286865350206893118470M-22"
      CALL FMST2M(ST,C(45))
      ST = " 3.760985085416611180417555002274204359368768836382888775095377932" //  &
           "135470299750400345139854657192126020629674958772171673259844584632" //  &
           "29740983608860531344547744626628209787912508838546108351215194899892193M-23"
      CALL FMST2M(ST,C(46))
      ST = " 1.253661274394284819616871799214565550306261501251793404757960132" //  &
           "128170781722119090896566129331363704599359253979761928823159537461" //  &
           "94504254386899126662346756986738717779547048333427719023221981595254954M-23"
      CALL FMST2M(ST,C(47))
      ST = " 4.178869862795538345454967070155508575326951978759241233273121057" //  &
           "066301381631679857138532781845567887396083218733585140280524330791" //  &
           "93670559242093402244963076978237398106292624308475677695772071716993274M-24"
      CALL FMST2M(ST,C(48))
      ST = " 1.392956357970703804166482382560887146464466644976989900838409857" //  &
           "521105907861179378438919270011579646317439048476258541449951226731" //  &
           "38419505723140506483598868257584439349831369024815848605796104120125198M-24"
      CALL FMST2M(ST,C(49))
      ST = " 4.643187202503244267904840086459603070244180285978311534148487451" //  &
           "448533368113912140098658002328251742282983537128133995397515041612" //  &
           "48378614922938242264999090255128209599611777303756393485557336865892384M-25"
      CALL FMST2M(ST,C(50))
      ST = " 1.547728903152056758023013339236654329438934392366540425603322082" //  &
           "857263082844161081125623346144761860535134488231475517768722978006" //  &
           "97598742236912925627747252856046998990338903727397536889459369962969529M-25"
      CALL FMST2M(ST,C(51))
      ST = " 5.159095932969129018305623899832229004426259340923333088824701344" //  &
           "793799573384328764667708388371262541343393211413511112875917018796" //  &
           "26630534722311094084888639746029822030436534231881230203368649013498048M-26"
      CALL FMST2M(ST,C(52))
      ST = " 1.719698541605578250055328719172355061652680958536807515991957911" //  &
           "829231225440009541518975734286993664349423799759754184346111779848" //  &
           "98079517451175822251033508127845088987176652373067048423597073312187144M-26"
      CALL FMST2M(ST,C(53))
      ST = " 5.732328215225532836270189877348903743690272187963364883413404892" //  &
           "515967840972047550982297271962784377794755127033081531768642894199" //  &
           "64735397060888178165089361563869938931990240827823701959473704067979558M-27"
      CALL FMST2M(ST,C(54))
      ST = " 1.910776007543699055364968001468624686158867348024934230266622903" //  &
           "018662755804722736204383531033467520086936412589269186167968820789" //  &
           "31707316415310370070101583553225900248595006769483528789991489268005919M-27"
      CALL FMST2M(ST,C(55))
      ST = " 6.369253197983874006821823217108741793471311336545161803572473280" //  &
           "581604669538018391744708133203440680673579856484395859330652484509" //  &
           "72888929728309163536568371996260645727875086529584444740409818707168597M-28"
      CALL FMST2M(ST,C(56))
      ST = " 2.123084359204225333255211453879706270058062440003428132183384754" //  &
           "529220299115266894193502387449244415133870841331224790006731846829" //  &
           "83950869831354206398680371015186352923965072680137000319344572605758909M-28"
      CALL FMST2M(ST,C(57))
      ST = " 7.076947763704848854568916919680447890729663289024670563717349289" //  &
           "716854593909643699182828273092172522117888394772977756940206908939" //  &
           "88161833503128621124125052157189818939182888192518392960394844544910580M-29"
      CALL FMST2M(ST,C(58))
      ST = " 2.358982562824326603834177965008914574063289371087237954036406546" //  &
           "340493525463133458597261132503854782619333331885562197138535071408" //  &
           "23201579847913351266307691059142085404786612749993269600147335936631424M-29"
      CALL FMST2M(ST,C(59))
      ST = " 7.863275146721236242647451555165511648580559926859636607085030645" //  &
           "828570768337179488776594015720853254496569344629950772241890794413" //  &
           "09501208585846001333592788550065884722420498762308117260230188148248777M-30"
      CALL FMST2M(ST,C(60))
      ST = " 2.621091699900456658110115330583854052361897297784388638216583319" //  &
           "454384526174907954107229789803487469826658513137203063896172131706" //  &
           "68596675776534544455338620395186907938046711829117294010990223395191200M-30"
      CALL FMST2M(ST,C(61))
      ST = " 8.736972293818315676196547510693128031654563870400207411221472197" //  &
           "802537238798558154077761157016481387194295979174198832797107057716" //  &
           "55476119097180397397991205334340641881095558538017176052985551441032265M-31"
      CALL FMST2M(ST,C(62))
      ST = " 2.912324088143640003892515793451613942403905838900460353749079195" //  &
           "711293166403329382629400828420996934679831800044190489170302330372" //  &
           "89702647828398182289986576193569329546458981411599932131292250327217139M-31"
      CALL FMST2M(ST,C(63))
      ST = " 9.707746935989309774922153324275043050136559616419228148856384390" //  &
           "891207031590122433573161121435856761535255587985039419083521928281" //  &
           "47684192432450134453307134064460958883080711047615861323976659104916668M-32"
      CALL FMST2M(ST,C(64))
      ST = " 3.235915639207398595265693615961166003757636977735808496558273648" //  &
           "928958056872747435108942393361659134982792854945130370217146958406" //  &
           "96083858500218202729498941860260710013473689957089195606216847161948489M-32"
      CALL FMST2M(ST,C(65))
      ST = " 1.078638544871873611955050957012575767956166828939502396913361632" //  &
           "134006203107387187862076294858437749004255229312668679921800233056" //  &
           "74417612290238598612397811829199658493331617719065112441605814593748378M-32"
      CALL FMST2M(ST,C(66))
      ST = " 3.595461812413097732268985825592100369404790978561873060558407383" //  &
           "209843595084925537819419221457817216101556873881028197503043710989" //  &
           "71993446117511506289219252721788791857419650690058381970466123873747686M-33"
      CALL FMST2M(ST,C(67))
      ST = " 1.198487269847745765578016200858552396971801017866213814921147936" //  &
           "194342329888616529805943628521815471009477410250705796740507122991" //  &
           "05724055220198767971701073860808057115160815984757015916251499607980512M-33"
      CALL FMST2M(ST,C(68))
      ST = " 3.994957563767602385747901769948142409291248613545961370363883891" //  &
           "289691397311922302379137927297721501329041681797620724073370767562" //  &
           "18203408450216245071443700831249773241142322486002435752961943222542254M-34"
      CALL FMST2M(ST,C(69))
      ST = " 1.331652520657979959724598554013660845601546719077233063789633368" //  &
           "960435001352641490522946960948433409671303505299895763210435682642" //  &
           "64618257123231948431647534610234863412519330901304158646595801812800221M-34"
      CALL FMST2M(ST,C(70))
      ST = " 4.438841734031881188976818132822337642864369008251133361954967150" //  &
           "427526248489023180060951578854782817826656197035293616050385245228" //  &
           "69777224342488088789975020608283234140930896389710286843599614310829011M-35"
      CALL FMST2M(ST,C(71))
      ST = " 1.479613910970280742873945057507129611414800958022743884631361380" //  &
           "691798159539547487537052914060034185767422767130178282321602757860" //  &
           "83348663879834983529553026971940768027904120497673742153199914849116728M-35"
      CALL FMST2M(ST,C(72))
      ST = " 4.932046368966736707433238163653472803158736679721922230398981807" //  &
           "148509857901058886361798749120231700519606437174141329665127637580" //  &
           "60684029229789780624847253236488984529122857484143590545454988280087620M-36"
      CALL FMST2M(ST,C(73))
      ST = " 1.644015456088695799904278450146142178669043440878937685558456872" //  &
           "964025555598274081805412440896705440428517289000442501284221387694" //  &
           "55648732942491166386921283069386388704660866255758554699458240090291278M-36"
      CALL FMST2M(ST,C(74))
      ST = " 5.480051519711778255840272708324976030739754268948537269674402054" //  &
           "568534364217773209485346648013194520472068667682265478950114643548" //  &
           "57817502762576875030228023959898997369951420244275748984693326649040707M-37"
      CALL FMST2M(ST,C(75))
      ST = " 1.826683839757957485171861873006044105081660879173944661934615164" //  &
           "058228248983434414103054534197242809510738787922754612090096010008" //  &
           "32972234391112427466530639806131521397347115826207673334357276487387067M-37"
      CALL FMST2M(ST,C(76))
      ST = " 6.088946132161603455339501324095998745526413263096303935940878780" //  &
           "526359496483279209617877435619263014735196336319313697924877016533" //  &
           "09653632325766553783756318556864993407257715531353455924785891667301524M-38"
      CALL FMST2M(ST,C(77))
      ST = " 2.029648710629304112312264073466486255977035674544143740902384580" //  &
           "066925825480897303013099124850654602496048781418796500497911435814" //  &
           "55895496319542786203501573229289360635504754435873888697991558050538067M-38"
      CALL FMST2M(ST,C(78))
      ST = " 6.765495701869604444386835156000328903984913424070294867383326826" //  &
           "380125179490385914541280070377395224806865489400873522529357739540" //  &
           "13593097642976584317974244356761507356447028338622758884083690956549688M-39"
      CALL FMST2M(ST,C(79))
      ST = " 2.255165233899515832701742852677093869944624882375775392021565853" //  &
           "727820148309140426329940190201858812882180125645736863330093959501" //  &
           "39799185623421035440349003272811535983000708934970150324591131369976675M-39"
      CALL FMST2M(ST,C(80))
      ST = " 7.517217446189171987910422000959627404182160006415193289405563037" //  &
           "073141918979212912887404738051712797448922513382013488736054976966" //  &
           "44850928549751713769786767895881754130344984097285305963557272547145616M-40"
      CALL FMST2M(ST,C(81))
      ST = " 2.505739148694087132524150695488551963220019249166337393102845297" //  &
           "929187685834976527612995960496060104814687111155509389611886823768" //  &
           "45665657833105762416203034605047428562380070279581109059970215759343049M-40"
      CALL FMST2M(ST,C(82))
      ST = " 8.352463828891198283454574490687921776166017804023933180339411723" //  &
           "551630949077812713723188475201183251308083861018090692334062700224" //  &
           "19315941542359676555596601655478811403243506810721773017251413934374514M-41"
      CALL FMST2M(ST,C(83))
      ST = " 2.784154609608126388309518953024776333056303224324599419154596270" //  &
           "687189694467353799519873714017939494084666475975688987152456659642" //  &
           "26654762776582515405508388836892873507912509482458807279902034848895589M-41"
      CALL FMST2M(ST,C(84))
      ST = " 9.280515365304738695722333964470955476404932927589213406274394075" //  &
           "824251507915677707145886824360137294712999378365268640074244947377" //  &
           "75283581062718625871709431187118953937401911092491908328625126927814924M-42"
      CALL FMST2M(ST,C(85))
      ST = " 3.093505121754325582272552779234873274821484670440649874514125833" //  &
           "450221430848146677414227286193944601969620041844899866725992046638" //  &
           "96302520509550456127533362858925937984066799183063861137995551939093475M-42"
      CALL FMST2M(ST,C(86))
      ST = " 1.031168373914628365020619376010732175534509522276934226759611010" //  &
           "510330113936747333958108874337789248731979567783939919999577683507" //  &
           "22523295728071715108784714082583918137083993400414421602035476389181042M-42"
      CALL FMST2M(ST,C(87))
      ST = " 3.437227913040060810736801880470831506837625258770689684886108518" //  &
           "300849420221764767894609466818173933155866849989575822424072255004" //  &
           "78234006087579117395941989824600255765731792341982892120664183263431722M-43"
      CALL FMST2M(ST,C(88))
      ST = " 1.145742637677845168748014850793946505879656739125856631649586463" //  &
           "591822853689599347930344326959430427527959142809100423533805439264" //  &
           "43279388738637495289806414123857142554621616733197424850302473869617722M-43"
      CALL FMST2M(ST,C(89))
      ST = " 3.819142125587379475420211530141217153875049185525247582904249203" //  &
           "019903748875977266231256469090038860233530356197288111009590135316" //  &
           "90898695851949084954771545562975566659699180249151895098720201541444897M-44"
      CALL FMST2M(ST,C(90))
      ST = " 1.273047375194433720039269643742156618287252568559809316454558670" //  &
           "180525454213261685018950248687574295353166212229651718103175620816" //  &
           "43760967542155803486826726482394407727128624904626495857158860946505910M-44"
      CALL FMST2M(ST,C(91))
      ST = " 4.243491250644713804047213900311521631782151086428302312117409417" //  &
           "778324805156532130172471108085960753421387148016192082165090341252" //  &
           "19545466280371097678329835612276755167203138210639186157532227100590980M-45"
      CALL FMST2M(ST,C(92))
      ST = " 1.414497083547388285661813522776106834139405615052171085969597516" //  &
           "047278841879024411976249475067654110853871648213868458414159189231" //  &
           "79891226179605118296023118379963942164595272691469246552143553753880550M-45"
      CALL FMST2M(ST,C(93))
      ST = " 4.714990278489170162988560867348152304757403878210496541497712053" //  &
           "006454958803147191193828617164924983154190125072717651655296406044" //  &
           "51236582999806300249260089437863523751237893569424876357019027689437850M-46"
      CALL FMST2M(ST,C(94))
      ST = " 1.571663426162525690358614617253775521309331567276009924639764177" //  &
           "358960165102899050236124157794756906336803102013665429067943394214" //  &
           "57838273206825762014705848617755003448485196508751247061517100802618351M-46"
      CALL FMST2M(ST,C(95))
      ST = " 5.238878087207091391268381971748475496510636983623239581337201528" //  &
           "761219196441713174722639342282806574120757748535810991181068549199" //  &
           "89053413431795493494028007267927630087829683052755847961739807896841957M-47"
      CALL FMST2M(ST,C(96))
      ST = " 1.746292695735365236274430121252895780353566878171851946466982282" //  &
           "916481274302755866597786442055146506112819565744487880483609437125" //  &
           "77321479855945945213560009077900564250744371125376843314616795699839063M-47"
      CALL FMST2M(ST,C(97))
      ST = " 5.820975652450387718877296368406106766373716711813705919181086521" //  &
           "999505975590854145900097731105648953941956782748776332821329494966" //  &
           "87768367928768066507060035439222042970126325626238817880646490785855621M-48"
      CALL FMST2M(ST,C(98))
      ST = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409601786683742364221787811915022144162851994955921858529462196970" //  &
           "10653973717672741870614055497821682510355774493997650251816154517127732M-48"
      CALL FMST2M(ST,C(99))
      ST = " 6.467750724943665212448072244898217344228281509203436692886144544" //  &
           "710488376123702904475209151820097662127258578415899891069730495416" //  &
           "37336243969682934496722083054141458419645859035208215900305459742433866M-49"
      CALL FMST2M(ST,C(100))
      ST = " 2.155916908314425424664368170497409014232503939749568528677540140" //  &
           "384039734094541956602791846039169318650021459160866243512075243331" //  &
           "45679505658773347404938241005432513933656138666470399349344701169458177M-49"
      CALL FMST2M(ST,C(101))
      ST = " 7.186389694381093966835437692494728822349002314959532010292364775" //  &
           "394946247059389433028322727013522877670270796020110428790305813054" //  &
           "79391776953852548570365845653848831536967043669276608555999675341559488M-50"
      CALL FMST2M(ST,C(102))
      ST = " 2.395463231460283626767035225609077295862357711256733986014148707" //  &
           "753272199463531514035780844426290282772850231675309468999618270293" //  &
           "06226615257093166993337223904134396989045750924820301622864539591983840M-50"
      CALL FMST2M(ST,C(103))
      ST = " 7.984877438200742850444847499777309845694641795079466763347310518" //  &
           "973477267679513036692556925499430697000376845097566527468301532263" //  &
           "68593074139587048157403440914703927108798266764367635240248126118737063M-51"
      CALL FMST2M(ST,C(104))
      ST = " 2.661625812733530307120299705689856310419430305299514816454219978" //  &
           "167720121577781636596013737099879504260242494410428404547299997096" //  &
           "29214426445076866714408263418452627026007712187686306994919339537176315M-51"
      CALL FMST2M(ST,C(105))
      ST = " 8.872086042444974416164378071031044765486837933978062891736690757" //  &
           "063302976670153482438120949026393088923322321063932750682909484640" //  &
           "80118939886335367290880449750827102760828907286267653373299382121005954M-52"
      CALL FMST2M(ST,C(106))
      ST = " 2.957362014148293153495637994224156508433858704035708219961848704" //  &
           "752814743630032704058576844386754167614614033997051904620347311738" //  &
           "61904345412997662020042929619746892567448362596680832152684925750243880M-52"
      CALL FMST2M(ST,C(107))
      ST = " 9.857873380494231381920907655510228783611078844545021454399920772" //  &
           "141062619227406263790226964711069068688447840761328895136653289698" //  &
           "66981214088475384265075552305006338119605469313298818722398857563732976M-53"
      CALL FMST2M(ST,C(108))
      ST = " 3.285957793498057344874164686873206738067743142840216191903487618" //  &
           "019941680979531742712197349882728018267551869210987929616034749064" //  &
           "30303538626114994902987549690732156800575304242342439460223044767290112M-53"
      CALL FMST2M(ST,C(109))
      ST = " 1.095319264499347502683187139319325563979656486096742174653628128" //  &
           "976581637422575945930267442158932925061363256302618217044235776727" //  &
           "78289678865564842523041070219617158649346807209669750276034200426122137M-53"
      CALL FMST2M(ST,C(110))
      ST = " 3.651064214997812644923454493506674835323388056021714399807493703" //  &
           "605967302048397979154313095594794645711111183057404193592791956678" //  &
           "66172552061879738476243285533776439739119193738969145723129786576511450M-54"
      CALL FMST2M(ST,C(111))
      ST = " 1.217021404999267790636025855753778604335807084870166221152973014" //  &
           "506916159759972779875308117306931009803008009678064932776645093318" //  &
           "00842098229392080507684746488956996056988713932200497206909259105378943M-54"
      CALL FMST2M(ST,C(112))
      ST = " 4.056738016664218241273938781923458650417321982457636718798922936" //  &
           "477302304740685369168107498238001936713766023175775737524892409160" //  &
           "01634272341340971077361157145530586562647498591786411480985240150120553M-55"
      CALL FMST2M(ST,C(113))
      ST = " 1.352246005554737481879776083250264536787105289190169898749791140" //  &
           "348233188200740056915744202769004512689087720776827335229272164151" //  &
           "84364840446652924162659286494044457495071328336364564380197269062778195M-55"
      CALL FMST2M(ST,C(114))
      ST = " 4.507486685182453443237078181203119239131669164992680684219261837" //  &
           "277644454396847551795676165306867658683702735066801164086167252711" //  &
           "19484010084871947031012001315393818015815520382515662702573278448350109M-56"
      CALL FMST2M(ST,C(115))
      ST = " 1.502495561727483273655148872429157437910868921767186291387141573" //  &
           "512573119402964065902228084442655668385002115354783777594857713998" //  &
           "29523050153288241379342972449409357035473017504499197092941874010814147M-56"
      CALL FMST2M(ST,C(116))
      ST = " 5.008318539091607893624136610372602345176507591543467689236137943" //  &
           "884673550591046086592830872513439140608629637038740043915787148541" //  &
           "52394870950686380101306680838055095132070888200259040353691065606620624M-57"
      CALL FMST2M(ST,C(117))
      ST = " 1.669439513030535209901455630134076834170615280098683744729402670" //  &
           "296396657337808597037921736436660468249832659227172779367140247404" //  &
           "03362990043020714217884143429674645399729964793508983794394882884002423M-57"
      CALL FMST2M(ST,C(118))
      ST = " 5.564798376768448813071710669353659573416270465590122350543315121" //  &
           "413388656111319238743752535035180158976403027283093627581775200347" //  &
           "08950549480561185545001882864566882001602568174009919346046996759045750M-58"
      CALL FMST2M(ST,C(119))
      ST = " 1.854932792256149132707284865787646721627824417634136205769228907" //  &
           "351320889807301200265876310886504825399338639660085162561571671143" //  &
           "80178781198866361165024767169800779385647991333075996890986127709064413M-58"
      CALL FMST2M(ST,C(120))
      ST = " 6.183109307520495929899402826852708229420151109621107470264900121" //  &
           "134345986789710812316854495785567736467232785746686941727193331941" //  &
           "56103871513252933011548432169303614875570158457053586066135942237566488M-59"
      CALL FMST2M(ST,C(121))
      ST = " 2.061036435840165015185247594351604598673466050924812223481238383" //  &
           "744650549307488207514436927186243454249400309582767262472952477865" //  &
           "39488089477469737100729325446476505038057243548633416390135776998909246M-59"
      CALL FMST2M(ST,C(122))
      ST = " 6.870121452800549313664441945028230766782586053733765495536930184" //  &
           "148735432170307184364193773249356218482192867580453706078982702322" //  &
           "36906147589341063176294087284637487815185909131173012735635871205970777M-60"
      CALL FMST2M(ST,C(123))
      ST = " 2.290040484266849586983218139377689608197401631939278155837315152" //  &
           "749176998379162942186288612171254733497127165504629660957484257215" //  &
           "03960145633908464981886082313132803826782445898913850664341670496286810M-60"
      CALL FMST2M(ST,C(124))
      ST = " 7.633468280889498162681737525654781395094610920374961079941892134" //  &
           "693686042107521045090976432509818240749828811152884417434183792443" //  &
           "40208045334338980097933050903816256868615301460865703415771912193724986M-61"
      CALL FMST2M(ST,C(125))
      ST = " 2.544489426963165939078331773845571337558244149440634270398446661" //  &
           "730902552806699411443989280898922405978534154707887233634737588764" //  &
           "69277444899419995451128654151512085551424867809084295696469106990521519M-61"
      CALL FMST2M(ST,C(126))
      ST = " 8.481631423210552842388820742776895367676872160158770358942482422" //  &
           "735183525513672190915958631633045631581296672220414159119266677730" //  &
           "00882790484855601476924199497856972658319507003728226425960873810966916M-62"
      CALL FMST2M(ST,C(127))
      ST = " 2.827210474403517542161535621759888928745745898925998679999176972" //  &
           "500449767039313885942472306882332999282623012200216004408023722942" //  &
           "35548228163002484117039136830425719490113419540684925428659006215127579M-62"
      CALL FMST2M(ST,C(128))
      ST = " 9.424034914678391627284940507974624769084040519392748443016620129" //  &
           "151493273032159506798645125157903918497199981418255987213825116544" //  &
           "91313520782402912277192097971388451766192404480480266469096595803740649M-63"
      CALL FMST2M(ST,C(129))
      ST = " 3.141344971559463830781602278189827439570491126580879213267566098" //  &
           "634582653573961371388430476987677106802274861280003439184958337497" //  &
           "55871137194361985101053142410164165629409400589300651854575488722127625M-63"
      CALL FMST2M(ST,C(130))
      ST = " 1.047114990519821265682189619947088028639202210810159318824710297" //  &
           "418144878455534152843738752328520535580617712220747998447348456148" //  &
           "87128390653434870273058245640426383654361423379776610643883264096972007M-63"
      CALL FMST2M(ST,C(131))
      ST = " 3.490383301732737524161437551201638806706639111674055435356822668" //  &
           "242340068122359401431212212101510842260288841134358619348306937471" //  &
           "32292385947826289933592114188205257470612591292887863954967567373067619M-64"
      CALL FMST2M(ST,C(132))
      ST = " 1.163461100577579167692347221578745581156399690416630219259420060" //  &
           "140471624651128200456995286998175955667309375958539555927592191244" //  &
           "69108542176232753118949875989033621399852815112398485508138602381100101M-64"
      CALL FMST2M(ST,C(133))
      ST = " 3.878203668591930541404160833208709487069318555519787588536748926" //  &
           "079489227092349654317217820179356059640911818309293644987827038914" //  &
           "23113705652681321350172045452704473329699236304435049788227394174622197M-65"
      CALL FMST2M(ST,C(134))
      ST = " 1.292734556197310176075471134722937741048543949863716607618949311" //  &
           "134596575499614268058353886586544618677755951138400973297684683800" //  &
           "49929217081801053935564115665217627139106390261578300958135297518693689M-65"
      CALL FMST2M(ST,C(135))
      ST = " 4.309115187324367242603447591543502614635432074915146455974961100" //  &
           "783991800140039817841446475586229840527592677387439828807409996406" //  &
           "58572000140795436674747033557343891137764503605700790270107002153194098M-66"
      CALL FMST2M(ST,C(136))
      ST = " 1.436371729108122411455785149464652955014483913555925454567566343" //  &
           "033751539926464502402671954114290440329353433043868042553216356430" //  &
           "95760927792248401840769385171665086466412488627981015154342470344616262M-66"
      CALL FMST2M(ST,C(137))
      ST = " 4.787905763693741364655873712257673345968093702500400380413759009" //  &
           "343709671855218190105116076110599847270179980048633459127967075496" //  &
           "95329570740860986232312515609865359747150038120760918167660196395395859M-67"
      CALL FMST2M(ST,C(138))
      ST = " 1.595968587897913786502772040929797311513936155534630802777161042" //  &
           "323085710283013809416229252137018873920387828320283701537288724338" //  &
           "18222527779868222288064331588809401461453186408435455724607829956650895M-67"
      CALL FMST2M(ST,C(139))
      ST = " 5.319895292993045950719608811875781719400488218015940339624963833" //  &
           "904468790238424394665705538673163852924018058746539220799914498871" //  &
           "87123883979205073632821149986880853121193839902134978166092188353175974M-68"
      CALL FMST2M(ST,C(140))
      ST = " 1.773298430997681982500795106152343395146291244985375992301024831" //  &
           "172880492620523208419431056495256021417076918908947764372774801634" //  &
           "66308162036559401365955897830840212263006984532789801526556111330540563M-68"
      CALL FMST2M(ST,C(141))
      ST = " 5.910994769992273272321630775993113357374306776150164446878995429" //  &
           "199988365546454090281139320572057370171863201292260358152263114701" //  &
           "84849003352679924628129743645300899848128310062948455843231411729916686M-69"
      CALL FMST2M(ST,C(142))
      ST = " 1.970331589997424423436955364217490328008758498727308342596972914" //  &
           "838317948717210312982993577885955575234727205227508863543462414701" //  &
           "19790327280248261234206607030131137515730415891713737174983639027604997M-69"
      CALL FMST2M(ST,C(143))
      ST = " 6.567771966658081409780880644570952852212869394142774498275969597" //  &
           "051352302027804591436366292098249004955749719212407233759626410804" //  &
           "23094265521905707737671802871297906382006218125926665760693315871567840M-70"
      CALL FMST2M(ST,C(144))
      ST = " 2.189257322219360469508050905240435788723932139126639198455650265" //  &
           "181880562634665346793855787464756222043343074562742957750457331886" //  &
           "51136835170527293161085727720893207671856322049649329515124067695351675M-70"
      CALL FMST2M(ST,C(145))
      ST = " 7.297524407397868230646229744835872327874966073160276767231213689" //  &
           "623218792935837978230418401268856718201925396539510384196175753170" //  &
           "66652198429614667985969715027449338257278758408128943199367755324652975M-71"
      CALL FMST2M(ST,C(146))
      ST = " 2.432508135799289409953591617661733991864335564333111377209692880" //  &
           "074976374750213242253051652321561734041852268969020358465621089424" //  &
           "14424996317706067303976880419998421002358404179645130678096779653358570M-71"
      CALL FMST2M(ST,C(147))
      ST = " 8.108360452664298032524092931381732192579715420011362584102530122" //  &
           "399082594247638810857284958385615023239610775424662458807879174869" //  &
           "99208578767507795046313489342326234225642585624250987626962498888032182M-72"
      CALL FMST2M(ST,C(148))
      ST = " 2.702786817554766010677727150378738299179197264006681328494022283" //  &
           "461713062938474709283827967021738008108993688482511856757752986924" //  &
           "83022205593730217582984347916302439090400201412445704126518051302925734M-72"
      CALL FMST2M(ST,C(149))
      ST = " 9.009289391849220035183332673115118436689105231658609100131576105" //  &
           "746817524522178460300592879017536531814751063263253522537492214691" //  &
           "66287676119612980647194230638456363682773535596502263016913065096674627M-73"
      CALL FMST2M(ST,C(150))
      ST = " 3.003096463949740011625527637203839580670438558448697439316922582" //  &
           "080500699241877972753395936644410394325148621157014967621235051277" //  &
           "19702357955843408402299203602763881244696185804277033716869763248333675M-73"
      CALL FMST2M(ST,C(151))
      ST = " 1.001032154649913337182941137354579752756157403350587184082572655" //  &
           "668720365134577993101924383011283318540511319882434333492124758136" //  &
           "56328900549930706700593452010716708224185836746712866383541238461850333M-73"
      CALL FMST2M(ST,C(152))
      ST = " 3.336773848833044457211857959630261241457227305512566083673355396" //  &
           "481818433800591390918626541367515865084768432579659244905807486980" //  &
           "29134378942434319177868848768173954755492210535184756504211022367766391M-74"
      CALL FMST2M(ST,C(153))
      ST = " 1.112257949611014819054635753320402681213887420341206221531310860" //  &
           "985682956261502881389306545840511198169923612506852778221149565252" //  &
           "81459361368566900183720441504615495296290954141555036222396831117077406M-74"
      CALL FMST2M(ST,C(154))
      ST = " 3.707526498703382730161873261392491115828186807291897198915909604" //  &
           "155674067990161834342683376529820781124868349247913942628339699553" //  &
           "19187594923162356418905498458595704597809148916916571510786341062302288M-75"
      CALL FMST2M(ST,C(155))
      ST = " 1.235842166234460910044062971858447900664274034201950858925878124" //  &
           "083887957837752863211714821751135044697824600808010987957735653910" //  &
           "85021760966460551881259692413828184054079514253554146831394157759200228M-75"
      CALL FMST2M(ST,C(156))
      ST = " 4.119473887448203032928247987246026060335598144698999438082486484" //  &
           "981872504026407021712061503540785866057593612250257886109051123261" //  &
           "20553540800492774307915913243657294990555992068366814198248544293239073M-76"
      CALL FMST2M(ST,C(157))
      ST = " 1.373157962482734344300829830088785762819828470154677406792486349" //  &
           "582215434835624433211455183472833063222300779138846503724376654756" //  &
           "97153990917671843512951431419776274311910081550489091472125204982219742M-76"
      CALL FMST2M(ST,C(158))
      ST = " 4.577193208275781160871184364111765898905714315410964770181334551" //  &
           "559734462338946414187167832153901075953527960902149729732952392999" //  &
           "05739092117020357910064590291184764747354548289282230511803212990314666M-77"
      CALL FMST2M(ST,C(159))
      ST = " 1.525731069425260387008576333292791990843668717239246139931723054" //  &
           "113730949750810518714216058816633073359740920341684018573316882922" //  &
           "19161413294992398162552504179370639600545735768135221710078494678533369M-77"
      CALL FMST2M(ST,C(160))
      ST = " 5.085770231417534313032798702697681197383439273915544588375043156" //  &
           "982436257501835267954582765438953697752001176322824202363456833480" //  &
           "84822237757173265524313083452491401792161623828870993995239601500752613M-78"
      CALL FMST2M(ST,C(161))
      ST = " 1.695256743805844769784622112797766089615978935755501503220932068" //  &
           "343174291091693715417344263720144349029281513168498097220402832110" //  &
           "79996411923403065677514822313169241774858920814773828257766665033772313M-78"
      CALL FMST2M(ST,C(162))
      ST = " 5.650855812686156039255381634430268704055968949073218709347085199" //  &
           "742155287063313738806948673339105867918184157411397848315417982770" //  &
           "28216209989585045629974649193921980908524940232212434747464651403766044M-79"
      CALL FMST2M(ST,C(163))
      ST = " 1.883618604228718704942922337070948507896675501998486050379053659" //  &
           "203222058229334282486849245788565645787611354772468558241052640628" //  &
           "68090996198582244338892337657054683701568414292331480633193743238899042M-79"
      CALL FMST2M(ST,C(164))
      ST = " 6.278728680762256512149009149976440283047018296660977205232840187" //  &
           "711671745561355189005624289121525977497317264018845068610009630166" //  &
           "24422122072055952477161863795374233113339410369040977100353306447007727M-80"
      CALL FMST2M(ST,C(165))
      ST = " 2.092909560254085021920435547839978227290505174219696260063426880" //  &
           "879036670946017746113568504819405540190923727599189799888162522342" //  &
           "82688033004648088111864002916433340227047169032122354503266913856888244M-80"
      CALL FMST2M(ST,C(166))
      ST = " 6.976365200849595928568515913272594158672772019779337814697530205" //  &
           "514328112647957246760099455857571687826289491085647676946101437355" //  &
           "54833971648944261391739603826369822509790583940615701556419202194043338M-81"
      CALL FMST2M(ST,C(167))
      ST = " 2.325455066949873863606967397576505711197188840184692731505571050" //  &
           "057010126988203224760379663164013876837099897428308506101979830146" //  &
           "10509395537389044680077986544130564059305007513097257902320076380128891M-81"
      CALL FMST2M(ST,C(168))
      ST = " 7.751516889786273230333744396009595784689618339833872888076148749" //  &
           "510954270591897268986918218161521302808459344904049745958883339834" //  &
           "97636368620176777364813719377132199681517454923842508307735464876551893M-82"
      CALL FMST2M(ST,C(169))
      ST = " 2.583838963261950823751464199102541531987080961128181249653133059" //  &
           "486343391931814427787289188223115323267471180053604447425299309852" //  &
           "43333277896763688823725567334545875021894956285785557169534759498102028M-82"
      CALL FMST2M(ST,C(170))
      ST = " 8.612796544966339593464148319279864385495846603731409332903857040" //  &
           "341111578596179250787433586544432993469429659882790724588244062567" //  &
           "78136790746398664694553035857800597304056454220060017665421505719967290M-83"
      CALL FMST2M(ST,C(171))
      ST = " 2.870932181657563853682489496869596716118149568767000014172109841" //  &
           "753698478327036128411797178375480340579847035333592372289787795793" //  &
           "96627619330877369349750053557082939116418335842754914658257204585102926M-83"
      CALL FMST2M(ST,C(172))
      ST = " 9.569773927459502329189843968932453842109493094807395751883972275" //  &
           "108106634425357758674379648287072224301747951696615265196165041805" //  &
           "20236585969398304163224702023392754793840706634155432621406698219669058M-84"
      CALL FMST2M(ST,C(173))
      ST = " 3.189924642457193947274983048068918789864588583187967339730200869" //  &
           "383977309483707594218810831491599791827472770895338811393310795354" //  &
           "69234531929746996008196354596059905584934184315535092321474774208305020M-84"
      CALL FMST2M(ST,C(174))
      ST = " 1.063308229833233763649833968823830359312501010885534593366422641" //  &
           "631138341936187529001129656673501820789940104427992740873815715203" //  &
           "53412492554104141309331928436306992144198744553482555692829414468432600M-84"
      CALL FMST2M(ST,C(175))
      ST = " 3.544360766480896268661948406666249396818945618937640720661704673" //  &
           "296436347072454208561096669377429691244542539862734276732737789906" //  &
           "87985432036327462359694991859663225608649510569830536167392892074714882M-85"
      CALL FMST2M(ST,C(176))
      ST = " 1.181453391991692193233905477505817491959791629667967979777058345" //  &
           "391387128260137859898575835696679473316746285686162580343604354886" //  &
           "33746615556680423641254628884245686047585862162458511355057706178924765M-85"
      CALL FMST2M(ST,C(177))
      ST = " 3.938177969065104259816577437558454136986820863927184608342465808" //  &
           "644130213208017150749164656763736226904608349061342579349394401954" //  &
           "11955443745482049001748543874113465084785050139876732361231723529022225M-86"
      CALL FMST2M(ST,C(178))
      ST = " 1.312728231460229835781775849221721497298632770454454059027673781" //  &
           "147657857867325372034109920647863595009065024284231880168892910826" //  &
           "53488283009582034319652319525792167583043745345137953029043134270740314M-86"
      CALL FMST2M(ST,C(179))
      ST = " 4.375760815315077535413782421712416021566276398233684094737691912" //  &
           "768825492780444215747826165057411744207345952312538488710400858828" //  &
           "27700668026171627589196059317745967100234000846254430975531508363872519M-87"
      CALL FMST2M(ST,C(180))
      ST = " 1.458563929048378339389356324275832391447007080182288931684002700" //  &
           "009472184445323295339567304943041273340490012950372985830518037286" //  &
           "27460201464773612755677066535469683435847032008950889605333804095236722M-87"
      CALL FMST2M(ST,C(181))
      ST = " 4.861879359454319859107850617575234255777767433683221708284430699" //  &
           "990829575672698923326870227967687183467108336363217071248382357963" //  &
           "22818905179326628057052156616846776700350617514896748728636343647107755M-88"
      CALL FMST2M(ST,C(182))
      ST = " 1.620837575639336717669585897558965566795189581102158562505695709" //  &
           "761058058214152430539033470517727442776271455644632399079159816470" //  &
           "13032790990474394168725899077889253682309738675257461400762111892656053M-88"
      CALL FMST2M(ST,C(183))
      ST = " 5.402795219201229254205870902900594939962067229843983888917879564" //  &
           "569447106085277432976440651841249190437245953800537313805443864980" //  &
           "06342541344494885255739000367067646594242251182208803771724906930826406M-89"
      CALL FMST2M(ST,C(184))
      ST = " 1.799216964519093606731219963783752545188788013842673930468641591" //  &
           "448479933065901726577672674840349510506058583228709079379586399536" //  &
           "92651555915483777543359909186871398885320260440340033124792023837781809M-89"
      CALL FMST2M(ST,C(185))
      ST = " 5.997366309057088767075298231986828202847652039333576421385057338" //  &
           "145629178278871106675461140725723229061908016307033578803459780175" //  &
           "07666172639242691690123978056031089958911595034842389306632163036435150M-90"
      CALL FMST2M(ST,C(186))
      ST = " 2.011301294926252140726390741032210138299321852132295904710257720" //  &
           "158209117243470457856408196331997445864262615242552875300814542975" //  &
           "47170830674630176097026011113551746496002275896336822879606882224230602M-90"
      CALL FMST2M(ST,C(187))
      ST = " 6.704482593621562564692937104577317810644610039525202376129260569" //  &
           "861749723553513086341477081381278126242511169725032335903896422492" //  &
           "18854955408659222455853625926956312559220163444056344847372949727294762M-91"
      CALL FMST2M(ST,C(188))
      ST = " 2.160351395289544486253226495324951606774126604957407637555483550" //  &
           "521132050784441566021695109519541771023447038718264653048827134039" //  &
           "73414393141529555898480576201941789130545638907969682039980597723815399M-91"
      CALL FMST2M(ST,C(189))
      ST = " 7.200419569439204992397584876133276247439864059745857658513848169" //  &
           "634972230829808411159889094321665351721254003922021586700615812024" //  &
           "99355813646045295572813794504886619128172862586448322114482098387570581M-92"
      CALL FMST2M(ST,C(190))
      ST = " 2.784319712626698759566047586489485590648301900234226820496273235" //  &
           "253278946132569789086775657480520424132403062835830911025372468898" //  &
           "94806632232823225075878972837000029411691959653897178979682691313860829M-92"
      CALL FMST2M(ST,C(191))
      ST = " 9.284263699802481030477812401350944543556932743559221880685236144" //  &
           "608807942910647790463633201299242608070391986248492383364489375260" //  &
           "66506636257311455988821088223165685964257289358894735278070005979762986M-93"
      CALL FMST2M(ST,C(192))
      ST = " 1.469128321729119845643781712942080844517377977136622326900618953" //  &
           "248797751416855621723808444613828590416570423767280724666117572301" //  &
           "34285990191248448522554726873193884488157002183510418398417800853692970M-93"
      CALL FMST2M(ST,C(193))
      ST = " 4.886379978539319342120523930953291961277105452075509621364036950" //  &
           "981474984583217822110836621562995692449070713522036826314376565947" //  &
           "22694606242271109407828035720163781683675686187162678102051578537829111M-94"
      CALL FMST2M(ST,C(194))
      ST = " 7.046670647920504479063475010556879295393094797174920722994400551" //  &
           "715505897095883223398696557122758497726817737906295249088240133320" //  &
           "85226292447629611992116676332110323776745430326383013890000067486498923M-94"
      CALL FMST2M(ST,C(195))
      ST = " 2.351541158501990523752731749555092275030088173405523455954546630" //  &
           "113446321330723773662111826297238234224538212221014494477821368974" //  &
           "29678996883123994564079639022862654561283884722866834645277830050207084M-94"
      CALL FMST2M(ST,C(196))

      NDIG = NDSAVE

      END SUBROUTINE FMPSI_C

      SUBROUTINE FMWRN2

!  Called by one of the FM routines to print a warning message if any error condition arises
!  in that routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NAME

      INTEGER :: NCS

      IF (KFLAG >= 0 .OR. NCALL /= 1 .OR. KWARN <= 0) RETURN
      NCS = NCALL
      NAME = NAMEST(NCALL)
      WRITE (KW,                                   &
             "(/' Error of type KFLAG =',I3,"  //  &
             "' in FM package in routine ',A/)"    &
            ) KFLAG,TRIM(NAME)

  110 NCALL = NCALL - 1
      IF (NCALL > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (KFLAG == -3) THEN
          WRITE (KW,                                                     &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -4 .OR. KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (KFLAG == -8) THEN
          WRITE (KW,                                                          &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (KFLAG == -9) THEN
          WRITE (KW,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,                                        &
                 "(I23,' digits were requested (NDIG).'/)"  &
                ) NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -10) THEN
          IF (NAMEST(NCS) == 'FMM2SP') THEN
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to single precision.'/)"                      &
                    )
          ELSE
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to double precision.'/)"                      &
                    )
          ENDIF
          WRITE (KW,"(' Zero has been returned.'/)")
      ELSE IF (KFLAG == -11) THEN
          WRITE (KW,"(' Array MBERN is not large enough.')")
      ELSE IF (KFLAG == -12) THEN
          WRITE (KW,"(' Array MJSUMS is not large enough.')")
      ENDIF

      NCALL = NCS
      IF (KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE FMWRN2

!  These are the longer and more readable routine names, equivalent to the older names.

      SUBROUTINE FMATAN2(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMATN2(MA,MB,MC)
      RETURN
      END SUBROUTINE FMATAN2

      SUBROUTINE FMCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE FMCOSH_SINH

      FUNCTION FMCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: FMCOMPARE
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      FMCOMPARE = FMCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION FMCOMPARE

      SUBROUTINE FMCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE FMCOS_SIN

      SUBROUTINE FMEULER(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FMEULR(MA)
      RETURN
      END SUBROUTINE FMEULER

      SUBROUTINE FMFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL FMFPRT(FORM,MA)
      RETURN
      END SUBROUTINE FMFPRINT

      SUBROUTINE FMIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      CALL FMIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE FMIPOWER

      SUBROUTINE FMLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      CALL FMLG10(MA,MB)
      RETURN
      END SUBROUTINE FMLOG10

      SUBROUTINE FMPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FMPRNT(MA)
      RETURN
      END SUBROUTINE FMPRINT

      SUBROUTINE FMPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE FMPOWER

      SUBROUTINE FMRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL,JVAL
      CALL FMRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE FMRATIONAL_POWER

      SUBROUTINE FMWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL FMWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE FMWRITE

      FUNCTION IMCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: IMCOMPARE
      LOGICAL, EXTERNAL :: IMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      IMCOMPARE = IMCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION IMCOMPARE

      SUBROUTINE IMFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL IMFPRT(FORM,MA)
      RETURN
      END SUBROUTINE IMFPRINT

      SUBROUTINE IMMPY_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IMMPYM(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IMMPY_MOD

      SUBROUTINE IMPOWER_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IMPMOD(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IMPOWER_MOD

      SUBROUTINE IMPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL IMPRNT(MA)
      RETURN
      END SUBROUTINE IMPRINT

      SUBROUTINE IMPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL IMPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE IMPOWER

      SUBROUTINE IMWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL IMWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE IMWRITE

      SUBROUTINE ZMCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZMCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE ZMCOSH_SINH

      SUBROUTINE ZMCOMPLEX(MAFM,MBFM,MC)
      IMPLICIT NONE
      INTEGER :: MAFM,MBFM,MC(2)
      CALL ZMCMPX(MAFM,MBFM,MC)
      RETURN
      END SUBROUTINE ZMCOMPLEX

      SUBROUTINE ZMCONJUGATE(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZMCONJ(MA,MB)
      RETURN
      END SUBROUTINE ZMCONJUGATE

      SUBROUTINE ZMCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZMCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE ZMCOS_SIN

      SUBROUTINE ZMFPRINT(FORM1,FORM2,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      INTEGER :: MA(2)
      CALL ZMFPRT(FORM1,FORM2,MA)
      RETURN
      END SUBROUTINE ZMFPRINT

      SUBROUTINE ZMIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL
      CALL ZMIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE ZMIPOWER

      SUBROUTINE ZMLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZMLG10(MA,MB)
      RETURN
      END SUBROUTINE ZMLOG10

      SUBROUTINE ZMPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA(2)
      CALL ZMPRNT(MA)
      RETURN
      END SUBROUTINE ZMPRINT

      SUBROUTINE ZMPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZMPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE ZMPOWER

      SUBROUTINE ZMRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      CALL ZMRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE ZMRATIONAL_POWER

      SUBROUTINE ZMWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA(2)
      CALL ZMWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE ZMWRITE

      SUBROUTINE FPATAN2(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPATN2(MA,MB,MC)
      RETURN
      END SUBROUTINE FPATAN2

      SUBROUTINE FPCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE FPCOSH_SINH

      FUNCTION FPCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: FPCOMPARE
      LOGICAL, EXTERNAL :: FPCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      FPCOMPARE = FPCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION FPCOMPARE

      SUBROUTINE FPCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE FPCOS_SIN

      SUBROUTINE FPEULER(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FPEULR(MA)
      RETURN
      END SUBROUTINE FPEULER

      SUBROUTINE FPFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL FPFPRT(FORM,MA)
      RETURN
      END SUBROUTINE FPFPRINT

      SUBROUTINE FPIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      CALL FPIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE FPIPOWER

      SUBROUTINE FPLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      CALL FPLG10(MA,MB)
      RETURN
      END SUBROUTINE FPLOG10

      SUBROUTINE FPPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FPPRNT(MA)
      RETURN
      END SUBROUTINE FPPRINT

      SUBROUTINE FPPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE FPPOWER

      SUBROUTINE FPRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL,JVAL
      CALL FPRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE FPRATIONAL_POWER

      SUBROUTINE FPWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL FPWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE FPWRITE

      FUNCTION IPCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: IPCOMPARE
      LOGICAL, EXTERNAL :: IPCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      IPCOMPARE = IPCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION IPCOMPARE

      SUBROUTINE IPFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL IPFPRT(FORM,MA)
      RETURN
      END SUBROUTINE IPFPRINT

      SUBROUTINE IPMPY_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IPMPYM(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IPMPY_MOD

      SUBROUTINE IPPOWER_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IPPMOD(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IPPOWER_MOD

      SUBROUTINE IPPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL IPPRNT(MA)
      RETURN
      END SUBROUTINE IPPRINT

      SUBROUTINE IPPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL IPPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE IPPOWER

      SUBROUTINE IPWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL IPWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE IPWRITE

      SUBROUTINE ZPCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZPCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE ZPCOSH_SINH

      SUBROUTINE ZPCOMPLEX(MAFM,MBFM,MC)
      IMPLICIT NONE
      INTEGER :: MAFM,MBFM,MC(2)
      CALL ZPCMPX(MAFM,MBFM,MC)
      RETURN
      END SUBROUTINE ZPCOMPLEX

      SUBROUTINE ZPCONJUGATE(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZPCONJ(MA,MB)
      RETURN
      END SUBROUTINE ZPCONJUGATE

      SUBROUTINE ZPCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZPCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE ZPCOS_SIN

      SUBROUTINE ZPFPRINT(FORM1,FORM2,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      INTEGER :: MA(2)
      CALL ZPFPRT(FORM1,FORM2,MA)
      RETURN
      END SUBROUTINE ZPFPRINT

      SUBROUTINE ZPIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL
      CALL ZPIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE ZPIPOWER

      SUBROUTINE ZPLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZPLG10(MA,MB)
      RETURN
      END SUBROUTINE ZPLOG10

      SUBROUTINE ZPPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA(2)
      CALL ZPPRNT(MA)
      RETURN
      END SUBROUTINE ZPPRINT

      SUBROUTINE ZPPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZPPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE ZPPOWER

      SUBROUTINE ZPRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      CALL ZPRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE ZPRATIONAL_POWER

      SUBROUTINE ZPWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA(2)
      CALL ZPWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE ZPWRITE

!             Packed versions of routines for special functions.

      SUBROUTINE FPBERNOULLI(INTVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: INTVAL
      INTENT (IN) :: INTVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMBERNOULLI(INTVAL,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBERNOULLI

      SUBROUTINE FPBERN(INTVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: INTVAL
      INTENT (IN) :: MA,INTVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMBERN(INTVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBERN

      SUBROUTINE FPBETA(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMBETA(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBETA

      SUBROUTINE FPCMBI(N,K,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: K,N
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMCMBI(N,K,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCMBI

      SUBROUTINE FPCOMB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMCOMB(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCOMB

      SUBROUTINE FPEULR(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEULR(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEULR

      SUBROUTINE FPFACT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMFACT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPFACT

      SUBROUTINE FPGAM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMGAM(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPGAM

      SUBROUTINE FPIBTA(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMUNPK(MC,MPC)
      CALL FMIBTA(MPA,MPB,MPC,MPD)
      CALL FMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIBTA

      SUBROUTINE FPIGM1(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMIGM1(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIGM1

      SUBROUTINE FPIGM2(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMIGM2(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIGM2

      SUBROUTINE FPLNGM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLNGM(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLNGM

      SUBROUTINE FPPGAM(N,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: N
      INTENT (IN) :: MA,N
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPGAM(N,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPGAM

      SUBROUTINE FPPOCH(MA,N,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: N
      INTENT (IN) :: MA,N
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPOCH(MPA,N,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPOCH

      SUBROUTINE FPPSI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPSI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPSI


!     FM exponential integral and related functions

!  Here is a list of the routines that are designed to be called by the user:


!  FMBESJ(N,MA,MB)      MB = J(N,MA)   Bessel function of the first kind.

!  FMBESY(N,MA,MB)      MB = Y(N,MA)   Bessel function of the second kind.

!  FMC(MA,MB)           MB = C(MA)     Fresnel Cosine Integral

!  FMCHI(MA,MB)         MB = Chi(MA)   Hyperbolic Cosine Integral

!  FMCI(MA,MB)          MB = Ci(MA)    Cosine Integral

!  FMEI(MA,MB)          MB = Ei(MA)    Exponential Integral

!  FMEN(N,MA,MB)        MB = E(N,MA)   Exponential Integral E_n

!  FMERF(MA,MB)         MB = Erf(MA)   Error function

!  FMERFC(MA,MB)        MB = Erfc(MA)  Complimentary Error function

!  FMLERC(MA,MB)        MB = Ln(Erfc(MA))  Log Erfc

!  FMLI(MA,MB)          MB = Li(MA)    Logarithmic Integral

!  FMS(MA,MB)           MB = S(MA)     Fresnel Sine Integral

!  FMSHI(MA,MB)         MB = Shi(MA)   Hyperbolic Sine Integral

!  FMSI(MA,MB)          MB = Si(MA)    Sine Integral

!  For each of these routines there is also a version available for which the argument list is the
!  same but all FM numbers are in packed format.  The packed versions have the same names except
!  'FM' is replaced by 'FP' at the start of each name.

! --------------------------------------------------------------------------------------------------

      SUBROUTINE FMBESJ(N,MA,MB)

!  MB = Bessel J(N,MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      DOUBLE PRECISION :: CBIG,CKLOG,CRHS,DBIG,DKLOG,DRHS,ERR,FMDPLG,X,XLOG
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KD,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NDGOAL,NDIG2,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. N >= 0 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMDIVI(MXY(1),2,MXY(3))
          CALL FMIPWR(MXY(3),N,MXY(2))
          CALL FMI2M(N,MXY(4))
          CALL FMFACT(MXY(4),MXY(5))
          CALL FMDIV(MXY(2),MXY(5),MXY(4))
          CALL FMMPY(MXY(4),MXY(3),MXY(5))
          CALL FMMPY(MXY(5),MXY(3),MXY(6))
          CALL FMDIVI(MXY(6),N+1,MXY(5))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMSUB(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) > 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMBESJ'
                  CALL FMNTRI(2,N,1)
                  CALL FMNTR(2,MA,MA,1,0)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBESJ'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMBESJ   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

  120 IF (N < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12))
          KFLAG = -4
          GO TO 210
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          IF (N == 0) THEN
              CALL FMI2M(1,MXY(12))
          ELSE
              CALL FMI2M(0,MXY(12))
          ENDIF
          GO TO 210
      ENDIF
      IF (2*MWK(START(MXY(1))+2) < -NDIG-1) THEN
          CALL FMDIVI(MXY(1),2,MXY(12))
          CALL FMIPWR(MXY(12),N,MXY(15))
          CALL FMFCTI(N,MXY(14))
          CALL FMDIV(MXY(15),MXY(14),MXY(12))
          GO TO 190
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      NMETHD = 1
      CALL FMABS(MXY(1),MXY(15))
      CKLOG = MWK(START(MXY(15))+2)
      MWK(START(MXY(15))+2) = 0
      CALL FMM2DP(MXY(15),XLOG)
      XLOG = LOG(XLOG) + CKLOG*DLOGMB

!             c(k) is the absolute value of the kth term of the convergent series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      CRHS = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1)) - NDIG*DLOGMB - 20*DLOGTN

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      DRHS = N
      DRHS = MIN(0.0D0,LOG(ABS(4*DRHS*DRHS-1))-XLOG-3*DLOGTW) - NDIG*DLOGMB - 20*DLOGTN - 50

      CBIG = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1))
      DBIG = 1
      K = 1
      DO J = 0, 50
         K = 2*K
         CKLOG = (2*K+N)*XLOG - (2*K+N)*DLOGTW - FMDPLG(DBLE(K+1)) - FMDPLG(DBLE(N+K+1))
         CBIG = MAX(CBIG,CKLOG)
         IF (CKLOG < CRHS) THEN
             NMETHD = 1
             IF (NUMTRY == 0) THEN
                 CKLOG = MIN(0.0D0,N*XLOG - N*DLOGTW - FMDPLG(DBLE(N+1)))
                 IEXTRA = ((CBIG-CKLOG)/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
         KD = K/2
         IF (N-2*KD < 0) THEN
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) + FMDPLG(DBLE(2*KD-N+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ELSE
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) - FMDPLG(DBLE(N-2*KD+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ENDIF
         DBIG = MAX(DBIG,DKLOG)
         IF (DKLOG < DRHS) THEN
             NMETHD = 2
             IF (NUMTRY == 0) THEN
                 IEXTRA = (DBIG/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
      ENDDO
      IF (KR_RETRY <= 0 .AND. NCALL <= 1 .AND. N <= 100) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      IF (NMETHD == 2) GO TO 160

!             Method 1.  Sum the convergent series.
!                        J(n,x) = Sum( (-1)^k (x/2)^(2k+n) / ( k! (n+k)! )

  130 CALL FMM2DP(MXY(1),X)
      X = ABS(X)
      IF (KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = INT(0.63*SQRT(FMNTERMS(X*X/4,1,1,N,1)) - 1)
      ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
          J2 = 2
      ELSE IF (MWK(START(MXY(1))+2) > 0) THEN
          GO TO 160
      ENDIF
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))

!             MXY(1) is X
!             MXY(14) is X**2/4
!             MXY(15) is MXY(14)**J2
!             MXY(13) is the current term in the sum
!             MJSUMS holds the partial sums

      NDSAV1 = NDIG
      CALL FMSQR(MXY(1),MXY(14))
      CALL FMDIVI_R1(MXY(14),4)
      CALL FMIPWR(MXY(14),J2,MXY(15))
      CALL FMI2M(1,MXY(10))
      CALL FMFCTI(N,MXY(11))
      CALL FMDIV(MXY(10),MXY(11),MXY(13))
      DO J = 1, J2
         NTERM = J
         CALL FMEQ(MXY(13),MJSUMS(J))
         IF (J > 1) CALL FMCSDIVI_R1(MXY(13),J)
         CALL FMCSDIVI_R1(MXY(13),N+J)
      ENDDO

      NTERM = J2
      NDIG2 = NDIG
  140 CALL FMCSMPY_R1(MXY(13),MXY(15))
      NDIG = NDIG2
      DO J = 1, J2
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(13))
         IF (KFLAG /= 0) THEN
             GO TO 150
         ELSE
             NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(13))+2)))
             NDIG = MIN(NDSAV1,NDIG)
             NTERM = NTERM + 1
             CALL FMCSDIVI_R1(MXY(13),NTERM)
             CALL FMCSDIVI_R1(MXY(13),N+NTERM)
         ENDIF
      ENDDO
      GO TO 140

!             Put the J2 concurrent sums back together.

  150 NDIG = NDSAV1
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(11))
      MWK(START(MXY(14))) = -1
      DO J = J2-1, 1, -1
         CALL FMCSMPY_R1(MXY(11),MXY(14))
         CALL FMADD_R1(MXY(11),MJSUMS(J))
      ENDDO
      CALL FMEQ(MXY(11),MJSUMS(1))
      CALL FMCSDIVI(MXY(1),2,MXY(11))
      CALL FMIPWR(MXY(11),N,MXY(12))
      CALL FMMPY_R1(MXY(12),MJSUMS(1))
      GO TO 190

!             Method 2.  Sum the asymptotic series.
!                        J(n,x) = Sqrt(2/(Pi*x)) * (Cos(c)*Sum(a(k)) - Sin(c)*Sum(b(k)))
!                        c = x - n*Pi/2 - Pi/4
!                        a(k) = (-1)^k * Gamma(2k+n+0.5) / ( (2x)^(2k) * (2k)! * Gamma(-2k+n+0.5) )
!                        b(k) = (-1)^k * Gamma(2k+n+1.5) /
!                               ( (2x)^(2k+1) * (2k+1)! * Gamma(-2k+n-0.5) )

!             MXY(1) is x
!             MXY(15) is the current term for the series
!             MXY(14) is 1/x^2
!             MXY(13) is MXY(14)^J2
!             MXY(12) is the sum of the a(k) series
!             MXY(11) is the sum of the b(k) series

  160 NDSAV1 = NDIG
      CALL FMM2DP(MXY(1),X)
      X = ABS(X)
      IF (KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = NINT(0.41*SQRT(FMNTERMS(2*X,2,1,N,0)) + 0.02)
      ELSE IF (MWK(START(MXY(1))+2) > 0) THEN
          J2 = 1
      ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
          GO TO 130
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum the A(k) series.

      CALL FMI2M(1,MXY(15))
      CALL FMSQR(MXY(1),MXY(14))
      CALL FMDIV_R2(MXY(15),MXY(14))
      CALL FMIPWR(MXY(14),J2,MXY(13))
      LARGE = SQRT(MXBASE+1.0D-3)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(15),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(15),1+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(15),1+4*NTERM+2*N)
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N)
             CALL FMCSDIVI_R1(MXY(15),-128)
             CALL FMCSDIVI_R1(MXY(15),1+NTERM)
             CALL FMCSDIVI_R1(MXY(15),1+2*NTERM)
         ELSE
             CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
             CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
             CALL FMCSDIVI_R1(MXY(15),-128)
             CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(1+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(15),MXY(13))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(15))
            IF (KFLAG /= 0) GO TO 170
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(15))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(15),1+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(15),1+4*NTERM+2*N)
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N)
                CALL FMCSDIVI_R1(MXY(15),-128)
                CALL FMCSDIVI_R1(MXY(15),1+NTERM)
                CALL FMCSDIVI_R1(MXY(15),1+2*NTERM)
            ELSE
                CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
                CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
                CALL FMCSDIVI_R1(MXY(15),-128)
                CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(1+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  170 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11))
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(11),MXY(14))
             CALL FMADD_R1(MXY(11),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(11),MXY(12))
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(12))
      ENDIF

!             Sum the B(k) series.

      NDIG = NDSAV1
      IF (N < LARGE) THEN
          CALL FMI2M(4*N*N-1,MXY(15))
      ELSE
          CALL FMI2M(N,MXY(15))
          CALL FMSQR_R1(MXY(15))
          CALL FMMPYI_R1(MXY(15),4)
          CALL FMADDI(MXY(15),-1)
      ENDIF
      CALL FMCSDIVI_R1(MXY(15),8)
      CALL FMDIV_R1(MXY(15),MXY(1))
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(15),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(15),5+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N)
             CALL FMCSMPYI_R1(MXY(15),5+4*NTERM+2*N)
             CALL FMCSDIVI_R1(MXY(15),-128)
             CALL FMCSDIVI_R1(MXY(15),1+NTERM)
             CALL FMCSDIVI_R1(MXY(15),3+2*NTERM)
         ELSE
             CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
             CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
             CALL FMCSDIVI_R1(MXY(15),-128)
             CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(3+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(15),MXY(13))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(15))
            IF (KFLAG /= 0) GO TO 180
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(15))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(15),5+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N)
                CALL FMCSMPYI_R1(MXY(15),5+4*NTERM+2*N)
                CALL FMCSDIVI_R1(MXY(15),-128)
                CALL FMCSDIVI_R1(MXY(15),1+NTERM)
                CALL FMCSDIVI_R1(MXY(15),3+2*NTERM)
            ELSE
                CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
                CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
                CALL FMCSDIVI_R1(MXY(15),-128)
                CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(3+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  180 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11))
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(11),MXY(14))
             CALL FMADD_R1(MXY(11),MJSUMS(J))
          ENDDO
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(11))
      ENDIF

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(7),MXY(8))
      KRAD = KRSAVE
      K = MOD(N,4)
      IF (K == 0) THEN
          CALL FMADD(MXY(8),MXY(7),MXY(9))
          CALL FMSUB(MXY(8),MXY(7),MXY(10))
      ELSE IF (K == 1) THEN
          CALL FMSUB(MXY(8),MXY(7),MXY(9))
          CALL FMADD(MXY(8),MXY(7),MXY(10))
          CALL FMMPYI_R1(MXY(10),-1)
      ELSE IF (K == 2) THEN
          CALL FMADD(MXY(8),MXY(7),MXY(9))
          CALL FMMPYI_R1(MXY(9),-1)
          CALL FMSUB(MXY(7),MXY(8),MXY(10))
      ELSE
          CALL FMSUB(MXY(7),MXY(8),MXY(9))
          CALL FMADD(MXY(8),MXY(7),MXY(10))
      ENDIF
      CALL FMI2M(2,MXY(5))
      CALL FMSQRT(MXY(5),MXY(6))
      CALL FMDIV(MXY(9),MXY(6),MXY(7))
      CALL FMDIV(MXY(10),MXY(6),MXY(8))

      CALL FMMPY_R2(MXY(7),MXY(12))
      CALL FMMPY_R2(MXY(8),MXY(11))
      CALL FMSUB(MXY(12),MXY(11),MXY(9))
      CALL FMPI(MXY(10))
      CALL FMMPY(MXY(10),MXY(1),MXY(8))
      CALL FMI2M(2,MXY(7))
      CALL FMDIV(MXY(7),MXY(8),MXY(6))
      CALL FMSQRT(MXY(6),MXY(7))
      CALL FMMPY(MXY(7),MXY(9),MXY(12))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(12))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(12))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(12))+J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(12))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          IF (N >= 1000) IEXTRA = MAX(NDIG/2,IEXTRA)
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(15))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(12),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  210 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(12))+1) = MIN(MWK(START(MXY(12))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(12))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(12))+3) /= 0) THEN
              MWK(START(MXY(12))) = -MWK(START(MXY(12)))
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(12),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBESJ

      SUBROUTINE FMBESJ2(N1,N2,X,ARRAY)

!  ARRAY = (/  J(n1,x) , ..., J(n2,x)  /)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J,K,N,N1,N2,NDSAVE
      INTEGER :: ARRAY(ABS(N2-N1)+1),X
      INTENT (IN) :: N1,N2,X
      INTENT (INOUT) :: ARRAY
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      N = ABS(N2-N1) + 1
      DO J = 1, N
         IF (ARRAY(J) <= 0) THEN
             CALL FMDEFINE(ARRAY(J))
         ELSE IF (SIZE_OF(ARRAY(J)) < NDIG+3) THEN
             CALL FMDEFINE(ARRAY(J))
         ENDIF
      ENDDO
      NUMBER_USED_SAVE = NUMBER_USED
      NDSAVE = NDIG

      IF (N1 < 0 .OR. N2 < 0) THEN
          DO J = 1, SIZE(ARRAY)
             CALL FMST2M('UNKNOWN',ARRAY(J))
          ENDDO
          RETURN
      ENDIF

!             The last two entries in the array are done with calls to FMBESJ.
!             The rest use this recurrence:

!             J(k-1,x) = 2*k*J(k,x) / x  -  J(k+1,x)

      NDIG = NDIG + NGRD52
      CALL FMEQU(X,MXY(1),NDSAVE,NDIG)
      K = MAX(N1,N2)
      CALL FMBESJ(K,MXY(1),MXY(4))
      CALL FMEQU(MXY(4),ARRAY(N),NDIG,NDSAVE)
      IF (N <= 1) GO TO 110
      CALL FMBESJ(K-1,MXY(1),MXY(3))
      CALL FMEQU(MXY(3),ARRAY(N-1),NDIG,NDSAVE)
      IF (N <= 2) GO TO 110

      DO J = K-2, MIN(N1,N2), -1
         CALL FMMPYI(MXY(3),2*(J+1),MXY(2))
         CALL FMDIV_R1(MXY(2),MXY(1))
         CALL FMSUB_R1(MXY(2),MXY(4))
         CALL FMEQU(MXY(2),ARRAY(J-MIN(N1,N2)+1),NDIG,NDSAVE)
         IF (J == MIN(N1,N2)) EXIT
         CALL FMEQ(MXY(3),MXY(4))
         CALL FMEQ(MXY(2),MXY(3))
      ENDDO

!             Reverse the list if N2 < N1.

      IF (N2 < N1) THEN
          NDIG = NDSAVE
          DO J = 1, N/2
             CALL FMEQ(ARRAY(J),MXY(4))
             CALL FMEQ(ARRAY(N+1-J),ARRAY(J))
             CALL FMEQ(MXY(4),ARRAY(N+1-J))
          ENDDO
      ENDIF

  110 NUMBER_USED = NUMBER_USED_SAVE
      NDIG = NDSAVE
      DO J = 1, N
         IF (TEMPV_CALL_STACK == 1) THEN
             IF (TEMPV(ARRAY(J)) == -1) TEMPV(ARRAY(J)) = -2
         ENDIF
      ENDDO
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBESJ2

      SUBROUTINE FMBESY(N,MA,MB)

!  MB = Bessel Y(N,MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      DOUBLE PRECISION :: CBIG,CKLOG,CRHS,DBIG,DKLOG,DRHS,ERR,FMDPLG,X,XLOG
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KD,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NDGOAL,  &
                 NDIG2,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBESY'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMBESY   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

  120 IF (N < 0 .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) == -1) THEN
          CALL FMST2M('UNKNOWN',MXY(9))
          KFLAG = -4
          GO TO 240
      ENDIF
      IF (N < 2 .AND. MWK(START(MA)+2) == MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(9))
          KFLAG = -4
          GO TO 240
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      NMETHD = 1
      CALL FMABS(MXY(1),MXY(12))
      CKLOG = MWK(START(MXY(12))+2)
      MWK(START(MXY(12))+2) = 0
      CALL FMM2DP(MXY(12),XLOG)
      XLOG = LOG(XLOG) + CKLOG*DLOGMB

!             c(k) is the absolute value of the kth term of the convergent series.  The psi terms
!                  grow logarithmically, so they are ignored for this estimate.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      CRHS = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1)) - NDIG*DLOGMB - 20*DLOGTN

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      DRHS = N
      DRHS = MIN(0.0D0,LOG(ABS(4*DRHS*DRHS-1))-XLOG-3*DLOGTW) - NDIG*DLOGMB - 20*DLOGTN - 50

      CBIG = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1))
      DBIG = 1
      K = 1
      DO J = 0, 50
         K = 2*K
         CKLOG = (2*K+N)*XLOG - (2*K+N)*DLOGTW - FMDPLG(DBLE(K+1)) - FMDPLG(DBLE(N+K+1))
         CBIG = MAX(CBIG,CKLOG)
         IF (CKLOG < CRHS) THEN
             NMETHD = 1
             IF (NUMTRY == 0) THEN
                 CKLOG = MIN(0.0D0,N*XLOG - N*DLOGTW - FMDPLG(DBLE(N+1)))
                 IEXTRA = ((CBIG-CKLOG)/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
         KD = K
         IF (N-2*KD < 0) THEN
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) + FMDPLG(DBLE(2*KD-N+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ELSE
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) - FMDPLG(DBLE(N-2*KD+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ENDIF
         DBIG = MAX(DBIG,DKLOG)
         IF (DKLOG < DRHS) THEN
             NMETHD = 2
             IF (NUMTRY == 0) THEN
                 IEXTRA = (DBIG/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
      ENDDO
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      IF (NMETHD == 2) GO TO 190

!             Method 1.  Sum the convergent series.
!                        Y(n,x) = (-1/pi)*
!                        Sum( (-1)^k (psi(k+1) + psi(n+k+1)) (x/2)^(2k+n) / ( k! (n+k)! )
!                        - (1/pi)*Sum( (n-k-1)! (x/2)^(2k-n) / k! ) + (2/pi)*ln(x/2)*J(n,x)

!                        The first sum above (involving psi) runs from k=0 to infinity, but the
!                        second sum is finite, for k=0 to k=n-1.

  130 CALL FMM2DP(MXY(1),X)
      X = ABS(X)
      IF (KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(X*X/4,1,1,N,1)) - 0.4)
      ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
          J2 = 1
      ELSE IF (MWK(START(MXY(1))+2) > 0) THEN
          GO TO 190
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum( (-1)^k (psi(k+1) + psi(n+k+1)) (x/2)^(2k+n) / ( k! (n+k)! )

!             MXY(1) is X
!             MXY(11) is -X**2/4
!             MXY(12) is MXY(11)**J2
!             MXY(13) is psi(k+1)
!             MXY(14) is psi(n+k+1)
!             MXY(10) is the current term in the sum
!             MJSUMS holds the partial sums

      NDSAV1 = NDIG
      CALL FMEULR(MXY(13))
      MWK(START(MXY(13))) = -1
      IF (N < 5000) THEN
          CALL FMEQ(MXY(13),MXY(14))
          IF (N > 0) THEN
              CALL FMI2M(1,MXY(7))
              DO J = 1, N
                 CALL FMCSDIVI(MXY(7),J,MXY(8))
                 CALL FMADD_R1(MXY(14),MXY(8))
              ENDDO
          ENDIF
      ELSE
          CALL FMI2M(N+1,MXY(12))
          CALL FMPSI(MXY(12),MXY(14))
      ENDIF
      CALL FMCSDIVI(MXY(1),2,MXY(8))
      CALL FMIPWR(MXY(8),N,MXY(9))
      CALL FMSQR(MXY(1),MXY(11))
      CALL FMCSDIVI_R1(MXY(11),4)
      MWK(START(MXY(11))) = -1
      CALL FMIPWR(MXY(11),J2,MXY(12))
      CALL FMI2M(1,MXY(7))
      CALL FMFCTI(N,MXY(8))
      CALL FMADD(MXY(13),MXY(14),MXY(6))
      CALL FMDIV(MXY(6),MXY(8),MXY(2))
      CALL FMMPY(MXY(2),MXY(9),MXY(3))
      IF (MWK(START(MXY(3))+2) <= MEXPUN) THEN
          CALL FMEQ(MXY(3),MXY(9))
          IF (MWK(START(MXY(9))+2) /= MUNKNO) MWK(START(MXY(9))) = -MWK(START(MXY(9)))
          GO TO 160
      ENDIF
      IF (MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMPI(MXY(6))
          MWK(START(MXY(6))) = -1
          CALL FMDIV(MXY(3),MXY(6),MXY(9))
          GO TO 160
      ENDIF
      CALL FMDIV(MXY(7),MXY(8),MXY(10))
      DO J = 1, J2
         NTERM = J
         CALL FMADD(MXY(13),MXY(14),MXY(6))
         CALL FMMPY(MXY(10),MXY(6),MJSUMS(J))
         CALL FMCSDIVI_R1(MXY(10),J)
         CALL FMCSDIVI_R1(MXY(10),N+J)
         CALL FMCSDIVI(MXY(7),NTERM,MXY(6))
         CALL FMADD_R1(MXY(13),MXY(6))
         IF (N > 0) CALL FMCSDIVI(MXY(7),N+NTERM,MXY(6))
         CALL FMADD_R1(MXY(14),MXY(6))
      ENDDO
      CALL FMI2M(0,MXY(5))

      NTERM = J2
      NDIG2 = NDIG
      CALL FMADD_R2(MXY(13),MXY(14))
      CALL FMEQ(MXY(10),MXY(13))
      CALL FMCSMPY_R1(MXY(10),MXY(14))

!             Start the main summation loop.
!             The psi terms are updated without doing a full multiply inside the J loop.
!             MXY(13) now holds (x/2)^L / [ (k-1)! (n+k-1)! ].

  140 CALL FMMPYD(MXY(12),MXY(10),MXY(13),MXY(2),MXY(3))
      CALL FMEQ(MXY(2),MXY(10))
      CALL FMEQ(MXY(3),MXY(13))
      NDIG = NDIG2
      DO J = 1, J2
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(10))
         IF (KFLAG /= 0) THEN
             GO TO 150
         ELSE
             NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(10))+2)))
             NDIG = MIN(NDSAV1,NDIG)
             NTERM = NTERM + 1
             LARGE = SQRT(MXBASE+1.0D-3)
             IF (N+NTERM > LARGE) THEN
                 CALL FMCSDIVI_R1(MXY(13),NTERM)
                 CALL FMCSDIVI_R1(MXY(13),N+NTERM)
                 CALL FMCSDIVI(MXY(13),NTERM,MXY(2))
                 CALL FMCSDIVI_R1(MXY(2),N+NTERM)
                 CALL FMCSMPYI_R1(MXY(2),N+2*NTERM)
                 CALL FMCSDIVI(MXY(10),NTERM,MXY(4))
                 CALL FMCSDIVI_R1(MXY(4),N+NTERM)
             ELSE
                 CALL FMCSDIVI_R1(MXY(13),NTERM*(N+NTERM))
                 CALL FMCSDIVI(MXY(13),NTERM*(N+NTERM),MXY(2))
                 CALL FMCSMPYI_R1(MXY(2),N+2*NTERM)
                 CALL FMCSDIVI(MXY(10),NTERM*(N+NTERM),MXY(4))
             ENDIF
             CALL FMADD(MXY(4),MXY(2),MXY(10))
         ENDIF
      ENDDO
      GO TO 140

!             Put the J2 concurrent sums back together.

  150 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8))
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(8),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(8),MJSUMS(1))
      ENDIF
      CALL FMCSMPY_R1(MXY(9),MJSUMS(1))
      CALL FMPI(MXY(6))
      MWK(START(MXY(6))) = -1
      CALL FMDIV_R1(MXY(9),MXY(6))

!             Sum( (n-k-1)! (x/2)^(2k-n) / k! )

  160 IF (N > 0) THEN
          MWK(START(MXY(11))) = 1
          CALL FMCSDIVI(MXY(1),2,MXY(6))
          CALL FMIPWR(MXY(6),-N,MXY(7))
          CALL FMFCTI(N-1,MXY(6))
          CALL FMCSMPY_R1(MXY(7),MXY(6))
          CALL FMEQ(MXY(7),MXY(8))
          IF (MWK(START(MXY(8))+2) == MEXPOV) THEN
              MWK(START(MXY(8))) = -1
              GO TO 170
          ENDIF
          DO J = 1, N-1
             CALL FMCSMPY_R1(MXY(7),MXY(11))
             CALL FMCSDIVI_R1(MXY(7),N-J)
             CALL FMCSDIVI_R1(MXY(7),J)
             CALL FMADD_R1(MXY(8),MXY(7))
          ENDDO
          CALL FMPI(MXY(6))
          MWK(START(MXY(6))) = -1
          CALL FMDIV_R1(MXY(8),MXY(6))

  170     CALL FMADD(MXY(9),MXY(8),MXY(14))
          IF (NCALL <= 1 .AND. MWK(START(MXY(14))+1) <= INT(REAL(NDSAVE)*ALOGM2)+17) THEN
              CALL FMEQ(MXY(14),MXY(9))
              CALL FMI2M(0,MRETRY)
              GO TO 220
          ENDIF
      ELSE
          CALL FMEQ(MXY(9),MXY(14))
      ENDIF

!             Add the J(n,x) term.

      CALL FMBESJ(N,MXY(1),MXY(15))
      IF (MWK(START(MXY(15))+2) == MEXPUN) THEN
          MWK(START(MXY(15))) = -1
          GO TO 180
      ENDIF
      CALL FMCSDIVI(MXY(1),2,MXY(6))
      CALL FMLN(MXY(6),MXY(7))
      CALL FMMPY(MXY(15),MXY(7),MXY(8))
      CALL FMPI(MXY(6))
      CALL FMDIV_R1(MXY(8),MXY(6))
      CALL FMCSMPYI(MXY(8),2,MXY(15))

  180 CALL FMADD(MXY(14),MXY(15),MXY(9))

      GO TO 220

!             Method 2.  Sum the asymptotic series.
!                        Y(n,x) = Sqrt(2/(Pi*x))*(Sin(c)*Sum(a(k)) + Cos(c)*Sum(b(k)))
!                        c = x - n*Pi/2 - Pi/4
!                        a(k) = (-1)^k * Gamma(2k+n+0.5) / ( (2x)^(2k) * (2k)! * Gamma(-2k+n+0.5) )
!                        b(k) = (-1)^k * Gamma(2k+n+1.5) /
!                               ( (2x)^(2k+1) * (2k+1)! * Gamma(-2k+n-0.5) )

!             MXY(1) is x
!             MXY(12) is the current term for the series
!             MXY(11) is 1/x^2
!             MXY(10) is MXY(11)^J2
!             MXY(9) is the sum of the a(k) series
!             MXY(8) is the sum of the b(k) series

  190 NDSAV1 = NDIG
      CALL FMM2DP(MXY(1),X)
      X = ABS(X)
      IF (KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = NINT(0.41*SQRT(FMNTERMS(2*X,2,1,N,0)) + 0.02)
      ELSE IF (MWK(START(MXY(1))+2) > 0) THEN
          J2 = 1
      ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
          GO TO 130
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum the A(k) series.

      CALL FMI2M(1,MXY(12))
      CALL FMSQR(MXY(1),MXY(11))
      CALL FMDIV_R2(MXY(12),MXY(11))
      CALL FMIPWR(MXY(11),J2,MXY(10))
      LARGE = SQRT(MXBASE+1.0D-3)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(12),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(12),1+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(12),1+4*NTERM+2*N)
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N)
             CALL FMCSDIVI_R1(MXY(12),-128)
             CALL FMCSDIVI_R1(MXY(12),1+NTERM)
             CALL FMCSDIVI_R1(MXY(12),1+2*NTERM)
         ELSE
             CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
             CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
             CALL FMCSDIVI_R1(MXY(12),-128)
             CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(1+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(12),MXY(10))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(12))
            IF (KFLAG /= 0) GO TO 200
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(12))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(12),1+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(12),1+4*NTERM+2*N)
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N)
                CALL FMCSDIVI_R1(MXY(12),-128)
                CALL FMCSDIVI_R1(MXY(12),1+NTERM)
                CALL FMCSDIVI_R1(MXY(12),1+2*NTERM)
            ELSE
                CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
                CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
                CALL FMCSDIVI_R1(MXY(12),-128)
                CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(1+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  200 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8))
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(8),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(8),MXY(9))
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(9))
      ENDIF

!             Sum the B(k) series.

      NDIG = NDSAV1
      IF (N < LARGE) THEN
          CALL FMI2M(4*N*N-1,MXY(12))
      ELSE
          CALL FMI2M(N,MXY(12))
          CALL FMSQR_R1(MXY(12))
          CALL FMCSMPYI_R1(MXY(12),4)
          CALL FMADDI(MXY(12),-1)
      ENDIF
      CALL FMCSDIVI_R1(MXY(12),8)
      CALL FMDIV_R1(MXY(12),MXY(1))
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(12),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(12),5+4*NTERM-2*N)
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N)
             CALL FMCSMPYI_R1(MXY(12),5+4*NTERM+2*N)
             CALL FMCSDIVI_R1(MXY(12),-128)
             CALL FMCSDIVI_R1(MXY(12),1+NTERM)
             CALL FMCSDIVI_R1(MXY(12),3+2*NTERM)
         ELSE
             CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
             CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
             CALL FMCSDIVI_R1(MXY(12),-128)
             CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(3+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(12),MXY(10))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(12))
            IF (KFLAG /= 0) GO TO 210
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(12))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(12),5+4*NTERM-2*N)
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N)
                CALL FMCSMPYI_R1(MXY(12),5+4*NTERM+2*N)
                CALL FMCSDIVI_R1(MXY(12),-128)
                CALL FMCSDIVI_R1(MXY(12),1+NTERM)
                CALL FMCSDIVI_R1(MXY(12),3+2*NTERM)
            ELSE
                CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
                CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
                CALL FMCSDIVI_R1(MXY(12),-128)
                CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(3+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  210 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8))
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(8),MJSUMS(J))
          ENDDO
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(8))
      ENDIF

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(4),MXY(5))
      KRAD = KRSAVE
      K = MOD(N,4)
      IF (K == 0) THEN
          CALL FMADD(MXY(5),MXY(4),MXY(6))
          CALL FMSUB(MXY(5),MXY(4),MXY(7))
      ELSE IF (K == 1) THEN
          CALL FMSUB(MXY(5),MXY(4),MXY(6))
          CALL FMADD(MXY(5),MXY(4),MXY(7))
          CALL FMMPYI_R1(MXY(7),-1)
      ELSE IF (K == 2) THEN
          CALL FMADD(MXY(5),MXY(4),MXY(6))
          CALL FMMPYI_R1(MXY(6),-1)
          CALL FMSUB(MXY(4),MXY(5),MXY(7))
      ELSE
          CALL FMSUB(MXY(4),MXY(5),MXY(6))
          CALL FMADD(MXY(5),MXY(4),MXY(7))
      ENDIF
      CALL FMI2M(2,MXY(2))
      CALL FMSQRT(MXY(2),MXY(3))
      CALL FMDIV(MXY(6),MXY(3),MXY(4))
      CALL FMDIV(MXY(7),MXY(3),MXY(5))

      CALL FMMPY_R2(MXY(5),MXY(9))
      CALL FMMPY_R2(MXY(4),MXY(8))
      CALL FMADD(MXY(9),MXY(8),MXY(6))
      CALL FMPI(MXY(7))
      CALL FMMPY(MXY(7),MXY(1),MXY(5))
      CALL FMI2M(2,MXY(4))
      CALL FMDIV(MXY(4),MXY(5),MXY(3))
      CALL FMSQRT(MXY(3),MXY(4))
      CALL FMMPY(MXY(4),MXY(6),MXY(9))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  220 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(9))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(9))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              IF (MWK(START(MRETRY)+3) == 0) GO TO 230
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(9))+J+1)) GO TO 230
              ENDDO
              GO TO 240
          ENDIF
  230     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(9))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(12))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(9),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  240 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(9))+1) = MIN(MWK(START(MXY(9))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(9))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(9))+3) /= 0) THEN
              MWK(START(MXY(9))) = -MWK(START(MXY(9)))
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(9),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBESY

      SUBROUTINE FMBESY2(N1,N2,X,ARRAY)

!  ARRAY = (/  Y(n1,x) , ..., Y(n2,x)  /)


      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J,K,N,N1,N2,NDSAVE
      INTEGER :: ARRAY(ABS(N2-N1)+1),X
      INTENT (IN) :: N1,N2,X
      INTENT (INOUT) :: ARRAY
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      N = ABS(N2-N1) + 1
      DO J = 1, N
         IF (ARRAY(J) <= 0) THEN
             CALL FMDEFINE(ARRAY(J))
         ELSE IF (SIZE_OF(ARRAY(J)) < NDIG+3) THEN
             CALL FMDEFINE(ARRAY(J))
         ENDIF
      ENDDO
      NUMBER_USED_SAVE = NUMBER_USED
      NDSAVE = NDIG

      IF (N1 < 0 .OR. N2 < 0) THEN
          DO J = 1, SIZE(ARRAY)
             CALL FMST2M('UNKNOWN',ARRAY(J))
          ENDDO
          RETURN
      ENDIF

!             The first two entries in the array are done with calls to FMBESY.
!             The rest use this recurrence:

!             Y(k+1,x) = 2*k*Y(k,x) / x  -  Y(k-1,x)

      NDIG = NDIG + NGRD52
      CALL FMEQU(X,MXY(1),NDSAVE,NDIG)
      K = MIN(N1,N2)
      CALL FMBESY(K,MXY(1),MXY(4))
      CALL FMEQU(MXY(4),ARRAY(1),NDIG,NDSAVE)
      IF (N <= 1) GO TO 110
      CALL FMBESY(K+1,MXY(1),MXY(3))
      CALL FMEQU(MXY(3),ARRAY(2),NDIG,NDSAVE)
      IF (N <= 2) GO TO 110

      DO J = K+2, MAX(N1,N2)
         CALL FMMPYI(MXY(3),2*(J-1),MXY(2))
         CALL FMDIV_R1(MXY(2),MXY(1))
         CALL FMSUB_R1(MXY(2),MXY(4))
         CALL FMEQU(MXY(2),ARRAY(J-K+1),NDIG,NDSAVE)
         IF (J == MIN(N1,N2)) EXIT
         CALL FMEQ(MXY(3),MXY(4))
         CALL FMEQ(MXY(2),MXY(3))
      ENDDO

!             Reverse the list if N2 < N1.

      IF (N2 < N1) THEN
          NDIG = NDSAVE
          DO J = 1, N/2
             CALL FMEQ(ARRAY(J),MXY(4))
             CALL FMEQ(ARRAY(N+1-J),ARRAY(J))
             CALL FMEQ(MXY(4),ARRAY(N+1-J))
          ENDDO
      ENDIF

  110 NUMBER_USED = NUMBER_USED_SAVE
      NDIG = NDSAVE
      DO J = 1, N
         IF (TEMPV_CALL_STACK == 1) THEN
             IF (TEMPV(ARRAY(J)) == -1) TEMPV(ARRAY(J)) = -2
         ENDIF
      ENDDO
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBESY2

      SUBROUTINE FMC(MA,MB)

!  MB = C(MA)    Fresnel Cosine Integral.

!  Integral from 0 to MA of Cos(pi*t**2/2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMDP2M(1.0D-10,MXY(1))
          CALL FMULP(MXY(1),MXY(2))
          CALL FMSQRT(MXY(2),MXY(3))
          CALL FMSQRT(MXY(3),MXY(2))
          CALL FMABS(MA,MXY(3))
          CALL FMSUB(MXY(3),MXY(2),MXY(4))
          IF (MWK(START(MXY(4))) < 0) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMIPWR(MXY(1),5,MXY(2))
          CALL FMPI(MXY(3))
          CALL FMSQR(MXY(3),MXY(4))
          CALL FMDIVI(MXY(4),40,MXY(3))
          CALL FMMPY(MXY(2),MXY(3),MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMSUB(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) > 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMC'
                  CALL FMNTR(2,MA,MA,1,1)
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NAMEST(NCALL) = 'FMC'
                  KFLAG = -4
                  CALL FMWRN2
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NAMEST(NCALL) = 'FMC'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
              ENDIF
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMC'
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMC      ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(10))
          GO TO 180
      ENDIF
      IF (4*MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMEQ(MXY(1),MXY(10))
          GO TO 180
      ENDIF
      CALL FMINT(MXY(1),MXY(8))
      IF (3*MWK(START(MXY(1))+2) > NDIG .AND. FMCOMP(MXY(1),'==',MXY(8)) .AND.  &
          MWK(START(MXY(1))+2) < MEXPOV) THEN
          MWK(START(MXY(1))) = MWK(START(MA))
          IF (MOD(INT(MBASE),2) == 0 .AND. MWK(START(MXY(1))+2) > NDSAVE) THEN
              K = 0
          ELSE
              CALL FMI2M(2,MXY(8))
              CALL FMMOD(MXY(1),MXY(8),MXY(7))
              CALL FMM2I(MXY(7),K)
          ENDIF
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(10))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(10))
          ENDIF
          IF (K == 0) THEN
              CALL FMIPWR(MXY(1),3,MXY(7))
              CALL FMPI(MXY(6))
              CALL FMSQR_R1(MXY(6))
              CALL FMMPY_R1(MXY(6),MXY(7))
              CALL FMDIV_R2(MXY(8),MXY(6))
              CALL FMSUB_R1(MXY(10),MXY(6))
          ELSE
              CALL FMPI(MXY(6))
              CALL FMMPY_R1(MXY(6),MXY(1))
              CALL FMDIV_R2(MXY(8),MXY(6))
              CALL FMADD_R1(MXY(10),MXY(6))
          ENDIF
          IF (MWK(START(MA)) < 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) > NDIG) THEN
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(10))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(10))
          ENDIF
          GO TO 180
      ENDIF

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) , INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      IF (KFLAGX == 0) THEN
          IF (ABS(X) < SQRT(HUGE(X)/(4*LOG(HUGE(X))))) THEN
              Y = (DPPI*X*X-1)/2
              Y = (2*Y+1.5)*LOG(2*Y+2) - (2*Y+1) - Y*DLOGTW - (Y+0.5)*LOG(Y+1) + Y - Y*LOG(DPPI*X*X)
              IF (Y <= -(NDIG+1)*DLOGMB) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n)/((4*n+1)*(2*n)!).

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          IEXTRA = MAX(0.0D0,(0.096*X*X + 0.033*ABS(X) - 0.5)*LOG(1.0E7)/ALOGMB)*1.02
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          ENDIF
      ENDIF
      NDIG = NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF

      IF (KFLAGX == 0) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(3.14159D0*X*X/2,2,0,0,1)) - 1.6)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(4))
      CALL FMCSDIVI(MXY(4),2,MXY(9))
      CALL FMPI(MXY(3))
      CALL FMCSMPY_R1(MXY(9),MXY(3))
      CALL FMI2M(1,MXY(6))
      CALL FMI2M(1,MJSUMS(1))
      NTERM = 0
      DO J = 2, J2
         NTERM = NTERM + 2
         NBOT = NTERM*(NTERM-1)
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             IF (NTERM > 2) CALL FMCSDIVI_R1(MXY(6),NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NTERM)
         ELSE
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(9),2*J2,MXY(7))

  130 CALL FMCSMPY_R1(MXY(6),MXY(7))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NTERM)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MXY(2))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(10))
      CALL FMSQR(MXY(9),MXY(8))
      MWK(START(MXY(8))) = -1
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(10),MXY(8))
         CALL FMADD_R1(MXY(10),MJSUMS(J2-J+1))
      ENDDO
      CALL FMCSMPY_R1(MXY(10),MXY(1))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then C(x) = 0.5 + f(x)*sin(pi*x*x/2) - g(x)*cos(pi*x*x/2).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMFGFI(MXY(1),MXY(11),MXY(12))
      CALL FMSQR(MXY(1),MXY(4))
      KRSAVE = KRAD
      KRAD = 0
      CALL FMMPYI(MXY(4),90,MXY(7))
      CALL FMCSSN(MXY(7),MXY(13),MXY(14))
      KRAD = KRSAVE
      CALL FMMPY(MXY(11),MXY(14),MXY(10))
      CALL FMMPY(MXY(12),MXY(13),MXY(7))
      CALL FMI2M(1,MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(5))
      CALL FMADD(MXY(5),MXY(10),MXY(6))
      CALL FMSUB(MXY(6),MXY(7),MXY(10))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF (MWK(START(MXY(10))+3) /= 0 .AND. MWK(START(MXY(10))+2) /= MUNKNO)  &
              MWK(START(MXY(10))) =-1
      ENDIF
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMC

      SUBROUTINE FMCHI(MA,MB)

!  MB = Hyperbolic Cosine Integral(MA)

!  EulerGamma + Ln(MA) + Integral from 0 to MA of ( Cosh(t) - 1 ) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,J2,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,LARGE,NBOT,NDGOAL,  &
                 NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(11),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMCHI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check for special cases.

      IF (MWK(START(MXY(1))) == -1 .OR. MWK(START(MXY(1))+2) == MEXPUN .OR.  &
          MWK(START(MXY(1))+3) ==0) THEN
          CALL FMST2M('UNKNOWN',MXY(7))
          KFLAG = -4
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(7))
          KFLAG = -5
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the gamma + ln(X) + X**(2*N)/((2*N)*(2*N)!) series.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.62*SQRT(FMNTERMS(X,2,0,0,1)) - 1.3)
          J2 = MAX(1,MIN(LJSUMS,J2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(2))
      CALL FMCSDIVI(MXY(2),2,MXY(6))
      CALL FMCSDIVI(MXY(6),2,MJSUMS(1))
      NTERM = 2
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMCSDIVI_R1(MXY(6),NTERM)
         NTERM = NTERM + 1
         NBOT = NTERM
         CALL FMCSDIVI_R1(MXY(6),NBOT)
         CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(4))

  130 CALL FMCSMPY_R1(MXY(6),MXY(4))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM)
             NBOT = (NTERM - 1)
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),NTERM,MXY(3))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(3))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(7))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(5))
          DO J = 2, J2
             CALL FMCSMPY_R1(MXY(7),MXY(5))
             CALL FMADD_R1(MXY(7),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMEQ(MXY(7),MXY(11))
      CALL FMEULR(MXY(9))
      CALL FMLN(MXY(1),MXY(2))
      CALL FMADD(MXY(9),MXY(2),MXY(10))
      CALL FMADD(MXY(10),MXY(11),MXY(7))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then CHI(x) = f(x)*sinh(x) + g(x)*cosh(x).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      CALL FMFHGH(MXY(1),MXY(8),MXY(9))
      CALL FMCHSH(MXY(1),MXY(10),MXY(11))
      IF (MWK(START(MXY(10))+2) < MEXPOV) THEN
          CALL FMMPY(MXY(8),MXY(11),MXY(7))
          CALL FMMPY(MXY(9),MXY(10),MXY(4))
          CALL FMADD_R1(MXY(7),MXY(4))
      ELSE
          CALL FMADD(MXY(8),MXY(9),MXY(4))
          CALL FMDIVI_R1(MXY(4),2)
          CALL FMLN(MXY(4),MXY(7))
          CALL FMADD(MXY(1),MXY(7),MXY(4))
          CALL FMEXP(MXY(4),MXY(7))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(7))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(7))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(7))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(7))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(7),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(7))+1) = MIN(MWK(START(MXY(7))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(7),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHI

      SUBROUTINE FMCI(MA,MB)

!  MB = Cosine Integral(MA)

!  Integral from MA to Infinity of -Cos(t) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NBOT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(11),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMCI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check for special cases.

      IF (MWK(START(MXY(1))) == -1 .OR. MWK(START(MXY(1))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(7))
          KFLAG = -4
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(7))
          KFLAG = -4
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the  gamma + ln(X) + (-1)**N*X**(2*N)/((2*N)*(2*N)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = 1.03*Y/DLOGMB
          IEXTRA = MAX(0,INT(Y+1))
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      IF (ABS(X) < 5 .AND. KR_RETRY <= 0) THEN
          NDIG = NDIG - 2
          IEXTRA = 0
      ENDIF
      NDIG = NDIG + IEXTRA

      IF (KFLAGX == 0) THEN
          J2 = INT(0.64*SQRT(FMNTERMS(X,2,0,0,1)) - 1.4)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(2))
      CALL FMCSDIVI(MXY(2),2,MXY(6))
      CALL FMCSDIVI(MXY(6),2,MJSUMS(1))
      NTERM = 2
      DO J = 2, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NTERM)
         ELSE
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(4))

  130 CALL FMCSMPY_R1(MXY(6),MXY(4))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NTERM)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),NTERM,MXY(3))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(3))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(7))
      CALL FMSQR(MXY(1),MXY(5))
      MWK(START(MXY(5))) = -1
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(7),MXY(5))
         CALL FMCSADD_R1(MXY(7),MJSUMS(J2-J+1))
      ENDDO
      IF (MWK(START(MXY(7))+2) /= MUNKNO .AND. MWK(START(MXY(7))+3) /= 0)  &
          MWK(START(MXY(7))) = -MWK(START(MXY(7)))
      CALL FMEQ(MXY(7),MXY(11))
      CALL FMEULR(MXY(9))
      CALL FMLN(MXY(1),MXY(2))
      CALL FMADD(MXY(9),MXY(2),MXY(10))
      CALL FMADD(MXY(10),MXY(11),MXY(7))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then CI(x) = f(x)*sin(x) - g(x)*cos(x).

  150 CALL FMFXGX(MXY(1),MXY(8),MXY(9))
      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(10),MXY(11))
      KRAD = KRSAVE
      CALL FMMPY(MXY(8),MXY(11),MXY(7))
      CALL FMMPY(MXY(9),MXY(10),MXY(4))
      CALL FMSUB_R1(MXY(7),MXY(4))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(7))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(7))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(7))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(7))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(7),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(7))+1) = MIN(MWK(START(MXY(7))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(7),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCI

      SUBROUTINE FMEI(MA,MB)

!  MB = Exponential Integral(MA)

!  Integral from -Infinity to MA of e**t / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,JEXTRA,JTERMS,KASAVE,KFLAG1,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMEI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

  120 NTERMS = INT(INTMAX/10)

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0),INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0 .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(10))
          KFLAG = -4
          GO TO 200
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMI2M(0,MXY(10))
          IF (MWK(START(MXY(1))) > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(10))
              KFLAG = -5
          ELSE
              CALL FMST2M('-UNDERFLOW',MXY(10))
              KFLAG = -6
          ENDIF
          GO TO 200
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+3)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
          IF (X < 0.0D0 .AND. NMETHD == 1) THEN
              IF (X <= -14.3D0-0.275D0*Y) NMETHD = 3
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170

!             Method 1.  Use the X**N/(N*N!) series.

      IF (KFLAGX == 0) THEN
          IF (X < 0) THEN
              IEXTRA = INT(2.0D0*ABS(X)/DLOGMB)
          ELSE IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
              NDIG = NDIG - IEXTRA - 1
              IEXTRA = 0
          ELSE IF (KR_RETRY <= 0 .AND. NCALL > 1) THEN
              NDIG = NDIG - IEXTRA
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      IF (KFLAGX == 0) THEN
          J2 = INT(0.63*SQRT(FMNTERMS(ABS(X),1,0,0,1)) - 1.4)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6))
      CALL FMEQ(MXY(6),MJSUMS(1))
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMCSDIVI_R1(MXY(6),NTERM)
         CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),J2,MXY(5))

  130 CALL FMCSMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMCSDIVI_R1(MXY(6),NTERM)
         CALL FMCSDIVI(MXY(6),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(5))
      DO J = 2, J2
         CALL FMMPY_R1(MXY(5),MXY(1))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO
      CALL FMMPY(MXY(1),MXY(5),MXY(13))

      CALL FMEULR(MXY(12))
      CALL FMABS(MXY(1),MXY(2))
      CALL FMLN(MXY(2),MXY(11))
      CALL FMADD(MXY(13),MXY(11),MXY(2))
      CALL FMADD(MXY(2),MXY(12),MXY(10))

      GO TO 180

!             Method 2.  Use the N!/X**N series.

  150 IF (KFLAGX == 0) THEN
          J2 = INT(0.38*SQRT(FMNTERMS(ABS(X),1,0,0,0)) + 0.6)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      IF (KFLAGX == 0) THEN
          IF (X > 0 .AND. KR_RETRY <= 0 .AND. NCALL <= 1) THEN
              NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
          ENDIF
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6))
      CALL FMDIV(MXY(6),MXY(1),MXY(15))
      CALL FMEQ(MXY(6),MJSUMS(1))
      NTERM = 1
      DO J = 2, J2
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(6),NTERM)
         CALL FMEQ(MXY(6),MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(15))+2)+MWK(START(MXY(6))+2) < -NDIG-3) GO TO 160
      CALL FMIPWR(MXY(15),J2,MXY(5))

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(6),MXY(5))
         DO J = 1, J2
            CALL FMCSMPYI_R1(MXY(6),NTERM)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(6))
            IF (KFLAG /= 0) GO TO 160
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  160 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(5))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(15))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO
      CALL FMMPY(MXY(15),MXY(5),MXY(13))
      CALL FMEXP(MXY(1),MXY(11))
      IF (MWK(START(MXY(11))+2) == MEXPOV .AND. MWK(START(MXY(1))) > 0) THEN
          CALL FMEQ(MXY(11),MXY(10))
          GO TO 180
      ELSE
          CALL FMMPY(MXY(11),MXY(13),MXY(10))
      ENDIF

      NDIG = NDSAV1
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  170 NDSAV1 = NDIG
      JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMEQ(MXY(1),MXY(13))
      IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
          MWK(START(MXY(13))) = -MWK(START(MXY(13)))
      CALL FMI2M(1,MXY(8))
      CALL FMEQU(MXY(13),MXY(9),NDSAV1,NDIG)
      CALL FMI2M(1,MXY(2))
      CALL FMDIV(MXY(2),MXY(13),MXY(10))
      CALL FMEQ(MXY(10),MXY(14))

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         CALL FMCSMPYI(MXY(8),J,MXY(6))
         CALL FMEQ(MXY(9),MXY(7))
         CALL FMCSADD_R1(MXY(7),MXY(6))
         CALL FMCSMPY_R1(MXY(10),MXY(6))
         CALL FMCSDIV(MXY(10),MXY(7),MXY(11))
         CALL FMEQ(MXY(11),MXY(10))
         IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
             MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10))
         KFLAG1 = KFLAG
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
         CALL FMCSMPYI(MXY(8),J,MXY(6))
         CALL FMEQ(MXY(9),MXY(3))
         CALL FMCSMPY_R1(MXY(3),MXY(13))
         CALL FMEQ(MXY(3),MXY(7))
         CALL FMCSADD_R1(MXY(7),MXY(6))
         CALL FMCSMPY_R1(MXY(10),MXY(6))
         CALL FMCSDIV(MXY(10),MXY(7),MXY(11))
         CALL FMEQ(MXY(11),MXY(10))
         IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
             MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQU_R1(MXY(14),NDIG,NDSAV1)
      NDIG = NDSAV1
      CALL FMEXP(MXY(1),MXY(15))
      CALL FMMPY(MXY(14),MXY(15),MXY(10))
      IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
          MWK(START(MXY(10))) = -MWK(START(MXY(10)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEI

      SUBROUTINE FMEN(IVAL,MA,MB)

!  MB = Exponential Integral(IVAL,MA)

!  Integral from 1 to Infinity of e**(-MA*t) / t**IVAL  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL,N
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,JS,JTERM,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,  &
                 K_RETURN_CODE,NDSAVE,NDSAV1,NDSAV2,NGOAL,NMETHD,NTERM,NTERMS
      INTEGER, SAVE :: M_EULER_HARMONIC = -3
      INTEGER, SAVE :: IVAL_E_H = 0, NDIG_E_H = 0
      REAL (KIND(1.0D0)), SAVE :: MBS_E_H = 0
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: IVAL,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IEXTRA = 0
      K_RETURN_CODE = 0
      K = 0
      N = IVAL

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          IF (N > 1 .AND. MWK(START(MA)+2) < -NDIG) K = 1
          IF (N <= 0) THEN
              J = NTRACE
              NTRACE = 0
              KL = KWARN
              KWARN = 0
              KRSAVE = KROUND
              KROUND = 1
              NDSAVE = NDIG
              NDIG = NDIG + NGRD52
              CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
              CALL FMI2M(-N,MXY(2))
              CALL FMFACT(MXY(2),MXY(3))
              CALL FMIPWR(MXY(1),-N+1,MXY(5))
              CALL FMDIV(MXY(3),MXY(5),MXY(4))
              CALL FMI2M(-1,MXY(6))
              CALL FMDIVI(MXY(6),-N+1,MXY(5))
              IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG) K = 1
              NTRACE = J
              KWARN = KL
              NDIG = NDSAVE
              KROUND = KRSAVE
          ENDIF
          IF (MWK(START(MA)) < 0 .AND. N > 0) K = 0
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          IF (MWK(START(MA)+2) == MEXPUN) CALL FMTINY(MXY(1))
          IF (N == 2) THEN
              CALL FMI2M(1,MXY(4))
              CALL FMLN(MXY(1),MXY(2))
              CALL FMEULR(MXY(3))
              CALL FMADD(MXY(2),MXY(3),MXY(5))
              CALL FMMPY(MXY(5),MXY(1),MXY(6))
              CALL FMSUB(MXY(6),MXY(1),MXY(5))
          ELSE IF (N >= 3) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMDIVI(MXY(2),N-1,MXY(4))
              CALL FMDIVI(MXY(1),-(N-2),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MUNKNO) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  CALL FMNTRI(2,N,1)
                  CALL FMNTR(2,MA,MA,1,0)
                  NCALL = NCALL - 1
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  KFLAG = -4
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEN'
          CALL FMNTRI(2,IVAL,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMEN     ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Special cases.

      IF (IVAL > 0 .AND. (MWK(START(MXY(1))) < 0 .OR. MWK(START(MXY(1))+3) == 0)) THEN
          IF (IVAL > 1 .AND. MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMDIVI(MXY(2),IVAL-1,MXY(12))
          ELSE
              CALL FMST2M('UNKNOWN',MXY(12))
              KFLAG = -4
          ENDIF
          GO TO 180
      ENDIF
      IF (IVAL <= 0 .AND. MWK(START(MXY(1))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12))
          KFLAG = -4
          GO TO 180
      ENDIF
      IF (IVAL == 0) THEN
          CALL FMI2M(-1000,MXY(3))
          IF (FMCOMP(MXY(1),'>=',MXY(3))) THEN
              CALL FMEQ(MXY(1),MXY(3))
              IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
                  MWK(START(MXY(3))) = -MWK(START(MXY(3)))
              CALL FMEXP(MXY(3),MXY(4))
              CALL FMDIV(MXY(4),MXY(1),MXY(12))
          ELSE
              CALL FMEQ(MXY(1),MXY(3))
              IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
                  MWK(START(MXY(3))) = -MWK(START(MXY(3)))
              CALL FMLN(MXY(3),MXY(4))
              CALL FMSUB(MXY(3),MXY(4),MXY(5))
              CALL FMEXP(MXY(5),MXY(12))
              IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0)  &
                  MWK(START(MXY(12))) = -MWK(START(MXY(12)))
          ENDIF
          GO TO 180
      ELSE IF (IVAL == 1 .AND. MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMEULR(MXY(11))
          CALL FMLN(MXY(1),MXY(10))
          CALL FMADD(MXY(10),MXY(11),MXY(4))
          CALL FMSUB(MXY(1),MXY(4),MXY(12))
          GO TO 180
      ELSE IF (IVAL == 2 .AND. (MWK(START(MXY(1))+2) < -NDIG .OR. MWK(START(MXY(1))+3) == 0)) THEN
          IF (MWK(START(MXY(1))+2) < -NDIG*2 .OR. MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(1,MXY(12))
          ELSE
              CALL FMEULR(MXY(11))
              CALL FMLN(MXY(1),MXY(10))
              CALL FMADD(MXY(10),MXY(11),MXY(4))
              CALL FMI2M(1,MXY(3))
              CALL FMSUB(MXY(4),MXY(3),MXY(2))
              CALL FMMPY(MXY(2),MXY(1),MXY(5))
              CALL FMADD(MXY(3),MXY(5),MXY(12))
          ENDIF
          GO TO 180
      ELSE IF (IVAL > 2 .AND. (MWK(START(MXY(1))+2) < -NDIG .OR. MWK(START(MXY(1))+3) == 0)) THEN
          CALL FMI2M(1,MXY(3))
          CALL FMDIVI(MXY(3),IVAL-1,MXY(4))
          CALL FMDIVI(MXY(1),IVAL-2,MXY(5))
          CALL FMSUB(MXY(4),MXY(5),MXY(12))
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use the continued fraction expansion,
!                    = 3 for small positive IVAL use a recurrence involving ExponentialEi,
!                    = 4 for small negative IVAL use a recurrence involving exp,
!                    = 5 use incomplete gamma.

      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      NMETHD = 5
      K = 0
      IF (N == 1 .AND. ABS(X) >= 1) K = 10
      IF (IVAL > 0) THEN
          IF (ABS(X) < (NDIG*ALOGMB)/(5.5 + 0.00095*IVAL) + K +                                  &
              (NDIG*ALOGMB)**2 * 1.0E-4 * (4.22 + LOG(REAL(IVAL)))/(24 + LOG(REAL(IVAL))) .AND.  &
              ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
              NMETHD = 1
          ELSE IF (IVAL < MAX(2,INT((NDIG+3)*ALOGMB/32)) .AND.  &
                   ABS(X) > (NDIG+5)*ALOGMB + LOG(6.2832*(NDIG+5)*ALOGMB)/2) THEN
              NMETHD = 3
          ELSE
              NMETHD = 2
          ENDIF
      ELSE IF (IVAL < 0 .AND. IVAL >= -10 .AND. ABS(X) > 1 .AND.  &
               ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
          NMETHD = 2
      ELSE IF (IVAL < 0 .AND. IVAL >= -10 .AND. ABS(X) <= 1 .AND.  &
               ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
          NMETHD = 4
      ELSE IF (IVAL < 0 .AND. IVAL > -500 .AND.  &
               ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
          NMETHD = 4
      ENDIF
      IF (N == 1 .AND. K == 10 .AND. NMETHD == 1) NMETHD = 3
      IF (NMETHD == 2) GO TO 140
      IF (NMETHD == 3) GO TO 150
      IF (NMETHD == 4) GO TO 160
      IF (NMETHD == 5) GO TO 170

!             Method 1.  Use the (-X)**N/((N-IVAL+1)*N!) series.

      IF (KFLAGX == 0) THEN
          IF (X > 0) THEN
              IEXTRA = INT(2.0D0*ABS(X)/DLOGMB)
          ELSE IF (KR_RETRY <= 0) THEN
              NDIG = NDIG - IEXTRA - 1
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      IF (KFLAGX == 0) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(ABS(X),1,0,0,1)) + 0.7)
          J2 = MAX(1,MIN(LJSUMS,J2))
      ELSE
          J2 = 1
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6))
      JTERM = 0
      NTERM = IVAL - 1
      DO J = 1, J2
         IF (J > 2) CALL FMCSDIVI_R1(MXY(6),JTERM)
         IF (NTERM /= 0) THEN
             CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J))
         ELSE
             IF (IVAL == IVAL_E_H .AND. NDIG <= NDIG_E_H .AND. MBS_E_H == MBASE) THEN
                 CALL FMEQ(M_EULER_HARMONIC,MXY(2))
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(2),MXY(3))
                 CALL FMMPY(MXY(6),MXY(2),MJSUMS(J))
             ELSE
                 CALL FMEULER(MXY(2))
                 MWK(START(MXY(2))) = -MWK(START(MXY(2)))
                 CALL FMI2M(1,MXY(3))
                 DO K = 1, IVAL-1
                    CALL FMCSDIVI(MXY(3),K,MXY(4))
                    CALL FMADD_R1(MXY(2),MXY(4))
                 ENDDO
                 IVAL_E_H = IVAL
                 NDIG_E_H = NDIG
                 MBS_E_H = MBASE
                 CALL FMEQ(MXY(2),M_EULER_HARMONIC)
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(2),MXY(3))
                 CALL FMMPY(MXY(6),MXY(2),MJSUMS(J))
             ENDIF
         ENDIF
         JTERM = JTERM + 1
         NTERM = NTERM - 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 130
      CALL FMEQ(MXY(1),MXY(2))
      IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
          MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      CALL FMIPWR(MXY(2),J2,MXY(5))

  120 CALL FMCSMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(6),JTERM)
         IF (NTERM /= 0) THEN
             CALL FMCSDIVI(MXY(6),NTERM,MXY(4))
         ELSE
             IF (IVAL == IVAL_E_H .AND. NDIG <= NDIG_E_H .AND. MBS_E_H == MBASE) THEN
                 CALL FMEQ(M_EULER_HARMONIC,MXY(7))
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(7),MXY(3))
                 CALL FMMPY(MXY(6),MXY(7),MXY(4))
             ELSE
                 CALL FMEULER(MXY(7))
                 MWK(START(MXY(7))) = -MWK(START(MXY(7)))
                 CALL FMI2M(1,MXY(3))
                 DO K = 1, IVAL-1
                    CALL FMCSDIVI(MXY(3),K,MXY(4))
                    CALL FMADD_R1(MXY(7),MXY(4))
                 ENDDO
                 IVAL_E_H = IVAL
                 NDIG_E_H = NDIG
                 MBS_E_H = MBASE
                 CALL FMEQ(MXY(7),M_EULER_HARMONIC)
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(7),MXY(3))
                 CALL FMMPY(MXY(6),MXY(7),MXY(4))
             ENDIF
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 130
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         JTERM = JTERM + 1
         NTERM = NTERM - 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(5))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(2))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO
      CALL FMEQ(MXY(5),MXY(12))
      GO TO 180

!             Method 2.  use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  140 IF (KFLAGX == 0) THEN
          IF (X > 0 .AND. IVAL > 0 .AND. KR_RETRY <= 0 .AND. NCALL <= 1) THEN
              NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
          ENDIF
      ENDIF
      CALL FMI2M(-IVAL,MXY(2))
      CALL FMSUB(MXY(2),MXY(1),MXY(3))
      CALL FMNINT(MXY(3),MXY(2))
      CALL FMSUB(MXY(3),MXY(2),MXY(4))
      IF (MWK(START(MXY(4))+3) == 0) THEN
          IF (IVAL <= 0) THEN
              IF (ABS(IVAL) <= 100) THEN
                  GO TO 160
              ELSE
                  GO TO 170
              ENDIF
          ENDIF
      ENDIF
      IEXTRA = 0
      IF (MWK(START(MXY(2))) >= 0) THEN
          IF (MWK(START(MXY(4))+2) < 0) IEXTRA = -MWK(START(MXY(4))+2)
      ENDIF
      IF (IVAL < 0) THEN
          IF (ABS(X) > 1/SQRT(DPMAX) .AND. ABS(X) < SQRT(DPMAX)) THEN
              J = (LOG(6.2831853D0) + LOG(DBLE(-IVAL)) - IVAL*(LOG(DBLE(-IVAL))-1) -  &
                  (1-IVAL)*LOG(ABS(X))) / DLOGMB + NGRD21
          ELSE
              J = (LOG(6.2831853D0) + LOG(DBLE(-IVAL)) - IVAL*(LOG(DBLE(-IVAL))-1)) / DLOGMB  &
                  - DBLE(1-IVAL)*(MWK(START(MXY(1))+2)-1)
          ENDIF
          IEXTRA = MAX(IEXTRA,J)
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      NDSAV1 = NDIG
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(0,MXY(10))
      CALL FMI2M(0,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(1),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
             CALL FMCSMPYI(MXY(8),(J-1)/2,MXY(12))
         ELSE
             CALL FMEQ(MXY(9),MXY(11))
             CALL FMCSMPYI(MXY(8),IVAL+(J-2)/2,MXY(12))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMEXP(MXY(1),MXY(5))
             IF (MWK(START(MXY(5))+2) >= MEXPOV) GO TO 170
             CALL FMMPY(MXY(1),MXY(5),MXY(6))
             CALL FMI2M(1,MXY(2))
             CALL FMDIV(MXY(2),MXY(6),MXY(10))
         ELSE
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMCSMPY_R1(MXY(10),MXY(12))
             CALL FMCSDIV(MXY(10),MXY(7),MXY(3))
             CALL FMEQ(MXY(3),MXY(10))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (KFLAG == 1 .AND. J > 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(12))
      NDIG = NDSAV1
      IF (MWK(START(MXY(12))+2) == MUNKNO) GO TO 170
      GO TO 180

!             Method 3.  For small positive IVAL use a recurrence involving ExponentialEi.

  150 KACCSW = 1
      NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 27
      IF (MWK(START(MXY(1))) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12))
          KFLAG = -4
      ELSE IF (IVAL == 1) THEN
          CALL FMEQ(MXY(1),MXY(3))
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
          CALL FMEI(MXY(3),MXY(12))
          IF (MWK(START(MXY((12)))+2) /= MUNKNO .AND. MWK(START(MXY((12)))+3) /= 0)  &
              MWK(START(MXY((12)))) = -MWK(START(MXY((12))))
          IF (MWK(START(MXY(12))+1) <= NGOAL) THEN
              NDIG = 2*NDIG
              GO TO 110
          ENDIF
      ELSE
          IEXTRA = 0
          IF (KFLAGX == 0) THEN
              IEXTRA = INT(IVAL/2.25D0*(LOG(ABS(X))-1.1D0*(LOG(DBLE(IVAL))-1.4D0))*DLOGTN/DLOGMB)
              IEXTRA = MAX(0,IEXTRA)
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          CALL FMEQ(MXY(1),MXY(3))
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
          CALL FMEI(MXY(3),MXY(4))
          IF (MWK(START(MXY((4)))+2) /= MUNKNO .AND. MWK(START(MXY((4)))+3) /= 0)  &
              MWK(START(MXY((4)))) = -MWK(START(MXY((4))))
          IF (MWK(START(MXY(4))+2) == MEXPUN) THEN
              CALL FMEQ(MXY(4),MXY(12))
          ELSE
              CALL FMEXP(MXY(3),MXY(5))
              DO J = 1, IVAL-1
                 CALL FMMPY(MXY(4),MXY(3),MXY(6))
                 IF (J > 2) CALL FMDIVI_R1(MXY(6),J-1)
                 CALL FMADD(MXY(6),MXY(5),MXY(4))
              ENDDO
              CALL FMDIVI(MXY(4),IVAL-1,MXY(12))
          ENDIF
          IF (MWK(START(MXY(12))+1) <= NGOAL) THEN
              NDIG = 2*NDIG
              GO TO 110
          ENDIF
      ENDIF
      IF (MWK(START(MXY(12))+2) == MUNKNO) GO TO 170
      GO TO 180

!             Method 4.  For small negative IVAL use a recurrence involving exp.

  160 CALL FMEQ(MXY(1),MXY(3))
      IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
          MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      CALL FMI2M(1,MXY(4))
      CALL FMI2M(1,MXY(5))
      DO J = 1, -IVAL
         CALL FMMPY_R1(MXY(5),MXY(1))
         IF (J > 1) CALL FMDIVI_R1(MXY(5),J)
         CALL FMADD_R1(MXY(4),MXY(5))
      ENDDO
      CALL FMMPY_R1(MXY(5),MXY(1))
      CALL FMDIV(MXY(4),MXY(5),MXY(6))
      CALL FMABS(MXY(6),MXY(7))
      CALL FMLN(MXY(7),MXY(8))
      CALL FMSUB(MXY(8),MXY(1),MXY(5))
      CALL FMEXP(MXY(5),MXY(12))
      IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(6))) < 0)  &
          MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      IF (MWK(START(MXY(12))+2) == MUNKNO) GO TO 170
      GO TO 180

!             Method 5.  use incomplete gamma.

  170 IF (MWK(START(MXY(1))) < 0) THEN
          IF (IVAL > 0) THEN
              CALL FMST2M('UNKNOWN',MXY(12))
              KFLAG = -4
          ELSE
              CALL FMI2M(-1,MXY(12))
              IF (IVAL == -1 .AND. FMCOMP(MXY(1),'==',MXY(12))) THEN
                  CALL FMI2M(0,MXY(12))
              ELSE
                  N = 1 - IVAL
                  CALL FMI2M(N,MXY(12))
                  RAISE_NDIG = 1
                  CALL FMIGM2(MXY(12),MXY(1),MXY(13))
                  RAISE_NDIG = 0
                  IF (MWK(START(MXY(13))+2) == MEXPOV) THEN
                      N = IVAL
                      CALL FMI2M(1,MXY(7))
                      CALL FMI2M(1,MXY(8))
                      CALL FMDIV(MXY(8),MXY(1),MXY(9))
                      IF (MWK(START(MXY(9))+2) /= MUNKNO .AND. MWK(START(MXY(9))+3) /= 0)  &
                          MWK(START(MXY(9))) = -MWK(START(MXY(9)))
                      JS = 0
                      DO J = 0, 10000
                         CALL FMMPYI_R1(MXY(7),N+J)
                         CALL FMMPY_R1(MXY(7),MXY(9))
                         CALL FMADD_R1(MXY(8),MXY(7))
                         IF (KFLAG == 1) THEN
                             JS = 1
                             EXIT
                         ENDIF
                      ENDDO
                      IF (JS == 1) THEN
                          CALL FMLN(MXY(8),MXY(9))
                          CALL FMSUB(MXY(9),MXY(1),MXY(7))
                          CALL FMI2M(0,MXY(6))
                          CALL FMSUB(MXY(6),MXY(1),MXY(2))
                          CALL FMLN(MXY(2),MXY(3))
                          CALL FMSUB(MXY(7),MXY(3),MXY(2))
                          CALL FMEXP(MXY(2),MXY(3))
                          CALL FMSUB(MXY(6),MXY(3),MXY(12))
                      ELSE
                          CALL FMST2M('UNKNOWN',MXY(12))
                          KFLAG = -4
                      ENDIF
                  ELSE
                      CALL FMEQ(MXY(13),MXY(12))
                      N = IVAL - 1
                      CALL FMIPWR(MXY(1),N,MXY(3))
                      CALL FMMPY_R2(MXY(3),MXY(12))
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          N = 1 - IVAL
          CALL FMI2M(N,MXY(12))
          RAISE_NDIG = 1
          CALL FMIGM2(MXY(12),MXY(1),MXY(13))
          RAISE_NDIG = 0
          IF (MWK(START(MXY(13))+2) == MEXPUN .AND. IVAL > 0) THEN
              CALL FMEQ(MXY(1),MXY(4))
              IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
                  MWK(START(MXY(4))) = -MWK(START(MXY(4)))
              CALL FMEXP(MXY(4),MXY(5))
              CALL FMDIV(MXY(5),MXY(1),MXY(6))
              IF (MWK(START(MXY(6))+2) == MEXPUN) THEN
                  CALL FMST2M('UNDERFLOW',MXY(12))
                  KFLAG = -6
              ELSE
                  CALL FMI2M(1,MXY(7))
                  CALL FMI2M(1,MXY(8))
                  CALL FMDIV(MXY(8),MXY(1),MXY(9))
                  IF (MWK(START(MXY(9))+2) /= MUNKNO .AND. MWK(START(MXY(9))+3) /= 0)  &
                      MWK(START(MXY(9))) = -MWK(START(MXY(9)))
                  JS = 0
                  DO J = 0, 10000
                     CALL FMMPYI_R1(MXY(7),N+J)
                     CALL FMMPY_R1(MXY(7),MXY(9))
                     CALL FMADD_R1(MXY(8),MXY(7))
                     IF (KFLAG == 1) THEN
                         JS = 1
                         EXIT
                     ENDIF
                  ENDDO
                  IF (JS == 1) THEN
                      CALL FMMPY(MXY(6),MXY(8),MXY(12))
                  ELSE
                      CALL FMST2M('UNKNOWN',MXY(12))
                      KFLAG = -4
                  ENDIF
              ENDIF
          ELSE
              CALL FMEQ(MXY(13),MXY(12))
              N = IVAL - 1
              CALL FMIPWR(MXY(1),N,MXY(3))
              CALL FMMPY_R2(MXY(3),MXY(12))
          ENDIF
      ENDIF

  180 NAMEST(NCALL) = 'FMEN'
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(12))+1) = MIN(MWK(START(MXY(12))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(12))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(12),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEN

      SUBROUTINE FMERF(MA,MB)

!  MB = Erf(MA)    Error function.

!  2/Sqrt(pi) * Integral from 0 to MA of e**(-t**2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: C1,C2,ERR,X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NDSAV1,NDSAV2,  &
                 NMETHD,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMERF    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(3))
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(3))
          KFLAG = -4
          GO TO 180
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      MWK(START(MXY(1))) = 1
      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX**0.33D0
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX**0.33D0
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use a 2nd convergent series -- slower but no cancellation,
!                    = 3 use a continued fraction expansion.

      C1 = SQRT(DLOGMB*(NDIG+21))/5
      C2 = (DLOGMB*(NDIG+6))**0.6D0/4.1D0
      IF (MWK(START(MXY(1))+2) < 1) THEN
          NMETHD = 1
      ELSE IF (ABS(X) <= C1) THEN
          NMETHD = 1
      ELSE IF (ABS(X) <= C2) THEN
          NMETHD = 2
      ELSE
          NMETHD = 3
      ENDIF
      IF (NMETHD /= 1) GO TO 140

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!             If MA is large in magnitude, use more guard digits.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (KFLAGX == 0) THEN
          IF (ABS(X) > 2 .AND. ABS(X) < SQRT(HUGE(X))) THEN
              IEXTRA = MAX(INT((X*X-1.83-LOG(2*X*X+1))/ALOGMB+1),0)
              IF (IEXTRA > 0) THEN
                  CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              ENDIF
              NDIG = NDIG + IEXTRA
          ENDIF
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,1)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL FMI2M(1,MXY(6))
      CALL FMI2M(1,MJSUMS(1))
      DO J = 2, J2
         IF (NTERM > 1) CALL FMCSDIVI_R1(MXY(6),NTERM)
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 130
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  120 CALL FMCSMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(6),NTERM)
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MXY(4))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 130
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMSQR(MXY(1),MXY(4))
      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMEQ(MJSUMS(J2),MXY(5))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(4))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO
      CALL FMCSMPY_R1(MXY(5),MXY(1))

      CALL FMPI(MXY(4))
      CALL FMSQRT(MXY(4),MXY(3))
      CALL FMCSMPYI(MXY(5),2,MXY(4))
      CALL FMDIV_R2(MXY(4),MXY(3))
      GO TO 180

  140 IF (NMETHD /= 2) GO TO 170

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      MWK(START(MXY(1))) = 1
      IF (KFLAGX == 0) THEN
          J2 = INT(0.51*SQRT(FMNTERMS(2*X,2,-1,0,1)))
      ELSE
          J2 = 1
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL FMCSMPYI(MXY(1),2,MXY(6))
      CALL FMEQ(MXY(6),MJSUMS(1))
      DO J = 2, J2
         CALL FMCSMPYI_R1(MXY(6),2)
         CALL FMCSDIVI_R1(MXY(6),2*NTERM+1)
         CALL FMEQ(MXY(6),MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 160
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  150 CALL FMCSMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMCSMPYI_R1(MXY(6),2)
         CALL FMCSDIVI_R1(MXY(6),2*NTERM+1)
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(6))
         IF (KFLAG /= 0) GO TO 160
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 150

!             Put the J2 separate sums back together.

  160 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMSQR(MXY(1),MXY(6))
      CALL FMEQ(MJSUMS(J2),MXY(5))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(6))
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
      ENDDO

      CALL FMPI(MXY(4))
      CALL FMSQRT(MXY(4),MXY(3))
      CALL FMDIV_R2(MXY(5),MXY(3))
      CALL FMEXP(MXY(6),MXY(4))
      CALL FMDIV_R1(MXY(3),MXY(4))

      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(4) is -x*x.
!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  170 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG
      CALL FMABS(MXY(1),MXY(2))
      CALL FMMPYI(MXY(2),2,MXY(3))
      CALL FMSQR(MXY(2),MXY(4))
      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(1,MXY(10))
      CALL FMI2M(1,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(2),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
         ELSE
             CALL FMEQ(MXY(3),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMEXP(MXY(4),MXY(5))
             CALL FMPI(MXY(12))
             CALL FMSQRT(MXY(12),MXY(6))
             CALL FMDIV(MXY(5),MXY(6),MXY(10))
             CALL FMDIV_R1(MXY(10),MXY(2))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ELSE
             CALL FMCSMPYI(MXY(8),J-1,MXY(12))
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMCSMPY_R1(MXY(10),MXY(12))
             CALL FMEQ(MXY(10),MXY(5))
             CALL FMCSDIV(MXY(5),MXY(7),MXY(10))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (KFLAG == 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(3))
      NDIG = NDSAV1
  180 IF (KROUND /= 1) THEN
          IF (MWK(START(MXY(3))+2) == 1 .AND. MWK(START(MA)) > 0 .AND.  &
              (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMTINY(MXY(1))
              CALL FMSUB_R1(MXY(3),MXY(1))
          ENDIF
          IF (MWK(START(MXY(3))+2) == 1 .AND. MWK(START(MA)) < 0 .AND.  &
              (KROUND == 2 .OR. KROUND == 0)) THEN
              KRSAVE = KROUND
              KROUND = 0
              CALL FMTINY(MXY(1))
              CALL FMSUB_R1(MXY(3),MXY(1))
              KROUND = KRSAVE
          ENDIF
          IF (KFLAG == 1) KFLAG = 0
      ENDIF

      IF (MWK(START(MA)) < 0) THEN
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      ENDIF
      NAMEST(NCALL) = 'FMERF'

      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMERF

      SUBROUTINE FMERFC(MA,MB)

!  MB = ERFC(MA)    Complimentary Error function.

!  2/Sqrt(pi) * Integral from MA to infinity of e**(-t**2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: C1,ERR,X
      INTEGER :: IEXTRA,J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(4))
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(0,MXY(2))
              CALL FMSUB(MXY(2),MXY(1),MXY(5))
          ELSE
              CALL FMPI(MXY(2))
              CALL FMSQRT(MXY(2),MXY(3))
              CALL FMDIV(MXY(4),MXY(3),MXY(5))
              CALL FMMPYI(MXY(5),-2,MXY(6))
              CALL FMMPY(MXY(1),MXY(6),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
              NDIG = NDSAVE
              KROUND = KRSAVE
              CALL FMADD(MXY(6),MXY(7),MB)
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMERFC'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMERFC   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMI2M(1,MXY(3))
      CALL FMDIVI_R1(MXY(3),2)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0 .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMI2M(1,MXY(3))
          GO TO 130
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X)
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use 1 - erf(x),
!                    = 2 means use the continued fraction expansion.

      C1 = (DLOGMB*(NDIG+6))**0.7D0/9
      IF (MWK(START(MXY(1))+2) < 1) THEN
          NMETHD = 1
      ELSE IF (X <= C1) THEN
          NMETHD = 1
      ELSE
          NMETHD = 2
      ENDIF
      IF (NMETHD /= 1) GO TO 120

!             Method 1.  Use ERF.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1 .AND. NDIG < 100) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (X < 2) THEN
          CALL FMERF(MXY(1),MXY(4))
          CALL FMI2M(1,MXY(2))
          CALL FMSUB(MXY(2),MXY(4),MXY(3))
          GO TO 130
      ENDIF

!             Raise precision to compensate for cancellation if x is large.

      IEXTRA = MAX(INT((X*X+LOG(2*X))/ALOGMB+1),0)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      RAISE_NDIG = 1
      CALL FMERF(MXY(1),MXY(4))
      RAISE_NDIG = 0
      CALL FMI2M(1,MXY(2))
      CALL FMSUB(MXY(2),MXY(4),MXY(3))
      GO TO 130

  120 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG

!             Method 2.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(4) is -x*x.
!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

      CALL FMABS(MXY(1),MXY(2))
      CALL FMMPYI(MXY(2),2,MXY(3))
      CALL FMSQR(MXY(2),MXY(4))
      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(1,MXY(10))
      CALL FMI2M(0,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(2),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
         ELSE
             CALL FMEQ(MXY(3),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMEXP(MXY(4),MXY(5))
             CALL FMPI(MXY(12))
             CALL FMSQRT(MXY(12),MXY(6))
             CALL FMDIV(MXY(5),MXY(6),MXY(10))
             CALL FMDIV_R1(MXY(10),MXY(2))
             IF (MWK(START(MXY(10))+2) == MEXPUN) THEN
                 CALL FMEQ(MXY(10),MXY(3))
                 GO TO 130
             ENDIF
         ELSE
             CALL FMCSMPYI(MXY(8),J-1,MXY(12))
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMCSMPY_R1(MXY(10),MXY(12))
             CALL FMEQ(MXY(10),MXY(5))
             CALL FMCSDIV(MXY(5),MXY(7),MXY(10))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (J > 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(3))
      NDIG = NDSAV1

  130 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)
      NAMEST(NCALL) = 'FMERFC'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (KROUND == -1 .OR. KROUND == 0) THEN
          CALL FMI2M(2,MXY(1))
          IF (FMCOMP(MXY(3),'==',MXY(1))) THEN
              CALL FMDP2M(1.9999D0,MXY(2))
              CALL FMULP(MXY(2),MXY(4))
              CALL FMSUB(MXY(1),MXY(4),MXY(3))
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMERFC

      SUBROUTINE FMERFCS(MA,MB)

!  MB = ERFC_SCALED(MA)    Scaled Complimentary Error function.

!     = exp(x^2) * erfc(x)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: C1,ERR,X
      INTEGER :: IEXTRA,J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(4))
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(0,MXY(2))
              CALL FMSUB(MXY(2),MXY(1),MXY(5))
          ELSE
              CALL FMPI(MXY(2))
              CALL FMSQRT(MXY(2),MXY(3))
              CALL FMDIV(MXY(4),MXY(3),MXY(5))
              CALL FMMPYI(MXY(5),-2,MXY(6))
              CALL FMMPY(MXY(1),MXY(6),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
              NDIG = NDSAVE
              KROUND = KRSAVE
              CALL FMADD(MXY(6),MXY(7),MB)
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMERFCS'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMERFCS  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMI2M(1,MXY(3))
      CALL FMDIVI_R1(MXY(3),2)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0 .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMI2M(1,MXY(3))
          GO TO 130
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X)
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use exp(x^2) * (1 - erf(x)),
!                    = 2 means use the continued fraction expansion.

      C1 = (DLOGMB*(NDIG+6))**0.7D0/9
      IF (MWK(START(MXY(1))+2) < 1) THEN
          NMETHD = 1
      ELSE IF (X <= C1) THEN
          NMETHD = 1
      ELSE
          NMETHD = 2
      ENDIF
      IF (NMETHD /= 1) GO TO 120

!             Method 1.  Use ERF.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1 .AND. NDIG < 100) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (X < 2) THEN
          RAISE_NDIG = 1
          CALL FMERF(MXY(1),MXY(4))
          RAISE_NDIG = 0
          CALL FMI2M(1,MXY(2))
          CALL FMSUB(MXY(2),MXY(4),MXY(3))
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMEXP(MXY(2),MXY(4))
          CALL FMMPY_R1(MXY(3),MXY(4))
          GO TO 130
      ENDIF

!             Raise precision to compensate for cancellation if x is large.

      IEXTRA = MAX(INT((X*X+LOG(2*X))/ALOGMB+1),0)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      RAISE_NDIG = 1
      CALL FMERF(MXY(1),MXY(4))
      RAISE_NDIG = 0
      CALL FMI2M(1,MXY(2))
      CALL FMSUB(MXY(2),MXY(4),MXY(3))
      CALL FMSQR(MXY(1),MXY(2))
      CALL FMEXP(MXY(2),MXY(4))
      CALL FMMPY_R1(MXY(3),MXY(4))
      GO TO 130

  120 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG

!             Method 2.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

      CALL FMABS(MXY(1),MXY(2))
      CALL FMMPYI(MXY(2),2,MXY(3))
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(1,MXY(10))
      CALL FMI2M(0,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(2),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
         ELSE
             CALL FMEQ(MXY(3),MXY(11))
             CALL FMCSMPY_R1(MXY(11),MXY(9))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMI2M(1,MXY(5))
             CALL FMPI(MXY(12))
             CALL FMSQRT(MXY(12),MXY(6))
             CALL FMDIV(MXY(5),MXY(6),MXY(10))
             CALL FMDIV_R1(MXY(10),MXY(2))
             IF (MWK(START(MXY(10))+2) == MEXPUN) THEN
                 CALL FMEQ(MXY(10),MXY(3))
                 GO TO 130
             ENDIF
         ELSE
             CALL FMCSMPYI(MXY(8),J-1,MXY(12))
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMCSMPY_R1(MXY(10),MXY(12))
             CALL FMEQ(MXY(10),MXY(5))
             CALL FMCSDIV(MXY(5),MXY(7),MXY(10))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (J > 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(3))
      NDIG = NDSAV1

  130 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)
      NAMEST(NCALL) = 'FMERFCS'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMERFCS

      SUBROUTINE FMFGFI(MA,MB,MC)

!  Internal routine for the two auxiliary asymptotic series used in the sine and cosine
!  Fresnel integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 - 1*3/(pi*x*x)**2 + 1*3*5*7/(pi*x*x)**4 - ...) / (pi*x)
!  MC = g(x) = (1 - 1*3*5/(pi*x*x)**2 + 1*3*5*7*9/(pi*x*x)**4 - ...) / (pi**2*x**3)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      DOUBLE PRECISION :: X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(6),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTERMS = INT(INTMAX/10)
      CALL FMM2DP(MA,X)
      IF (KFLAG == 0) THEN
          J2 = INT(0.35*SQRT(FMNTERMS(3.14159D0*X*X/2,2,0,0,0)) - 0.2)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS/2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(4))
      CALL FMDIV(MXY(4),MA,MXY(2))
      CALL FMSQR(MXY(2),MXY(6))
      CALL FMPI(MXY(1))
      CALL FMDIV(MXY(6),MXY(1),MXY(2))
      CALL FMSQR(MXY(2),MXY(6))
      NTERM = 0
      DO J = 1, J2
         NBOT = 2*NTERM - 1
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(4),NBOT)
         CALL FMEQ(MXY(4),MJSUMS(J))
         NTERM = NTERM + 1

         NBOT = 2*NTERM - 1
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(4),NBOT)
         CALL FMEQ(MXY(4),MJSUMS(J2+J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(6))+2)+MWK(START(MXY(4))+2) < -NDIG-3) GO TO 110
      CALL FMIPWR(MXY(6),J2,MXY(3))

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(4),MXY(3))
         DO J = 1, J2
            NBOT = 2*NTERM - 1
            CALL FMCSMPYI_R1(MXY(4),NBOT)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1

            NBOT = 2*NTERM - 1
            CALL FMCSMPYI_R1(MXY(4),NBOT)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J2+J),MXY(4))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J2+J))+2)-MWK(START(MXY(4))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 KFLAG = 0
      CALL FMCSNSUMS(2*J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(3))
      CALL FMEQ(MJSUMS(J2+J2),MXY(5))
      IF( MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0) MWK(START(MXY(6))) = -1
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(6))
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))

         CALL FMCSMPY_R1(MXY(5),MXY(6))
         CALL FMADD_R1(MXY(5),MJSUMS(J2+J2-J+1))
      ENDDO
      CALL FMMPY(MA,MXY(1),MXY(2))
      CALL FMDIV(MXY(3),MXY(2),MB)

      CALL FMSQR(MXY(2),MXY(3))
      CALL FMMPY(MXY(3),MA,MXY(2))
      CALL FMDIV(MXY(5),MXY(2),MC)

      NDIG = NDSAV1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFGFI

      SUBROUTINE FMFHGH(MA,MB,MC)

!  Internal routine for the two auxiliary asymptotic series used in the hyperbolic sine and
!  cosine integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 + 2!/x**2 + 4!/x**4 + ...) / x
!  MC = g(x) = (1 + 3!/x**2 + 5!/x**4 + ...) / x**2

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      DOUBLE PRECISION :: X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(5),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTERMS = INT(INTMAX/10)
      CALL FMM2DP(MA,X)
      IF (KFLAG == 0) THEN
          J2 = INT(0.30*SQRT(FMNTERMS(X,2,0,0,0)) + 0.8)
          J2 = MAX(1,MIN(LJSUMS/2,J2))
      ELSE
          J2 = 1
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(3))
      CALL FMDIV(MXY(3),MA,MXY(1))
      CALL FMSQR(MXY(1),MXY(5))
      NTERM = 0
      DO J = 1, J2
         NBOT = NTERM
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NBOT)
         CALL FMEQ(MXY(3),MJSUMS(J))
         NTERM = NTERM + 1

         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NTERM)
         CALL FMEQ(MXY(3),MJSUMS(J2+J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(5))+2)+MWK(START(MXY(3))+2) < -NDIG-3) GO TO 110
      CALL FMIPWR(MXY(5),J2,MXY(2))

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(3),MXY(2))
         DO J = 1, J2
            NBOT = NTERM
            CALL FMCSMPYI_R1(MXY(3),NBOT)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1

            CALL FMCSMPYI_R1(MXY(3),NTERM)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J2+J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J2+J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 KFLAG = 0
      CALL FMCSNSUMS(2*J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(2))
      CALL FMEQ(MJSUMS(2*J2),MXY(4))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(2),MXY(5))
         CALL FMADD_R1(MXY(2),MJSUMS(J2-J+1))

         CALL FMCSMPY_R1(MXY(4),MXY(5))
         CALL FMADD_R1(MXY(4),MJSUMS(J2+J2-J+1))
      ENDDO
      CALL FMDIV(MXY(2),MA,MB)
      CALL FMMPY(MXY(4),MXY(5),MC)

      NDIG = NDSAV1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFHGH

      SUBROUTINE FMFXGX(MA,MB,MC)

!  Internal routine for the two auxiliary asymptotic series used in the sine and
!  cosine integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 - 2!/x**2 + 4!/x**4 - ...) / x
!  MC = g(x) = (1 - 3!/x**2 + 5!/x**4 - ...) / x**2

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NDSAV1,NTERM,NTERMS
      DOUBLE PRECISION :: X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(5),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTERMS = INT(INTMAX/10)
      CALL FMM2DP(MA,X)
      IF (KFLAG == 0) THEN
          J2 = INT(0.38*SQRT(FMNTERMS(X,2,0,0,0)) - 0.2)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS/2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(3))
      CALL FMDIV(MXY(3),MA,MXY(1))
      CALL FMSQR(MXY(1),MXY(5))
      NTERM = 0
      DO J = 1, J2
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NTERM)
         CALL FMEQ(MXY(3),MJSUMS(J))
         NTERM = NTERM + 1

         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NTERM)
         CALL FMEQ(MXY(3),MJSUMS(J2+J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(5))+2)+MWK(START(MXY(3))+2) < -NDIG-3) GO TO 110
      CALL FMIPWR(MXY(5),J2,MXY(2))

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(3),MXY(2))
         DO J = 1, J2
            CALL FMCSMPYI_R1(MXY(3),NTERM)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1

            CALL FMCSMPYI_R1(MXY(3),NTERM)
            NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J2+J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J2+J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 KFLAG = 0
      CALL FMCSNSUMS(2*J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(2))
      CALL FMEQ(MJSUMS(J2+J2),MXY(4))
      IF (MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(2),MXY(5))
         CALL FMADD_R1(MXY(2),MJSUMS(J2-J+1))

         CALL FMCSMPY_R1(MXY(4),MXY(5))
         CALL FMADD_R1(MXY(4),MJSUMS(J2+J2-J+1))
      ENDDO
      CALL FMDIV(MXY(2),MA,MB)
      MWK(START(MXY(5))) = 1
      CALL FMMPY(MXY(4),MXY(5),MC)

      NDIG = NDSAV1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFXGX

      SUBROUTINE FMLERC(MA,MB)

!  MB = Ln(erfc(MA))

!  MA must be positive, and is assumed to be large enough that erfc(MA) might underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JEXTRA,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAV1,NDSAV2,NDSAVE,NMETHD,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(17),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMLERC   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

      NTERMS = INT(INTMAX/10)

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(11))
          GO TO 140
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(11))
          GO TO 140
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))) > 0) THEN
              CALL FMST2M('-OVERFLOW',MXY(11))
              KFLAG = -5
          GO TO 140
      ENDIF

!             Close to zero use the series for Ln(1-erf(x)).

      IF (LOG(MWK(START(MXY(1))+3)+1.0D0)+(MWK(START(MXY(1))+2)-1)*DLOGMB < -10.0D0*DLOGTN) THEN
          CALL FMERF(MXY(1),MXY(10))
          CALL FMEQ(MXY(10),MXY(11))
          CALL FMEQ(MXY(10),MXY(6))
          IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
              MWK(START(MXY(11))) = -MWK(START(MXY(11)))
          DO J = 2, NTERMS
             CALL FMMPY_R1(MXY(6),MXY(10))
             CALL FMDIVI(MXY(6),J,MXY(3))
             CALL FMSUB_R1(MXY(11),MXY(3))
             IF (KFLAG == 1) EXIT
          ENDDO
          GO TO 140
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use FMERFC,
!                    = 2 means use the asymptotic value,
!                    = 3 means use the continued fraction expansion.

      NMETHD = 1
      CALL FMI2M(1000,MXY(3))
      IF (MWK(START(MXY(1))+2) >= NDIG) THEN
          NMETHD = 2
      ELSE IF(FMCOMP(MXY(1),'>',MXY(3))) THEN
          NMETHD = 3
      ENDIF

      IF (NMETHD == 2) GO TO 120
      IF (NMETHD == 3) GO TO 130

!             Method 1.  Use FMERFC.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMERFC(MXY(1),MXY(15))
      CALL FMLN(MXY(15),MXY(11))

      NAMEST(NCALL) = 'FMLERC'

      GO TO 140

!             Method 2.  Use the asymptotic value.

  120 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (MWK(START(MXY(1))) == 1) THEN
          CALL FMPI(MXY(16))
          CALL FMSQRT(MXY(16),MXY(3))
          CALL FMMPY_R1(MXY(3),MXY(1))
          CALL FMI2M(1,MXY(2))
          CALL FMDIV(MXY(2),MXY(3),MXY(11))
          CALL FMLN(MXY(11),MXY(4))
          CALL FMSQR(MXY(1),MXY(5))
          CALL FMSUB(MXY(4),MXY(5),MXY(11))
      ELSE
          CALL FMI2M(2,MXY(3))
          CALL FMLN(MXY(3),MXY(11))
      ENDIF

      GO TO 140

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(11) is the term in the sum, S(k).
!             MXY(9), MXY(10) are the latest denominators, Q(k-1) and Q(k).

  130 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG
      JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMI2M(1,MXY(9))
      CALL FMEQ(MXY(1),MXY(10))
      CALL FMI2M(1,MXY(11))
      CALL FMI2M(1,MXY(14))

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 0) THEN
             CALL FMCSMPYI(MXY(9),J/2,MXY(7))
             CALL FMEQ(MXY(1),MXY(3))
             CALL FMCSMPY_R1(MXY(3),MXY(10))
             CALL FMADD(MXY(3),MXY(7),MXY(8))
         ELSE
             CALL FMCSMPYI(MXY(9),J,MXY(3))
             CALL FMCSDIVI(MXY(3),2,MXY(7))
             CALL FMEQ(MXY(1),MXY(3))
             CALL FMCSMPY_R1(MXY(3),MXY(10))
             CALL FMADD(MXY(3),MXY(7),MXY(8))
         ENDIF
         CALL FMEQ(MXY(7),MXY(3))
         CALL FMCSMPY_R1(MXY(3),MXY(11))
         CALL FMDIV(MXY(3),MXY(8),MXY(11))
         IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
             MWK(START(MXY(11))) = -MWK(START(MXY(11)))
         NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(11))

!             Check for convergence.

         IF (KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(10),MXY(9))
         CALL FMEQ(MXY(8),MXY(10))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(11))+2))))
      ENDDO

      CALL FMEQU_R1(MXY(14),NDIG,NDSAV1)
      NDIG = NDSAV1
      CALL FMPI(MXY(16))
      CALL FMSQRT(MXY(16),MXY(3))
      CALL FMDIV(MXY(14),MXY(3),MXY(11))
      CALL FMDIV(MXY(11),MXY(1),MXY(12))
      CALL FMLN(MXY(12),MXY(13))
      CALL FMSQR(MXY(1),MXY(12))
      IF (MWK(START(MXY(12))+2) < MEXPOV) THEN
          CALL FMSUB(MXY(13),MXY(12),MXY(11))
      ELSE
          CALL FMEQ(MXY(12),MXY(11))
          IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
              MWK(START(MXY(11))) = -MWK(START(MXY(11)))
      ENDIF

  140 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLERC

      SUBROUTINE FMLI(MA,MB)

!  MB = Logarithmic Integral(MA)

!  Integral from 0 to MA of 1 / Ln(t)  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,X
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMLI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(2))
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN .AND. MWK(START(MXY(1))) == 1) THEN
          CALL FMST2M('-UNDERFLOW',MXY(2))
          KFLAG = -6
      ELSE
          CALL FMLN(MXY(1),MXY(3))
          CALL FMEI(MXY(3),MXY(2))
      ENDIF

      NAMEST(NCALL) = 'FMLI'

      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      KL = KFLAG
      CALL FMM2DP(MXY(1),X)
      IF (KFLAG == 0 .AND. KL == 0) THEN
          IF (X > 1.44 .AND. X < 1.46) THEN
              IF (MWK(START(MXY(2))+2) < 0) THEN
                  IF (KR_RETRY <= 1 .AND. NDIG < 2*NDSAVE+10) THEN
                      KR_RETRY = 2
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
      ENDIF
      KFLAG = KL
      CALL FMEXT2(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLI

      SUBROUTINE FMS(MA,MB)

!  MB = S(MA)    Fresnel Sine Integral.

!  Integral from 0 to MA of Sin(pi*t**2/2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,JR,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NBOT,NDGOAL,  &
                 NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE
      LOGICAL, EXTERNAL :: FMCOMP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMS      ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(11))
          GO TO 180
      ENDIF
      IF (4*MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMSQR(MXY(1),MXY(11))
          CALL FMMPY_R2(MXY(1),MXY(11))
          CALL FMPI(MXY(3))
          CALL FMDIVI(MXY(3),6,MXY(4))
          CALL FMMPY_R1(MXY(11),MXY(4))
          GO TO 160
      ENDIF
      CALL FMINT(MXY(1),MXY(8))
      IF (MWK(START(MXY(1))+2) > NDIG .AND. FMCOMP(MXY(1),'==',MXY(8)) .AND.  &
          MWK(START(MXY(1))+2) < MEXPOV) THEN
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(11))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(11))
          ENDIF
          CALL FMPI(MXY(6))
          CALL FMMPY_R1(MXY(6),MXY(1))
          CALL FMDIV_R2(MXY(8),MXY(6))
          JR = KROUND
          IF (KROUND == -1 .AND. MWK(START(MA)) < 0) KROUND =  2
          IF (KROUND ==  2 .AND. MWK(START(MA)) < 0) KROUND = -1
          CALL FMSUB_R1(MXY(11),MXY(6))
          KROUND = JR
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) > NDIG) THEN
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(11))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(11))
          ENDIF
          GO TO 160
      ENDIF

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      IF (KFLAGX == 0) THEN
          IF (ABS(X) < SQRT(HUGE(X)/(4*LOG(HUGE(X))))) THEN
              Y = (DPPI*X*X-1)/2
              Y = (2*Y+1.5)*LOG(2*Y+2) - (2*Y+1) - Y*DLOGTW - (Y+0.5)*LOG(Y+1) + Y - Y*LOG(DPPI*X*X)
              IF (Y <= -(NDIG+1)*DLOGMB) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n+1)/((4*n+3)*(2*n+1)!).

!             MXY(6) is the current term
!             MXY(9) is pi*x*x/2

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          IEXTRA = MAX(0.0D0,(0.096*X*X + 0.033*ABS(X) - 0.5)*LOG(1.0E7)/ALOGMB)*1.02
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          ENDIF
      ENDIF
      NDIG = NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF

      IF (KFLAGX == 0) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(3.14159D0*X*X/2,2,0,0,1)) - 1.6)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(4))
      CALL FMCSDIVI(MXY(4),2,MXY(9))
      CALL FMPI(MXY(3))
      CALL FMCSMPY_R1(MXY(9),MXY(3))
      CALL FMI2M(1,MXY(6))
      CALL FMCSDIVI(MXY(6),3,MJSUMS(1))
      NTERM = 0
      DO J = 2, J2
         NTERM = NTERM + 2
         NBOT = NTERM*(NTERM+1)
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM)
             CALL FMCSDIVI_R1(MXY(6),NTERM+1)
         ELSE
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+3,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(9),2*J2,MXY(7))

  130 CALL FMCSMPY_R1(MXY(6),MXY(7))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM)
             CALL FMCSDIVI_R1(MXY(6),NTERM+1)
         ELSE
             NBOT = NTERM*(NTERM+1)
             CALL FMCSDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+3,MXY(2))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(11))
      CALL FMSQR(MXY(9),MXY(8))
      MWK(START(MXY(8))) = -1
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(11),MXY(8))
         CALL FMADD_R1(MXY(11),MJSUMS(J2-J+1))
      ENDDO
      CALL FMCSMPY_R1(MXY(11),MXY(1))
      CALL FMCSMPY_R1(MXY(11),MXY(9))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then S(x) = 0.5 - f(x)*cos(pi*x*x/2) - g(x)*sin(pi*x*x/2).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMFGFI(MXY(1),MXY(12),MXY(13))
      CALL FMSQR(MXY(1),MXY(4))
      KRSAVE = KRAD
      KRAD = 0
      CALL FMMPYI(MXY(4),90,MXY(7))
      CALL FMCSSN(MXY(7),MXY(14),MXY(10))
      KRAD = KRSAVE
      CALL FMMPY(MXY(12),MXY(14),MXY(11))
      CALL FMMPY(MXY(13),MXY(10),MXY(7))
      CALL FMI2M(1,MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(5))
      CALL FMSUB(MXY(5),MXY(11),MXY(6))
      CALL FMSUB(MXY(6),MXY(7),MXY(11))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(11))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(11))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(11))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF(MWK(START(MXY(11))+3) /= 0 .AND. MWK(START(MXY(11))+2) /= MUNKNO)  &
             MWK(START(MXY(11))) =-1
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMS

      SUBROUTINE FMSHI(MA,MB)

!  MB = Hyperbolic Sine Integral(MA)

!  Integral from 0 to MA of sinh(t) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(12),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),18,MXY(2))
          IF (MWK(START(MXY(2))+2) < -NDIG) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MXY(3))
          CALL FMDIVI(MXY(3),18,MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MXY(9))
                  IF (MWK(START(MXY(9))+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9))
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9))
                          ENDIF
                      ENDIF
                  ENDIF
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ELSE IF (MWK(START(MXY(4))+2) == MEXPUN) THEN
              IF (KRSAVE == 2 .AND. MWK(START(MA)) == 1) THEN
                  CALL FMTINY(MXY(9))
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
                  K_RETURN_CODE = 1
              ENDIF
              IF (KRSAVE == -1 .AND. MWK(START(MA)) == -1) THEN
                  CALL FMTINY(MXY(9))
                  MWK(START(MXY(9))) = -1
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
                  K_RETURN_CODE = 1
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMSHI'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMSHI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMEQ(MXY(1),MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(8))
          KFLAG = -5
          GO TO 180
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the X**(2*N+1)/((2*N+1)*(2*N+1)!) series.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.62*SQRT(FMNTERMS(X,2,0,0,1)) - 1.3)
          J2 = MAX(1,MIN(LJSUMS,J2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMEQ(MXY(1),MXY(7))
      CALL FMEQ(MXY(1),MJSUMS(1))
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 2
         NBOT = NTERM*(NTERM-1)
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM)
             CALL FMCSDIVI_R1(MXY(7),NTERM-1)
         ELSE
             CALL FMCSDIVI_R1(MXY(7),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  130 CALL FMCSMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM)
             CALL FMCSDIVI_R1(MXY(7),NTERM-1)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(7),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(8))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(6))
          DO J = 2, J2
             CALL FMCSMPY_R1(MXY(8),MXY(6))
             CALL FMADD_R1(MXY(8),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then Shi(x) = f(x)*cosh(x) + g(x)*sinh(x).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      CALL FMFHGH(MXY(1),MXY(9),MXY(10))
      CALL FMCHSH(MXY(1),MXY(11),MXY(12))
      IF (MWK(START(MXY(11))+2) < MEXPOV) THEN
          CALL FMMPY(MXY(9),MXY(11),MXY(2))
          CALL FMMPY(MXY(10),MXY(12),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(8))
      ELSE
          CALL FMADD(MXY(9),MXY(10),MXY(5))
          CALL FMDIVI_R1(MXY(5),2)
          CALL FMLN(MXY(5),MXY(8))
          CALL FMADD(MXY(1),MXY(8),MXY(5))
          CALL FMEXP(MXY(5),MXY(8))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(8))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(8))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(8))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(8))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(8))+1) = MIN(MWK(START(MXY(8))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(8))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(8))+3) /= 0) THEN
          MWK(START(MXY(8))) = -MWK(START(MXY(8)))
      ENDIF
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSHI

      SUBROUTINE FMSI(MA,MB)

!  MB = Sine Integral(MA)

!  Integral from 0 to MA of sin(t) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(13),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),18,MXY(2))
          IF (MWK(START(MXY(2))+2) < -NDIG) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MXY(3))
          CALL FMDIVI(MXY(3),-18,MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMSI'
                  CALL FMNTR(2,MA,MA,1,1)
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NAMEST(NCALL) = 'FMSI'
                  KFLAG = -4
                  CALL FMWRN2
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NAMEST(NCALL) = 'FMSI'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
              ENDIF
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMSI'
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMSI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMEQ(MXY(1),MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) > NDIG) THEN
          CALL FMPI(MXY(8))
          CALL FMDIVI_R1(MXY(8),2)
          GO TO 160
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the (-1)**N*X**(2*N+1)/((2*N+1)*(2*N+1)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = 1.03*Y/DLOGMB - 7/ALOGMT
          IEXTRA = MAX(0,INT(Y+1))
          IF (ABS(X) < 5 .AND. KR_RETRY <= 0) THEN
              NDIG = NDIG - 2
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      IF (KFLAGX == 0) THEN
          J2 = INT(0.64*SQRT(FMNTERMS(X,2,0,0,1)) - 1.4)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMEQ(MXY(1),MXY(7))
      CALL FMEQ(MXY(1),MJSUMS(1))
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(7),NBOT)
         ELSE
             CALL FMCSDIVI_R1(MXY(7),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  130 CALL FMCSMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(7),NBOT)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(7),NBOT)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS)
      CALL FMEQ(MJSUMS(J2),MXY(8))
      CALL FMSQR(MXY(1),MXY(6))
      MWK(START(MXY(6))) = -1
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(6))
         CALL FMADD_R1(MXY(8),MJSUMS(J2-J+1))
      ENDDO

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then Si(x) = pi/2 - f(x)*cos(x) - g(x)*sin(x).

  150 CALL FMFXGX(MXY(1),MXY(10),MXY(11))
      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(12),MXY(13))
      KRAD = KRSAVE
      CALL FMPI(MXY(9))
      IF (MWK(START(MXY(12))+2) == MUNKNO .OR. MWK(START(MXY(13))+2) == MUNKNO) THEN
          CALL FMMPYI(MXY(9),2,MXY(8))
          CALL FMDIV(MXY(1),MXY(8),MXY(3))
          CALL FMINT(MXY(3),MXY(2))
          CALL FMMPY(MXY(2),MXY(8),MXY(3))
          CALL FMSUB(MXY(1),MXY(3),MXY(8))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMCSSN(MXY(8),MXY(12),MXY(13))
          KRAD = KRSAVE
      ENDIF
      CALL FMDIVI(MXY(9),2,MXY(2))
      CALL FMMPY(MXY(10),MXY(12),MXY(3))
      CALL FMSUB_R1(MXY(2),MXY(3))
      CALL FMMPY(MXY(11),MXY(13),MXY(3))
      CALL FMSUB(MXY(2),MXY(3),MXY(8))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(8))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(8))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(8))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(8))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(8))+1) = MIN(MWK(START(MXY(8))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(8))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(8))+3) /= 0) THEN
          MWK(START(MXY(8))) = -MWK(START(MXY(8)))
      ENDIF
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSI


!  Here are the routines which work with packed FM numbers.
!  All names are the same as unpacked versions with 'FM' replaced by 'FP'.

!  This packed format is not available when using the FM, IM, or ZM derived types.

      SUBROUTINE FPBESJ(IVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMBESJ(IVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBESJ

      SUBROUTINE FPBESY(IVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMBESY(IVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBESY

      SUBROUTINE FPC(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMC(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPC

      SUBROUTINE FPCHI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCHI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCHI

      SUBROUTINE FPCI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCI

      SUBROUTINE FPEI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEI

      SUBROUTINE FPEN(IVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEN(IVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEN

      SUBROUTINE FPERF(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMERF(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPERF

      SUBROUTINE FPERFC(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMERFC(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPERFC

      SUBROUTINE FPERFCS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMERFCS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPERFCS

      SUBROUTINE FPLERC(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLERC(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLERC

      SUBROUTINE FPLI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLI

      SUBROUTINE FPS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPS

      SUBROUTINE FPSHI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSHI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSHI

      SUBROUTINE FPSI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSI
